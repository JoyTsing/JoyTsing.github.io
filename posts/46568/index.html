<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="EffectiveModernCpp:条款与实践, joytsing blog"><meta name="description" content="一份读书笔记"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>EffectiveModernCpp:条款与实践 | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/9.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">EffectiveModernCpp:条款与实践</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-category">读书笔记</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2023-09-26</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-03-21</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 33.2k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 131 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="第一章：类型推导"><a href="#第一章：类型推导" class="headerlink" title="第一章：类型推导"></a>第一章：类型推导</h2><h3 id="条款-1：理解模板类型推导"><a href="#条款-1：理解模板类型推导" class="headerlink" title="条款 1：理解模板类型推导"></a>条款 1：理解模板类型推导</h3><p>函数模板大致形如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在编译期，编译器会通过表达式推导出两个类型：一个是<code>T</code>的类型，另一个是<code>ParamType</code>的类型，这两个类型往往不一样，<code>ParamType</code>常包含一些饰词，如<code>const</code>或引用符号等限定词。</p><p><strong>情况 1：ParamType 是个指针或引用，但不是个万能引用</strong></p><ol><li>若表达式具有引用类型，则先将引用部分忽略。</li><li>对表达式的类型和<code>ParamType</code>进行匹配来决定<code>T</code>的类型。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 int&amp;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int, paramType 为 const int&amp;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int, paramType 为 const int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若我们假定<code>param</code>具有常引用类型，则<code>T</code>的类型推导结果中也就没必要包含<code>const</code>了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 int&amp;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 const int&amp;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 const int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果<code>param</code>是个指针（或指向 const 对象的指针）而非引用，运作方式本质上并无不同：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">*</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> px <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 int*</span>
<span class="token function">f</span><span class="token punctuation">(</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int, paramType 为 const int*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>情况 2：ParamType 是个万能引用</strong></p><blockquote><p>详细说明请参考<strong>条款 24</strong>。</p></blockquote><ol><li>如果表达式是个左值，则<code>T</code>和<code>ParamType</code>都会被推导为左值引用。</li><li>如果表达式是个右值，则遵循情况 1 中的规则。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 左值的情况</span>

<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 的类型为 int&amp;, paramType 为 int&amp;</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int&amp;, paramType 为 const int&amp;</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int&amp;, paramType 为 const int&amp;</span>

<span class="token comment" spellcheck="true">// 右值的情况</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 int&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>情况 3：ParamType 既非指针也非引用</strong></p><p>这种情况即为按值传递，无论传入的是什么，<code>param</code>都会是它的一个副本。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 和 param 的类型均为 int</span>
<span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 和 param 的类型均为 int</span>
<span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 和 param 的类型均为 int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是对于指向 const 对象的 const 指针的传递，仅有指针本身的常量性会被忽略：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr <span class="token operator">=</span> <span class="token string">"Fun with pointers"</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 和 param 的类型均为 const char*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>数组实参：</strong></p><p>按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"J. P. Briggs"</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const char[13], paramType 为 const char (&amp;)[13]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用声明数组引用这一能力可以创造出一个模板，用来推导出数组含有的元素个数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t N<span class="token operator">></span>
<span class="token keyword">constexpr</span> std<span class="token operator">::</span>size_t <span class="token function">arraySize</span><span class="token punctuation">(</span><span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> N<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数实参：</strong></p><p>函数类型同样也会退化成函数指针，并且和数组类型的规则类似：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f1</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// param 被推导为函数指针，具体类型为 void (*)(int, double)</span>
<span class="token function">f2</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// param 被推导为函数引用，具体类型为 void (&amp;)(int, double)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-2：理解-auto-类型推导"><a href="#条款-2：理解-auto-类型推导" class="headerlink" title="条款 2：理解 auto 类型推导"></a>条款 2：理解 auto 类型推导</h3><p><code>auto</code>类型推导除了在一个例外情况下，和模板类型推导的规则一模一样，同样可以分为三种情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 情况 3</span>

<span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 类型为 int</span>
<span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 类型为 const int</span>

<span class="token comment" spellcheck="true">// 情况 1</span>

<span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类型为 const int&amp;</span>

<span class="token comment" spellcheck="true">// 情况 2</span>

<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref1 <span class="token operator">=</span> x<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 类型为 int&amp;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref2 <span class="token operator">=</span> cx<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 类型为 const int&amp;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref3 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 类型为 int&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组和函数实参的非引用退化规则也同样适用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"J. P. Briggs"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类型为 const char[13]</span>
<span class="token keyword">auto</span> arr1 <span class="token operator">=</span> name<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 类型为 const char*</span>
<span class="token keyword">auto</span><span class="token operator">&amp;</span> arr2 <span class="token operator">=</span> name<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 类型为 const char (&amp;)[13]</span>

<span class="token keyword">void</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 类型为 void(int, double)</span>
<span class="token keyword">auto</span> func1<span class="token operator">=</span> someFunc<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 类型为 void (*)(int, double)</span>
<span class="token keyword">auto</span><span class="token operator">&amp;</span> func2<span class="token operator">=</span> someFunc<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 类型为 void (&amp;)(int, double)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们将讨论例外情况：<code>auto</code>会假定用大括号括起的初始化表达式代表一个<code>std::initializer_list</code>，但模板类型推导不会。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">27</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 类型为 std::initializer_list&lt;int>，值为 { 27 }</span>
<span class="token keyword">auto</span> x4<span class="token punctuation">{</span> <span class="token number">27</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 同上</span>

<span class="token keyword">auto</span> x5 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误，类型不一致</span>
                            <span class="token comment" spellcheck="true">// 无法推导出 std::initializer_list&lt;T> 中的 T</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 错误</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">></span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 正确，ParamType 为 std::initializer_list&lt;int></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++14 中，允许使用<code>auto</code>来说明函数返回值需要推导，而且 lambda 表达式也会在形参声明中用到<code>auto</code>。然而这些<code>auto</code>用法使用的是模板类型推导而非<code>auto</code>类型推导，因此也不能使用大括号括起的初始化表达式。</p><h3 id="条款-3：理解-decltype"><a href="#条款-3：理解-decltype" class="headerlink" title="条款 3：理解 decltype"></a>条款 3：理解 decltype</h3><p>绝大多数情况下，<code>decltype</code>会得出变量或表达式的类型而不作任何修改。对于类型为<code>T</code>的左值表达式，除非该表达式仅有一个名字，否则<code>decltype</code>总是得出类型<code>T&amp;</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 推导结果为 int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 推导结果为 int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 C++11 中，<code>decltype</code>的主要用途是声明返回值类型依赖于形参类型的函数模板，这需要用到<strong>返回值类型尾置语法（trailing return type syntax）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Container<span class="token punctuation">,</span> <span class="token keyword">typename</span> Index<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">authenticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 允许对单表达式的 lambda 的返回值实施类型推导，而 C++14 将这个允许范围扩张到了一切函数和一切 lambda，包括那些多表达式的。这就意味着在 C++14 中可以去掉返回值类型尾置语法，仅保留前导<code>auto</code>。</p><p>但编译器会为<code>auto</code>指定为返回值类型的函数实施模板类型推导，这样就会留下隐患（例如忽略初始化表达的引用性），使用<code>decltype(auto)</code>来说明我们采用的是<code>decltype</code>的规则，就可以解决这个问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Container<span class="token punctuation">,</span> <span class="token keyword">typename</span> Index<span class="token operator">></span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">authenticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在初始化表达式处也可以应用<code>decltype</code>类型推导规则：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span>
<span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> cw <span class="token operator">=</span> w<span class="token punctuation">;</span>

<span class="token keyword">auto</span> myWidget1 <span class="token operator">=</span> cw<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// auto 推导出类型为 Widget</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> myWidget2 <span class="token operator">=</span> cw<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// decltype 推导出类型为 const Widget&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述情形中，我们无法向函数传递右值容器，若想要采用一种既能绑定到左值也能绑定到右值的引用形参，就需要借助万能引用，并应用<code>std::forward</code>（参考<strong>条款 25</strong>）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Container<span class="token punctuation">,</span> <span class="token keyword">typename</span> Index<span class="token operator">></span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">authenticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Container<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-4：掌握查看类型推导结果的方法"><a href="#条款-4：掌握查看类型推导结果的方法" class="headerlink" title="条款 4：掌握查看类型推导结果的方法"></a>条款 4：掌握查看类型推导结果的方法</h3><p><strong>1. IDE 编辑器</strong></p><p><strong>2. 编译器诊断信息</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token comment" spellcheck="true">// 只声明 TD 而不定义</span>
<span class="token keyword">class</span> <span class="token class-name">TD</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// TD 是 “类型显示类”（Type Displayer）的缩写</span>

TD<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">></span> xType<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 诱发包括 x 和 y 的类型的错误信息</span>
TD<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">></span> yType<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 运行时输出</strong></p><p>针对某个对象调用<code>typeid</code>，可以得到一个<code>std::type_info</code>对象，其拥有一个成员函数<code>name</code>，该函数产生一个代表类型的 C-style 的字符串。</p><p>但遗憾的是，不同编译器对于<code>std::type_info::name</code>的实现各不相同，无法保证完全可靠。并且按照标准，<code>std::type_info::name</code>中处理类型的方式和向函数模板按值传参一样，因此类型的引用性以及<code>const</code>和<code>volatile</code>限定符也将被忽略。</p><p>原书中介绍了 Boost.TypeIndex 第三方库用于代替<code>typeid</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;boost/type_index.hpp></span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> std<span class="token operator">::</span>cout<span class="token punctuation">;</span>
    <span class="token keyword">using</span> boost<span class="token operator">::</span>typeindex<span class="token operator">::</span>type_id_with_cvr<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 显示 T 的类型</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"T =          "</span>
         <span class="token operator">&lt;&lt;</span> type_id_with_cvr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pretty_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 显示 param 的类型</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"param =          "</span>
         <span class="token operator">&lt;&lt;</span> type_id_with_cvr<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pretty_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第二章：auto"><a href="#第二章：auto" class="headerlink" title="第二章：auto"></a>第二章：auto</h2><h3 id="条款-5：优先选用-auto，而非显式类型声明"><a href="#条款-5：优先选用-auto，而非显式类型声明" class="headerlink" title="条款 5：优先选用 auto，而非显式类型声明"></a>条款 5：优先选用 auto，而非显式类型声明</h3><p><code>auto</code>变量要求必须初始化，基本上可以避免会导致兼容性和效率问题的类型不匹配现象，还可以简化重构流程，通常也比显式指定类型要少打一些字，但在使用时需要注意<strong>条款 2</strong> 和<strong>条款 6</strong> 中提到的问题。</p><p>使用<code>auto</code>和<code>std::function</code>都可以存储闭包：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// C++14 允许在 lambda 表达式的形参中使用 auto</span>

<span class="token keyword">auto</span> derefLess <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p2<span class="token punctuation">)</span>
                  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">,</span>
                   <span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span>
    derefUPLess <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> p1<span class="token punctuation">,</span>
                     <span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> p2<span class="token punctuation">)</span>
                   <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>auto</code>声明的、存储着一个闭包的变量和该闭包是同一类型，从而它要求的内存量也和该闭包相同；而使用<code>std::function</code>声明的、存储着一个闭包的变量是<code>std::function</code>的一个实例，不管给定的签名如何，它都占有固定大小的内存，而这个大小对于其存储的闭包而言并不一定够用，如果是这样，那么<code>std::function</code>的构造函数就会分配堆上的内存来存储该闭包。再有，编译器的细节一般都会限制内联，并会产生间接函数调用。</p><p>综上所述，<code>std::function</code>通常比起<code>auto</code>更大更慢，还可能导致内存消耗异常，因此实际使用时更推荐<code>auto</code>。</p><p>考虑以下代码的隐患：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> m<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> p <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::unordered_map</code>的键值部分是 const 的，所以哈希表中的<code>std::pair</code>类型应为<code>std::pair&lt;const std::string, int&gt;</code>而非<code>std::pair&lt;std::string, int&gt;</code>，类型的不匹配会导致额外的临时对象被复制出来，降低了运行效率。</p><p>使用<code>auto</code>就可以轻松避免这种问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="条款-6：当-auto-推导的类型不符合要求时，使用显式类型初始化惯用法"><a href="#条款-6：当-auto-推导的类型不符合要求时，使用显式类型初始化惯用法" class="headerlink" title="条款 6：当 auto 推导的类型不符合要求时，使用显式类型初始化惯用法"></a>条款 6：当 auto 推导的类型不符合要求时，使用显式类型初始化惯用法</h3><p>“隐形” 的代理类型可以导致<code>auto</code>根据初始化表达式推导出 “错误的” 类型，应该防止写出这样的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> someVar <span class="token operator">=</span> <span class="token string">" 隐形 "</span> 代理类型表达式<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个隐形代理类的典型例子是<code>std::vector&lt;bool&gt;</code>，它经过了特化，与一般的<code>std::vector</code>的行为不同，和<code>std::bitset</code>的行为相似，使用一种压缩形式表示其持有的<code>bool</code>元素，每个<code>bool</code>元素用一个比特来表示。因此，<code>std::vector&lt;bool&gt;</code>的<code>operator[]</code>并不会直接返回一个<code>bool&amp;</code>，而是会返回一个具有类似行为的<code>std::vector&lt;bool&gt;::reference</code>类型的对象，并可以隐式转换为<code>bool</code>类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">features</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
Widget w<span class="token punctuation">;</span>

<span class="token keyword">bool</span> highPriority1 <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 得到正确的 bool 变量</span>
<span class="token keyword">auto</span> highPriority2 <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误地得到了 std::vector&lt;bool>::reference 对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了<code>std::vector&lt;bool&gt;</code>以外，标准库中的智能指针和另外一些 C++ 库中的类也使用了代理类的设计模式，例如为了提高数值计算代码效率的<strong>表达式模板</strong>技术：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Matrix sum <span class="token operator">=</span> m1 <span class="token operator">+</span> m2 <span class="token operator">+</span> m3 <span class="token operator">+</span> m4<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过使 operator+ 返回结果的代理来提高效率</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在实际编写代码时，记得通过查看文档或头文件中的函数原型来确认手头上的类是否为代理类。</p></blockquote><p>解决代理类问题的做法是：使用带显式类型的初始值设定项来强制<code>auto</code>推导出你想要的类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> highPriority <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种用法并不仅限于会产生代理类型的初始值设定项，它同样可以应用于你想要强调创建一个类型不同于初始化表达式类型的场合，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">calcEpsilon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">float</span> ep1 <span class="token operator">=</span> <span class="token function">calcEpsilon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 进行从 double 到 float 的隐式类型转换</span>
<span class="token keyword">auto</span> ep2 <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">calcEpsilon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 强调了类型转换的存在</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第三章：转向现代-C"><a href="#第三章：转向现代-C" class="headerlink" title="第三章：转向现代 C++"></a>第三章：转向现代 C++</h2><h3 id="条款-7：在创建对象时注意区分-和"><a href="#条款-7：在创建对象时注意区分-和" class="headerlink" title="条款 7：在创建对象时注意区分 () 和 {}"></a>条款 7：在创建对象时注意区分 () 和 {}</h3><p>为了着手解除众多的初始化语法带来的困惑，也为了解决这些语法不能覆盖所有初始化场景的问题，C++11 引入了统一初始化，以<strong>大括号初始化（braced initialize）</strong> 的形式存在：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 下面两种写法等价</span>
<span class="token keyword">int</span> x<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>大括号可以用于指定容器的初始内容：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>大括号和等号可以用于为非静态成员指定默认初始化值，而小括号不行：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> x<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可行</span>
    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可行</span>
    <span class="token keyword">int</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不可行！</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不可复制的对象可以采用大括号和小括号进行初始化，而不能使用等号：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ai1<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可行</span>
std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ai2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 可行</span>
std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ai3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不可行！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>大括号初始化禁止内建类型之间进行<strong>隐式窄化类型转换（narrowing conversion）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>

<span class="token keyword">int</span> sum1<span class="token punctuation">{</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 错误！double 之和可能无法用 int 表达</span>
<span class="token keyword">int</span> <span class="token function">sum2</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确，表达式的值被截断为 int</span>
<span class="token keyword">int</span> sum3 <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 同上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大括号初始化可以避免<strong>最令人烦恼的解析语法（most vexing parse）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget <span class="token function">w1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 调用 Widget 构造函数</span>
Widget <span class="token function">w2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 声明了一个名为 w2，返回值为 Widget 对象的函数</span>
Widget w3<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用没有形参的 Widget 构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>大括号初始化也有一些缺点，其中一个是<strong>条款 2</strong> 中提到的 auto 推导问题，另一个则产生于对带有<code>std::initializer_list</code>类型形参的重载版本的强烈偏向性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">bool</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Widget <span class="token function">w1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用第一个构造函数</span>
Widget w2<span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 调用带有 std::initializer_list 形参的构造函数</span>

Widget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 调用第二个构造函数</span>
Widget w4<span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 错误！禁止窄化类型转换</span>

Widget <span class="token function">w5</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 调用拷贝构造函数</span>
Widget w6<span class="token punctuation">{</span> w4 <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将 w4 强制转换为 int 后，调用带有 std::initializer_list 形参的构造函数</span>

Widget <span class="token function">w7</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 调用移动构造函数</span>
Widget w8<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 情况和 w6 相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有在找不到任何办法把大括号初始值设定项中的实参转换为<code>std::initializer_list</code>模板中的类型时，编译器才会退而检查普通的重载决议。</p><p>值得注意的是，一对空大括号代表的意义是 “没有实参”，而非 “空的<code>std::initializer_list</code>”，后者可以用套娃的括号来表示：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget w1<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 调用默认构造函数</span>
Widget w2<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 仍然调用默认构造函数</span>
Widget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 变成了函数声明语句</span>
Widget <span class="token function">w4</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 调用带有 std::initializer_list 形参的构造函数</span>
                <span class="token comment" spellcheck="true">// 并传入空的 std::initializer_list</span>
Widget w5<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 同上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用模板进行对象创建时，到底该使用小括号还是大括号会成为一个棘手的问题。举例来说，如果你想以任意数量的实参来创建一个任意类型的对象，那么，一个可变参数模板将会是不错的选择：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">doSomeWork</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 利用 params 创建 T 类型的局部对象</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

doSomeWork<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而此时，在模板内部创建局部对象时，对小括号和大括号的选择将会影响实际创建出的内容：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 得到一个包含 10 个元素的 std::vector</span>
T <span class="token function">localObject</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 得到一个包含 2 个元素的 std::vector</span>
T localObject<span class="token punctuation">{</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标准库函数<code>std::make_unique</code>和<code>std::make_shared</code>也面临着这个问题，它们的解决方案是在内部使用小括号，并将这个决定写进文档中，作为其接口的组成部分。</p><h3 id="条款-8：优先选用-nullptr，而非-0-或-NULL"><a href="#条款-8：优先选用-nullptr，而非-0-或-NULL" class="headerlink" title="条款 8：优先选用 nullptr，而非 0 或 NULL"></a>条款 8：优先选用 nullptr，而非 0 或 NULL</h3><p><code>nullptr</code>的实际类型是<code>std::nullptr_t</code>，该类型可以隐式转换到所有的裸指针类型，因此<code>nullptr</code>可以扮演所有类型的指针。与<code>0</code>和<code>NULL</code>不同，<code>nullptr</code>不具备整数类型，因此不具有多义性。</p><p><code>0</code>和<code>NULL</code>导致的重载问题提醒我们应当尽量避免在整型和指针类型之间进行重载：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// f 的三个重载版本</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 调用 f(int)</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 可能无法通过编译，但一般会调用 f(int)，绝不会调用 f(void*)</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 调用 f(void*)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>nullptr</code>在有模板的前提下表现最亮眼：模板类型推导会将<code>0</code>和<code>NULL</code>推导成 “错误” 类型（即它们的真实类型，而非空指针这个含义），而使用<code>nullptr</code>的话，模板就不会带来特殊的麻烦。考虑如下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">f1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> upw<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">f3</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> FuncType<span class="token punctuation">,</span> <span class="token keyword">typename</span> MuxType<span class="token punctuation">,</span> <span class="token keyword">typename</span> PtrType<span class="token operator">></span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">lockAndCall</span><span class="token punctuation">(</span>FuncType func<span class="token punctuation">,</span> MuxType<span class="token operator">&amp;</span> mutex<span class="token punctuation">,</span> PtrType ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

std<span class="token operator">::</span>mutex f1m<span class="token punctuation">,</span> f2m<span class="token punctuation">,</span> f3m<span class="token punctuation">;</span>
<span class="token keyword">auto</span> result1 <span class="token operator">=</span> <span class="token function">lockAndCall</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span> f1m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 错误！</span>
<span class="token keyword">auto</span> result2 <span class="token operator">=</span> <span class="token function">lockAndCall</span><span class="token punctuation">(</span>f2<span class="token punctuation">,</span> f2m<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 错误！</span>
<span class="token keyword">auto</span> result3 <span class="token operator">=</span> <span class="token function">lockAndCall</span><span class="token punctuation">(</span>f3<span class="token punctuation">,</span> f3m<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-9：优先选用别名声明，而非-typedef"><a href="#条款-9：优先选用别名声明，而非-typedef" class="headerlink" title="条款 9：优先选用别名声明，而非 typedef"></a>条款 9：优先选用别名声明，而非 typedef</h3><p>很多人发现别名声明在处理涉及函数指针的类型时，比<code>typedef</code>更容易理解：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代替为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> FP <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但别名声明的压倒性优势在于<strong>别名模板（alias template）</strong>，它给予了 C++11 程序员一种直截了当的表达机制，用以表达 C++98 程序员不得不用嵌套在模板化的<code>struct</code>里面的<code>typedef</code>才能硬搞出来的东西。考虑如下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> MyAllocList <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span> type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">typename</span> MyAllocList<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type list<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用别名模板，就可以让整个写法更简洁，并且可以摆脱类型前的<code>typename</code>限定符：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">using</span> MyAllocList <span class="token operator">=</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    MyAllocList<span class="token operator">&lt;</span>T<span class="token operator">></span> list<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++11 中，标准库的<code>&lt;type_traits&gt;</code>给出了一整套用于进行值类别转换的模板，它们是使用<code>typedef</code>实现的，对于给定待变换类型 T，其结果类型需要通过<code>std::transformation&lt;T&gt;::type</code>的方式获得。而在 C++14 中，所有的值类别转换都加上了对应的别名模板，通过<code>std::transformation_t&lt;T&gt;</code>的方式使用，这显然比<code>typedef</code>实现的版本更加好用。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>remove_const<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type          <span class="token comment" spellcheck="true">// C++11: const T -> T</span>
std<span class="token operator">::</span>remove_const_t<span class="token operator">&lt;</span>T<span class="token operator">></span>              <span class="token comment" spellcheck="true">// C++14 中的等价物</span>

std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type      <span class="token comment" spellcheck="true">// C++11: T&amp;/T&amp;&amp; -> T</span>
std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span>          <span class="token comment" spellcheck="true">// C++14 中的等价物</span>

std<span class="token operator">::</span>add_lvalue_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type  <span class="token comment" spellcheck="true">// C++11: T -> T&amp;</span>
std<span class="token operator">::</span>add_lvalue_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span>      <span class="token comment" spellcheck="true">// C++14 中的等价物</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型"><a href="#条款-10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型" class="headerlink" title="条款 10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型"></a>条款 10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h3><p>C++98 中的枚举类型被称为不限作用域的枚举类型，与之相对的即是 C++11 中引入的限定作用域的枚举类型，即枚举类<code>enum class</code>，它的优点很明显：不会产生名称污染。</p><p>除此以外，枚举类还是强类型的，而不限范围的枚举类型中的枚举量可以隐式转换到整型（并由此更进一步转换到浮点型）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> Color <span class="token punctuation">{</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span> <span class="token function">primeFactors</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t x<span class="token punctuation">)</span><span class="token punctuation">;</span>

Color c <span class="token operator">=</span> red<span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">14.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> factors <span class="token operator">=</span> <span class="token function">primeFactors</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想要用<code>enum class</code>代替<code>enum</code>，对其施以强制类型转换即可，但是无法确保转换的合法性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span> <span class="token function">primeFactors</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t x<span class="token punctuation">)</span><span class="token punctuation">;</span>

Color c <span class="token operator">=</span> Color<span class="token operator">::</span>red<span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">14.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> factors <span class="token operator">=</span> <span class="token function">primeFactors</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于不限范围的枚举类型，编译器为了节约使用内存，通常会为枚举类型选用足够表示枚举量取值的最小底层类型。即使在某些情况下，编译器会采取空间换时间的策略，导致放弃选择尺寸最小的类型，然而它仍然需要保留优化空间的能力。因此，在 C++98 中，<code>enum</code>只允许在声明处定义，没有提供对前置声明的支持。</p><p>而在 C++11 中，无论是<code>enum class</code>还是<code>enum</code>都可以进行前置声明，<code>enum class</code>的默认底层类型是<code>int</code>，而<code>enum</code>不具备默认底层类型，只有在指定了的前提下才可以进行前置声明：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Status</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 底层类型是 int</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Status</span> <span class="token operator">:</span> std<span class="token operator">::</span>uint32_t<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 底层类型是 std::uint32_t</span>
<span class="token keyword">enum</span> Color <span class="token operator">:</span> std<span class="token operator">::</span>uint8_t<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 底层类型是 std::uint8_t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>底层类型指定同样也可以在定义时进行：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Status</span> <span class="token operator">:</span> std<span class="token operator">::</span>uint32_t <span class="token punctuation">{</span>
    good <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    failed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    incomplete <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>
    corrupt <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">,</span>
    audited <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">,</span>
    indetermine <span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不限范围的枚举类型在你需要更便捷地为数字和名称建立联系时，还是比较好用的，例如在访问元组的元素时，你可以使用枚举量而非直接使用难懂的数字：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> UserInfo <span class="token operator">=</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token keyword">enum</span> UserInfoFields <span class="token punctuation">{</span> uiName<span class="token punctuation">,</span> uiEmail<span class="token punctuation">,</span> uiReputation <span class="token punctuation">}</span><span class="token punctuation">;</span>

UserInfo uInfo<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">auto</span> val <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span>uiEmail<span class="token operator">></span><span class="token punctuation">(</span>uInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而使用<code>enum class</code>就要啰嗦得多：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> val <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span><span class="token punctuation">(</span>UserInfoFields<span class="token operator">::</span>uiEmail<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>uInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你实在无法忍受名称污染，执意打算使用<code>enum class</code>，那么可以考虑使用以下辅助类来简化书写：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> E<span class="token operator">></span>    <span class="token comment" spellcheck="true">// C++14</span>
<span class="token keyword">constexpr</span> <span class="token keyword">auto</span> <span class="token function">toUType</span><span class="token punctuation">(</span>E enumerator<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>underlying_type_t<span class="token operator">&lt;</span>E<span class="token operator">>></span><span class="token punctuation">(</span>enumerator<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">auto</span> val <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token function">toUType</span><span class="token punctuation">(</span>UserInfoFields<span class="token operator">::</span>uiEmail<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>uInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-11：优先选用删除函数，而非-private-未定义函数"><a href="#条款-11：优先选用删除函数，而非-private-未定义函数" class="headerlink" title="条款 11：优先选用删除函数，而非 private 未定义函数"></a>条款 11：优先选用删除函数，而非 private 未定义函数</h3><p>删除函数和将函数声明为 private 看起来只是风格不同的选择，但其实有更多值得思考的微妙之处，例如：被删除的函数无法通过任何方法调用，对于成员和友元函数中的代码也是如此。</p><p>习惯上，删除函数会被声明为 public，而非 private，这样做的理由是：C++ 会先校验可访问性，后校验删除状态，当我们尝试调用某个 private 删除函数时，编译器可能只会提醒函数无法访问，而非更应关心的函数是否被删除。</p><p>以下是 C++11 中<code>std::basic_ios</code>阻止被复制的方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">charT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">traits</span> <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>charT<span class="token operator">>></span>
<span class="token keyword">class</span> <span class="token class-name">basic_ios</span> <span class="token operator">:</span> <span class="token keyword">public</span> ios_base <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">basic_ios</span><span class="token punctuation">(</span><span class="token keyword">const</span> basic_ios<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    basic_ios<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> basic_ios<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任何函数都能被删除，藉此我们可以过滤掉不想要的函数重载版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 原始版本</span>

<span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拒绝 char 类型</span>

<span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">bool</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拒绝 bool 类型</span>

<span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 拒绝 double 和 float 类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>float</code>类型的参数会优先转换到<code>double</code>类型，因此传入<code>float</code>时会调用<code>double</code>类型的重载版本，但由于这个重载版本被删除了，所以编译会被阻止。</p><p>删除函数还可以阻止那些不应该进行的模板具现。举例来说，假设你需要一个和内建指针协作的模板，却不想要它对<code>void*</code>和<code>char*</code>指针进行处理，那么可以写出以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">processPointer</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>
<span class="token keyword">void</span> processPointer<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>
<span class="token keyword">void</span> processPointer<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>
<span class="token keyword">void</span> processPointer<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>
<span class="token keyword">void</span> processPointer<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 删去其它版本，如 volatile void* 和 volatile char*</span>
<span class="token comment" spellcheck="true">// 与其它标准字符类型，如 std::wchar_t, std::char16_t 和 std::char32_t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员函数模板可以在类外被删除：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
    <span class="token keyword">void</span> <span class="token function">processPointer</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>
<span class="token keyword">void</span> Widget<span class="token operator">::</span>processPointer<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-12：为意在改写的函数添加-override-声明"><a href="#条款-12：为意在改写的函数添加-override-声明" class="headerlink" title="条款 12：为意在改写的函数添加 override 声明"></a>条款 12：为意在改写的函数添加 override 声明</h3><p>如果要使虚函数重写发生，有一系列要求需要满足：</p><ol><li>基类中的函数必须是虚函数。</li><li>基类和派生类中的<strong>函数名称</strong>必须完全相同（析构函数除外）。</li><li>基类和派生类中的<strong>函数形参类型</strong>必须完全相同。</li><li>基类和派生类中的<strong>函数常量性</strong>必须完全相同。</li><li>基类和派生类中的<strong>函数返回值</strong>和<strong>异常规格</strong>必须兼容。</li><li>基类和派生类的<strong>函数引用限定符</strong>必须完全相同。</li></ol><p>由于对声明派生类中的重写，保证正确性很重要，而出错又很容易，C++11 提供了<code>override</code>声明来显式地标明派生类中的函数是为了重写基类版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override<span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> override<span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> override<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 加个 "virtual" 没问题，但也没必要</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样做的好处不仅在于让编译器提醒你想要重写的函数实际上并未重写，还可以让你在打算更改基类中虚函数的签名时，衡量一下其所造成的影响。</p><blockquote><p><code>override</code>和<code>final</code>是 C++11 中加入的<strong>语境关键字（contextual keyword）</strong>，它们的特点是仅会在特定语境下才发挥被保留的意义，因此如果你有一些遗留代码，其中已经用过<code>override</code>和<code>final</code>作为名称的话，并不需要为它们改名。</p></blockquote><p><strong>函数引用限定符（reference qualifier）：</strong> 限制成员函数仅用于左值对象或右值对象。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 仅在 *this 是左值时调用</span>
   <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 仅在 *this 是右值时调用</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Widget w<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

w<span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 以左值调用 Widget::doWork &amp;</span>
<span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 以右值调用 Widget::doWork &amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>带引用限定符的成员函数并不常见，但有时也是需要的。举例来说，假设我们的<code>Widget</code>类中有个<code>std::vector</code>类型的数据成员，我们提供一个函数让用户能对这个数据成员直接访问，但对于左值对象和右值对象有不同的行为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> DataType <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span>

    DataType<span class="token operator">&amp;</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>              <span class="token comment" spellcheck="true">// 对于左值 Widget 类型，返回左值</span>
    <span class="token punctuation">{</span> <span class="token keyword">return</span> values<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    DataType <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>              <span class="token comment" spellcheck="true">// 对于右值 Widget 类型，返回右值</span>
    <span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    DataType values<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Widget w<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">auto</span> vals1 <span class="token operator">=</span> w<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 调用 Widget::data 的左值重载版本</span>
                                    <span class="token comment" spellcheck="true">// vals1 采用拷贝构造完成初始化</span>

<span class="token keyword">auto</span> vals2 <span class="token operator">=</span> <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 调用 Widget::data 的右值重载版本</span>
                                    <span class="token comment" spellcheck="true">// vals2 采用移动构造完成初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-13：优先选用-const-iterator，而非-iterator"><a href="#条款-13：优先选用-const-iterator，而非-iterator" class="headerlink" title="条款 13：优先选用 const_iterator，而非 iterator"></a>条款 13：优先选用 const_iterator，而非 iterator</h3><p><code>const_iterator</code>是 STL 中提供的与指向 const 的指针含义相同之物，它们指向不可被修改的值。任何时候只要你需要一个迭代器而其所指向的内容没有修改的必要，那就应该使用 const_iterator。</p><p>但在 C++98 中，<code>const_iterator</code>得到的支持不够全面，想要获取它们就很不容易，而获取到了以后使用它们的方法也很受限。例如在 C++98 中，我们会被迫写出以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator IterT<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator ConstIterT<span class="token punctuation">;</span>

std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> values<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

ConstIterT ci <span class="token operator">=</span> 
    std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ConstIterT<span class="token operator">></span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
              <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ConstIterT<span class="token operator">></span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
              <span class="token number">1983</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// const_iterator 作为参数，返回 const_iterator</span>

values<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1998</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// C++98 中 insert 只能接受 iterator</span>
                                                <span class="token comment" spellcheck="true">// 从 const_iterator 到 iterator 不存在可移植的类型转换</span>
                                                <span class="token comment" spellcheck="true">// 可能无法通过编译</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在 C++11 中，这些现象得到了彻底的改变，获取和使用<code>const_iterator</code>都变得容易了。要把原始的、使用<code>iterator</code>的 C++98 代码修改成使用<code>const_iterator</code>的 C++11 代码也很简单：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> values<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1983</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

values<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token number">1998</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 对于<code>const_iterator</code>支持的唯一缺陷是只为<code>begin</code>和<code>end</code>提供了对应的非成员函数版本，而没有为<code>cbegin</code>、<code>cend</code>、<code>rbegin</code>、<code>cend</code>、<code>crbegin</code>和<code>crend</code>这些返回<code>const_iterator</code>的函数提供对应的非成员函数版本，这个问题在 C++14 中得到了解决。想要自己实现它们也很简单，如下就是非成员函数版本的<code>cbegin</code>的一个实现方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该模板在传入一个内建数组时也管用，此时<code>container</code>会成为一个 const 数组的引用。</p><blockquote><p>C++11 的非成员函数版本的<code>begin</code>为内建数组提供了一个特化版本，它返回一个指向数组首元素的指针。由于 const 数组的元素都为 const，所以若给<code>begin</code>传入一个 const 数组，则返回的指针是个指向 const 的指针，即数组意义下的 const_iterator。</p></blockquote><p>由于内建数组和第三方库的存在，最通用化的代码往往不会假定成员函数的存在，而是更多地采用非成员函数版本，例如以下<code>findAndInsert</code>模板的通用形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> C<span class="token punctuation">,</span> <span class="token keyword">typename</span> V<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">findAndInsert</span><span class="token punctuation">(</span>C<span class="token operator">&amp;</span> container<span class="token punctuation">,</span> <span class="token keyword">const</span> V<span class="token operator">&amp;</span> targetVal<span class="token punctuation">,</span> <span class="token keyword">const</span> V<span class="token operator">&amp;</span> insertVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> std<span class="token operator">::</span>cbegin<span class="token punctuation">;</span>
    <span class="token keyword">using</span> std<span class="token operator">::</span>cend<span class="token punctuation">;</span>

    <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">cbegin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cend</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span> targetVal<span class="token punctuation">)</span><span class="token punctuation">;</span>

    container<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> insertVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-14：只要函数不会抛出异常，就为其加上-noexcept-声明"><a href="#条款-14：只要函数不会抛出异常，就为其加上-noexcept-声明" class="headerlink" title="条款 14：只要函数不会抛出异常，就为其加上 noexcept 声明"></a>条款 14：只要函数不会抛出异常，就为其加上 noexcept 声明</h3><p>在 C++11 中，C++98 风格的异常规范已经被弃用，而转为为不会抛出异常的函数提供<code>noexcept</code>声明，函数是否要加上这个声明，事关接口声明。</p><p>调用方可以查询函数的<code>noexcept</code>状态，而查询结果可能会影响调用代码的异常安全性和运行效率。这么一来，函数是否带有<code>noexcept</code>声明就是和成员函数是否带有 const 声明同等重要的信息。当你明明知道一个函数不会抛出异常却未给它加上<code>noexcept</code>声明的话，就属于接口规格设计缺陷。</p><p>相当于不带<code>noexcept</code>声明的函数，带有<code>noexcept</code>声明的函数有更多机会得到优化：</p><pre class="line-numbers language-cpp"><code class="language-cpp">RetType <span class="token function">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 最优化</span>

RetType <span class="token function">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 优化不足</span>

RetType <span class="token function">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 优化不足</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在带有<code>noexcept</code>声明的函数中，优化器不需要在异常传出函数的前提下，将运行时栈保持在可展开状态；也不需要在异常逸出函数的前提下，保证所有其中的对象以其被构造顺序的逆序完成析构。而那些以<code>throw()</code>异常规格声明的函数就享受不到这样的优化灵活性，和那些没有加上异常规格的函数一样。</p><p><code>noexcept</code>属性对于移动操作、swap、内存释放函数和析构函数最有价值。C++11 STL 中的大部分函数遵循 “能移动则移动，必须复制才复制” 策略，但这必须保证在使用移动操作代替复制操作后，函数依旧具备强异常安全性。为了得知移动操作会不会产生异常，就需要校验这个操作是否带有<code>noexcept</code>声明。</p><p><code>swap</code>函数是许多 STL 算法实现的核心组件，它的广泛使用昭示着针对其实施<code>noexcept</code>声明带来的收益是可观的。标准库中的<code>swap</code>是否带有<code>noexcept</code>声明，取决于用户定义的<code>swap</code>自身。例如，标准库为数组和<code>std::pair</code>准备的<code>swap</code>函数如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t N<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>
          <span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">struct</span> pair <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>pair<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">swap</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> p<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                                <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">swap</span><span class="token punctuation">(</span>second<span class="token punctuation">,</span> p<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些函数带有条件式<code>noexcept</code>声明，它们到底是否具备<code>noexcept</code>属性，取决于它的<code>noexcept</code>分句中的表达式是否结果为<code>noexcept</code>。在此处，数组和<code>std::pair</code>的<code>swap</code>具备<code>noexcept</code>属性的前提是，其每一个元素的<code>swap</code>都具备<code>noexcept</code>属性。</p><p>对于某些函数来说，具备<code>noexcept</code>属性是如此之重要，所以它们默认就是如此。在 C++11 中，内存释放函数和所有的析构函数都默认隐式地具备<code>noexcept</code>属性。析构函数未隐式地具备<code>noexcept</code>属性的唯一情况，就是所有类中有数据成员（包括继承而来的成员，以及在其他数据成员中包含的数据成员）的类型显式地将其析构函数声明为<code>noexcept(false)</code>，即可能抛出异常。</p><blockquote><p>不具备<code>noexcept</code>属性的析构函数很少见，标准库里一个都没有，而如果标准库使用了某个对象，其析构函数抛出了异常，则该行为是未定义的。</p></blockquote><p>大多数函数都是<strong>异常中立（exception-neutral）</strong> 的，不具备<code>noexcept</code>属性。此类函数自身并不抛出异常，但它们调用的函数可能会抛出异常，这些异常会经由异常中立函数传至调用栈的更深一层。</p><p>C++ 允许带有<code>noexcept</code>声明的函数依赖于缺乏<code>noexcept</code>保证的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得一提的是，有些库的接口设计者会把函数区分为带有<strong>宽松规约（wide constract）</strong> 和带有<strong>狭隘规约（narrow constract）</strong> 的不同种类。带有宽松规约的函数是没有前置条件的，要调用这样的函数也无须关心程序状态；而对于带有狭隘规约的函数，如果前置条件被违反，则结果将成为未定义的。一般而言，我们只会把<code>noexcept</code>声明保留给那些带有宽松规约的函数。</p><h3 id="条款-15：只要有可能使用-constexpr，就使用它"><a href="#条款-15：只要有可能使用-constexpr，就使用它" class="headerlink" title="条款 15：只要有可能使用 constexpr，就使用它"></a>条款 15：只要有可能使用 constexpr，就使用它</h3><p><strong><code>constexpr</code>对象：</strong> 具备 const 属性，并由编译期已知的值完成初始化。</p><p>在编译阶段就已知的值拥有许多特权，它们可能被放置在只读内存里（对于嵌入式开发尤为重要）；在编译阶段就已知的常量整型值可以用在 C++ 要求整型常量表达式的语境中，包括数组的尺寸规格、整型模板实参、枚举量的值、对齐规格等，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> sz<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// 非 constexpr 变量</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">const</span> <span class="token keyword">auto</span> arraySize <span class="token operator">=</span> sz<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 正确，arraySize 是 sz 的一个 const 副本</span>
std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> arraySize<span class="token operator">></span> data<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误！arraySize 的值非编译期可知</span>

<span class="token keyword">constexpr</span> <span class="token keyword">auto</span> arraySize1 <span class="token operator">=</span> sz<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 错误！sz 的值在编译期未知</span>
std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> sz<span class="token operator">></span> data1<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 错误！问题同上</span>

<span class="token keyword">constexpr</span> <span class="token keyword">auto</span> arraySize2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 正确，10 是编译期常量</span>
std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> arraySize2<span class="token operator">></span> data2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确，arraySize2 是编译期常量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>constexpr</code>函数：</strong></p><ul><li><code>constexpr</code>函数可以用在要求编译期常量的语境中。在这种情况下，若传给一个<code>constexpr</code>函数的实参值是在编译期已知的，则结果也会在编译期计算出来；如果任何一个实参值在编译期未知，则代码将无法通过编译。</li><li><code>constexpr</code>函数也可以运用在非编译期常量的语境中，此时传入的值可以有一个或多个在编译期未知。它的运作方式和普通函数无异，同样在运行期完成结果的计算。</li><li>在 C++11 中，<code>constexpr</code>函数不得包含多于一个可执行语句，即一条<code>return</code>语句；而到了 C++14，就没有了这种限制。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">int</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// C++11</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>exp <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> base <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> exp <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">int</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// C++14</span>
    <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> exp<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> result <span class="token operator">*</span><span class="token operator">=</span> base<span class="token punctuation">;</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">auto</span> numConds <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> numConds<span class="token punctuation">)</span><span class="token operator">></span> results<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>constexpr</code>函数仅限于传入和返回<strong>字面类型（literal type）</strong>，这些类型能够持有编译期可以决议的值。在 C++11 中，除了<code>void</code>的所有内建类型都是字面类型；此外，我们也可以自定义字面类型，这需要将其构造函数和部分成员函数声明为<code>constexpr</code>函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">constexpr</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">double</span> xVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> yVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span>
        <span class="token function">x</span><span class="token punctuation">(</span>xVal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>yVal<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> newY<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> Point <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">9.4</span><span class="token punctuation">,</span> <span class="token number">27.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 在编译期执行 constexpr 构造函数</span>
<span class="token keyword">constexpr</span> Point <span class="token function">p2</span><span class="token punctuation">(</span><span class="token number">28.8</span><span class="token punctuation">,</span> <span class="token number">5.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 同上</span>

<span class="token keyword">constexpr</span> Point <span class="token function">midpoint</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p2<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用 constexpr 成员函数</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">auto</span> mid <span class="token operator">=</span> <span class="token function">midpoint</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使用 constexpr 函数的返回值来初始化 constexpr 对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++14 中，就连返回值类型为<code>void</code>的 setter 函数也可以声明为<code>constexpr</code>函数，这就使以下代码变为可能：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> newY<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">constexpr</span> Point <span class="token function">reflection</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    Point result<span class="token punctuation">;</span>

    result<span class="token punctuation">.</span><span class="token function">setX</span><span class="token punctuation">(</span><span class="token operator">-</span>p<span class="token punctuation">.</span><span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">setY</span><span class="token punctuation">(</span><span class="token operator">-</span>p<span class="token punctuation">.</span><span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">auto</span> reflectionMid <span class="token operator">=</span> <span class="token function">reflection</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，一旦你把一个对象或函数声明成了<code>constexpr</code>，而后来你又感觉对<code>constexpr</code>运用不当，然后进行了移除，那么这会导致非常多客户代码无法通过编译。因此，“只要有可能使用<code>constexpr</code>，就使用它” 这句话中的 “只要有可能” 的含义就是你是否有一个长期的承诺，将由<code>constexpr</code>带来的种种限制施加于相关的函数和对象上。</p><h3 id="条款-16：保证-const-成员函数的线程安全性"><a href="#条款-16：保证-const-成员函数的线程安全性" class="headerlink" title="条款 16：保证 const 成员函数的线程安全性"></a>条款 16：保证 const 成员函数的线程安全性</h3><p>对于 const 成员函数，我们通常认为它代表的是读操作，而多个线程在没有同步的情况下执行读操作应该是安全的。因此，我们需要保证 const 成员函数的线程安全性，除非可以确信它们不会在并发语境中被使用。</p><p>考虑如下情形，我们将计算出的多项式的根存入缓存中，以避免代价高昂的重复计算：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Polynomial</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> RootsType <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span>

    RootsType <span class="token function">roots</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootsAreValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 如果缓存无效</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            rootsAreValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 则计算根，并将其存入 rootVals</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> rootsVals<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">mutable</span> <span class="token keyword">bool</span> rootsAreValid<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">mutable</span> RootsType rootVals<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 mutable 成员变量的存在，可能有不同的多个线程通过<code>roots</code>成员函数在没有同步的情况下读写同一块内存，造成<strong>数据竞争（data race）</strong>，这会导致未定义行为的出现。</p><p>有两种方法可以解决这个问题，最简单的方法也是最常见的，引入一个 mutex 互斥量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Polynomial</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> RootsType <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span>

    RootsType <span class="token function">roots</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 互斥量加锁</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootsAreValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 如果缓存无效</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            rootsAreValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 则计算根，并将其存入 rootVals</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> rootsVals<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>                                       <span class="token comment" spellcheck="true">// 互斥量解锁</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">mutable</span> std<span class="token operator">::</span>mutex m<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 添加 mutable 的互斥量</span>
    <span class="token keyword">mutable</span> <span class="token keyword">bool</span> rootsAreValid<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">mutable</span> RootsType rootVals<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种方法是使用<code>std::atomic</code>类型的变量，这会比使用互斥量提供更好的性能，但更适用于对单个变量或内存区域的操作。以下情况更适合使用<code>std::atomic</code>来确保线程安全性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">double</span> <span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>callCount<span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">// 带原子性的自增操作</span>

        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">mutable</span> std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> callCount<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 存储调用次数</span>
    <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论是<code>std::mutex</code>还是<code>std::atomic</code>都是只移类型，无法进行复制，因此加入它们都会使类失去可复制性，但仍然可以移动。</p><h3 id="条款-17：理解特殊成员函数的生成机制"><a href="#条款-17：理解特殊成员函数的生成机制" class="headerlink" title="条款 17：理解特殊成员函数的生成机制"></a>条款 17：理解特殊成员函数的生成机制</h3><p>在 C++11 中，支配特殊成员函数的机制如下（所有生成的默认特殊函数都是 inline 的，且具有 public 访问权限）：</p><ul><li><strong>默认构造函数：</strong> 与 C++98 的机制相同。仅当类中不包含用户声明的构造函数时才生成。</li><li><strong>析构函数：</strong> 与 C++98 的机制基本相同，唯一的区别在于析构函数默认为 noexcept（参考<strong>条款 14</strong>）。仅当基类的析构函数为虚时，派生类的析构函数才为虚。</li><li><strong>拷贝构造函数：</strong> 运行期行为与 C++98 相同：<strong>按成员</strong>进行<strong>非静态</strong>数据成员的拷贝构造。仅当类中不包含用户声明的拷贝构造函数时才生成。如果该类声明了移动操作，则拷贝构造函数将被删除。在已经存在拷贝赋值运算符或析构函数的情况下，仍然生成拷贝构造函数已经成为了被废弃的行为（但未被禁止），原因见三者法则。</li><li><strong>拷贝赋值运算符：</strong> 运行期行为与 C++98 相同：<strong>按成员</strong>进行<strong>非静态</strong>数据成员的拷贝赋值。仅当类中不包含用户声明的拷贝赋值运算符时才生成。如果该类声明了移动操作，则拷贝赋值运算符将被删除。在已经存在拷贝构造函数或析构函数的情况下，仍然生成拷贝构造函数已经成为了被废弃的行为（但未被禁止），原因见三者法则。</li></ul><blockquote><p><strong>三者法则（Rule of Three）：</strong> 如果你声明了拷贝构造函数、拷贝赋值运算符或析构函数中的任何一个，你就得同时声明所有这三个。<br>三者法则根植于这样的思想：如果有改写拷贝操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：</p><ol><li>在一种拷贝操作中进行的任何资源管理，也极有可能在另一种拷贝操作中也需要进行。</li><li>该类的析构函数也会参与到该资源的管理中（通常是对资源进行释放）。<br>三者法则对移动操作也同样成立。</li></ol></blockquote><ul><li><strong>移动构造函数和移动赋值运算符：</strong> 都<strong>按成员</strong>进行<strong>非静态</strong>数据成员的移动操作。仅当类中不包含用户声明的拷贝操作、移动操作和析构函数时才生成。声明一个移动构造函数会阻止编译器生成移动赋值运算符，而声明一个移动赋值运算符也会阻止编译器生成移动构造函数。</li></ul><blockquote><p>声明拷贝操作（无论是拷贝构造还是拷贝赋值）的行为表明了对象的常规拷贝方式（按成员拷贝）对于该类并不适用，那么编译器就会认为按成员移动极有可能也不适用于移动操作。因此，一旦显式声明了拷贝操作，编译器就不再会为其生成移动操作，反之亦然。</p></blockquote><p>如果你有一些代码依赖于编译器自动生成的特殊函数，并且你确信这些函数会正确执行，那么可以用<code>=default</code>显式指定让它们生成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 使析构函数成为虚的</span>

    <span class="token function">Base</span><span class="token punctuation">(</span>Base<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 提供移动操作的支持</span>
    Base<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Base<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 提供拷贝操作的支持</span>
    Base<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员函数模板在任何情况下都不会抑制特殊成员函数的生成，例如下面这个类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 以任意类型构造 Widget</span>

    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以任意类型对 Widget 赋值</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器会始终生成<code>Widget</code>的拷贝和移动操作，即使这些模板的具现化生成了拷贝构造函数和拷贝赋值运算符的函数签名。</p><h2 id="第四章：智能指针"><a href="#第四章：智能指针" class="headerlink" title="第四章：智能指针"></a>第四章：智能指针</h2><p>以下理由使得裸指针不受欢迎：</p><ol><li>裸指针没有在声明中指出，其指向的内容是单个对象还是数组。</li><li>裸指针没有在声明中指出，是否该在其指向的对象使用完后进行析构。</li><li>无法得知怎样析构裸指针才是适当的，是使用<code>delete</code>运算符，还是有专门用于析构的函数。</li><li>在已知使用<code>delete</code>的情况下，难以确定该用<code>delete</code>还是<code>delete[]</code>。</li><li>很难保证对指针所指向对象的析构，在所有代码路径上只执行一次。</li><li>没有正规的方式来检测指针是否空悬（dangle）。</li></ol><p>因此，在大多数时候，应该优先选用智能指针。<code>std::auto_ptr</code>是从 C++98 中残留下来的弃用特性，应该被 C++11 中的 <code>std::unique_ptr</code>所替代。</p><h3 id="条款-18：使用-std-unique-ptr-管理具备专属所有权的资源"><a href="#条款-18：使用-std-unique-ptr-管理具备专属所有权的资源" class="headerlink" title="条款 18：使用 std::unique_ptr 管理具备专属所有权的资源"></a>条款 18：使用 std::unique_ptr 管理具备专属所有权的资源</h3><p><code>std::unique_ptr</code>是小巧、高速的、具备只移类型的智能指针，对于托管的指针实施专属所有权语义。它和裸指针所占大小相同，并且不允许被拷贝，在执行析构操作时，同时析构其所管理的资源。</p><p><code>std::unique_ptr</code>的一个常见用法是在继承体系中，作为工厂函数的返回值类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Investment</span> <span class="token punctuation">{</span> 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Investment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 必备的虚析构函数！</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Stock</span> <span class="token operator">:</span> <span class="token keyword">public</span> Investment <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Bond</span> <span class="token operator">:</span> <span class="token keyword">public</span> Investment <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">RealEstate</span> <span class="token operator">:</span> <span class="token keyword">public</span> Investment <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 std::unique_ptr</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">auto</span> pInvestment <span class="token operator">=</span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// *pInvestment 在此处析构</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认地，资源析构采用<code>delete</code>运算符来完成，但也可以指定自定义删除器，并且删除器将会被视作<code>std::unique_ptr</code>类型的一部分。下面的例子中使用了 lambda 表达式作为自定义删除器，并在删除时写入一条日志：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> delInvmt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Investment<span class="token operator">*</span> pInvestment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span>pInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> pInvestment<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>delInvmt<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 改进后的返回值类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++14 中，由于有了函数返回值类型推导（参考<strong>条款 3</strong>），<code>makeInvestment</code>可以用更加简单的、封装性更好的方法实现，自定义删除器也可以放在函数内部，完整的代码演示如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 现在自定义删除器位于函数内部</span>
    <span class="token keyword">auto</span> delInvmt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Investment<span class="token operator">*</span> pInvestment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">makeLogEntry</span><span class="token punctuation">(</span>pInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">delete</span> pInvestment<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>delInvmt<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">pInv</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> delInvmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 待返回的指针</span>

    <span class="token comment" spellcheck="true">// 使用 reset 来让 pInv 获取 new 产生的对象的所有权</span>
    <span class="token comment" spellcheck="true">// 对每一次 new 的调用结果，都使用 std::forward 对实参进行完美转发（参考条款 25）</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment" spellcheck="true">/* 应创建一个 Stock 类型的对象 */</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pInv<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Stock</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment" spellcheck="true">/* 应创建一个 Bond 类型的对象 */</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pInv<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Bond</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment" spellcheck="true">/* 应创建一个 RealEstate 类型的对象 */</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pInv<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">RealEstate</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> pInv<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用自定义删除器后，<code>std::unique_ptr</code>的大小可能不再和裸指针相同：有状态的删除器和采用函数指针的删除器会增加<code>std::unique_ptr</code>类型的对象尺寸大小。无状态的函数对象（例如无捕获的 lambda 表达式）不会浪费任何存储内存，而函数指针通常会使<code>std::unique_ptr</code>的大小增加一到两个字长（word），这意味着无捕获的 lambda 表达式往往是用作删除器的最佳选择。</p><p><code>std::unique_ptr</code>提供了两种形式，一种是单个对象（<code>std::unique_ptr&lt;T&gt;</code>），另一种是数组（<code>std::unique_ptr&lt;T[]&gt;</code>）。为了避免二义性，单个对象形式不提供索引运算符（<code>operator[]</code>），而数组形式不提供解引用运算符（<code>operator*</code>和<code>operator-&gt;</code>）。但实际上，数组形式用到的场合非常少，唯一的应用场合大概是在使用 C 风格 API 时，它返回了存放在堆上的裸指针；大部分时候我们会优先考虑<code>std::array</code>、<code>std::vector</code>和<code>std::string</code>这些数据结构。</p><p><code>std::unique_ptr</code>可以方便高效地转换为<code>std::shared_ptr</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> sp <span class="token operator">=</span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="条款-19：使用-std-shared-ptr-管理具备共享所有权的资源"><a href="#条款-19：使用-std-shared-ptr-管理具备共享所有权的资源" class="headerlink" title="条款 19：使用 std::shared_ptr 管理具备共享所有权的资源"></a>条款 19：使用 std::shared_ptr 管理具备共享所有权的资源</h3><p><code>std::shared_ptr</code>提供了方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。与<code>std::unique_ptr</code>相比，<code>std::shared_ptr</code>所占大小通常是裸指针的两倍，它还会带来控制块的开销，并且要求成本高昂的原子化的引用计数操作。</p><p>默认的资源析构通过<code>delete</code>运算符来完成，但同时也支持自定义删除器。与<code>std::unique_ptr</code>不同的是，删除器的类型对<code>std::shared_ptr</code>的类型没有影响，也不会影响<code>std::shared_ptr</code>的尺寸大小：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> loggingDel <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> pw<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>loggingDel<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">upw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span>                       <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这使得<code>std::shared_ptr</code>的设计更具弹性，拥有不同类型自定义删除器的<code>std::shared_ptr</code>也可以被放在同一个容器中：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> customDeleter1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 自定义删除器</span>
<span class="token keyword">auto</span> customDeleter2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 各有不同的类型</span>

std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">pw1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> customDeleter1<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">pw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> customDeleter2<span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">>></span> vpw<span class="token punctuation">{</span> pw1<span class="token punctuation">,</span> pw2 <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>控制块（control block）：</strong> 每一个由<code>std::shared_ptr</code>管理的对象都拥有一个控制块，它的内存被动态分配在堆上，除了包含引用计数以外，还包含作用于<code>std::weak_ptr</code>的弱计数（参考<strong>条款 20</strong>），自定义删除器以及从分配器等内容。</p><p>一个对象的控制块应该在创建首个指向该对象的<code>std::shared_ptr</code>时确定，因此，控制块的创建遵循以下规则：</p><ol><li>使用<code>std::make_shared</code>（参考<strong>条款 21</strong>）总是会创建一个控制块。</li><li>从具备专属所有权的指针（<code>std::unique_ptr</code>或<code>std::auto_ptr</code>）出发构造一个<code>std::shared_ptr</code>时，会创建一个控制块。</li><li>用裸指针作为实参调用<code>std::shared_ptr</code>的构造函数时，会创建一个控制块。</li></ol><p>由以上规则我们可以得出，应该避免使用裸指针类型的变量来创建<code>std::shared_ptr</code>。用同一个裸指针构造出不止一个<code>std::shared_ptr</code>将会使对象拥有多重的控制块，这会导致对资源的多次析构，产生未定义行为，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> pw <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pw 是个裸指针</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw1</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应该改为：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span>spw1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当你希望一个托管到<code>std::shared_ptr</code>的类能够安全地由<code>this</code>指针创建一个<code>std::shared_ptr</code>时，应该使该类继承自<code>std::enable_shared_from_this</code>，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::enable_shared_from_this</code>定义了一个成员函数<code>std::shared_from_this</code>，它会创建一个<code>std::shared_ptr</code>指向当前对象，但不会重复创建控制块：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">>></span> processedWidget<span class="token punctuation">;</span>

<span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 处理对象本身</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment" spellcheck="true">// 将指向当前对象的 std::shared_ptr 加入 processedWidget</span>
    processedWidget<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免用户在<code>std::shared_ptr</code>指向该对象前就调用了<code>std::shared_from_this</code>（这会导致其无法查询到对象拥有的控制块，产生未定义行为），继承自<code>std::enable_shared_from_this</code>的类通常会将其构造函数声明为 private，并且只允许通过调用返回<code>std::shared_ptr</code>的工厂函数来创建对象。例如，以下是<code>Widget</code>类的一个可能实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment" spellcheck="true">// 将实参完美转发给 private 构造函数的工厂函数</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
    <span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 构造函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::unique_ptr</code>可以轻易转换为<code>std::shared_ptr</code>，反之却并不成立，一旦资源的生存期被托管给了<code>std::shared_ptr</code>，就不能回收该资源的所有权，并让一个<code>std::unique_ptr</code>来托管它。并且和<code>std::unique_ptr</code>不同，<code>std::shared_ptr</code>直到 C++17 才拥有处理数组的能力（<code>std::shared_ptr&lt;T[]&gt;</code>），在 C++11/14 中，它的 API 仅被设计用来处理指向单个对象的指针。</p><h3 id="条款-20：对于类似-std-shared-ptr-但有可能空悬的指针使用-std-weak-ptr"><a href="#条款-20：对于类似-std-shared-ptr-但有可能空悬的指针使用-std-weak-ptr" class="headerlink" title="条款 20：对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr"></a>条款 20：对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr</h3><p><code>std::weak_ptr</code>并不是一种独立的智能指针，而是<code>std::shared_ptr</code>的一种扩充。它一般是通过<code>std::shared_ptr</code>来创建的，两者会指向相同位置，但<code>std::weak_ptr</code>并不影响所指向对象的引用计数，而是会影响控制块中的弱计数。</p><p>使用<code>expired</code>函数来检测<code>std::weak_ptr</code>的空悬：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> spw <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">wpw</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

spw <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// Widget 对象被析构，wpw 空悬</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>wpw<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 若 wpw 不再指向任何对象</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过<code>std::weak_ptr</code>创建<code>std::shared_ptr</code>，可以在未失效情况下提供对资源的访问：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 使用 lock 函数时，若 wpw 失效，则 spw1 和 spw2 为空</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw1 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> spw2 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 直接构造时，若 wpw 失效，则抛出 std::bad_weak_ptr 类型的异常</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw3</span><span class="token punctuation">(</span>wpw<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::weak_ptr</code>有以下可能的用武之地：</p><ul><li>创建带缓存的工厂函数：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> Widget<span class="token operator">></span> <span class="token function">fastLoadWidget</span><span class="token punctuation">(</span>WidgetID id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span>WidgetID<span class="token punctuation">,</span> std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> Widget<span class="token operator">>></span> cache<span class="token punctuation">;</span>

    <span class="token keyword">auto</span> objPtr <span class="token operator">=</span> cache<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果对象不在缓存中，则返回空指针</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>objPtr<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// 加载并缓存对象</span>
        objPtr <span class="token operator">=</span> <span class="token function">loadWidget</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cache<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> objPtr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> objPtr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>观察者设计模式（Observer design pattern）：多个观察者（observer）对象同时监听一个主题（subject）对象，主题对象会在其发生状态改变时发出通知。主题对象不会控制其观察者的生存期，但需要确认当一个观察者对象被析构后，主题对象不会再访问它。一种合理的设计就是让每个主题对象持有指向其观察者对象的<code>std::weak_ptr</code>，以便在使用之前确认它是否空悬。</li><li>避免<code>std::shared_ptr</code>循环引用：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">></span> pb<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> pa<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">auto</span> pa <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> pb <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

pa<span class="token operator">-</span><span class="token operator">></span>pb <span class="token operator">=</span> pb<span class="token punctuation">;</span>
pb<span class="token operator">-</span><span class="token operator">></span>pa <span class="token operator">=</span> pa<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，<code>A</code>和<code>B</code>互相保存着指向对方的<code>std::shared_ptr</code>，产生了循环引用，两者会永久保持彼此的引用计数至少为一，这会阻止<code>A</code>和<code>B</code>被析构，实际上产生了内存泄漏。</p><p>将其中一者改为<code>std::weak_ptr</code>可以避免循环的产生：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">></span> pb<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> pa<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-21：优先选用-std-make-unique-和-std-make-shared，而非直接使用-new"><a href="#条款-21：优先选用-std-make-unique-和-std-make-shared，而非直接使用-new" class="headerlink" title="条款 21：优先选用 std::make_unique 和 std::make_shared，而非直接使用 new"></a>条款 21：优先选用 std::make_unique 和 std::make_shared，而非直接使用 new</h3><p><code>std::make_shared</code>是 C++11 的一部分，但<code>std::make_unique</code>到了 C++14 才被加入标准库，不过要写出一个基础版本的<code>std::make_unique</code>非常容易：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_unique</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>相对于直接使用<code>new</code>运算符，make 函数有以下优势：</p><ul><li>消除重复代码：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">upw1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用 make 函数</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">upw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不使用 make 函数</span>

<span class="token keyword">auto</span> <span class="token function">spw1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用 make 函数</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不使用 make 函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>改进了异常安全性：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 有潜在的内存泄漏风险</span>

<span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 不具有潜在的内存泄漏风险</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在直接使用<code>new</code>运算符的情况下，由于分配<code>Widget</code>对象、执行<code>std::shared_ptr</code>构造函数、执行<code>computePriority</code>函数三者并不存在固定顺序，<code>computePriority</code>函数可能会晚于<code>Widget</code>对象的分配，先于<code>std::shared_ptr</code>的构造函数执行，此时若<code>computePriority</code>产生异常，那么分配的<code>Widget</code>内存就会发生泄漏。使用<code>std::make_shared</code>则不会产生这个问题。</p><ul><li>使用<code>std::make_shared</code>和<code>std::allocate_shared</code>有助于生成的尺寸更小、速度更快的目标代码。</li></ul><blockquote><p><code>std::make_shared</code>会将指向的对象和与其相关联的控制块分配在单块内存中，这种优化减少了程序的静态尺寸，并且因为只进行一次内存分配，还可以加块代码的运行速度。使用<code>std::make_shared</code>还可以减少对控制块一些簿记信息（bookkeeping information）的需要，潜在地减少了程序的内存占用量（memory footprint）。<code>std::allocate_shared</code>也是同理。</p></blockquote><p>虽然有着如此多的优势，但还是有一些情形下，不能或者不应该使用 make 函数：</p><ul><li>使用 make 函数无法自定义删除器，以及直接传递大括号内的初始值设定项：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 想要自定义删除器，就只能使用 new 运算符</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>widgetDeleter<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">upw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> widgetDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span>                          <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> widgetDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 只能间接传递初始化列表给 make 函数</span>
<span class="token keyword">auto</span> initList <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> spv <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">(</span>initList<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>不建议对自定义内存管理方式的类使用 make 函数：通常情况下，类自定义的<code>operator new</code>和<code>operator delete</code>被设计成用来分配和释放能精确容纳该类大小的内存块，但<code>std::allocate_shared</code>所要求的内存大小并不等于动态分配对象的大小，而是在其基础上加上控制块的大小。因此，使用 make 函数去创建重载了<code>operator new</code>和<code>operator delete</code>类的对象，通常并不是个好主意。</li><li>当处于特别关注内存的系统中时，若存在非常大的对象和比相应的<code>std::shared_ptr</code>生存期更久的<code>std::weak_ptr</code>，不建议使用 make 函数：这会导致对象的析构和内存的释放之间产生延迟，而若直接使用<code>new</code>运算符，内存的释放就不必等待<code>std::weak_ptr</code>的析构。</li></ul><p>如果你发现自己处于不应该使用<code>std::make_shared</code>的情形下，又不想受到之前所述异常安全问题的影响。最好的方法是确保在直接使用<code>new</code>时，立即将结果传递给智能指针的构造函数，并且在这条语句中不做其它任何事：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> cusDel<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="条款-22：使用-Pimpl-惯用法时，将特殊成员函数的定义放到实现文件中"><a href="#条款-22：使用-Pimpl-惯用法时，将特殊成员函数的定义放到实现文件中" class="headerlink" title="条款 22：使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中"></a>条款 22：使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中</h3><p>Pimpl 惯用法的第一部分，是声明一个指针类型的数据成员，指向一个非完整类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">struct</span> Impl<span class="token punctuation">;</span>
    Impl<span class="token operator">*</span> pImpl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二部分是动态分配和回收持有原始类中数据成员的对象，而分配和回收的代码被放在实现文件中：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Widget<span class="token operator">::</span>Impl <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">// Widget::Impl 的实现</span>
    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 包含在原始 Widget 类中的数据成员</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span>
    Gadget g1<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> g3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span><span class="token keyword">new</span> Impl<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 为 Widget 对象分配数据成员所需内存</span>

Widget<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> pImpl<span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 为 Widget 对象析构数据成员</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面展示的是 C++98 的写法，使用了裸指针、裸<code>new</code>运算符和裸<code>delete</code>运算符。而到了 C++11，使用<code>std::unique_ptr</code>替代指向<code>Impl</code>的裸指针成为了首选：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明代码位于头文件 widget.h 内</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">struct</span> Impl<span class="token punctuation">;</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 实现代码位于实现文件 widget.cpp 内</span>

<span class="token keyword">struct</span> Widget<span class="token operator">::</span>Impl <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 同前</span>
    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span>
    Gadget g1<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> g3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Impl<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遗憾的是，这段代码本身能通过编译，但在创建对象时却会报错。因为编译器自动生成的析构函数默认是<code>inline</code>的，而<code>std::unique_ptr</code>的默认删除器要求其指向完整类型，所以即使默认特殊函数的实现有着正确行为，我们仍必须将其声明和实现分离：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明代码位于头文件 widget.h 内</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">struct</span> Impl<span class="token punctuation">;</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 实现代码位于实现文件 widget.cpp 内</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Impl<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

Widget<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 写成 Widget::~Widget() = default; 效果相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<strong>条款 17</strong> 中我们提到，声明析构函数会阻止编译器生成移动操作，所以假如你需要支持移动操作，也必须采用声明和实现分离的方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明代码位于头文件 widget.h 内</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 实现代码位于实现文件 widget.cpp 内</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器不会为带有<code>std::unique_ptr</code>这种只移类型的类生成拷贝操作，假如你需要支持拷贝操作，则需要自行编写执行深拷贝的函数实现，并且同样需要遵守前面所说的规则：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明代码位于头文件 widget.h 内</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 实现代码位于实现文件 widget.cpp 内</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Impl<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>pImpl <span class="token operator">=</span> <span class="token operator">*</span>rhs<span class="token punctuation">.</span>pImpl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述建议仅仅适用于<code>std::unique_ptr</code>，而不适用于<code>std::shared_ptr</code>。对于<code>std::shared_ptr</code>而言，删除器类型并非智能指针类型的一部分，这就会导致更大的运行时数据结构以及更慢的目标代码，但在使用编译器生成的特殊函数时，并不要求其指向完整类型。以下代码并不会产生问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token comment" spellcheck="true">// 不再需要析构函数或移动操作的声明</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">struct</span> Impl<span class="token punctuation">;</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就 Pimpl 惯用法而言，并不需要在<code>std::unique_ptr</code>和<code>std::shared_ptr</code>的特性之间作出权衡，因为<code>Widget</code>和<code>Impl</code>之间的关系是专属所有权，所以在此处<code>std::unique_ptr</code>就是完成任务的合适工具。</p><h2 id="第五章：右值引用、移动语义和完美转发"><a href="#第五章：右值引用、移动语义和完美转发" class="headerlink" title="第五章：右值引用、移动语义和完美转发"></a>第五章：右值引用、移动语义和完美转发</h2><p>在阅读本章中的条款时，需要铭记一点：形参总是左值，即使其类型是右值引用。例如给定函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>尽管形参<code>w</code>的类型是指向<code>Widget</code>对象的右值引用，可以传入绑定到右值的实参，但它仍然是个左值。</p><h3 id="条款-23：理解-std-move-和-std-forward"><a href="#条款-23：理解-std-move-和-std-forward" class="headerlink" title="条款 23：理解 std::move 和 std::forward"></a>条款 23：理解 std::move 和 std::forward</h3><p><code>std::move</code>执行的是向右值的无条件强制类型转换，就其自身而言，它不会移动任何东西。它的基本实现大致是这样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// C++11 版本</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">typename</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> ReturnType <span class="token operator">=</span> <span class="token keyword">typename</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ReturnType<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// C++14 版本</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> ReturnType <span class="token operator">=</span> remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ReturnType<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::move</code>并不改变常量性，也不保证经过其强制类型转换后的对象可被移动，针对常量对象执行的移动操作可能会悄无声息地转化为拷贝操作，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Annotation</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">Annotation</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string text<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 想要将 text “移动入” value</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 但实际上执行了 std::string 的拷贝构造函数</span>
                                            <span class="token comment" spellcheck="true">// 而非移动构造函数 string(string&amp;&amp;)</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>string value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，如果想要取得对某个对象执行移动操作的能力，就不要将其声明为常量。</p><p>与<code>std::move</code>不同，<code>std::forward</code>是有条件的。仅当传入的实参被绑定到右值时，<code>std::forward</code>才会针对该实参执行向右值的强制类型转换，它同样不会转发任何东西。</p><p><code>std::forward</code>的一个典型应用场景，是某个函数模板使用万能引用作为形参，随后将其传递给另一个函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> lvalArg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 处理左值</span>
<span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rvalArg<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 处理右值</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">logAndProcess</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 使用万能引用作为实参</span>
    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span><span class="token string">"Calling 'process'"</span><span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若在调用<code>logAndProcess</code>时传入左值，那么该左值自然会传递给处理左值版本的<code>process</code>函数；若在调用<code>logAndProcess</code>时传入右值，由于函数形参皆为左值，必须要通过<code>std::forward</code>将<code>param</code>强制转换为右值类型，才能得以正确调用处理右值版本的<code>process</code>函数。<code>std::forward</code>会通过模板类型<code>T</code>来判断是否该对<code>param</code>进行强制类型转换，具体的原理细节参考<strong>条款 28</strong>。</p><p>尽管<code>std::move</code>和<code>std::forward</code>归根结底都是强制类型转换，但两者的行为具有本质上的不同：前者用于为移动操作进行铺垫，而后者仅仅用于转发一个对象到另一个函数，在此过程中该对象仍保持原来的左值性或右值性。</p><blockquote><p>需要注意的是，在运行期，<code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p></blockquote><h3 id="条款-24：区分万能引用和右值引用"><a href="#条款-24：区分万能引用和右值引用" class="headerlink" title="条款 24：区分万能引用和右值引用"></a>条款 24：区分万能引用和右值引用</h3><p>如果函数模板形参的类型为<code>T&amp;&amp;</code>，并且 T 的类型需要推导得到，或一个对象使用<code>auto&amp;&amp;</code>声明其类型，则此处的<code>T&amp;&amp;</code>和<code>auto&amp;&amp;</code>表示<strong>万能引用（universal reference）</strong>；如果类型声明不是标准的<code>type&amp;&amp;</code>形式，或者并未发生类型推导，则此处的<code>type&amp;&amp;</code>表示右值引用。</p><p>符合万能引用的情形如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> var2 <span class="token operator">=</span> var1<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">>></span>
<span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
    <span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> timeFuncInvocation <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> func<span class="token punctuation">,</span> <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// C++14</span>
    std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span>                         <span class="token comment" spellcheck="true">// 调用 func</span>
        std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               <span class="token comment" spellcheck="true">// 取用 params</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型声明不是标准<code>type&amp;&amp;</code>的情形如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// param 是右值引用</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// param 是右值引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型是<code>T&amp;&amp;</code>，但并未发生类型推导的情形如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">>></span>
<span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// x 是右值引用</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若使用右值来初始化万能引用，就会得到一个右值引用；同理，若使用左值来初始化万能引用，就会得到一个左值引用。如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// param 是万能引用</span>

Widget w<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 左值被传递给 f，param 的类型为 Widget&amp;</span>

<span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右值被传递给 f，param 的类型为 Widget&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-25：针对右值引用实施-std-move，针对万能引用实施-std-forward"><a href="#条款-25：针对右值引用实施-std-move，针对万能引用实施-std-forward" class="headerlink" title="条款 25：针对右值引用实施 std::move，针对万能引用实施 std::forward"></a>条款 25：针对右值引用实施 std::move，针对万能引用实施 std::forward</h3><p>右值引用一定会被绑定到右值，因此当转发右值引用给其他函数时，应当通过<code>std::move</code>对其实施向右值的无条件强制类型转换：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token function">p</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SomeDataStructure<span class="token operator">></span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而万能引用不一定会被绑定到右值，因此当转发万能引用时，应当通过<code>std::forward</code>对其实施向右值的有条件强制类型转换：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然针对右值引用实施<code>std::forward</code>也能硬弄出正确行为，但代码啰嗦、易错，且不符合习惯用法；而针对万能引用实施<code>std::move</code>会造成更加严重的后果，这会导致某些左值遭受意外的改动：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SomeDataStructure<span class="token operator">></span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>string <span class="token function">getWidgetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 工厂函数</span>

Widget w<span class="token punctuation">;</span>
<span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token function">getWidgetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
w<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 将 n 移入 w</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                         <span class="token comment" spellcheck="true">// n 的值变为未知</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一种手法是将万能引用的版本改成对左值和右值分别进行重载：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> newName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        name <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种手法虽然看似可以解决问题，但是拥有更大的缺点：第一，需要编写和维护更多源码；第二，效率会大打折扣（产生额外的临时对象）；第三，可扩展性太差。因此，正确地使用万能引用才是问题的唯一解决之道。</p><p>在有些情况下，你可能想在函数内将某个对象不止一次地绑定到右值引用或万能引用，并且想保证在完成对该对象地其它所有操作之前，其值不会发生移动，那么就得仅在最后一次使用该引用时，对其实施<code>std::move</code>或<code>std::forward</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">setSignText</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sign<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 使用 text，但不修改其值</span>

    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    signHistory<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 有条件地将 text 强制转换为右值</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在极少数的情况下，你需要用<code>std::move_if_noexcept</code>来代替<code>std::move</code>。</p><blockquote><p><code>std::move_if_noexcept</code>是<code>std::move</code>的一个变体，它是否会将对象强制转换为右值，取决于其类型的移动构造函数是否带有 noexcept 声明。</p></blockquote><p>在按值返回的函数中，如果返回的是绑定到右值引用或万能引用的对象，则当你返回该引用时，应当对其实施<code>std::move</code>或<code>std::forward</code>，这样可以避免编译器将其视作左值，从而消除拷贝左值进入返回值存储位置的额外开销：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 按值返回右值引用形参</span>
Matrix <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>Matrix<span class="token operator">&amp;&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Matrix<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lhs <span class="token operator">+</span><span class="token operator">=</span> rhs<span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 按值返回万能引用形参</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
Fraction <span class="token function">reduceAndCopy</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> frac<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    frac<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>frac<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是若局部对象可能适用于<strong>返回值优化（return value optimization，RVO）</strong>，则请勿对其实施<code>std::move</code>或<code>std::forward</code>。这是因为当 RVO 的前提条件得到满足时，要么发生<strong>拷贝省略（copy elision）</strong>，要么<code>std::move</code>会隐式地被实施于返回的局部对象上；而人为地添加<code>std::move</code>或<code>std::forward</code>，会导致编译器失去执行 RVO 的能力。</p><p>下面的<code>makeWidget</code>函数满足 RVO 的两个前提条件：局部对象类型和函数返回值类型相同，且返回的就是局部对象本身：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> w<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但由于函数形参不适合实施拷贝省略，所以编译器必须处理以上代码，使其与以下代码等价：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-26：避免对万能引用类型进行重载"><a href="#条款-26：避免对万能引用类型进行重载" class="headerlink" title="条款 26：避免对万能引用类型进行重载"></a>条款 26：避免对万能引用类型进行重载</h3><p>形参为万能引用的函数是 C++ 中最贪婪的，它们会在具现过程中和几乎所有实参类型产生精确匹配（极少的不适用实参将在<strong>条款 30</strong> 中介绍），这就是为何把重载和万能引用两者结合通常不会达到预期效果。考虑如下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token operator">::</span>string <span class="token function">nameFromIdx</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">short</span> nameIdx<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 用 short 类型持有索引值</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token function">logAndAdd</span><span class="token punctuation">(</span>nameIdx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用的却是万能引用版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>logAndAdd</code>有两个重载版本，形参类型为万能引用的版本可以将<code>T</code>推导为<code>short</code>，从而产生精确匹配；而形参类型为<code>int</code>的版本却只能在类型提升后才可以匹配到<code>short</code>类型的实参。因此，形参类型为万能引用的版本才是被优先调用的版本。</p><p>当完美转发出现在类的构造函数中时，情况会变得更加复杂：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>        <span class="token comment" spellcheck="true">// 完美转发构造函数</span>
    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 形参为 int 的构造函数</span>

    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 拷贝构造函数（由编译器生成）</span>

    <span class="token function">Person</span><span class="token punctuation">(</span>Person<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 移动构造函数（由编译器生成）</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于非常量的左值类型，完美转发构造函数一般都会优先于拷贝构造函数形成匹配；而对于常量左值类型，完美转发构造函数和拷贝构造函数具有相等的匹配程度，此时由于非函数模板会优先于函数模板被匹配，编译器才会转向调用拷贝构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Person <span class="token function">p</span><span class="token punctuation">(</span><span class="token string">"Nancy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">cloneOfP</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 调用完美转发构造函数，无法通过编译</span>

<span class="token keyword">const</span> Person <span class="token function">cp</span><span class="token punctuation">(</span><span class="token string">"Nancy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 对象成为了常量</span>
<span class="token keyword">auto</span> <span class="token function">cloneOfCp</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 会正确调用拷贝构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完美转发构造函数还会劫持派生类中对基类的拷贝和移动构造函数的调用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SpecialPerson</span> <span class="token operator">:</span> <span class="token keyword">public</span> Person <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">SpecialPerson</span><span class="token punctuation">(</span><span class="token keyword">const</span> SpecialPerson<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 拷贝构造函数</span>
        <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 调用的是基类的完美转发构造函数！</span>

    <span class="token function">SpecialPerson</span><span class="token punctuation">(</span>SpecialPerson<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 移动构造函数</span>
        <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// 调用的是基类的完美转发构造函数！</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-27：熟悉对万能引用类型进行重载的替代方案"><a href="#条款-27：熟悉对万能引用类型进行重载的替代方案" class="headerlink" title="条款 27：熟悉对万能引用类型进行重载的替代方案"></a>条款 27：熟悉对万能引用类型进行重载的替代方案</h3><p><strong>1. 放弃重载</strong></p><p><strong>2. 传递<code>const T&amp;</code>类型的形参</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法可以避免重载万能引用带来的不良影响，但会舍弃一些性能。</p><p><strong>3. 传值</strong></p><p>把传递的形参从引用类型换成值类型，是一种经常能够提升性能，却不会增加任何复杂性的方法，尽管这有些反直觉。这种设计遵循了<strong>条款 41</strong> 的建议——当你知道肯定需要复制形参时，考虑按值传递对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string n<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 替换掉 T&amp;&amp; 类型的构造函数</span>
        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 同前</span>
        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 使用标签分派（tag dispatch）</strong></p><p>在这个方案中，我们将实际重载和实现功能的函数改为<code>logAndAddImpl</code>，而<code>logAndAdd</code>仅仅用于执行完美转发和标签分派：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">logAndAddImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>
        std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// C++14 可以使用 std::remove_reference_t</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对<code>std::is_integral</code>产生的布尔值，我们可以写出两个<code>logAndAddImpl</code>重载版本，用于区分它们的类型<code>std::false_type</code>和<code>std::true_type</code>就是所谓 “标签”。具体实现代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">logAndAddImpl</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">,</span> std<span class="token operator">::</span>false_type<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 非整型实参</span>
    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token operator">::</span>string <span class="token function">nameFromIdx</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">logAndAddImpl</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> std<span class="token operator">::</span>true_type<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 整型实参</span>
    <span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. 对接受万能引用的模板施加限制</strong></p><p>通过 SFINAE 技术和<code>std::enable_if</code>，我们可以让一些模板在满足了指定条件的情况下才被启用，它的使用方式大致如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span>
             <span class="token keyword">typename</span> <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span>condition<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span>    <span class="token comment" spellcheck="true">// C++14 可以使用 std::enable_if_t</span>
    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处我们想要<code>T</code>是<code>Person</code>以外的类型时，才启用该模板构造函数，则我们可以写下面这样的条件：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">!</span>std<span class="token operator">::</span>is_same<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>decay<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span><span class="token operator">::</span>value  <span class="token comment" spellcheck="true">// C++17 可以使用 std::is_same_v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>std::decay</code>用于使类型完全退化，在此处用来移除<code>T</code>的引用和 cv 限定符（即<code>const</code>或<code>volatile</code>限定符），使我们可以更加纯粹地关注类型本身。<code>std::decay</code>还可以用于把数组和函数类型强制转换为指针类型（参考<strong>条款 1</strong>），它当然也拥有更易用的 C++14 版本，即<code>std::decay_t</code>。</p><p>写出这个条件并不意味着完成，<strong>条款 26</strong> 中还提到了在派生类中调用基类的拷贝和移动构造函数时，错误调用完美转发构造函数的问题。因此，我们想要的是为<code>Person</code>和继承自<code>Person</code>的类型都不一样的实参类型启用模板构造函数。标准库中的<code>std::is_base_of</code>用于判断一个类型是否由另一个类型派生而来，用它代替<code>std::is_same</code>就可以得到我们想要的东西（C++17 可以使用<code>std::is_base_of_v</code>）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span>
        <span class="token keyword">typename</span> T<span class="token punctuation">,</span>
        <span class="token keyword">typename</span> <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span>
                       <span class="token operator">!</span>std<span class="token operator">::</span>is_base_of<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> 
                                        <span class="token keyword">typename</span> std<span class="token operator">::</span>decay<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type
                                       <span class="token operator">></span><span class="token operator">::</span>value
                   <span class="token operator">></span><span class="token operator">::</span>type
    <span class="token operator">></span>
    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再加上处理整型实参的构造函数重载版本，并进一步限制模板构造函数，禁止其接受整型实参，我们得到的完美的<code>Person</code>类代码如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span>
        <span class="token keyword">typename</span> T<span class="token punctuation">,</span>
        <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>
            <span class="token operator">!</span>std<span class="token operator">::</span>is_base_of<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> std<span class="token operator">::</span>decay_t<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token operator">::</span>value
            <span class="token operator">&amp;&amp;</span>
            <span class="token operator">!</span>std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span>std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token operator">::</span>value
        <span class="token operator">></span>
    <span class="token operator">></span>
    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">// 接受 std::string 类型以及可以强制转换为 </span>
    <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// std::string 类型的实参的构造函数</span>

    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 接受整型实参的构造函数</span>
    <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment" spellcheck="true">// 拷贝和移动构造函数等</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>权衡</strong></p><p>本条款讨论的前三种方案（舍弃重载，传递<code>const T&amp;</code>类型的形参和传值）都需要对待调用的函数形参逐一指定类型，而后两种方案（使用标签分派和对接受万能引用的模板施加限制）则使用了完美转发，因此无需指定形参类型。</p><p>按照常理，完美转发的效率更高，因为它将类型保持和形参声明时完全一致，所以会避免创建临时对象。但完美转发也有一些不足：首先是针对某些类型无法实现完美转发（参考<strong>条款 30</strong>），其次是完美转发会使得在传递非法形参时，出现更难理解的错误信息。</p><p><code>std::is_constructible</code>这个类型特征（type trait）可以在编译期判断某个类型的对象是否可以用另一类型的对象（或不同类型的多个对象）来构造，我们可以用它来验证转发函数的万能引用形参是否合法。下面是增加了<code>static_assert</code>后的<code>Person</code>类，它可以产生更明确的报错信息：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">>></span>  <span class="token comment" spellcheck="true">// 同前</span>
    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 断言可以用 T 类型的对象构造 std::string</span>
        <span class="token keyword">static_assert</span><span class="token punctuation">(</span>
            std<span class="token operator">::</span>is_constructible<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// C++17 可以使用 std::is_constructible_v</span>
            <span class="token string">"Parameter n can't be used to construct a std::string"</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// 构造函数通常要完成的工作</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-28：理解引用折叠"><a href="#条款-28：理解引用折叠" class="headerlink" title="条款 28：理解引用折叠"></a>条款 28：理解引用折叠</h3><p>在<strong>条款 24</strong> 中我们了解了万能引用和右值引用的区别，但实际上万能引用并非一种新的引用类型，其实它就是在满足下面两个条件的语境中的右值引用：</p><ol><li>类型推导的过程中会区分左值和右值；</li><li>会发生<strong>引用折叠（reference collapsing）</strong>。</li></ol><p>C++ 标准禁止直接声明 “引用的引用” ，但引用折叠不受此限制。当左值被传递给接受万能引用的函数模板时，会发生下面这样的状况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">func</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用 func 并传入左值，T 推导出的类型为 Widget&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>代入<code>T</code>的推导类型，我们可以得到下面这样的具现化模板：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现了引用的引用！然而这并不违规，引用折叠的规则会把双重引用折叠成单个引用，规则如下：</p><blockquote><p>如果任一引用为左值引用，则结果为左值引用，否则（即两个皆为右值引用），结果为右值引用。</p></blockquote><p>所以实际上的函数签名为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>引用折叠是使<code>std::forward</code>得以运作的关键，也是将左值或右值信息编码到万能引用形参<code>T</code>中的实现途径。<code>std::forward</code>的任务是，当且仅当编码在<code>T</code>中的信息表明传递的实参是右值，即<code>T</code>推导出的类型是个非引用类型时，对左值形参实施到右值的强制类型转换。它的基本实现大致是这样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// C++11 版本</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// C++14 版本</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设传递给函数<code>forward</code>的实参类型是左值<code>Widget</code>，则模板的具现化结果可以写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>发生引用折叠后，生成的最终结果如下，可以看出左值类型并不会发生改变：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>假设传递给函数<code>forward</code>的实参类型是右值<code>Widget</code>，则模板的具现化结果可以写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>发生引用折叠后，生成的最终结果如下，显然左值类型的形参会被强制转换为右值：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>引用折叠会在四种语境中出现：模板具现化，<code>auto</code>类型推断，创建和使用<code>typedef</code>和别名声明，以及<code>decltype</code>。</p><p><code>auto</code>类型推断中发生的引用折叠：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 变量（左值）</span>
Widget <span class="token function">widgetFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回右值的函数</span>

<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> w1 <span class="token operator">=</span> w<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 推导出 Widget&amp; &amp;&amp; w1，引用折叠后为 Widget&amp; w1</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> w2 <span class="token operator">=</span> <span class="token function">widgetFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 推导出 Widget&amp;&amp; w1，不会发生引用折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建和使用<code>typedef</code>中发生的引用折叠：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> T<span class="token operator">&amp;&amp;</span> RvalueRefToT<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Widget<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span> w<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用左值引用类型来具现化 Widget 模板</span>

<span class="token comment" spellcheck="true">// 具现化后得到 typedef int&amp; &amp;&amp; RvalueRefToT</span>
<span class="token comment" spellcheck="true">// 引用折叠后为 typedef int&amp; RvalueRefToT</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一种会发生引用折叠的语境在<code>decltype</code>的运用中：如果在分析一个涉及<code>decltype</code>的类型时出现了引用的引用，则引用折叠会介入并将其消灭。</p><h3 id="条款-29：假定移动操作不存在、成本高、未被使用"><a href="#条款-29：假定移动操作不存在、成本高、未被使用" class="headerlink" title="条款 29：假定移动操作不存在、成本高、未被使用"></a>条款 29：假定移动操作不存在、成本高、未被使用</h3><p>在下面几个情形下，C++11 的移动语义不会给你带来什么好处：</p><ul><li><strong>没有移动操作：</strong> 待移动的对象未能提供移动操作。因此，移动请求就变成了拷贝请求。</li><li><strong>移动未能更快：</strong> 待移动的对象虽然有移动操作，但并不比其拷贝操作更快。</li></ul><blockquote><p>移动操作不比拷贝操作更快的例子：<code>std::array</code>将数据直接存储在对象内，移动<code>std::array</code>需要逐个移动容器内的每个元素；开启了<strong>短字符串优化（small string optimization，SSO）</strong> 的<code>std::string</code>，它会将字符串存储在<code>std::string</code>对象的某个缓冲区内，而非使用堆上的内存。</p></blockquote><ul><li><strong>移动不可用：</strong> 移动本可以发生的情况下，要求移动操作不会抛出异常，但该操作未加上<code>noexcept</code>声明。</li><li><strong>源对象是左值：</strong> 只有右值可以作为移动操作的源。</li></ul><p>因此，我们应该为通用的代码假定移动操作不存在、成本高且未被使用。然而，对于已知的类型或支持移动语义的代码中，就不需要作上述假定，在你知道移动操作成本低廉的情况下，可以放心大胆地将拷贝操作替换为相对不那么昂贵的移动操作。</p><h3 id="条款-30：熟悉完美转发的失败情形"><a href="#条款-30：熟悉完美转发的失败情形" class="headerlink" title="条款 30：熟悉完美转发的失败情形"></a>条款 30：熟悉完美转发的失败情形</h3><p>完美转发的含义是我们不仅转发对象，还转发其特征：类型，是左值还是右值，以及是否带有<code>const</code>和<code>volatile</code>限定符。出于此目的，我们会运用万能引用来将左、右值信息编码到类型中，而用于转发的函数自然也该是泛型的，它的标准形式如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">fwd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了使转发函数能接受任意数量的形参，使用可变参数模板也在我们的考虑范围内：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">fwd</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>若用相同实参调用<code>f</code>和<code>fwd</code>会执行不同的操作，则称<code>fwd</code>将实参完美转发到<code>f</code>失败。完美转发的失败情形源于模板类型推导失败，或推导出错误的类型。下面我们将了解会造成完美转发失败的典型例子。</p><p><strong>大括号初始值设定项（Braced initializers）</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// “{ 1, 2, 3 }” 会隐式转换为 std::vector&lt;int></span>
<span class="token function">fwd</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 无法通过编译！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于<code>fwd</code>的形参为被声明为<code>std::initializer_list</code>，编译器就会被禁止在<code>fwd</code>的调用过程中从表达式<code>{ 1, 2, 3 }</code>出发来推导类型。既然无法推导出形参的类型，那么编译器也只能拒绝对<code>fwd</code>的调用。</p><p>我们可以通过先用<code>auto</code>声明一个局部变量，再传递给<code>fwd</code>来避免这个问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> il <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// il 的类型被推导为 std::initializer_list&lt;int></span>
<span class="token function">fwd</span><span class="token punctuation">(</span>il<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 没问题，将 il 完美转发给 f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>0 和 NULL 作空指针</strong></p><p><strong>条款 8</strong> 中曾经说明过，当你试图将<code>0</code>或<code>NULL</code>作为空指针传递给模板时，类型推导就会发生错误，将实参推导为一个整型而非指针类型，结果不管是<code>0</code>还是<code>NULL</code>都不会作为空指针被完美转发。解决方法非常简单，传一个<code>nullptr</code>而不是<code>0</code>或<code>NULL</code>。</p><p><strong>仅有声明的整型<code>static const</code>成员变量</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> std<span class="token operator">::</span>size_t MinVals <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 仅提供 MinVals 的声明</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>                                          <span class="token comment" spellcheck="true">// 未给出 MinVals 的定义</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t v<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span>Widget<span class="token operator">::</span>MinVals<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 没问题，当作 “f(28)” 处理</span>
<span class="token function">fwd</span><span class="token punctuation">(</span>Widget<span class="token operator">::</span>MinVals<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 可能无法通过链接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般而言，编译器会绕过<code>MinVals</code>缺少定义的事实，并用其值替换所有涉及到<code>MinVals</code>的地方，但并不会为其实际分配存储空间。这就导致如果我们尝试对<code>MinVals</code>实施取地址或对它进行引用，就会导致链接无法通过，这也就是为何不能将<code>Widget::MinVals</code>作为实参传递给<code>fwd</code>。</p><p>按照标准，按引用传递<code>MinVals</code>时要求<code>MinVals</code>有定义。然而并不是所有实现都遵循了这个规定，对于一些编译器和链接器，你会发现将<code>MinVals</code>用于完美转发并不会产生错误，甚至对它取地址也不会。但为了代码的可移植性，还是应当重视此处所讲的规则，为<code>static const</code>成员变量提供定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> std<span class="token operator">::</span>size_t Widget<span class="token operator">::</span>MinVals<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 在 Widget 的 .cpp 文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>重载函数的名称和模板名称</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 或者 void f(int pf(int))</span>

<span class="token keyword">int</span> <span class="token function">processVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">processVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span>processVal<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 没问题</span>
<span class="token function">fwd</span><span class="token punctuation">(</span>processVal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 错误！无法确定是哪个重载版本</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
T <span class="token function">workOnVal</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token function">fwd</span><span class="token punctuation">(</span>workOnVal<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 错误！无法确定是 workOnVal 的哪个实例</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们将<code>processVal</code>传递给<code>f</code>时，由于<code>f</code>的形参类型是已知的，编译器自然也知道它需要的是<code>processVal</code>的哪个重载版本；但纯粹的函数名称<code>processVal</code>并不包含类型信息，类型推导更是无从谈起，将它传递给<code>fwd</code>只会造成完美转发失败而已。</p><p>要让<code>fwd</code>接受重载函数的名称或模板名称，只能手动指定需要转发的哪个重载版本或模板实例。例如下面的做法就是合理的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> ProcessFuncType <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ProcessFuncType processValPtr <span class="token operator">=</span> processVal<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 指定了需要的 processVal 签名</span>

<span class="token function">fwd</span><span class="token punctuation">(</span>processValPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// 没问题</span>
<span class="token function">fwd</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ProcessFuncType<span class="token operator">></span><span class="token punctuation">(</span>workOnVal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 也没问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>位域</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> IPv4Header <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 用于表示 IPv4 头部的模型</span>
    std<span class="token operator">::</span>uint32_t version<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>
                  IHL<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>
                  DSCP<span class="token operator">:</span><span class="token number">6</span><span class="token punctuation">,</span>
                  ECN<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>
                  totalLength<span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t sz<span class="token punctuation">)</span><span class="token punctuation">;</span>

IPv4Header h<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token function">f</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 没问题</span>
<span class="token function">fwd</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 错误！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++ 标准规定：非常引用不得绑定到位域。位域是由机器字的若干任意部分组成的，但这样的实体是无法对其直接取地址的，无法将指针指向它，因此也无法对其进行引用。</p><blockquote><p>实际上常引用也不可能绑定到位域，它们绑定到的是 “常规” 对象（某种标准整型，例如<code>int</code>），其中拷贝了位域的值。</p></blockquote><p>将位域传递给转发函数的可能途径是制作一个副本，并以该副本调用转发函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 拷贝位域值，使用的初始化形式参考条款 6</span>
<span class="token keyword">auto</span> length <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>uint16_t<span class="token operator">></span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">fwd</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转发该副本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第六章：lambda-表达式"><a href="#第六章：lambda-表达式" class="headerlink" title="第六章：lambda 表达式"></a>第六章：lambda 表达式</h2><p>在开始本章之前，需要理解几个基本的概念：</p><ul><li><strong>lambda 表达式（lambda expression）：</strong> 表达式的一种，它的基本写法如下所示：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;</span> val <span class="token operator">&amp;&amp;</span> val <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>闭包（closure）：</strong> lambda 所创建的运行期对象，根据不同的捕获模式，闭包会持有数据的副本或引用。</li><li><strong>闭包类（closure class）：</strong> 实例化闭包的类，每个 lambda 都会使编译器生成唯一的闭包类。lambda 中的语句会成为其闭包类的成员函数中的可执行指令。</li></ul><blockquote><p>lambda 表达式和闭包类存在于编译期，而闭包存在于运行期。</p></blockquote><h3 id="条款-31：避免默认捕获模式"><a href="#条款-31：避免默认捕获模式" class="headerlink" title="条款 31：避免默认捕获模式"></a>条款 31：避免默认捕获模式</h3><p>C++11 中有两种默认捕获模式：按引用或按值。按引用捕获会导致闭包内包含指向局部变量的引用，或指向定义 lambda 的作用域内形参的引用，一旦由 lambda 所创建的闭包越过了该局部变量或形参的生命周期，那么闭包内的引用就会发生空悬：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> FilterContainer <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">;</span>
FilterContainer filters<span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">// 元素为筛选函数的容器</span>

<span class="token keyword">void</span> <span class="token function">addDivisorFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> calc1 <span class="token operator">=</span> <span class="token function">computeSomeValue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> calc2 <span class="token operator">=</span> <span class="token function">computeSomeValue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> divisor <span class="token operator">=</span> <span class="token function">computeDivisor</span><span class="token punctuation">(</span>calc1<span class="token punctuation">,</span> calc2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 危险！指向 divisor 的引用可能空悬</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换作用显式方式按引用捕获<code>divisor</code>，问题依旧会发生，但更容易看出 lambda 依赖于<code>divisor</code>的生命周期这一问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
    <span class="token punctuation">[</span><span class="token operator">&amp;</span>divisor<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一种权宜之计是不使用容器来存放筛选函数，转而使用 C++11 的<code>std::all_of</code>对每个元素逐一进行判断。但如果将该 lambda 拷贝到其它闭包比<code>divisor</code>生命周期更长的语境中，则空悬引用的问题仍会发生：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> C<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">workWithContainer</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> calc1 <span class="token operator">=</span> <span class="token function">computeSomeValue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> calc2 <span class="token operator">=</span> <span class="token function">computeSomeValue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> divisor <span class="token operator">=</span> <span class="token function">computeDivisor</span><span class="token punctuation">(</span>calc1<span class="token punctuation">,</span> calc2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">using</span> ContElemT <span class="token operator">=</span> <span class="token keyword">typename</span> C<span class="token operator">::</span>value_type<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 取得容器中的元素类型（参考条款 13）</span>

    <span class="token keyword">using</span> std<span class="token operator">::</span>begin<span class="token punctuation">;</span>
    <span class="token keyword">using</span> std<span class="token operator">::</span>end<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">all_of</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 判断是否所有元素都是 divisor 的倍数</span>
        <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> ContElemT<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">// C++14 可以直接写成 const auto&amp; value</span>
        <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本例中，使用默认的按值捕获模式就足以解决问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
    <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是默认的按值捕获模式也有其问题：默认的按值捕获极易受到空悬指针的影响（尤其是<code>this</code>指针），并且会误导人们认为 lambda 是独立的。考虑如下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> divisor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用于 Widget 的 filters</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于此处的 lambda 而言，<code>divisor</code>既不是局部变量，也不是形参，按理来讲是压根无法被捕获的。事实也确实如此，被捕获的实际上是<code>Widget</code>的<code>this</code>指针，而不是<code>divisor</code>。对于编译器来说，<code>addFilter</code>的代码相当于：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> currentObjectPtr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span>currentObjectPtr<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> currentObjectPtr<span class="token operator">-</span><span class="token operator">></span>divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>理解了这一点，也就能理解 lambda 闭包的存活依赖于它含有的<code>this</code>指针副本所指向的<code>Widget</code>对象的生命周期。假如面临以下代码，空悬指针的问题将出现在我们的眼前：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> FilterContainer <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">;</span>
FilterContainer filters<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 同前</span>

<span class="token keyword">void</span> <span class="token function">doSomeWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> pw <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 创建 Widget，std::make_unique 的使用参考条款 21</span>

    pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 添加使用了 Widget::divisor 的筛选函数</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>                                           <span class="token comment" spellcheck="true">// Widget 被销毁，filters 现在持有空悬指针！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一种解决方法是将你想捕获的成员变量拷贝至局部变量中，之后再捕获该副本局部变量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> divisorCopy <span class="token operator">=</span> divisor<span class="token punctuation">;</span>

    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span>divisorCopy<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisorCopy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++14 中，捕获成员变量的一种更好的方法是使用<strong>广义 lambda 捕获（generalized lambda capture，参考条款 32）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span>divisor <span class="token operator">=</span> divisor<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// C++14: 将 divisor 拷贝入闭包并使用副本</span>
        <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认的按值捕获模式的另一个缺点是，它会使人们误认为闭包是独立的，与闭包外的数据变化相隔绝。但实际上并非如此，lambda 可能不仅依赖于局部变量和形参，还会依赖于<strong>静态存储期（static storage duration）对象</strong>，这样的对象可以在 lambda 中使用，但却无法被捕获。下面这个例子足以体现这一点会造成的问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">addDivisorFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">auto</span> calc1 <span class="token operator">=</span> <span class="token function">computeSomeValue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">auto</span> calc2 <span class="token operator">=</span> <span class="token function">computeSomeValue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token keyword">auto</span> divisor <span class="token operator">=</span> <span class="token function">computeDivisor</span><span class="token punctuation">(</span>calc1<span class="token punctuation">,</span> calc2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true">// 未捕获任何东西！</span>
        <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 引用上面的 static 对象</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">++</span>divisor<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 意外修改了 divisor</span>
                                            <span class="token comment" spellcheck="true">// 导致每个 lambda 都出现新的行为</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-32：使用初始化捕获将对象移入闭包"><a href="#条款-32：使用初始化捕获将对象移入闭包" class="headerlink" title="条款 32：使用初始化捕获将对象移入闭包"></a>条款 32：使用初始化捕获将对象移入闭包</h3><p>C++14 中新增的<strong>初始化捕获（init capture，又称广义 lambda 捕获）</strong>，可以让你指定：</p><ol><li>由 lambda 生成的闭包类中成员变量的名字。</li><li>一个用于初始化该成员变量的表达式。</li></ol><p>下面演示了如何使用初始化捕获将<code>std::unique_ptr</code>移入闭包内：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>

    <span class="token keyword">bool</span> <span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token function">isProcessed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> pw <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 创建 Widget，std::make_unique 的使用参考条款 21</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 配置 *pw</span>

<span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">// 使用 std::move(pw) 初始化闭包类的数据成员</span>
            <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果经由<code>std::make_unique</code>创建的对象已具备被 lambda 捕获的合适状态，则闭包类成原对象可以直接由<code>std::make_unique</code>完成初始化：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
            <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在初始化捕获的代码中，位于<code>=</code>左侧的是所指定的闭包类成员变量的名称，右侧的则是其初始化表达式。值得一提的是，<code>=</code>的左右两侧位于不同的作用域，左侧作用域就是闭包的作用域，而右侧作用域则与 lambda 定义所在的作用域相同。</p><p>在 C++11 中，我们虽然无法使用初始化捕获，但是可以依靠原理相同的手写类达到目的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">IsValAndArch</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> DataType <span class="token operator">=</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">;</span>

    <span class="token keyword">explicit</span> <span class="token function">IsValAndArch</span><span class="token punctuation">(</span>DataType<span class="token operator">&amp;&amp;</span> ptr<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// std::move 的使用参考条款 25</span>
        <span class="token operator">:</span> <span class="token function">pw</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// 编写仿函数</span>
        <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    DataType pw<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token function">IsValAndArch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你非要使用 lambda，按移动捕获也可以通过以下方法模拟：</p><ol><li>将需要捕获的对象移至<code>std::bind</code>所产生的函数对象中。</li><li>给予 lambda 一个指向想要 “捕获” 的对象的引用。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span>

<span class="token keyword">auto</span> func <span class="token operator">=</span>
    std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// C++11 模拟初始化捕获</span>
              <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 使用 data */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
              std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::bind</code>的第一个实参是个可调用对象，接下来的所有实参表示传给该对象的值。和 lambda 表达式类似，<code>std::bind</code>也会生成函数对象（原书中称其为<strong>绑定对象，bind object</strong>），其中含有传递给<code>std::bind</code>的所有实参的副本，其中左值实参执行的是拷贝构造，而右值实参执行的则是移动构造。因此，在此处用<code>std::move(data)</code>作为实参可以让<code>data</code>被移入绑定对象中，被 lambda 的左值引用形参所接受。</p><p>默认情况下，lambda 生成的闭包类中的<code>operator()</code>成员函数会带有<code>const</code>限定符，它会导致是闭包类里的所有成员变量在 lambda 的函数体内都会带有<code>const</code>限定符。但是，绑定对象里通过移动构造得到的<code>data</code>副本却并不带有<code>const</code>限定符。因此，为了防止该<code>data</code>副本在 lambda 中被意外修改，我们会将其形参声明为常引用。但如果 lambda 在声明时带有<code>mutable</code>限定符，则闭包里的<code>operator()</code>就不再会带有<code>const</code>限定符，也不必再将形参声明为常引用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span>
    std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token keyword">mutable</span>
              <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 使用 data */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
              std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>回到之前的例子，使用 C++14 在闭包内创建<code>std::unique_ptr</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
            <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它在 C++11 中的模拟代码可以这样编写：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> pw<span class="token punctuation">)</span>
                      <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
                      std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="条款-33：对-auto-amp-amp-类型的形参使用-decltype-以对其实施-std-forward"><a href="#条款-33：对-auto-amp-amp-类型的形参使用-decltype-以对其实施-std-forward" class="headerlink" title="条款 33：对 auto&amp;&amp; 类型的形参使用 decltype 以对其实施 std::forward"></a>条款 33：对 auto&amp;&amp; 类型的形参使用 decltype 以对其实施 std::forward</h3><p>C++14 支持<strong>泛型 lambda（generic lambda）</strong>，可以在声明形参时使用<code>auto</code>，即闭包类中的<code>operator()</code>可以用模板实现。例如，给定以下 lambda：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则闭包类的<code>operator()</code>实现大致如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SomeCompilerGeneratedClassName</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
    <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// auto 类型的返回值，参考条款 3</span>
        <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此处，lambda 总会传递左值给<code>normalize</code>，这对于一个会区别对待左、右值的<code>normalize</code>显然是不行的。如果想要保留实参的左、右值性，就需要将形参声明为万能引用（参考<strong>条款 24</strong>），并使用<code>std::forward</code>将其转发给<code>normalize</code>（参考<strong>条款 25</strong>）。这样的改造十分简单，唯一的问题是在 lambda 中，我们并没有可用的模板形参<code>T</code>，只能对要转发的形参使用<code>decltype</code>，以取得其类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>条款 28</strong> 说明了，使用<code>std::forward</code>的惯例是：用左值引用类型的模板形参来表明想要返回左值，用非引用类型的模板形参来表明想要返回右值。而在此处，如果<code>param</code>是左值，则<code>decltype(param)</code>会产生左值引用类型，这符合惯例；但如果<code>param</code>是右值，则<code>decltype(param)</code>会产生右值引用类型，不符合惯例的非引用，在这种情况下，<code>std::forward</code>将被具现化为：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;&amp;</span> <span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;&amp;</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于引用折叠的存在，<code>Widget&amp;&amp; &amp;&amp;</code>将被折叠为<code>Widget&amp;&amp;</code>，所以实际上生成的代码和使用非引用类型作为模板形参生成的版本并没有什么区别。综上所述，在此处使用<code>decltype(param)</code>并不会产生任何问题，这是个非常不错的结果。</p><p>C++14 的 lambda 也支持可变参数，只需稍加改动，就可以得到能接受多个参数的完美转发 lambda 版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="条款-34：优先选用-lambda，而非-std-bind"><a href="#条款-34：优先选用-lambda，而非-std-bind" class="headerlink" title="条款 34：优先选用 lambda，而非 std::bind"></a>条款 34：优先选用 lambda，而非 std::bind</h3><p>之所以优先选用 lambda 而非 std::bind，最主要的原因是 lambda 具有更高的可读性。举个例子，假设我们有个函数用来设置警报声：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 表示时刻的类型</span>
<span class="token keyword">using</span> Time <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>steady_clock<span class="token operator">::</span>time_point<span class="token punctuation">;</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Sound</span> <span class="token punctuation">{</span> Beep<span class="token punctuation">,</span> Siren<span class="token punctuation">,</span> Whistle <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 表示时长的类型</span>
<span class="token keyword">using</span> Duration <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>steady_clock<span class="token operator">::</span>duration<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 在时刻 t，发出声音 s，持续时长 d</span>
<span class="token keyword">void</span> <span class="token function">setAlarm</span><span class="token punctuation">(</span>Time t<span class="token punctuation">,</span> Sound s<span class="token punctuation">,</span> Duration d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以编写一个 lambda，设置在一小时后发出警报并持续 30 秒，同时提供接口，以指定发出的声音：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> setSoundL <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Sound s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>chrono<span class="token punctuation">;</span>
    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>literals<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 引入 C++14 中的字面量后缀</span>

    <span class="token function">setAlarm</span><span class="token punctuation">(</span>steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> 1h<span class="token punctuation">,</span> s<span class="token punctuation">,</span> 30s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// C++11 需要用 hours 和 seconds 代替后缀</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们将尝试使用<code>std::bind</code>来编写相应的代码。下面的这段代码并不正确，但足以让我们发现<code>std::bind</code>的难用之处：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>chrono<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>literals<span class="token punctuation">;</span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>placeholders<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 引入占位符</span>

<span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">,</span>
                           steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> 1h<span class="token punctuation">,</span>
                           _1<span class="token punctuation">,</span>
                           30s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>占位符<code>_1</code>表示它在<code>std::bind</code>形参列表中的映射位置，在此处表示调用<code>setSoundB</code>时传入的第一个实参，会作为第二个实参传递给<code>setAlarm</code>。这显然已经不如 lambda 直观。</p><p>更重要的是上述代码所隐含的问题：调用时间的错误。在<code>std::bind</code>的调用中，<code>steady_clock::now() + 1h</code>作为实参被传递给了<code>std::bind</code>，而非<code>setAlarm</code>，这意味着该表达式会在调用<code>std::bind</code>的时刻计算出具体值，而非调用<code>setAlarm</code>的时刻，这与我们的意图显然不符。想要解决这个问题，就要嵌套第二层<code>std::bind</code>的调用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">,</span>
                           std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>plus<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// C++11 无法省略 std::plus&lt;steady_clock::time_point>()</span>
                                     steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                     1h<span class="token punctuation">)</span><span class="token punctuation">,</span>
                           _1<span class="token punctuation">,</span>
                           30s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个<code>std::bind</code>不如 lambda 的例子是重载。假如有个重载版本会接受第四个形参，用于指定警报的音量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Volume</span> <span class="token punctuation">{</span> Normal<span class="token punctuation">,</span> Loud<span class="token punctuation">,</span> LoudPlusPlus <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">setAlarm</span><span class="token punctuation">(</span>Time t<span class="token punctuation">,</span> Sound s<span class="token punctuation">,</span> Duration d<span class="token punctuation">,</span> Volume v<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原来的 lambda 仍会正常运作，而<code>std::bind</code>会立刻发生错误，因为它只有函数名，并不知道要调用哪个重载版本的函数。为使得<code>std::bind</code>的调用能通过编译，必须将<code>setAlarm</code>强制转换到适当的函数指针类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> SetAlarm3ParamType <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Time t<span class="token punctuation">,</span> Sound s<span class="token punctuation">,</span> Duration d<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>SetAlarm3ParamType<span class="token operator">></span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">)</span><span class="token punctuation">,</span>
                           std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>plus<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 1h<span class="token punctuation">)</span><span class="token punctuation">,</span>
                           _1<span class="token punctuation">,</span>
                           30s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是一个更极端的例子，演示了<code>std::bind</code>到底有多晦涩：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// lambda 版本（C++14）</span>
<span class="token keyword">auto</span> betweenL <span class="token operator">=</span> <span class="token punctuation">[</span>lowVal<span class="token punctuation">,</span> highVal<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> lowVal <span class="token operator">&lt;=</span> val <span class="token operator">&amp;&amp;</span> val <span class="token operator">&lt;=</span> highVal<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// std::bind 版本（C++14）</span>
<span class="token keyword">auto</span> betweenB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>logical_and<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                          std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>less_equal<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lowVal<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">,</span>
                          std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>less_equal<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span> highVal<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::bind</code>总是拷贝其实参，调用时需要借助<code>std::ref</code>来达到按引用存储实参的目的，这一点同样也不如 lambda 来得明确：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> compressRateL <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>w<span class="token punctuation">]</span><span class="token punctuation">(</span>CompLevel lev<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">compress</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> lev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> compressRateB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>compress<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>除了可读性以外，编译器通常能更好地以内联优化 lambda 所调用的函数，而对于使用函数指针的<code>std::bind</code>则很难做到，这会导致使用 lambda 有可能会生成比使用<code>std::bind</code>运行得更快的代码。</p><p>在 C++11 中，<code>std::bind</code>仅在两个受限的场合还有使用的理由：</p><ol><li>移动捕获（参考<strong>条款 32</strong>）；</li><li>多态函数对象（这在 C++14 中可以被泛型 lambda 轻易实现）：</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PolyWidget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

PolyWidget pw<span class="token punctuation">;</span>
<span class="token keyword">auto</span> boundPW <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 可以用不同类型的实参调用 PolyWidget::operator()</span>
<span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token number">1930</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token string">"Rosebud"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 原书作者玩的《公民凯恩》梗（应该是吧）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第七章：并发-API"><a href="#第七章：并发-API" class="headerlink" title="第七章：并发 API"></a>第七章：并发 API</h2><h3 id="条款-35：优先选用基于任务而非基于线程的程序设计"><a href="#条款-35：优先选用基于任务而非基于线程的程序设计" class="headerlink" title="条款 35：优先选用基于任务而非基于线程的程序设计"></a>条款 35：优先选用基于任务而非基于线程的程序设计</h3><p>如果你想以异步方式执行函数<code>doAsyncWork</code>，你可以选择<strong>基于线程（thread-based）</strong> 的方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">doAsyncWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也可以将<code>doAsyncWork</code>传递给<code>std::async</code>，这是<strong>基于任务（task-based）</strong> 的方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 需要 #include &lt;future></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>“线程” 在带有并发的 C++ 软件中有三重含义：</p><ul><li><strong>硬件线程（hardware threads）</strong> 是实际执行计算的线程。现代计算机架构会为每个 CPU 内核提供一个或多个硬件线程。</li><li><strong>软件线程（software threads，也称系统线程）</strong> 是操作系统（或嵌入式系统）用于实现跨进程的管理，以及进行硬件线程调度的线程。通常，能够创建的软件线程比硬件线程要多，因为当一个软件线程被阻塞时，运行其它未阻塞线程能够提高吞吐率。</li><li><strong><code>std::thread</code></strong> 是 C++ 进程中的对象，用作底层软件线程的句柄。有些<code>std::thread</code>对象表现为 “null” 句柄，表示其无软件线程，可能的原因有：处于默认构造状态（没有要执行的函数），被移动了（被移动的目标对象成为了该软件线程的句柄），被联结（join）了（函数已执行结束），被分离（detach）了（与其软件线程的连接被切断）。</li></ul><p>软件线程和硬件线程都是有限的。如果你试图创建多于系统能提供的数量的线程，就会抛出<code>std::system_error</code>异常，即使待执行的函数带有<code>noexcept</code>限定符也一样。如果非阻塞的软件线程数量超过了硬件线程数量，就会产生<strong>资源超额（oversubscription）</strong> 问题，此时线程调度器会将软件线程的 CPU 时间切片，分配到硬件线程之上。当一个软件线程的时间片执行结束，就会让给另一个软件线程，并产生上下文切换。在这种情况下，新的软件线程几乎不能命中 CPU 缓存，同时还会污染为旧线程所准备的数据（旧线程很可能还会再被调度到同一内核上运行），这会造成高昂的线程管理开销。</p><blockquote><p>避免资源超额很困难，因为软件线程和硬件线程的最佳比例取决于软件线程的执行频率，那是动态改变的，例如一个程序从 IO 密集型变成计算密集型，会使执行频率发生改变。而且该比例还依赖于上下文切换的开销以及软件线程对于 CPU 缓存的使用效率。计算机本身的架构也会对其具体细节产生很大的影响。</p></blockquote><p>比起基于线程，基于任务的设计能够减轻手动管理线程的艰难，而且它提供了一种很自然的方式（藉由<code>get</code>函数），让你检查异步执行函数的结果（即返回值或异常）。</p><p>虽然说了这么多，但仍有以下几种情况，直接使用线程会更合适：</p><ul><li><strong>你需要访问非常底层的线程 API。</strong> C++ 并发 API 通常会采用特定平台的低级 API 来实现，例如 pthread 和 Windows 线程库，它们提高的 API 比 C++ 更丰富。为了访问底层的线程 API，<code>std::thread</code>通常会提供<code>native_handle</code>成员函数，而<code>std::async</code>的返回值<code>std::future</code>则没有该功能。</li><li><strong>你需要且有能力为你的应用优化线程的使用。</strong> 例如在完成性能分析的情况下为专一硬件平台开发应用。</li><li><strong>你需要实现实现超越 C++ 并发 API 的线程技术。</strong> 例如为 C++ 未提供线程池的平台实现线程池。</li></ul><h3 id="条款-36：如果异步是必要的，则指定-std-launch-async"><a href="#条款-36：如果异步是必要的，则指定-std-launch-async" class="headerlink" title="条款 36：如果异步是必要的，则指定 std::launch::async"></a>条款 36：如果异步是必要的，则指定 std::launch::async</h3><p>在调用<code>std::async</code>时，有以下两种启动策略可以选择：</p><ul><li><code>std::launch::async</code>启动策略意味着函数必须以异步方式在另一条线程上执行。</li><li><code>std::launch::deferred</code>启动策略意味着函数会被推迟到<code>std::async</code>所返回的<code>std::future</code>的<code>get</code>或<code>wait</code>函数得到调用时才执行（这是个简化说法，关键点其实是<code>std::future</code>引用的共享状态，参考<strong>条款 38</strong>）。在那之后，调用<code>get</code>或<code>wait</code>的线程将会被阻塞，直至函数执行结束为止。如果<code>get</code>或<code>wait</code>都没得到调用，则函数将不会被执行。</li></ul><p><code>std::async</code>的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行，即下面两个调用是等价的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> fut2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async <span class="token operator">|</span> std<span class="token operator">::</span>launch<span class="token operator">::</span>deferred<span class="token punctuation">,</span>
                       f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种弹性使得<code>std::async</code>和标准库的线程管理组件能够承担起线程的创建和销毁，避免资源超额，以及负载均衡的责任。但也会带来一些意料之外的问题：</p><ul><li>无法预知<code>f</code>是否会与调用<code>std::async</code>的线程并发执行，它也可能会被推迟执行。</li><li>无法预知<code>f</code>是否会在与调用<code>get</code>和<code>wait</code>函数的线程不同的线程上执行。</li><li>无法预知<code>f</code>在读或写此<strong>线程本地存储（thread-local，TLS）</strong> 时，会在哪个线程的本地存储上完成操作，这会影响到<code>thread_local</code>变量的使用。</li><li>就连<code>f</code>是否会被执行这种基本的事情都无法预知。</li></ul><p>延迟启动策略还会影响以超时为条件的基于 wait 的循环：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>literals<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>1s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>100ms<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 循环至 f 完成执行</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// 若 f 被推迟执行，则 fut.wait_for 返回 std::future_status::deferred</span>
    <span class="token comment" spellcheck="true">// 循环永远不会被终止！</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决这个问题的方法很简单，只需要确认任务是否被推迟，可以通过调用一个基于超时的函数（例如<code>wait_for</code>）并检查其返回值来实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>0s<span class="token punctuation">)</span> <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>deferred<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果任务被推迟了</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// 调用 fut 的 wait 或 get，以同步方式执行 f</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>                                                  <span class="token comment" spellcheck="true">// 如果任务未被推迟</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>100ms<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// 不断去做并发任务，直至 f 完成执行</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// fut 已经就绪</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上所述，如果需要执行的任务满足以下条件，就可以使用<code>std::async</code>的默认启动策略：</p><ol><li>任务不需要与调用<code>get</code>或<code>wait</code>的线程并发执行。</li><li>读或写哪个线程的<code>thread_local</code>变量并无影响。</li><li>保证在<code>std::async</code>返回的<code>std::future</code>对象上调用<code>get</code>或<code>wait</code>，或者可以接受任务可能永不执行。</li><li>使用<code>wait_for</code>或<code>wait_until</code>的代码会考虑到任务被推迟的可能性。</li></ol><p>如果其中任何一个条件不满足，就需要确保任务以异步方式执行：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以编写一个辅助函数来自动执行<code>std::async</code>的异步启动策略：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> F<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
<span class="token keyword">inline</span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>result_of<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span> <span class="token comment" spellcheck="true">// C++14 可以直接用 auto 推导返回值类型</span>
<span class="token function">reallyAsync</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span>
                      std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span>
                      std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>用于获取可调用对象返回值类型的<code>std::result_of</code>在 C++17 后被弃用，其替代品为<code>std::invoke_result</code>。</p></blockquote><h3 id="条款-37：使-std-thread-对象在所有路径皆不可联结"><a href="#条款-37：使-std-thread-对象在所有路径皆不可联结" class="headerlink" title="条款 37：使 std::thread 对象在所有路径皆不可联结"></a>条款 37：使 std::thread 对象在所有路径皆不可联结</h3><p>当<code>std::thread</code>处于可联结的状态时，它对应于正在运行或可能将要运行的底层执行线程，这包括正在等待调度的或者被阻塞的线程，以及运行结束的线程。</p><p>以下几种<code>std::thread</code>对象处于不可联结的状态：</p><ul><li>默认构造的<code>std::thread</code>。</li><li>已移动的<code>std::thread</code>。</li><li>已联结（join）的<code>std::thread</code>。</li><li>已分离（detach）的<code>std::thread</code>。</li></ul><p>当<code>std::thread</code>执行析构时，若其处于可联结状态，就会导致程序终止运行（通常会调用<code>std::abort</code>）。考虑以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> tenMillion <span class="token operator">=</span> <span class="token number">10</span><span class="token string">'000'</span><span class="token number">000</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// C++14 的单引号数字分隔符</span>

<span class="token keyword">bool</span> <span class="token function">doWork</span><span class="token punctuation">(</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> filter<span class="token punctuation">,</span> <span class="token keyword">int</span> maxVal <span class="token operator">=</span> tenMillion<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> goodVals<span class="token punctuation">;</span>

    std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>filter<span class="token punctuation">,</span> maxVal<span class="token punctuation">,</span> <span class="token operator">&amp;</span>goodVals<span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 遍历 goodVals</span>
                      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxVal<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                      <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">filter</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> goodVals<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
                  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> nh <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">native_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 使用 t 的原生句柄来设定线程的优先级</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">conditionAreSatisfied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                   <span class="token comment" spellcheck="true">// 让 t 结束运行</span>
        <span class="token function">performComputation</span><span class="token punctuation">(</span>goodVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">// 计算已实施</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                                   <span class="token comment" spellcheck="true">// 计算未实施</span>
<span class="token punctuation">}</span>                                                   <span class="token comment" spellcheck="true">// 此处析构 std::thread 会导致程序终止</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标准委员会并没有选择让<code>std::thread</code>在销毁时，隐式执行<code>join</code>或<code>detach</code>，因为这带来的问题会比直接让程序终止运行还要严重：</p><ul><li><strong>隐式<code>join</code></strong> 会使<code>std::thread</code>的析构函数等待底层异步线程执行完毕。这听上去很合理，但却可能导致难以追踪的性能异常。例如，即使<code>conditionAreSatisfied</code>已经返回<code>false</code>了，<code>doWork</code>仍然会继续执行遍历操作，这是违反直觉的。</li><li><strong>隐式<code>detach</code></strong> 会使<code>std::thread</code>的析构函数分离<code>std::thread</code>对象和底层执行线程之间的连接，而该底层执行线程会继续运行。这会导致更要命的调试问题。假如<code>conditionAreSatisfied</code>返回了<code>false</code>，则<code>doWork</code>也会直接返回，同时销毁局部变量并弹出栈帧。但线程仍然在<code>doWork</code>的调用点继续运行，并导致栈帧上的内存被意外修改，</li></ul><p>我们可以编写一个 RAII 类，并让调用者自行选择在销毁时为<code>std::thread</code>调用<code>join</code>还是<code>detach</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ThreadRAII</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">DtorAction</span> <span class="token punctuation">{</span> join<span class="token punctuation">,</span> detach <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 关于枚举类，参考条款 20</span>

    <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>std<span class="token operator">::</span>thread<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">,</span> DtorAction a<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 对 t 执行操作 a</span>
        <span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token operator">~</span><span class="token function">ThreadRAII</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 先校验 t 是否处于可联结状态</span>
        <span class="token comment" spellcheck="true">// 对不可联结的 std::thread 调用 join 或 detach 是未定义行为</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token operator">==</span> DtorAction<span class="token operator">::</span>join<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>ThreadRAII<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 支持移动操作</span>
    ThreadRAII<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>ThreadRAII<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>thread<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 返回底层的 std::thread 对象</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    DtorAction action<span class="token punctuation">;</span>
    std<span class="token operator">::</span>thread t<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 使 t 最后被初始化，确保它可以安全访问其它成员</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>不需要担心在<code>t.joinable()</code>的执行和<code>join</code>或<code>detach</code>的调用之间，有另一个线程会让<code>t</code>变得不可联结。因为<code>std::thread</code>对象只能通过调用成员函数来从可联结状态转换为不可联结状态，而当<code>ThreadRAII</code>对象的析构函数被调用时，不应该有其它线程调用该对象的成员函数。一般地，若要在一个对象上同时调用两个成员函数，只有当所有这些函数都带有<code>const</code>限定符时才安全（参考<strong>条款 16</strong>）。</p></blockquote><p>在<code>doWork</code>函数的代码中，可以这样使用<code>ThreadRAII</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">doWork</span><span class="token punctuation">(</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> filter<span class="token punctuation">,</span> <span class="token keyword">int</span> maxVal <span class="token operator">=</span> tenMillion<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> goodVals<span class="token punctuation">;</span>

    ThreadRAII <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>filter<span class="token punctuation">,</span> maxVal<span class="token punctuation">,</span> <span class="token operator">&amp;</span>goodVals<span class="token punctuation">]</span> <span class="token punctuation">{</span>
                                 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxVal<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                                 <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">filter</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> goodVals<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
                             <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                 ThreadRAII<span class="token operator">::</span>DtorAction<span class="token operator">::</span>join<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> nh <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">native_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">conditionAreSatisfied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">performComputation</span><span class="token punctuation">(</span>goodVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-38：注意不同线程句柄的析构行为"><a href="#条款-38：注意不同线程句柄的析构行为" class="headerlink" title="条款 38：注意不同线程句柄的析构行为"></a>条款 38：注意不同线程句柄的析构行为</h3><p>future 位于通信信道的一端，被调用者通过该信道将结果发送给调用者。被调用者（通常以异步方式运行）将其计算所得的结果写入信道（通常经过<code>std::promise</code>对象），而调用者则使用 future 来读取该结果。</p><p>但被调用者的结果要存储在哪里呢？既不能存储在被调用者的<code>std::promise</code>对象中，因为它是个局部对象，在被调用者执行结束后会被销毁；也不能存储在调用者的 future 中，因为<code>std::future</code>可能会被用来创建<code>std::shared_future</code>，而后者会导致原始<code>std::future</code>析构之后被多次拷贝，但被调用者的结果并不能保证一定可以被拷贝，很难做到使它与最后一个指向它的 future 生命周期一样长。</p><p>因此该结果会被存储在位于两者外部的某个位置，这个位置称为<strong>共享状态（shared state）</strong>，通常用堆上的对象来表示，但是其类型、接口和实现皆未在标准中指定。我们可以把调用者，被调用者以及共享状态之间的关系用下图来表示：</p><p><img src="https://pic2.zhimg.com/80/v2-006b36a9b3ae2533a73d8c1646d49511_720w.webp" alt></p><p>共享状态的存在非常重要，因为 future 对象的析构行为取决于与其关联的共享状态。具体来说就是：</p><ul><li>常规的 future 对象在析构时仅会析构该 future 的成员变量。这相当于对底层执行线程执行了隐式<code>detach</code>。</li><li>引用了共享状态（使用<code>std::async</code>启动未延迟任务时创建的）的最后一个 future 对象的析构函数将会被阻塞住，直至该任务结束。这相当于对正在运行<code>std::async</code>所创建任务的线程执行了隐式<code>join</code>。</li></ul><p>也就是说，只有在满足下列条件时，future 的非常规析构行为才会被触发：</p><ol><li>future 所引用的共享状态是在调用<code>std::async</code>时创建的；</li><li>该任务执行异步启动策略，即<code>std::launch::async</code>（参考<strong>条款 36</strong>）；</li><li>该 future 是最后一个引用了该共享状态的 future。</li></ol><p>future 的 API 没有提供任何办法判断它引用的共享状态是否诞生于<code>std::async</code>的调用，因此任意给定一个 future 对象，我们没有办法判断它是否会在析构函数中阻塞。这可能会导致一些意外的情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 该容器的析构函数可能会发生阻塞</span>
<span class="token comment" spellcheck="true">// 因为它持有 future 可能会有一个或多个</span>
<span class="token comment" spellcheck="true">// 满足触发非常规析构行为的条件</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">>></span> futs<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 关于 std::future&lt;void>，参考条款 39</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>                          <span class="token comment" spellcheck="true">// Widget 对象的析构函数可能会发生阻塞</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>shared_future<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> fut<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>std::packaged_task</code>也能创建出共享对象，但是其衍生的 future 都会执行常规的析构行为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">calcValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">{</span>
    std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>       <span class="token comment" spellcheck="true">// 给 calcValue 加上包装</span>
    <span class="token function">pt</span><span class="token punctuation">(</span>calcValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 使之能以异步方式执行</span>

    <span class="token keyword">auto</span> fut <span class="token operator">=</span> pt<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 取得 pt 的 future</span>
    std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// std::packaged_task 是只移类型</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment" spellcheck="true">// 析构 std::thread（参考条款 37）</span>
<span class="token punctuation">}</span>                                   <span class="token comment" spellcheck="true">// 以常规方式析构 future 对象 fut</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-39：考虑对一次性事件通信使用-void-的-futures"><a href="#条款-39：考虑对一次性事件通信使用-void-的-futures" class="headerlink" title="条款 39：考虑对一次性事件通信使用 void 的 futures"></a>条款 39：考虑对一次性事件通信使用 void 的 futures</h3><p>有的时候，让一个任务能够在发生了特定事件后，通知另一个异步运行的任务，会是很有用的。为了实现这种简单的事件通信，使用条件变量会是一个显而易见的做法：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>condition_variable cv<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 事件的条件变量</span>
std<span class="token operator">::</span>mutex m<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 配合 cv 使用的互斥量</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 检测事件</span>
cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 通知反应任务，对多个任务使用 notify_all</span>

<span class="token comment" spellcheck="true">// 反应任务的代码</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 准备作出反应</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 为互斥量加锁</span>

    cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 等待通知到来</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment" spellcheck="true">// 针对事件作出反应</span>
<span class="token punctuation">}</span>                                       <span class="token comment" spellcheck="true">// 通过 lk 的析构函数为 m 解锁</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 继续等待反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种途径会导致以下几个问题：</p><ul><li><strong>代码异味（code smell）：</strong> 虽然代码能够运行，但总感觉哪里不太对劲。此处对互斥量的使用似乎有些多余，互斥量是用于控制共享数据访问的，但检测和反应任务之间大可以根本不需要这种介质。</li><li>如果检测任务在反应任务调用<code>wait</code>之前就通知了条件变量，则反应任务将会失去响应。</li><li>反应任务的<code>wait</code>语句无法应对<strong>虚假唤醒（spurious wakeups）</strong>，即使条件变量没有得到通知，针对该条件变量等待的代码也有可能被唤醒。如果反应线程可以确认它所等待的事件是否已经发生，那么我们可以通过将 lambda 传递给<code>wait</code>来处理这种情况：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> 事件是否真的已经发生<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基于 flag 的设计可以避免上述问题，但这一设计基于轮询而非阻塞，会对 CPU 核心产生额外的性能消耗：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">flag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 共享的 bool flag</span>
                                <span class="token comment" spellcheck="true">// 关于 std::atomic，参考条款 40</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment" spellcheck="true">// 检测事件</span>
flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 通知反应任务</span>

<span class="token comment" spellcheck="true">// 反应任务的代码</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment" spellcheck="true">// 准备作出反应</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 等待事件</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment" spellcheck="true">// 针对事件作出反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>条件变量可以和 flag 一起使用，但这样的通信机制设计看起来不太自然：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>condition_variable cv<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 同前</span>
std<span class="token operator">::</span>mutex m<span class="token punctuation">;</span>

<span class="token keyword">bool</span> <span class="token function">flag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 非 std::atomic 对象</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment" spellcheck="true">// 检测事件</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 为 m 加锁</span>
    flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 通知反应任务（第一部分）</span>
<span class="token punctuation">}</span>
cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 通知反应任务（第二部分）</span>

<span class="token comment" spellcheck="true">// 反应任务的代码</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment" spellcheck="true">// 准备作出反应</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 同前</span>

    cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>flag<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> flag<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使用 lambda 应对虚假唤醒</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 针对事件作出反应</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment" spellcheck="true">// 继续等待反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外一种方法是摆脱条件变量，互斥量和 flag，让反应任务去等待检测任务设置的 future。这种设计简单易行，检测任务有一个<code>std::promise</code>对象，反应任务有对应的 future。当检测任务发现它查找的事件已经发生时，它会设置<code>std::promise</code>对象；与此同时，反应任务调用<code>wait</code>以等待它的 future。由于在此处我们并不会真正向信道发送任何数据，所以对于<code>std::promise</code>、<code>std::future</code>和<code>std::shared_future</code>的模板类型形参，都只需使用<code>void</code>即可：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> p<span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 检测事件</span>
p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 通知反应任务</span>

<span class="token comment" spellcheck="true">// 反应任务的代码</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 准备作出反应</span>
p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 等待 p 对应的 future</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 针对事件作出反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种手法有两个最大的局限性：</p><ul><li><code>std::promise</code>和 future 之间依赖共享状态，而共享状态会带来在堆上分配和回收空间的成本。</li><li><code>std::promise</code>对象只能设置一次，这意味着该手法只能应用于一次性通信的情况。</li></ul><p>假如你想创建多个能暂停一次的线程，使用<code>void</code> future 手法就是合理的选择。代码演示如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> p<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">detect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> sf <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// sf 的类型是 std::shared_future&lt;void></span>

    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>thread<span class="token operator">></span> vt<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 反应任务的容器</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadsToRun<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vt<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">[</span>sf<span class="token punctuation">]</span> <span class="token punctuation">{</span> sf<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">react</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// sf 局部副本之上的 wait</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                                 <span class="token comment" spellcheck="true">// 若在此处抛出异常，则 detect 会失去响应！</span>

    p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">// 让所有线程取消暂停</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                                 <span class="token comment" spellcheck="true">// 完成其它工作</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vt<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment" spellcheck="true">// 把所有线程设为不可联结的状态</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-40：对并发使用-std-atomic，对特殊内存使用-volatile"><a href="#条款-40：对并发使用-std-atomic，对特殊内存使用-volatile" class="headerlink" title="条款 40：对并发使用 std::atomic，对特殊内存使用 volatile"></a>条款 40：对并发使用 std::atomic，对特殊内存使用 volatile</h3><p><code>std::atomic</code>可以保证它提供的操作被其它线程视为具有原子性，它产生的效果和受到互斥锁保护的操作类似，但是通常<code>std::atomic</code>的原子操作是通过特定的机器指令实现的，这比锁的实现更高效。考虑以下应用了<code>std::atomic</code>的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ai</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 ai 初始化为 0</span>
ai <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 原子地将 ai 设为 10</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ai<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 原子地读取 ai 地值</span>
<span class="token operator">++</span>ai<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 原子地将 ai 自增为 11</span>
<span class="token operator">--</span>ai<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 原子地将 ai 自减为 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，在<code>std::cout &lt;&lt; ai</code>语句中，<code>std::atomic</code>仅能保证对于<code>ai</code>的读取操作具有原子性，而不能保证整条语句都具有原子性，在读取<code>ai</code>的值和调用<code>operator&lt;&lt;</code>之间，可能会有别的线程修改了<code>ai</code>的值，但这对使用按值传参的<code>operator&lt;&lt;</code>并没有什么影响。</p><p><code>ai</code>的自增和自减操作是<strong>读取-修改-写入（read-modify-write，RWM）</strong> 操作，<code>std::atomic</code>能确保它们整体以原子方式执行。这是<code>std::atomic</code>最重要的特性之一：<code>std::atomic</code>对象之上的所有成员函数都能被其它线程视为原子性的。</p><p><code>std::atomic</code>在 RWM 上具有的优势与<code>volatile</code>相比十分明显：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ac</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// atomic counter</span>
<span class="token keyword">volatile</span> <span class="token keyword">int</span> <span class="token function">vc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// volatile counter</span>

<span class="token comment" spellcheck="true">/* 在两个同时运行的线程中各自执行自增操作 */</span>

<span class="token comment" spellcheck="true">// 线程 1</span>
<span class="token operator">++</span>ac<span class="token punctuation">;</span>
<span class="token operator">++</span>vc<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 线程 2</span>
<span class="token operator">++</span>ac<span class="token punctuation">;</span>
<span class="token operator">++</span>vc<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在两个执行结束后，<code>ac</code>的值一定为 2，而<code>vc</code>却不一定，数据竞争导致它的最终结果实际上是无法预测的，下面是一种可能的情况：</p><ol><li>线程 1 读取<code>vc</code>的值为 0；</li><li>线程 2 读取<code>vc</code>的值仍为 0；</li><li>线程 1 将读取的值 0 自增为 1，写入<code>vc</code>；</li><li>线程 2 也将读取的值 0 自增为 1，写入<code>vc</code>；</li><li><code>vc</code>最终的值为 1。</li></ol><p>除了 RWM 以外，<code>std::atomic</code>还在确保<strong>顺序一致性（sequential consistency）</strong> 上具有优势，这种一致性是它默认采用的（尽管 C++ 还支持其它的一致性模型，但它们的安全性无法得到保证），它规定：在源代码中，<strong>任何位于<code>std::atomic</code>变量的写入操作之前的代码不得发生于写入操作之后</strong>。使用<code>std::atomic</code>可以保证以下代码中的赋值语句不会进行重新排序：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">valAvailable</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> imptValue <span class="token operator">=</span> <span class="token function">computeImportantValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 计算出值</span>
valAvailable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 通知其它任务，值已可用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果不使用<code>std::atomic</code>，语句的顺序可能会被编译器或底层硬件重新排列，以使得代码运行得更快：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 重新排序后的结果</span>
valAvailable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> imptValue <span class="token operator">=</span> <span class="token function">computeImportantValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>std::atomic</code>是只移类型，因此以下代码无法通过编译：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>正确的方式是调用<code>std::atomic</code>的成员函数<code>load</code>和<code>store</code>来以原子方式读取和写入：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">y</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>尽管在很多时候<code>load</code>和<code>store</code>并不是必要的，但是有些开发者还是很喜欢使用它们，因为这样做可以在代码中明确强调所使用的变量并非常规。这在很大程度上是一个代码风格的问题。</p><p><code>volatile</code>是用来处理特殊内存的工具，它会被用在读写操作不应该被优化的内存上。一般来讲，编译器会为常规内存的冗余读取和写入自动执行优化，例如以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 读取 x</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 再次读取 x</span>

x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 写入 x</span>
x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 再次写入 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在经过优化后就能变成十分精简的版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 读取 x</span>

x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 写入 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但对于特殊内存，我们可能不想要编译器去执行这种优化。例如用于内存映射 I/O 的内存，这种内存的位置实际上会被用于与外部设备通信，而非用于读取或写入常规内存。这时，<code>volatile</code>就能派上用场：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">volatile</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 以 volatile 声明 x</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token comment" spellcheck="true">// 初始化 x</span>

<span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 读取 x</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 再次读取 x（不会被优化掉）</span>

x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 写入 x（不会被优化掉）</span>
x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 再次写入 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::atomic</code>和<code>volatile</code>用于不同的目的，它们甚至可以一起使用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">volatile</span> std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vai<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 针对 vai 的操作具有原子性</span>
                                <span class="token comment" spellcheck="true">// 并且不会被优化掉</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="第八章：微调"><a href="#第八章：微调" class="headerlink" title="第八章：微调"></a>第八章：微调</h2><h3 id="条款-41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递"><a href="#条款-41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递" class="headerlink" title="条款 41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递"></a>条款 41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递</h3><p>为了实现对传入函数的左值实参执行拷贝，对右值实参执行移动，我们一共有以下三种方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>                                  <span class="token comment" spellcheck="true">// 方法一：</span>
<span class="token keyword">public</span><span class="token operator">:</span>                                         <span class="token comment" spellcheck="true">// 对左值和右值分别重载</span>
    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> names<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>                                  <span class="token comment" spellcheck="true">// 方法二：</span>
<span class="token keyword">public</span><span class="token operator">:</span>                                         <span class="token comment" spellcheck="true">// 使用万能引用</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>                                  <span class="token comment" spellcheck="true">// 方法三：</span>
<span class="token keyword">public</span><span class="token operator">:</span>                                         <span class="token comment" spellcheck="true">// 按值传递参数</span>
    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++98 中，按值传递的形参总会通过拷贝构造函数创建，但在 C++11 后，形参仅在传入左值时才会被拷贝构造，而如果传入的是个右值，它会被移动构造。</p><p>对于可拷贝的，移动开销低的，并且总是会被拷贝的形参而言，按值传递和按引用传递的效率很接近，而且按值传递更容易实现，还可能会生成更少的目标代码。</p><p>对于不可拷贝的形参，由于它的拷贝构造函数已被禁用，我们也不需要为其左值类型的实参提供支持，只需要编写一个接受右值引用的版本就行了。考虑一个类，它含有一个<code>std::unique_ptr</code>类型的数据成员和对应的 setter，而<code>std::unique_ptr</code>是个只移类型，所以我们只需要编写单个函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">setPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">&amp;&amp;</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Widget w<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
w<span class="token punctuation">.</span><span class="token function">setPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Modern C++"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用按值传参的前提是形参移动的成本足够低廉，因为按值传参会比按引用传参多一次额外的移动操作，如果这个前提不成立，那么执行不必要的移动就与执行不必要的拷贝没有什么区别。另外，你应当只对一定会被拷贝的形参考虑使用按值传参，以下代码就是一个反例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newName<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> minLen<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span>newName<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> maxLen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> names<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即使没有向<code>names</code>添加任何内容，该函数也会造成构造和析构<code>newName</code>的开销，而如果使用按引用传参，就可以避免这笔开销。</p><p>通过构造拷贝形参的开销可能会比通过赋值拷贝形参要大得多。考虑以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Password</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">Password</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string pwd<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 按值传参</span>
        <span class="token operator">:</span> <span class="token function">text</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 对 text 进行构造</span>

    <span class="token keyword">void</span> <span class="token function">changeTo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string newPwd<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 按值传参</span>
        text <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newPwd<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 对 text 进行赋值</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>string text<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 表示密码</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

std<span class="token operator">::</span>string <span class="token function">initPwd</span><span class="token punctuation">(</span><span class="token string">"Supercalifragilisticexpialidocious"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 旧密码</span>
Password <span class="token function">p</span><span class="token punctuation">(</span>initPwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

std<span class="token operator">::</span>string newPassword <span class="token operator">=</span> <span class="token string">"Beware the Jabberwock"</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 新密码</span>
p<span class="token punctuation">.</span><span class="token function">changeTo</span><span class="token punctuation">(</span>newPassword<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此处，旧密码比新密码更长，因此不需要进行任何内存分配和回收。如果采用重载的方式，可能就不会发生任何动态内存管理操作：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Password</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">changeTo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span> newPwd<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对左值的重载</span>
        text <span class="token operator">=</span> newPwd<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 若 text.capacity() >= newPwd.size()</span>
                                            <span class="token comment" spellcheck="true">// 则可以复用 text 的内存</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此情形下，使用按值传参就会造成额外的内存分配和回收的开销，这可能会比移动<code>std::string</code>的开销高出几个数量级。</p><p>综上所述，通过赋值拷贝一个形参进行按值传参所造成的额外开销，取决于传参的类型，左值和右值的比例，这个类型是否需要动态分配内存，以及，如果需要分配内存的话，赋值操作符的具体实现，还有赋值目标所占的内存是否至少和赋值源所占的内存一样大。对于<code>std::string</code>来说，开销还取决于实现是否使用了 SSO（参考<strong>条款 29</strong>），如果是，那么要赋的值是否匹配 SSO 缓冲区。</p><p>最后要注意的一点是，按值传参肯定会导致<strong>对象切片（object slicing）</strong> 的问题，所以基类类型不适合用于按值传递：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">//基类</span>

<span class="token keyword">class</span> <span class="token class-name">SpecialWidget</span> <span class="token operator">:</span> <span class="token keyword">public</span> Widget <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//派生类</span>

<span class="token keyword">void</span> <span class="token function">processWidget</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 针对任意类型的 Widget 的函数</span>
                                                <span class="token comment" spellcheck="true">// 包括派生类型</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 

SpecialWidget sw<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token function">processWidget</span><span class="token punctuation">(</span>sw<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 发生对象切片，processWidget 只能看到 Widget</span>
                                                <span class="token comment" spellcheck="true">// 而非 SpecialWidget</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-42：考虑置入而非插入"><a href="#条款-42：考虑置入而非插入" class="headerlink" title="条款 42：考虑置入而非插入"></a>条款 42：考虑置入而非插入</h3><p>假如你想向 STL 容器中添加新元素，<strong>插入函数（insertion function）</strong> 通常是合乎逻辑的选择，但对于性能狂人而言，其背后所隐含的临时对象带来的开销是难以忍受的。考虑以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> vs<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 持有 std::string 对象的容器</span>
vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 添加字符串字面量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此处添加的字符串字面量和<code>std::string</code>类型并不匹配，因此需要先创建一个<code>std::string</code>类型的临时对象，然后再将其绑定到<code>push_back</code>函数的右值引用形参。换句话说，你可以把这句调用看作下面这样：</p><pre class="line-numbers language-cpp"><code class="language-cpp">vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这之后，<code>push_back</code>会在<code>std::vector</code>中构造出一个形参的副本，这个过程是通过调用移动构造函数来完成的（这已经是第二次调用构造函数了）。在<code>push_back</code>返回后，临时对象将立刻被销毁，这又调用了<code>std::string</code>的析构函数。</p><p>从原理上来说，<strong>置入函数（emplacement function）</strong> 在大部分时候应该比插入函数更高效，而且不会有更低效的可能性。<code>emplace_back</code>函数使用了完美转发，因此调用它不会带来任何的临时对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp">vs<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但令人遗憾的是，插入函数还是有可能比置入函数更快的，这取决于传递的实参类型，使用的容器种类，置入或插入到容器中的位置，容器中类型的构造函数的异常安全性，和对于禁止重复值的容器（<code>std::set</code>，<code>std::map</code>，<code>std::unordered_set</code>和<code>set::unordered_map</code>）而言，要添加的值是否已经在容器中。不过在以下这些情况，置入函数很有可能会运行得更快：</p><ul><li>待添加的值是通过构造而非赋值方式加入容器。一个反例是向<code>std::vector</code>中已经被占据的位置置入对象：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> vs<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment" spellcheck="true">// 向 vs 中添加元素</span>

vs<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 向 vs 的开头添加元素，该位置已经存在对象</span>
                                    <span class="token comment" spellcheck="true">// 使用的是赋值而非构造方式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>基于节点的容器一般都使用构造来添加新元素，而大多数标准库容器都是基于节点的，除了<code>std::vector</code>，<code>std::deque</code>和<code>std::string</code>等（<code>std::array</code>也不是基于节点的，但是它不支持置入和插入，所以和我们的讨论无关）。在不是基于节点的容器中，你可以确信<code>emplace_back</code>是使用构造来向容器添加元素的，这对于<code>std::deque</code>的<code>emplace_front</code>也同样成立。</p></blockquote><ul><li>传递的实参类型和容器所持有的类型不同。</li><li>容器不会因为存在重复值而拒绝待添加的值。</li></ul><p>在面对<code>new Widget</code>这样的表达式时，置入函数也没有什么优势。考虑以下两种向<code>std::shared_ptr</code>容器中添加新元素的方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">killWidget</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pWidget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 自定义删除器</span>

ptrs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> killWidget<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 和 ptrs.push_back({ new Widget, killWidget }) 等价</span>

ptrs<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> killWidget<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处使用<code>push_back</code>仍然会创建出<code>std::shared_ptr</code>类型的临时对象，但该临时对象却拥有了正面意义，如果在为链表节点分配内存时抛出了内存不足的异常，那么该<code>std::shared_ptr</code>临时对象可以自动调用<code>killWidget</code>来释放<code>Widget</code>的内存；但在使用<code>emplace_back</code>的情况下，起到保障作用的<code>std::shared_ptr</code>临时对象将不再存在，如果发生同样的异常，那么<code>Widget</code>的内存将不可避免地被泄漏。</p><p>如果你参考<strong>条款 21</strong> 所述，使用独立语句将<code>new Widget</code>产生的指针转交给资源管理对象，那么使用置入函数和插入函数的效果也是差不多的：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> killWidget<span class="token punctuation">)</span><span class="token punctuation">;</span>

ptrs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 或 ptrs.emplace_back(std::move(spw))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后需要注意的一点是，置入函数可能会执行在插入函数中会被拒绝的类型转换。这是因为置入函数使用的是直接初始化，而插入函数使用的是拷贝初始化，只有直接初始化会将带有<code>explicit</code>限定符的构造函数纳入考虑范围。因此在使用置入函数时，要特别关注是否传递了正确的实参：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>regex<span class="token operator">></span> regexes<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// C++11 提供了对正则表达式的支持</span>

regexes<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 无法通过编译！</span>
regexes<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 能通过编译，但会产生未定义行为</span>
                                    <span class="token comment" spellcheck="true">// 相当于执行 std::regex(nullptr)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/37537/"><div class="card-image"><img src="/medias/featureimages/12.jpg" class="responsive-img" alt="STL容器速查"> <span class="card-title">STL容器速查</span></div></a><div class="card-content article-content"><div class="summary block-with-text">Cpp中容器使用自查表</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2023-09-26 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></span></div></div><div class="card-action article-tags"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/35627/"><div class="card-image"><img src="/medias/featureimages/14.jpg" class="responsive-img" alt="ModernCpp快速教程"> <span class="card-title">ModernCpp快速教程</span></div></a><div class="card-content article-content"><div class="summary block-with-text">一些现代Cpp的准备工作</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2023-09-26 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-category">读书笔记</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="chip bg-color">读书笔记</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0!==window.getSelection&&((""+(n=window.getSelection())).length<Number.parseInt("120")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: JoyTsing<br />文章作者: JoyTsing<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者joytsing所有，请任何形式的转载都请注明出处并在文章评论区处告知。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)))})</script><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">834.6k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script></body></html>