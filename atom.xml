<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoyTsing</title>
  
  <subtitle>深海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joytsing.github.io/"/>
  <updated>2024-04-15T09:08:10.892Z</updated>
  <id>https://joytsing.github.io/</id>
  
  <author>
    <name>JoyTsing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cpp中还不完美的Coroutines</title>
    <link href="https://joytsing.github.io/posts/55948/"/>
    <id>https://joytsing.github.io/posts/55948/</id>
    <published>2024-04-15T07:23:58.000Z</published>
    <updated>2024-04-15T09:08:10.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Coroutines重要的不是它的性能，而是它带来的编程思维的改变，它能让你用同步的眼光去编写代码，也就是在对网络编程来说能消灭掉那些烦人的回调函数，仅此一点它的重要程度就不下于C++11，其次本篇文章为极客时间卢誉声老师的现代 C++20 实战高手课笔记，如果觉得本篇文章对你有帮助可以前去购买。</p><h2 id="C-协程"><a href="#C-协程" class="headerlink" title="C++协程"></a>C++协程</h2><p>首先，需要先纠正网络上盛传的观点“线程是轻量的进程，协程是更轻量的线程”，协程用一句话概括就是可以暂停恢复的函数。</p><p>而现代 C++20 标准下的协程，是一种可休眠、可恢复、不基于栈实现的函数。协程相较于函数来说是一个更加泛化的概念。函数只有“调用”和“返回”两个行为，而协程在这一基础上进行了扩展，增加了“休眠”和“恢复”。</p><p>同时，C++的协程属于无栈协程（与传统意义上的GO的协程不同），因此 C++ 并没有提供标准调度器，需要开发者按照规定的规则实现所需的接口约定（也就是需要在类或者结构体内部按照约定的名称命名函数，俗称硬编码），一般需要实现这么几个：</p><ul><li>调用者的传参方式。</li><li>将值返回给调用者的方式。</li><li>休眠与恢复执行的规则。</li><li>异常处理方式。</li></ul><h3 id="协程执行"><a href="#协程执行" class="headerlink" title="协程执行"></a>协程执行</h3><p>相较于函数，协程是一种可休眠、可恢复、不基于栈实现的函数。因此，它的生命周期管理自然与普通函数不同。也可以预见，C++ 中的协程是基于堆来实现的：</p><p><img src="/posts/55948/image-20240415154637876.png" alt></p><ol><li>调用函数在堆上创建协程帧（coroutine frame），用于存储协程的各类数据。协程帧的结构属于内存模型，因此不同编译器可能会有不同实现。</li><li>调用被调协程，开始执行协程代码。</li><li>被调协程执行到某个特定点，通过 co_await/co_yield 将当前协程休眠，线程 1 恢复自身原本的执行流程继续执行剩余代码</li><li>线程 2 通过协程句柄 coroutine_handle 的恢复函数 resume 恢复协程执行。</li><li>协程在线程 2 上恢复执行，继续向下执行，直到协程执行结束为止。结束后回到线程 2 的原本执行流程继续执行代码。</li><li>最后，线程 2 负责通过协程句柄 coroutine_handle 销毁协程帧。</li></ol><p>C++ 中的协程并不会像函数调用那样在栈上执行，它的状态储存在堆上。因此，我们只能在函数调用过程中，通过协程句柄 coroutine_handle 改变“部分”协程的状态——恢复或销毁。</p><h2 id="接口规定"><a href="#接口规定" class="headerlink" title="接口规定"></a>接口规定</h2><p>C++ 的协程要求开发者实现大量接口约定，而我们很难通过阅读标准文档来编写实际的代码，所以我们有必要学习一下实现接口约定的实践方法，这对我们在 C++ 里熟练应用协程非常重要。</p><p>实践里，有两个重要的用户自定义类型 Promise 和 Awaitable。我们先来看看 Promise（这里的promise和std::future里的promise没有任何关系，是协程和开发者约定的数据类型），Promise允许我们通过这个对象提供值，这个值会在之后计算得出：</p><p><img src="/posts/55948/image-20240415155849323.png" alt></p><p>生成器 Generator 用来控制协程，包括协程调用、返回值的操作、co_await/co_yield 的具体行为以及 promise_type 的具体定义。</p><p>我们要从 coroutine_traits 这一 concept 开始说起。标准中提供的代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token keyword">struct</span> coroutine_traits <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>requires requires <span class="token punctuation">{</span> <span class="token keyword">typename</span> R<span class="token operator">::</span>promise_type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">struct</span> coroutine_traits<span class="token operator">&lt;</span>R<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">using</span> promise_type <span class="token operator">=</span> <span class="token keyword">typename</span> R<span class="token operator">::</span>promise_type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际编程代码中特化的 coroutine_traits 必须定义一个公有的 promise_type 成员（见代码第 7 行）。否则，这就不是一个有效的协程类且属于未定义行为。也就是说，编译器会查找协程类中的 promise_type 作为 Promise，若 promise_type 不存在，就会发生编译时报错。</p><p>与此同时，一个协程类需要包含三个成员，分别是 <code>promise_type</code>、<code>coroutine_handle</code>和<code>coroutine_state</code>，这些都是硬编码，编译器不会给你任何提示（支持还不够好），其中：</p><p><strong>promise_type</strong> 在协程内操作时使用，它必须满足一定规则的类型，包含一系列约束的函数来支持休眠和恢复等功能，包括提交协程的返回值、提交协程异常。通常来说，编译器会通过 promise_type 的具体实现来判断协程是否合法。</p><p><strong>coroutine_handle</strong> 在协程外部操作时使用，可供调用者使用来休眠协程。它的类型是标准库提供的模板类，封装了协程帧的指针以及恢复、销毁协程帧的接口。</p><p><strong>coroutine_state</strong> 用于支持协程的生命周期，是运行时分配在堆（如果开启了编译器优化选项，则有可能会被优化使用寄存器）上的对象，目的是进一步规范说明协程执行时在堆上创建的数据，包括以下内容:</p><ul><li>promise 对象</li><li>参数（在协程创建时，会拷贝所有函数参数进入协程帧）</li><li>当前休眠的状态（在运行时，供后续恢复或销毁协程帧使用）</li><li>局部变量（在运行时，供协程帧使用）</li><li>临时变量（在运行时，供协程帧使用，它的生命周期是整个协程帧的生命周期）</li></ul><p>coroutine_state 参数还可以细分成这两种情况。</p><ul><li>值类型的参数会被移动或拷贝。</li><li>引用类型的参数会拷贝引用，当被引用的内存被释放了，那么协程状态中的引用会变成一个野引用。</li></ul><p>这三个成员里，coroutine_state 是比较特殊的抽象，是支持协程运行时的。</p><h3 id="promise-type"><a href="#promise-type" class="headerlink" title="promise_type"></a>promise_type</h3><p>对于 promise_type，它是实现协程的最关键一环。开发者需要自己来实现它，代码如下所示:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> promise<span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> Generator <span class="token operator">:</span> std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>promise<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token punctuation">{</span>  <span class="token keyword">using</span> promise_type <span class="token operator">=</span> promise<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> promise <span class="token punctuation">{</span>  T _value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 待计算的值</span>  std<span class="token operator">::</span>exception_ptr _exception<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 待抛出的异常</span>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Ty<span class="token operator">></span>  <span class="token function">promise</span><span class="token punctuation">(</span>Ty<span class="token operator">&amp;&amp;</span> lambdaObj<span class="token punctuation">,</span> T value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">promise</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  Generator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span> Generator<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">from_promise</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  std<span class="token operator">::</span>suspend_always <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  std<span class="token operator">::</span>suspend_always <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// optional，但co_yield需要这一函数实现</span>  std<span class="token operator">::</span>suspend_always <span class="token function">yield_value</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      _value <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// optional，但co_return需要这一函数实现或return_void</span>  std<span class="token operator">::</span>suspend_always <span class="token function">return_value</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      _value <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> _exception <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的调用流程和需要实现的函数如下：</p><p><img src="/posts/55948/image-20240415162354807.png" alt></p><h3 id="coroutine-handle"><a href="#coroutine-handle" class="headerlink" title="coroutine_handle"></a>coroutine_handle</h3><p>看看标准库提供的 coroutine_handle 这一模版类的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Promise</span><span class="token operator">></span><span class="token keyword">struct</span> coroutine_handle <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 构造函数和赋值函数</span>  <span class="token keyword">constexpr</span> <span class="token function">coroutine_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">constexpr</span> <span class="token function">coroutine_handle</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> coroutine_handle <span class="token function">from_promise</span><span class="token punctuation">(</span>Promise<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  coroutine_handle<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 导入和导出</span>  <span class="token keyword">constexpr</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取coroutine_handle内部数据的指针</span>  <span class="token keyword">static</span> <span class="token keyword">constexpr</span> coroutine_handle <span class="token function">from_address</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将内部数据指针转换为对应的coroutine_handle对象，会创建一个新对象</span>  <span class="token comment" spellcheck="true">// 转换函数</span>  <span class="token keyword">constexpr</span> <span class="token keyword">operator</span> coroutine_handle<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 查询协程状态</span>  <span class="token keyword">constexpr</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于确定coroutine_handle是否有效</span>  <span class="token keyword">bool</span> <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于确定协程是否已经执行完成</span>  <span class="token comment" spellcheck="true">// 控制协程执行</span>  <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 行为同resume，用于唤醒协程</span>  <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于唤醒协程</span>  <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于销毁协程</span>  <span class="token comment" spellcheck="true">// 访问Promise对象</span>  Promise<span class="token operator">&amp;</span> <span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// exposition only </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">struct</span> coroutine_handle<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 构造函数和赋值函数</span>  <span class="token keyword">constexpr</span> <span class="token function">coroutine_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">constexpr</span> <span class="token function">coroutine_handle</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  coroutine_handle<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 导入和导出</span>  <span class="token keyword">constexpr</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">constexpr</span> coroutine_handle <span class="token function">from_address</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 查询协程状态</span>  <span class="token keyword">constexpr</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 恢复协程执行</span>  <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// exposition only</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相比于 void 类型的特化版本，如果开发者指定了 promise 类型，那么就会用通用版本的 coroutine_handle，这个类多了以下几个成员函数。</p><ul><li>from_promise：获取 promise 对应的 coroutine_handle。实际行为会根据 promise 创建新的 coroutine_handle 对象。</li><li>operator coroutine_handle&lt;&gt;：将 promise 版本的 coroutine_handle 转换为 void 类型的 coroutine_handle。</li><li>promise：获取 coroutine_handle 内部的 promise 对象。</li></ul><p>两个版本最后一行用“exposition only”标识出来的部分，就是 coroutine_handle 的内部存储内容，这部分只是为了说明标准做的示例，实际不同编译器可以根据自己的需求定义这里的实现。</p><h2 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h2><p>除了定义外，还需要学习如何对协程进行调度，包括协程休眠、控制权转移和待计算值的传递。对协程进行调度的关键在于 co_await 和 co_yield 操作符（关键字）。</p><h3 id="co-await"><a href="#co-await" class="headerlink" title="co_await"></a>co_await</h3><p>co_await 是协程中必须要了解的与编译器的约定。只有了解它，我们才能知道如何通过 co_await 灵活处理线程的休眠与唤醒。而搞清楚 co_await 操作符的具体行为表现，是我们理解 Awaitable 的重点。co_await 操作符用于休眠协程，并将控制权返还给协程调用者，用法如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">co_await 表达式<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与此同时，co_await 的表达式需要满足下列两个条件之一。</p><ul><li>表达式类型必须定义了 co_await 操作符重载。</li><li>可以通过当前协程的 Promise::await_transform 转换为定义了 co_await 操作符的类型。</li></ul><p>co_await 只能出现在函数体的执行表达式中，不能出现在异常处理、声明语句、简单声明表达式、默认参数和带 static 和 thread_local 的局部变量定义中。另外，co_await 的执行过程较为复杂，其中涉及到两个类型。</p><ul><li>Awaitable：用于获取 Awaiter 对象。</li><li>Awaiter：用于控制实际的休眠操作细节。</li></ul><p>我们需要将其分为编译时和运行时两个阶段来理解。先看编译时:</p><p><img src="/posts/55948/image-20240415164924809.png" alt></p><p><strong>编译时，</strong>编译器通过以下方式，将表达式转换成 Awaitable 对象。</p><ul><li>如果表达式是通过初始休眠点、结束休眠点或 yield 产生的，那么表达式本身就是 Awaitable 对象。</li><li>否则，如果当前协程的 promise 中包含 await_transform 函数，那么就会调用 promise.await_transform 将表达式转换为 Awaitable 对象。</li><li>否则，表达式本身就是 Awaitable 对象。</li></ul><p>接着，编译器就会通过以下操作获取 Awaiter 对象。</p><ul><li>如果 Awaitable 类型包含 co_await 操作符重载，那么就会将 co_await 重载的执行结果作为 Awaiter。</li><li>如果没有找到 co_await 操作符重载，那么就会将 Awaitable 对象自身作为 Awaiter 对象。</li></ul><p>再了解一下 co_await 在运行时的执行过程:</p><p><img src="/posts/55948/image-20240415165240467.png" alt></p><p>在运行时，代码会调用 Awaiter 对象的 await_ready 函数，如果该函数返回值为 false，那么就会执行以下行为：首先，将协程休眠；然后，使用当前协程的句柄，调用 Awaiter 对象的 await_suspend(handle) 函数。</p><p>我们可以在 await_suspend 中通过句柄获取到当前协程的各种信息，在自己编写的调度器中选择何时唤醒或者销毁这个协程。</p><p><img src="/posts/55948/image-20240415165319160.png" alt></p><p>在唤醒协程时，会调用 Awaiter 的 await_resume 函数，并使用该函数的返回值作为 co_await 表达式的值。其中，await_resume 函数的执行，会根据 await_ready 和 await_suspend 的执行结果有所不同。</p><p><img src="/posts/55948/image-20240415165331019.png" alt></p><p>这里可能会有一些关于多线程上执行协程的疑问。<strong>如果协程的执行涉及在不同线程上执行，会有线程安全问题吗？</strong>答案其实是不会。协程在进入 await_suspend 之前会休眠，因此 await_suspend 函数可以将协程句柄传递给任意的线程，而不需要考虑额外的线程同步问题。</p><p>举例来说，通过协程处理异步任务，await_suspend 函数是某个 Awaiter 类的成员函数，其 this 指针指向 Awaiter 对象。</p><p><img src="/posts/55948/image-20240415165503995.png" alt></p><p>我们将句柄存储在一个回调函数中（如图中的 lambda 表达式）。然后，在预先设定的线程池中完成异步任务。最后，调用回调函数利用协程句柄调度唤醒协程。</p><p>在这种情况下，代码块 2 依然会在本线程继续执行，回调函数中的代码则会在其他线程执行。由于其他线程的调度时序是未知的，因此本线程在执行代码块 2 时，协程可能已经被其他线程唤醒。这种多线程同时访问同一内存块上数据的情况，我们通常称为数据竞争问题。</p><p>为了避免出现这种数据竞争问题，将协程句柄传递给其他线程后，await_suspend 后续代码（示例中代码块 2）必须假定 *this（也就是调用 await_suspend 的 Awaiter 对象）已经被销毁，并且再也不对其进行访问。</p><p>这是一种典型的使用异步 I/O 处理的场景。</p><h3 id="生成器和-co-yield"><a href="#生成器和-co-yield" class="headerlink" title="生成器和 co_yield"></a>生成器和 co_yield</h3><p>除了 co_await，在协程的上下文中还有一个常见操作符（关键字）——co_yield，它本质上是 co_await 的语法糖，一般用在生成器这种协程的常见场景中。那么，<strong>什么是生成器呢？</strong></p><p>生成器是基于协程的异步编程中常见的一种编程模式。最常见的应用场景就是，通过生成或其他数据源来获取某种序列。</p><p>生成器的核心思路是让协程的调用者和被调用的协程进行协同调度，其中被调用的协程就是生成器。</p><p>这个协同调度过程是这样的：首先，调用者唤醒生成器，生成器返回一个值，接着就会主动进入休眠状态；然后，调用者使用这个值来执行相应代码逻辑，然后重新唤醒生成器……这个过程如此往复，直到调用者从生成器获取了所需的值为止。</p><p><img src="/posts/55948/image-20240415165933860.png" alt></p><p>从图中可以看出，在生成器这种模式下，主要就是两个操作。</p><ul><li>调用者作为调度方恢复协程执行。</li><li>协程将获取或生成的值返回给调用者并继续休眠，等待调用者恢复执行。</li></ul><p>而其中的关键就是 co_yield 关键字，用法是这样。</p><pre class="line-numbers language-cpp"><code class="language-cpp">co_yield 表达式<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>协程可以通过该关键字将表达式的结果传回给调用方并自动休眠。代码等价于：</p><pre class="line-numbers language-cpp"><code class="language-cpp">co_await promise<span class="token punctuation">.</span><span class="token function">yield_value</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看出，调用 co_yield 的本质就是调用了 promise 的 yield_value 函数，并通过 co_await 将自身休眠。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;coroutine></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdint></span></span><span class="token keyword">struct</span> CountGenerator <span class="token punctuation">{</span>    <span class="token keyword">struct</span> promise_type <span class="token punctuation">{</span>        int32_t _value<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token operator">~</span><span class="token function">promise_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"promise_type 对象销毁"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        CountGenerator <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span>              <span class="token punctuation">.</span>_handle <span class="token operator">=</span> std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>promise_type<span class="token operator">></span><span class="token operator">::</span><span class="token function">from_promise</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        std<span class="token operator">::</span>suspend_never <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        std<span class="token operator">::</span>suspend_always <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        std<span class="token operator">::</span>suspend_always <span class="token function">yield_value</span><span class="token punctuation">(</span>int32_t value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            _value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>promise_type<span class="token operator">></span> _handle<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>CountGenerator <span class="token function">doCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int32_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        co_yield i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> h <span class="token operator">=</span> <span class="token function">doCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>_handle<span class="token punctuation">;</span>    <span class="token keyword">auto</span><span class="token operator">&amp;</span> promise <span class="token operator">=</span> h<span class="token punctuation">.</span><span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"计数: "</span> <span class="token operator">&lt;&lt;</span> promise<span class="token punctuation">.</span>_value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    h<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里定义了一个协程类 CountGenerator，比较特殊的是，这个类定义了一个 yield_value 成员函数，用于把 co_yield 的表达式值存储到 promise 对象内部，调用者通过这一方式来获取值。</p><p>由于调用方不知道协程什么时候结束执行，所以通过 coroutine_handle 中的 done 函数获取运行时状态。如果协程尚未结束执行，就获取相应的值并继续，否则就销毁协程并退出程序。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>协程是彻底迈向现代编程语言的关键标志之一，一个协程类（Generator 类）包含 promise_type、coroutine_handle、coroutine_state。</p><p>但是 C++20 的协程缺乏具体实现，<strong>接口约定都需要开发者来实现，换句话说目前只提供了跟编译器沟通的协议，</strong>相信以后的标准肯定会支持得更加完美。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ============= Promise的Concept定义 ===================</span><span class="token comment" spellcheck="true">// PromiseType是Promise的类型，ValueType是协程中待计算的值的类型</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> PromiseType<span class="token punctuation">,</span> <span class="token keyword">typename</span> ValueType<span class="token operator">></span>concept Promise <span class="token operator">=</span> <span class="token function">requires</span><span class="token punctuation">(</span>PromiseType promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Coroutine<span class="token operator">&lt;</span>PromiseType<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Awaiter<span class="token punctuation">;</span>  <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Awaiter<span class="token punctuation">;</span>  <span class="token function">requires</span> <span class="token punctuation">(</span><span class="token function">requires</span><span class="token punctuation">(</span>ValueType value<span class="token punctuation">)</span> <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">return_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">||</span> <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ============= Awaiter的Concept定义 ===================</span><span class="token comment" spellcheck="true">// AwaitSuspendResult约束了await_suspend的返回值类型</span><span class="token comment" spellcheck="true">// AwaiterType是Awaiter的类型，Promise是协程的Promise类型，下同</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> ResultType<span class="token punctuation">,</span> <span class="token keyword">typename</span> Promise<span class="token operator">></span>concept AwaitSuspendResult <span class="token operator">=</span> std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span>ResultType<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">></span> <span class="token operator">||</span>  std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span>ResultType<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> <span class="token operator">||</span>  std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span>ResultType<span class="token punctuation">,</span> std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>Promise<span class="token operator">>></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Awaiter约束定义，Awaiter类型必须满足requires中的所有接口约定</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> AwaiterType<span class="token punctuation">,</span> <span class="token keyword">typename</span> Promise<span class="token operator">></span>concept Awaiter <span class="token operator">=</span> <span class="token function">requires</span><span class="token punctuation">(</span>AwaiterType awaiter<span class="token punctuation">,</span> std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>Promise<span class="token operator">></span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    awaiter<span class="token punctuation">.</span><span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span> awaiter<span class="token punctuation">.</span><span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">;</span>    <span class="token punctuation">{</span> awaiter<span class="token punctuation">.</span><span class="token function">await_suspend</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> AwaitSuspendResult<span class="token operator">&lt;</span>Promise<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ============= Awaitable的Concept定义 ===================</span><span class="token comment" spellcheck="true">// ValidCoAwait约束用于判断对于AwaitableType是否存在正确的co_await操作符重载</span><span class="token comment" spellcheck="true">// co_await可以重载为成员函数或者非成员函数，约束中都需要判断</span><span class="token comment" spellcheck="true">// AwaitableType是Awaitable的类型，Promise是协程的Promise类型，下同</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> AwaitableType<span class="token punctuation">,</span> <span class="token keyword">typename</span> Promise<span class="token operator">></span>concept ValidCoAwait <span class="token operator">=</span> <span class="token function">requires</span><span class="token punctuation">(</span>AwaitableType awaitable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span> awaitable<span class="token punctuation">.</span><span class="token keyword">operator</span> <span class="token function">co_await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Awaiter<span class="token operator">&lt;</span>Promise<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token operator">||</span> <span class="token function">requires</span><span class="token punctuation">(</span>AwaitableType awaitable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span> <span class="token keyword">operator</span> <span class="token function">co_await</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>AwaitableType<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>awaitable<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Awaiter<span class="token operator">&lt;</span>Promise<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Awaitable约束定义</span><span class="token comment" spellcheck="true">// Awaitable必须存在正确的co_await操作符重载，或者自身是一个Awaiter</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> AwaitableType<span class="token punctuation">,</span> <span class="token keyword">typename</span> Promise<span class="token operator">></span>concept Awaitable <span class="token operator">=</span> ValidCoAwait<span class="token operator">&lt;</span>AwaitableType<span class="token punctuation">,</span> Promise<span class="token operator">></span> <span class="token operator">||</span>  Awaiter<span class="token operator">&lt;</span>AwaitableType<span class="token punctuation">,</span> Promise<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Coroutines重要的不是它的性能，而是它带来的编程思维的改变，它能让你用同步的眼光去编写代码，也就是在对网络编程来说能消灭掉那些烦人的
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Redis会遇到的15个坑</title>
    <link href="https://joytsing.github.io/posts/42709/"/>
    <id>https://joytsing.github.io/posts/42709/</id>
    <published>2024-04-11T15:21:45.000Z</published>
    <updated>2024-04-10T16:41:15.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，这篇文章是转载的，哥们暂时还没这个工程经验（捂脸）。</p><ul><li>明明一个 key 设置了过期时间，怎么变成不过期了？</li><li>使用 O(1) 复杂度的 SETBIT 命令，Redis 竟然被 OOM 了？</li><li>执行 RANDOMKEY 随机拿出一个 key，竟然也会阻塞 Redis？</li><li>同样的命令，为什么主库查不到数据，从库却可以查到？</li><li>从库内存为什么比主库用得还多？</li><li>写入到 Redis 的数据，为什么莫名其妙丢了？</li><li>…</li></ul><p>这些问题划分成了三大部分：</p><ol><li>常见命令有哪些坑？</li><li>数据持久化有哪些坑？</li><li>主从库同步有哪些坑？</li></ol><h2 id="常见命令有哪些坑？"><a href="#常见命令有哪些坑？" class="headerlink" title="常见命令有哪些坑？"></a>常见命令有哪些坑？</h2><p>首先，我们来看一下，平时在使用 Redis 时，有哪些常见的命令会遇到「意料之外」的结果。</p><p><strong>1) 过期时间意外丢失？</strong></p><p>你在使用 Redis 时，肯定经常使用 SET 命令，它非常简单。</p><p>SET 除了可以设置 key-value 之外，还可以设置 key 的过期时间，就像下面这样：</p><pre><code>127.0.0.1:6379&gt; SET testkey val1 EX 60OK127.0.0.1:6379&gt; TTL testkey(integer) 59</code></pre><p>此时如果你想修改 key 的值，但只是单纯地使用 SET 命令，而没有加上「过期时间」的参数，那这个 key 的过期时间将会被「擦除」。</p><pre><code>127.0.0.1:6379&gt; SET testkey val2OK127.0.0.1:6379&gt; TTL testkey  // key永远不过期了！(integer) -1</code></pre><p>看到了么？testkey 变成永远不过期了！</p><p><img src="/posts/42709/640.webp" alt></p><p>导致这个问题的原因在于：<strong>SET 命令如果不设置过期时间，那么 Redis 会自动「擦除」这个 key 的过期时间。</strong></p><p>如果你发现 Redis 的内存持续增长，而且很多 key 原来设置了过期时间，后来发现过期时间丢失了，很有可能是因为这个原因导致的。</p><p>这时你的 Redis 中就会存在大量不过期的 key，消耗过多的内存资源。</p><p>所以，你在使用 SET 命令时，如果刚开始就设置了过期时间，那么之后修改这个 key，也务必要加上过期时间的参数，避免过期时间丢失问题。</p><p><strong>2) DEL 竟然也会阻塞 Redis？</strong></p><p>删除一个 key，你肯定会用 DEL 命令，不知道你没有思考过它的时间复杂度是多少？O(1)？其实不一定。</p><p>如果有阅读 Redis 的官方文档，就会发现：<strong>删除一个 key 的耗时，与这个 key 的类型有关。</strong></p><p>Redis 官方文档在介绍 DEL 命令时，是这样描述的：</p><ul><li>key 是 String 类型，DEL 时间复杂度是 O(1)</li><li>key 是 List/Hash/Set/ZSet 类型，DEL 时间复杂度是 O(M)，M 为元素数量</li></ul><p><strong>也就是说，如果你要删除的是一个非 String 类型的 key，这个 key 的元素越多，那么在执行 DEL 时耗时就越久！</strong></p><p>为什么会这样？原因在于，删除这种 key 时，Redis 需要依次释放每个元素的内存，元素越多，这个过程就会越耗时。</p><p>而这么长的操作耗时，势必会阻塞整个 Redis 实例，影响 Redis 的性能。</p><p><img src="/posts/42709/640-1712762722266-3.webp" alt></p><p>所以，当你在删除 List/Hash/Set/ZSet 类型的 key 时，一定要格外注意，不能无脑执行 DEL，而是应该用以下方式删除：</p><ol><li>查询元素数量：执行 LLEN/HLEN/SCARD/ZCARD 命令</li><li>判断元素数量：如果元素数量较少，可直接执行 DEL 删除，否则分批删除</li><li>分批删除：执行 LRANGE/HSCAN/SSCAN/ZSCAN + LPOP/RPOP/HDEL/SREM/ZREM 删除</li></ol><p>了解了 DEL 对于 List/Hash/Set/ZSet 类型数据的影响，我们再来分析下，删除一个 String 类型的 key 会不会有这种问题？啊？前面不是提到，Redis 官方文档的描述，删除 String 类型的 key，时间复杂度是 O(1) 么？这不会导致 Redis 阻塞吧？</p><p>其实这也不一定！如果这个 key 占用的内存非常大呢？</p><p>例如，这个 key 存储了 500MB 的数据（很明显，它是一个 bigkey），那在执行 DEL 时，耗时依旧会变长！这是因为，Redis 释放这么大的内存给操作系统，也是需要时间的，所以操作耗时也会变长。</p><p>所以，对于 String 类型来说，你最好也不要存储过大的数据，否则在删除它时，也会有性能问题。此时，你可能会想：<strong>Redis 4.0 不是推出了 lazy-free 机制么？打开这个机制，释放内存的操作会放到后台线程中执行，那是不是就不会阻塞主线程了？</strong></p><p>这个问题非常好。真的会是这样吗？<strong>即使 Redis 打开了 lazy-free，在删除一个 String 类型的 bigkey 时，它仍旧是在主线程中处理，而不是放到后台线程中执行。所以，依旧有阻塞 Redis 的风险！</strong></p><p><strong>3) RANDOMKEY 竟然也会阻塞 Redis？</strong></p><p>如果想随机查看 Redis 中的一个 key，通常会使用 RANDOMKEY 这个命令。这个命令会从 Redis 中「随机」取出一个 key。</p><p>既然是随机，那这个执行速度肯定非常快吧？其实不然。</p><p>要解释清楚这个问题，就要结合 Redis 的过期策略来讲。如果你对 Redis 的过期策略有所了解，应该知道 Redis 清理过期 key，是采用定时清理 + 懒惰清理 2 种方式结合来做的。</p><p>而 RANDOMKEY 在随机拿出一个 key 后，首先会先检查这个 key 是否已过期。如果该 key 已经过期，那么 Redis 会删除它，这个过程就是<strong>懒惰清理</strong>。但清理完了还不能结束，Redis 还要找出一个「不过期」的 key，返回给客户端。此时，Redis 则会继续随机拿出一个 key，然后再判断是它否过期，直到找出一个未过期的 key 返回给客户端。</p><p>整个流程就是这样的：</p><ol><li>master 随机取出一个 key，判断是否已过期</li><li>如果 key 已过期，删除它，继续随机取 key</li><li>以此循环往复，直到找到一个不过期的 key，返回</li></ol><p>但这里就有一个问题了：<strong>如果此时 Redis 中，有大量 key 已经过期，但还未来得及被清理掉，那这个循环就会持续很久才能结束，而且，这个耗时都花费在了清理过期 key + 寻找不过期 key 上。</strong></p><p>导致的结果就是，RANDOMKEY 执行耗时变长，影响 Redis 性能。</p><p><img src="/posts/42709/640-1712766321625-6.webp" alt></p><p>以上流程，其实是在 master 上执行的。如果在 slave 上执行 RANDOMEKY，那么问题会更严重！</p><p>为什么？</p><p>主要原因就在于，slave 自己是不会清理过期 key。那 slave 什么时候删除过期 key 呢？其实，当一个 key 要过期时，master 会先清理删除它，之后 master 向 slave 发送一个 DEL 命令，告知 slave 也删除这个 key，以此达到主从库的数据一致性。</p><p>还是同样的场景：Redis 中存在大量已过期，但还未被清理的 key，那在 slave 上执行 RANDOMKEY 时，就会发生以下问题：</p><ol><li>slave 随机取出一个 key，判断是否已过期</li><li>key 已过期，但 slave 不会删除它，而是继续随机寻找不过期的 key</li><li>由于大量 key 都已过期，那 slave 就会寻找不到符合条件的 key，此时就会陷入「<strong>死循环</strong>」！</li></ol><p><strong>也就是说，在 slave 上执行 RANDOMKEY，有可能会造成整个 Redis 实例卡死！</strong></p><p><img src="/posts/42709/640-1712766365074-9.webp" alt></p><p>是不是没想到？在 slave 上随机拿一个 key，竟然有可能造成这么严重的后果？这其实是 Redis 的一个 Bug，这个 Bug 一直持续到 5.0 才被修复。</p><p>修复的解决方案是，在 slave 上执行 RANDOMKEY 时，会先判断整个实例所有 key 是否都设置了过期时间，如果是，为了避免长时间找不到符合条件的 key，<strong>slave 最多只会在哈希表中寻找 100 次</strong>，无论是否能找到，都会退出循环。</p><p>这个方案就是增加上了一个最大重试次数，这样一来，就避免了陷入死循环。虽然这个方案可以避免了 slave 陷入死循环、卡死整个实例的问题，但是，在 master 上执行这个命令时，依旧有概率导致耗时变长。</p><p>所以，你在使用 RANDOMKEY 时，如果发现 Redis 发生了「抖动」，很有可能是因为这个原因导致的！</p><p><strong>4) O(1) 复杂度的 SETBIT，竟然会导致 Redis OOM？</strong></p><p>在使用 Redis 的 String 类型时，除了直接写入一个字符串之外，还可以把它当做 bitmap 来用。具体来讲就是，我们可以把一个 String 类型的 key，拆分成一个个 bit 来操作，就像下面这样：</p><pre><code>127.0.0.1:6379&gt; SETBIT testkey 10 1(integer) 1127.0.0.1:6379&gt; GETBIT testkey 10(integer) 1</code></pre><p><img src="/posts/42709/640-1712766388874-12.webp" alt></p><p>其中，操作的每一个 bit 位叫做 offset。但是，这里有一个坑，你需要注意起来。如果这个 key 不存在，或者 key 的内存使用很小，此时你要操作的 offset 非常大，那么 Redis 就需要分配「更大的内存空间」，这个操作耗时就会变长，影响性能。</p><p><img src="/posts/42709/640-1712766400480-15.webp" alt></p><p>所以，当你在使用 SETBIT 时，也一定要注意 offset 的大小，操作过大的 offset 也会引发 Redis 卡顿。这种类型的 key，也是典型的 bigkey，除了分配内存影响性能之外，在删除它时，耗时同样也会变长。</p><p><strong>5) 执行 MONITOR 也会导致 Redis OOM？</strong></p><p>这个坑你肯定听说过很多次了。当你在执行 MONITOR 命令时，Redis 会把每一条命令写到客户端的「输出缓冲区」中，然后客户端从这个缓冲区读取服务端返回的结果。</p><p><img src="/posts/42709/640-1712766412176-18.webp" alt></p><p>但是，如果你的 Redis QPS 很高，这将会导致这个输出缓冲区内存持续增长，占用 Redis 大量的内存资源，如果恰好你的机器的内存资源不足，那 Redis 实例就会面临被 OOM 的风险。所以，你需要谨慎使用 MONITOR，尤其在 QPS 很高的情况下。</p><p>以上这些问题场景，都是我们在使用常见命令时发生的，而且，很可能都是「无意」就会触发的。</p><p>下面我们来看 Redis「数据持久化」都存在哪些坑？</p><h2 id="数据持久化有哪些坑？"><a href="#数据持久化有哪些坑？" class="headerlink" title="数据持久化有哪些坑？"></a>数据持久化有哪些坑？</h2><p>Redis 的数据持久化，分为 RDB 和 AOF 两种方式。其中，RDB 是数据快照，而 AOF 会记录每一个写命令到日志文件中。在数据持久化方面发生问题，主要也集中在这两大块，我们依次来看。</p><p><strong>1) master 宕机，slave 数据也丢失了？</strong></p><p>如果你的 Redis 采用如下模式部署，就会发生数据丢失的问题：</p><ul><li>master-slave + 哨兵部署实例</li><li>master 没有开启数据持久化功能</li><li>Redis 进程使用 supervisor 管理，并配置为「进程宕机，自动重启」</li></ul><p>如果此时 master 宕机，就会导致下面的问题：</p><ul><li>master 宕机，哨兵还未发起切换，此时 master 进程立即被 supervisor 自动拉起</li><li>但 master 没有开启任何数据持久化，启动后是一个「空」实例</li><li>此时 slave 为了与 master 保持一致，它会自动「清空」实例中的所有数据，slave 也变成了一个「空」实例</li></ul><p>看到了么？在这个场景下，master / slave 的数据就全部丢失了。这时，业务应用在访问 Redis 时，发现缓存中没有任何数据，就会把请求全部打到后端数据库上，这还会进一步引发「缓存雪崩」，对业务影响非常大。</p><p>所以，一定要避免这种情况发生：</p><ol><li>Redis 实例不使用进程管理工具自动拉起</li><li>master 宕机后，让哨兵发起切换，把 slave 提升为 master</li><li>切换完成后，再重启 master，让其退化成 slave</li></ol><p>你在配置数据持久化时，要避免这个问题的发生。</p><p><strong>2) AOF everysec 真的不会阻塞主线程吗？</strong></p><p>当 Redis 开启 AOF 时，需要配置 AOF 的刷盘策略。基于性能和数据安全的平衡，你肯定会采用<code>appendfsync everysec</code> 这种方案。这种方案的工作模式为，Redis 的后台线程每间隔 1 秒，就把 AOF page cache 的数据，刷到磁盘（fsync）上。这种方案的优势在于，把 AOF 刷盘的耗时操作，放到了后台线程中去执行，避免了对主线程的影响。但真的不会影响主线程吗？</p><p>答案是否定的。其实存在这样一种场景：<strong>Redis 后台线程在执行 AOF page cache 刷盘（fysnc）时，如果此时磁盘 IO 负载过高，那么调用 fsync 就会被阻塞住。</strong>此时，主线程仍然接收写请求进来，那么此时的主线程会先判断，上一次后台线程是否已刷盘成功。如何判断呢？</p><p>后台线程在刷盘成功后，都会记录刷盘的时间。主线程会根据这个时间来判断，距离上一次刷盘已经过去多久了。整个流程是这样的：</p><ol><li>主线程在写 AOF page cache（write系统调用）前，先检查后台 fsync 是否已完成？</li><li>fsync 已完成，主线程直接写 AOF page cache</li><li>fsync 未完成，则检查距离上次 fsync 过去多久？</li><li>如果距离上次 fysnc 成功在 2 秒内，那么主线程会直接返回，不写 AOF page cache</li><li>如果距离上次 fysnc 成功超过了 2 秒，那主线程会强制写 AOF page cache（write系统调用）</li><li>由于磁盘 IO 负载过高，此时，后台线程 fynsc 会发生阻塞，那主线程在写 AOF page cache 时，也会发生阻塞等待（操作同一个 fd，fsync 和 write 是互斥的，一方必须等另一方成功才可以继续执行，否则阻塞等待）</li></ol><p><img src="/posts/42709/640-1712766433045-21.webp" alt></p><p>通过分析我们可以发现，即使你配置的 AOF 刷盘策略是 appendfsync everysec，也依旧会有阻塞主线程的风险。其实，产生这个问题的重点在于，磁盘 IO 负载过高导致 fynsc 阻塞，进而导致主线程写 AOF page cache 也发生阻塞。</p><p>所以，你一定要保证磁盘有充足的 IO 资源，避免这个问题。</p><p><strong>3) AOF everysec 真的只会丢失 1 秒数据？</strong></p><p>接着上面的问题继续分析。如上所述，这里我们需要重点关注上面的步骤 4。</p><p>也就是：主线程在写 AOF page cache 时，会先判断上一次 fsync 成功的时间，如果距离上次 fysnc 成功在 2 秒内，那么主线程会直接返回，不再写 AOF page cache。这就意味着，<strong>后台线程在执行 fsync 刷盘时，主线程最多等待 2 秒不会写 AOF page cache。</strong></p><p>如果此时 Redis 发生了宕机，那么，AOF 文件中丢失是 2 秒的数据，而不是 1 秒！我们继续分析，Redis 主线程为什么要等待 2 秒不写 AOF page cache 呢？</p><p>其实，Redis AOF 配置为 appendfsync everysec 时，正常来讲，后台线程每隔 1 秒执行一次 fsync 刷盘，如果磁盘资源充足，是不会被阻塞住的。也就是说，Redis 主线程其实根本不用关心后台线程是否刷盘成功，只要无脑写 AOF page cache 即可。</p><p>但是，Redis 作者考虑到，如果此时的磁盘 IO 资源比较紧张，那么后台线程 fsync 就有概率发生阻塞风险。所以，Redis 作者在主线程写 AOF page cache 之前，先检查一下距离上一次 fsync 成功的时间，如果大于 1 秒没有成功，那么主线程此时就能知道，fsync 可能阻塞了。</p><p>所以，主线程会等待 2 秒不写 AOF page cache，其目的在于：</p><ol><li>降低主线程阻塞的风险（如果无脑写 AOF page cache，主线程则会立即阻塞住）</li><li>如果 fsync 阻塞，主线程就会给后台线程留出 1 秒的时间，等待 fsync 成功</li></ol><p>但代价就是，如果此时发生宕机，AOF 丢失的就是 2 秒的数据，而不是 1 秒。这个方案应该是 Redis 作者对性能和数据安全性的进一步权衡。无论如何，这里你只需要知道的是，即使 AOF 配置为每秒刷盘，在发生上述极端情况时，AOF 丢失的数据其实是 2 秒。</p><p><strong>4) RDB 和 AOF rewrite 时，Redis 发生 OOM？</strong></p><p>最后，我们来看一下，当 Redis 在执行 RDB 快照和 AOF rewrite 时，会发生的问题。</p><p>Redis 在做 RDB 快照和 AOF rewrite 时，会采用创建子进程的方式，把实例中的数据持久化到磁盘上。创建子进程，会调用操作系统的 fork 函数。fork 执行完成后，父进程和子进程会同时共享同一份内存数据。</p><p>但此时的主进程依旧是可以接收写请求的，而进来的写请求，会采用 Copy On Write（写时复制）的方式操作内存数据。也就是说，主进程一旦有数据需要修改，Redis 并不会直接修改现有内存中的数据，而是先将这块内存数据拷贝出来，再修改这块新内存的数据，这就是所谓的「写时复制」。</p><p>写时复制你也可以理解成，谁需要发生写操作，谁就先拷贝，再修改。你应该发现了，如果父进程要修改一个 key，就需要拷贝原有的内存数据，到新内存中，这个过程涉及到了「新内存」的申请。</p><p>如果你的业务特点是「写多读少」，而且 OPS 非常高，那在 RDB 和 AOF rewrite 期间，就会产生大量的内存拷贝工作。这会有什么问题呢？</p><p><strong>因为写请求很多，这会导致 Redis 父进程会申请非常多的内存。在这期间，修改 key 的范围越广，新内存的申请就越多。</strong>如果你的机器内存资源不足，这就会导致 Redis 面临被 OOM 的风险！</p><p><img src="/posts/42709/640-1712766433046-22.webp" alt></p><p>这就是你会从 DBA 同学那里听到的，要给 Redis 机器预留内存的原因。其目的就是避免在 RDB 和 AOF rewrite 期间，防止 Redis OOM。</p><p>下面我们再来看「主从复制」会存在哪些问题。</p><h2 id="主从复制有哪些坑？"><a href="#主从复制有哪些坑？" class="headerlink" title="主从复制有哪些坑？"></a>主从复制有哪些坑？</h2><p>Redis 为了保证高可用，提供了主从复制的方式，这样就可以保证 Redis 有多个「副本」，当主库宕机后，我们依旧有从库可以使用。在主从同步期间，依旧存在很多坑，我们依次来看。</p><p><strong>1) 主从复制会丢数据吗？</strong></p><p>首先，你需要知道，Redis 的主从复制是采用「异步」的方式进行的。这就意味着，如果 master 突然宕机，可能存在有部分数据还未同步到 slave 的情况发生。</p><p>这会导致什么问题呢？</p><p>如果你把 Redis 当做纯缓存来使用，那对业务来说没有什么影响。master 未同步到 slave 的数据，业务应用可以从后端数据库中重新查询到。但是，对于把 Redis 当做数据库，或是当做分布式锁来使用的业务，有可能因为异步复制的问题，导致数据丢失 / 锁丢失。</p><blockquote><p>关于 Redis 分布式锁可靠性的更多细节，这里先不展开，后面会单独写一篇文章详细剖析这个知识点。这里你只需要先知道，Redis 主从复制是有概率发生数据丢失的。</p></blockquote><p><strong>2) 同样命令查询一个 key，主从库却返回不同的结果？</strong></p><p>不知道你是否思考过这样一个问题：<strong>如果一个 key 已过期，但这个 key 还未被 master 清理，此时在 slave 上查询这个 key，会返回什么结果呢？</strong></p><ol><li>slave 正常返回 key 的值</li><li>slave 返回 NULL</li></ol><p>你认为是哪一种？可以思考一下。答案是：<strong>不一定</strong>。</p><p>其实，返回什么结果，这要取决于以下 3 个因素：</p><ol><li>Redis 的版本</li><li>具体执行的命令</li><li>机器时钟</li></ol><p>先来看 Redis 版本。</p><p>如果你使用的是 Redis 3.2 以下版本，只要这个 key 还未被 master 清理，那么，在 slave 上查询这个 key，它会永远返回 value 给你。</p><p><strong>也就是说，即使这个 key 已过期，在 slave 上依旧可以查询到这个 key。</strong></p><pre><code>// Redis 2.8 版本 在 slave 上执行127.0.0.1:6479&gt; TTL testkey(integer) -2    // 已过期127.0.0.1:6479&gt; GET testkey&quot;testval&quot;       // 还能查询到!</code></pre><p>但如果此时在 master 上查询这个 key，发现已经过期，就会把它清理掉，然后返回 NULL。</p><pre><code>// Redis 2.8 版本 在 master 上执行127.0.0.1:6379&gt; TTL testkey(integer) -2127.0.0.1:6379&gt; GET testkey(nil)</code></pre><p>发现了吗？在 master 和 slave 上查询同一个 key，结果竟然不一样？其实，slave 应该要与 master 保持一致，key 已过期，就应该给客户端返回 NULL，而不是还正常返回 key 的值。为什么会发生这种情况？</p><p>其实这是 Redis 的一个 Bug：<strong>3.2 以下版本的 Redis，在 slave 上查询一个 key 时，并不会判断这个 key 是否已过期，而是直接无脑返回给客户端结果。</strong>这个 Bug 在 3.2 版本进行了修复，但是，它修复得「不够彻底」。</p><p>什么叫修复得「不够彻底」？这就要结合前面提到的，第 2 个影响因素「具体执行的命令」来解释了。Redis 3.2 虽然修复了这个 Bug，但却遗漏了一个命令：<strong>EXISTS</strong>。</p><p>也就是说，一个 key 已过期，在 slave 直接查询它的数据，例如执行 GET/LRANGE/HGETALL/SMEMBERS/ZRANGE 这类命令时，slave 会返回 NULL。但如果执行的是 EXISTS，slave 依旧会返回：<strong>key 还存在</strong>。</p><pre><code>// Redis 3.2 版本 在 slave 上执行127.0.0.1:6479&gt; GET testkey(nil)           // key 已逻辑过期127.0.0.1:6479&gt; EXISTS testkey(integer) 1     // 还存在！</code></pre><p>原因在于，EXISTS 与查询数据的命令，使用的不是同一个方法。Redis 作者只在查询数据时增加了过期时间的校验，但 EXISTS 命令依旧没有这么做。</p><p>直到 Redis 4.0.11 这个版本，Redis 才真正把这个遗漏的 Bug 完全修复。如果你使用的是这个之上的版本，那在 slave 上执行数据查询或 EXISTS，对于已过期的 key，就都会返回「不存在」了。</p><p>这里我们先小结一下，slave 查询过期 key，经历了 3 个阶段：</p><ol><li>3.2 以下版本，key 过期未被清理，无论哪个命令，查询 slave，均正常返回 value</li><li>3.2 - 4.0.11 版本，查询数据返回 NULL，但 EXISTS 依旧返回 true</li><li>4.0.11 以上版本，所有命令均已修复，过期 key 在 slave 上查询，均返回「不存在」</li></ol><p>最后，我们来看影响查询结果的第 3 个因素：「机器时钟」。</p><p>假设我们已规避了上面提到的版本 Bug，例如，我们使用 Redis 5.0 版本，在 slave 查询一个 key，还会和 master 结果不同吗？答案是，还是有可能会的。</p><p>这就与 master / slave 的机器时钟有关了。无论是 master 还是 slave，在判断一个 key 是否过期时，都是基于「本机时钟」来判断的。</p><p>如果 slave 的机器时钟比 master 走得「快」，那就会导致，即使这个 key 还未过期，但以 slave 上视角来看，这个 key 其实已经过期了，那客户端在 slave 上查询时，就会返回 NULL。是不是很有意思？一个小小的过期 key，竟然藏匿这么多猫腻。</p><p>如果你也遇到了类似的情况，就可以通过上述步骤进行排查，确认是否踩到了这个坑。</p><p><strong>3) 主从切换会导致缓存雪崩？</strong></p><p>这个问题是上一个问题的延伸。</p><p>我们假设，slave 的机器时钟比 master 走得「快」，而且是「快很多」。此时，从 slave 角度来看，Redis 中的数据存在「大量过期」。如果此时操作「主从切换」，把 slave 提升为新的 master。</p><p>它成为 master 后，就会开始大量清理过期 key，此时就会导致以下结果：</p><ol><li>master 大量清理过期 key，主线程发生阻塞，无法及时处理客户端请求</li><li>Redis 中数据大量过期，引发缓存雪崩</li></ol><p>你看，当 master / slave 机器时钟严重不一致时，对业务的影响非常大！所以，如果你是 DBA 运维，一定要保证主从库的机器时钟一致性，避免发生这些问题。</p><p><strong>4) master / slave 大量数据不一致？</strong></p><p>还有一种场景，会导致 master / slave 的数据存在大量不一致。这就涉及到 Redis 的 maxmemory 配置了。Redis 的 maxmemory 可以控制整个实例的内存使用上限，超过这个上限，并且配置了淘汰策略，那么实例就开始淘汰数据。</p><p>但这里有个问题：<strong>假设 master / slave 配置的 maxmemory 不一样，那此时就会发生数据不一致。</strong></p><p>例如，master 配置的 maxmemory 为 5G，而 slave 的 maxmemory 为 3G，当 Redis 中的数据超过 3G 时，slave 就会「提前」开始淘汰数据，此时主从库数据发生不一致。</p><p><img src="/posts/42709/640-1712766433046-23.webp" alt></p><p>另外，尽管 master / slave 设置的 maxmemory 相同，如果你要调整它们的上限，也要格外注意，否则也会导致 slave 淘汰数据：</p><ul><li>调大 maxmemory 时，先调整 slave，再调整 master</li><li>调小 maxmemory 时，先调整 master，再调整 slave</li></ul><p>以此方式操作，就避免了 slave 提前超过 maxmemory 的问题。其实，你可以思考一下，发生这些问题的关键在哪？其根本原因在于，<strong>slave 超过 maxmemory 后，会「自行」淘汰数据</strong>。</p><p>如果不让 slave 自己淘汰数据，那这些问题是不是都可以规避了？没错。</p><p>针对这个问题，Redis 官方应该也收到了很多用户的反馈。在 Redis 5.0 版本增加了一个配置项：replica-ignore-maxmemory，默认 yes。这个参数表示，尽管 slave 内存超过了 maxmemory，也不会自行淘汰数据了！</p><p><strong>这样一来，slave 永远会向 master 看齐，只会老老实实地复制 master 发送过来的数据，不会自己再搞「小动作」。</strong></p><p>至此，master / slave 的数据就可以保证完全一致了！</p><blockquote><p>如果你使用的恰好是 5.0 版本，就不用担心这个问题了。</p></blockquote><p><strong>5) slave 竟然会有内存泄露问题？</strong></p><p>这是怎么发生的？我们具体来看一下。</p><p>当你在使用 Redis 时，符合以下场景，就会触发 slave 内存泄露：</p><ul><li>Redis 使用的是 4.0 以下版本</li><li>slave 配置项为 read-only=no（从库可写）</li><li>向 slave 写入了有过期时间的 key</li></ul><p>这时的 slave 就会发生内存泄露：<strong>slave 中的 key，即使到了过期时间，也不会自动清理。</strong>如果你不主动删除它，那这些 key 就会一直残留在 slave 内存中，消耗 slave 的内存。</p><p>最麻烦的是，你使用命令查询这些 key，却还查不到任何结果！这就 slave 「内存泄露」问题。</p><p><img src="/posts/42709/640-1712766433046-24.webp" alt></p><p>这其实也是 Redis 的一个 Bug，Redis 4.0 才修复了这个问题。解决方案是，<strong>在可写的 slave 上，写入带有过期时间 key 时，slave 会「记录」下来这些 key。</strong>然后 slave 会定时扫描这些 key，如果到达过期时间，则清理之。</p><p>如果你的业务需要在 slave 上临时存储数据，而且这些 key 也都设置了过期时间，那么就要注意这个问题了。你需要确认你的 Redis 版本，如果是 4.0 以下版本，一定要避免踩这个坑。</p><p>其实，最好的方案是，制定一个 Redis 使用规范，slave 必须强制设置为 read-only，不允许写，这样不仅可以保证 master / slave 的数据一致性，还避免了 slave 内存泄露问题。</p><p><strong>6) 为什么主从全量同步一直失败？</strong></p><p>在主从全量同步时，你可能会遇到同步失败的问题，具体场景如下：slave 向 master 发起全量同步请求，master 生成 RDB 后发给 slave，slave 加载 RDB。由于 RDB 数据太大，slave 加载耗时也会变得很长。此时你会发现，slave 加载 RDB 还未完成，master 和 slave 的连接却断开了，数据同步也失败了。</p><p>之后你又会发现，slave 又发起了全量同步，master 又生成 RDB 发送给 slave。同样地，slave 在加载 RDB 时，master / slave 同步又失败了，以此往复。</p><p>这是怎么回事？其实，这就是 Redis 的「复制风暴」问题。</p><p>什么是复制风暴？就像刚才描述的：<strong>主从全量同步失败，又重新开始同步，之后又同步失败，以此往复，恶性循环，持续浪费机器资源。</strong></p><p>为什么会导致这种问题呢？如果你的 Redis 有以下特点，就有可能发生这种问题：</p><ul><li>master 的实例数据过大，slave 在加载 RDB 时耗时太长</li><li>复制缓冲区（slave client-output-buffer-limit）配置过小</li><li>master 写请求量很大</li></ul><p>主从在全量同步数据时，master 接收到的写请求，会先写到主从「复制缓冲区」中，这个缓冲区的「上限」是配置决定的。当 slave 加载 RDB 太慢时，就会导致 slave 无法及时读取「复制缓冲区」的数据，这就引发了复制缓冲区「溢出」。</p><p>为了避免内存持续增长，此时的 master 会「强制」断开 slave 的连接，这时全量同步就会失败。之后，同步失败的 slave 又会「重新」发起全量同步，进而又陷入上面描述的问题中，以此往复，恶性循环，这就是所谓的「复制风暴」。</p><p>如何解决这个问题呢？</p><ol><li>Redis 实例不要太大，避免过大的 RDB</li><li>复制缓冲区配置的尽量大一些，给 slave 加载 RDB 留足时间，降低全量同步失败的概率</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先，这篇文章是转载的，哥们暂时还没这个工程经验（捂脸）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明明一个 key 设置了过期时间，怎么变成不过期了？&lt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Cpp包管理工具Conan2</title>
    <link href="https://joytsing.github.io/posts/36734/"/>
    <id>https://joytsing.github.io/posts/36734/</id>
    <published>2024-04-11T08:53:27.000Z</published>
    <updated>2024-04-11T10:25:32.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，先把<a href="https://conan.io/center">官网</a>和<a href="https://docs.conan.io/2/introduction.html">官方文档</a>放在这里。</p><p><img src="/posts/36734/conan-systems.png" alt></p><p>这个工具能让cpp开发者免去每个项目依赖都去make install或者都要源码编译的痛苦，相信就这一点经常写cpp的同志们就知道有切中痛点了，能够像pip一样帮你快速构建。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>建议cpp跟python一样内置一个包管理工具，2024年了在这种切实痛点的地方modern一点。</p><p>conan的安装非常简单，只需要</p><pre class="line-numbers language-sh"><code class="language-sh">pip install conan<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://docs.conan.io/2/tutorial/consuming_packages/build_simple_cmake_project.html">官方教程</a>中，把对应项目clone下来，按照对应的地方修改即可，注意，和之前vscode配置的不同，在使用conan初始化项目后编译链就确定了（或者你需要自己手写一套settings），默认的编译链则是输入：</p><pre class="line-numbers language-sh"><code class="language-sh">conan profile detect --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于clang编译链则是如下：</p><pre class="line-numbers language-sh"><code class="language-sh">[settings]arch=x86_64build_type=Releasecompiler=clangcompiler.cppstd=23compiler.version=17os=Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>msvc编译链如下：</p><pre class="line-numbers language-sh"><code class="language-sh">[settings]arch=x86_64build_type=Releasecompiler=msvccompiler.cppstd=14compiler.runtime=dynamiccompiler.version=193os=Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>gcc编译链如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">[</span>settings<span class="token punctuation">]</span>arch<span class="token operator">=</span>x86_64build_type<span class="token operator">=</span>Releasecompiler<span class="token operator">=</span>gcccompiler<span class="token punctuation">.</span>cppstd<span class="token operator">=</span><span class="token number">23</span>compiler<span class="token punctuation">.</span>libcxx<span class="token operator">=</span>libstdc<span class="token operator">++</span>compiler<span class="token punctuation">.</span>version<span class="token operator">=</span><span class="token number">13</span>os<span class="token operator">=</span>Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装包依赖"><a href="#安装包依赖" class="headerlink" title="安装包依赖"></a>安装包依赖</h3><p>对应的在conanfile.txt中写入需要的，对于官方的例子则是给好了：</p><pre><code>[requires]zlib/1.2.11[generators]CMakeDepsCMakeToolchain</code></pre><p>写好依赖后只需要</p><pre class="line-numbers language-sh"><code class="language-sh">conan install . --output-folder=build --build=missing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就帮你配置好依赖性了，非常方便。</p><h3 id="CMake对接"><a href="#CMake对接" class="headerlink" title="CMake对接"></a>CMake对接</h3><p>使用后会帮你生成<code>CMakeUserPresets.json</code>，这时候需要重新点工具链:</p><p><img src="/posts/36734/769b2dae762e41d18208c6469ca11504.png" alt></p><p>选择conan为你生成的toolchain即可，别的都一样</p><p><img src="/posts/36734/6f8cae5feb374f54bfe65845fb065285.png" alt></p><h3 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h3><p>开 <code>CMakeLists.txt</code> 文件，找到之前安装包的时候产生的命令行输出，添加 <code>find_package(你的包 REQUIRED)</code> 一行。并在 <strong>add_executable</strong> 的后面添加 <code>target_link_libraries(${PROJECT_NAME} 你的包::需要的模块)</code>。</p><p>好了，可以正常爽用了，不用再费劲写third-party的cmakelist和编译了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先，先把&lt;a href=&quot;https://conan.io/center&quot;&gt;官网&lt;/a&gt;和&lt;a href=&quot;https://docs.co
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>Redis最佳实践</title>
    <link href="https://joytsing.github.io/posts/41948/"/>
    <id>https://joytsing.github.io/posts/41948/</id>
    <published>2024-04-10T16:56:49.000Z</published>
    <updated>2024-04-10T17:20:38.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>学习他人的经验，首先还是抛出问题：</p><ul><li>我的 Redis 内存为什么增长这么快？</li><li>为什么我的 Redis 操作延迟变大了？</li><li>如何降低 Redis 故障发生的频率？</li><li>日常运维 Redis 需要注意什么？</li><li>部署 Redis 时，如何做好资源规划？</li><li>Redis 监控重点要关注哪些指标？</li></ul><h2 id="如何使用-Redis-更节省内存？"><a href="#如何使用-Redis-更节省内存？" class="headerlink" title="如何使用 Redis 更节省内存？"></a>如何使用 Redis 更节省内存？</h2><p>首先来看一下 Redis 内存方面的优化。</p><p>众所周知，Redis 的性能之所以如此之高，原因就在于它的数据都存储在「内存」中，所以访问 Redis 中的数据速度极快。但从资源利用率层面来说，机器的内存资源相比于磁盘，还是比较昂贵的。</p><p>当你的业务应用在 Redis 中存储数据很少时，你可能并不太关心内存资源的使用情况。但随着业务的发展，你的业务存储在 Redis 中的数据就会越来越多。如果没有提前制定好内存优化策略，那么等业务开始增长时，Redis 占用的内存也会开始膨胀。</p><p>所以，提前制定合理的内存优化策略，对于资源利用率的提升是很有必要的。</p><p><strong>1) 控制 key 的长度</strong></p><p>最简单直接的内存优化，就是控制 key 的长度。在开发业务时，你需要提前预估整个 Redis 中写入 key 的数量，如果 key 数量达到了百万级别，那么，过长的 key 名也会占用过多的内存空间。</p><p>所以，你需要保证 key 在简单、清晰的前提下，尽可能把 key 定义得短一些。例如，原有的 key 为 user:book:123，则可以优化为 u:bk:123。这样一来，你的 Redis 就可以节省大量的内存，这个方案对内存的优化非常直接和高效。</p><p><strong>2) 避免存储 bigkey</strong></p><p>除了控制 key 的长度之外，你同样需要关注 value 的大小，如果大量存储 bigkey，也会导致 Redis 内存增长过快。除此之外，客户端在读写 bigkey 时，还有产生性能问题（下文会具体详述）。</p><p>所以，你要避免在 Redis 中存储 bigkey：</p><ul><li>String：大小控制在 10KB 以下</li><li>List/Hash/Set/ZSet：元素数量控制在 1 万以下</li></ul><p><strong>3) 选择合适的数据类型</strong></p><p>Redis 提供了丰富的数据类型，这些数据类型在实现上，也对内存使用做了优化。具体来说就是，一种数据类型对应多种数据结构来实现：</p><p><img src="/posts/41948/640.webp" alt></p><p>例如，String、Set 在存储 int 数据时，会采用整数编码存储。Hash、ZSet 在元素数量比较少时（可配置），会采用压缩列表（ziplist）存储，在存储比较多的数据时，才会转换为哈希表和跳表。</p><p>作者这么设计的原因，就是为了进一步节约内存资源。那么你在存储数据时，就可以利用这些特性来优化 Redis 的内存。这里我给你的建议如下：</p><ul><li>String、Set：尽可能存储 int 类型数据</li><li>Hash、ZSet：存储的元素数量控制在转换阈值之下，以压缩列表存储，节约内存</li></ul><p><strong>4) 把 Redis 当作缓存使用</strong></p><p>Redis 数据存储在内存中，这也意味着其资源是有限的。你在使用 Redis 时，要把它当做缓存来使用，而不是数据库。所以，应用写入到  Redis 中的数据，尽可能地都设置「过期时间」。</p><p>业务应用在 Redis 中查不到数据时，再从后端数据库中加载到 Redis 中。</p><p><img src="/posts/41948/640-1712768648600-1.webp" alt></p><p>采用这种方案，可以让 Redis 中只保留经常访问的「热数据」，内存利用率也会比较高。</p><p><strong>5) 实例设置 maxmemory + 淘汰策略</strong></p><p>虽然你的 Redis key 都设置了过期时间，但如果你的业务应用写入量很大，并且过期时间设置得比较久，那么短期间内 Redis 的内存依旧会快速增长。如果不控制 Redis 的内存上限，也会导致使用过多的内存资源。</p><p>对于这种场景，需要提前预估业务数据量，然后给这个实例设置 maxmemory 控制实例的内存上限，这样可以避免 Redis 的内存持续膨胀。配置了 maxmemory，此时你还要设置数据淘汰策略，而淘汰策略如何选择，你需要结合你的业务特点来决定：</p><ul><li>volatile-lru / allkeys-lru：优先保留最近访问过的数据</li><li>volatile-lfu / allkeys-lfu：优先保留访问次数最频繁的数据（4.0+版本支持）</li><li>volatile-ttl ：优先淘汰即将过期的数据</li><li>volatile-random / allkeys-random：随机淘汰数据</li></ul><p><strong>6) 数据压缩后写入 Redis</strong></p><p>以上方案基本涵盖了 Redis 内存优化的各个方面。如果还想进一步优化 Redis 内存，还可以在业务应用中先将数据压缩，再写入到 Redis 中（例如采用 snappy、gzip 等压缩算法）。</p><p>当然，压缩存储的数据，客户端在读取时还需要解压缩，在这期间会消耗更多 CPU 资源，需要根据实际情况进行权衡。</p><h2 id="如何持续发挥-Redis-的高性能？"><a href="#如何持续发挥-Redis-的高性能？" class="headerlink" title="如何持续发挥 Redis 的高性能？"></a>如何持续发挥 Redis 的高性能？</h2><p>当决定引入 Redis 时，想必看中它最关键的一点就是：<strong>性能</strong>。</p><p>我们知道，一个单机版 Redis 就可以达到 10W QPS，这么高的性能，也意味着如果在使用过程中发生延迟情况，就会与我们的预期不符。所以，在使用 Redis 时，如何持续发挥它的高性能，避免操作延迟的情况发生，也是我们的关注焦点。</p><p><strong>1) 避免存储 bigkey</strong></p><p>存储 bigkey 除了前面讲到的使用过多内存之外，对 Redis 性能也会有很大影响。</p><p>由于 Redis 处理请求是单线程的，当你的应用在写入一个 bigkey 时，更多时间将消耗在「内存分配」上，这时操作延迟就会增加。同样地，删除一个 bigkey 在「释放内存」时，也会发生耗时。而且，当你在读取这个 bigkey 时，也会在「网络数据传输」上花费更多时间，此时后面待执行的请求就会发生排队，Redis 性能下降。</p><p><img src="/posts/41948/640-1712768648600-2.webp" alt></p><p>所以，业务应用尽量不要存储 bigkey，避免操作延迟发生。</p><blockquote><p>如果确实有存储 bigkey 的需求，可以把 bigkey 拆分为多个小 key 存储。</p></blockquote><p><strong>2) 开启 lazy-free 机制</strong></p><p>如果无法避免存储 bigkey，那么开启 Redis 的 lazy-free 机制。（4.0+版本支持）当开启这个机制后，Redis 在删除一个 bigkey 时，释放内存的耗时操作，将会放到后台线程中去执行，这样可以在最大程度上，避免对主线程的影响。</p><p><img src="/posts/41948/640-1712768648600-3.webp" alt></p><p><strong>3) 不使用复杂度过高的命令</strong></p><p>Redis 是单线程模型处理请求，除了操作 bigkey 会导致后面请求发生排队之外，在执行复杂度过高的命令时，也会发生这种情况。因为执行复杂度过高的命令，会消耗更多的 CPU 资源，主线程中的其它请求只能等待，这时也会发生排队延迟。</p><p>所以，你需要避免执行例如 SORT、SINTER、SINTERSTORE、ZUNIONSTORE、ZINTERSTORE 等聚合类命令。对于这种聚合类操作，我建议你把它放到客户端来执行，不要让 Redis 承担太多的计算工作。</p><p><strong>4) 执行 O(N) 命令时，关注 N 的大小</strong></p><p>规避使用复杂度过高的命令，就可以高枕无忧了么？答案是否定的。</p><p>当在执行 O(N) 命令时，同样需要注意 N 的大小。如果一次性查询过多的数据，也会在网络传输过程中耗时过长，操作延迟变大。所以，对于容器类型（List/Hash/Set/ZSet），在元素数量未知的情况下，一定不要无脑执行 LRANGE key 0 -1 / HGETALL / SMEMBERS / ZRANGE key 0 -1。</p><p>在查询数据时，你要遵循以下原则：</p><ol><li>先查询数据元素的数量（LLEN/HLEN/SCARD/ZCARD）</li><li>元素数量较少，可一次性查询全量数据</li><li>元素数量非常多，分批查询数据（LRANGE/HASCAN/SSCAN/ZSCAN）</li></ol><p><strong>5) 关注 DEL 时间复杂度</strong></p><p>你没看错，在删除一个 key 时，如果姿势不对，也有可能影响到 Redis 性能。删除一个 key，我们通常使用的是 DEL 命令，回想一下，你觉得 DEL 的时间复杂度是多少？O(1) ？其实不一定。</p><p>当你删除的是一个 String 类型 key 时，时间复杂度确实是 O(1)。但当你要删除的 key 是 List/Hash/Set/ZSet 类型，它的复杂度其实为 O(N)，N 代表元素个数。<strong>也就是说，删除一个 key，其元素数量越多，执行 DEL 也就越慢！</strong></p><p>原因在于，删除大量元素时，需要依次回收每个元素的内存，元素越多，花费的时间也就越久！而且，这个过程默认是在主线程中执行的，这势必会阻塞主线程，产生性能问题。</p><p>那删除这种元素比较多的 key，如何处理呢？分批删除：</p><ul><li>List类型：执行多次 LPOP/RPOP，直到所有元素都删除完成</li><li>Hash/Set/ZSet类型：先执行 HSCAN/SSCAN/SCAN 查询元素，再执行 HDEL/SREM/ZREM 依次删除每个元素</li></ul><p>没想到吧？一个小小的删除操作，稍微不小心，也有可能引发性能问题，在操作时需要格外注意。</p><p><strong>6) 批量命令代替单个命令</strong></p><p>当需要一次性操作多个 key 时，应该使用批量命令来处理。批量操作相比于多次单个操作的优势在于，可以显著减少客户端、服务端的来回网络 IO 次数。</p><ul><li>String / Hash 使用 MGET/MSET 替代 GET/SET，HMGET/HMSET 替代 HGET/HSET</li><li>其它数据类型使用 Pipeline，打包一次性发送多个命令到服务端执行</li></ul><p><img src="/posts/41948/640-1712768648600-4.webp" alt></p><p><strong>7) 避免集中过期 key</strong></p><p>Redis 清理过期 key 是采用定时 + 懒惰的方式来做的，而且这个过程都是在主线程中执行。如果业务存在大量 key 集中过期的情况，那么 Redis 在清理过期 key 时，也会有阻塞主线程的风险。</p><p><img src="/posts/41948/640-1712768648600-5.webp" alt></p><p>想要避免这种情况发生，你可以在设置过期时间时，增加一个随机时间，把这些 key 的过期时间打散，从而降低集中过期对主线程的影响。</p><p><strong>8) 使用长连接操作 Redis，合理配置连接池</strong></p><p>业务应该使用长连接操作 Redis，避免短连接。当使用短连接操作 Redis 时，每次都需要经过 TCP 三次握手、四次挥手，这个过程也会增加操作耗时。同时，客户端应该使用连接池的方式访问 Redis，并设置合理的参数，长时间不操作 Redis 时，需及时释放连接资源。</p><p><strong>9) 只使用 db0</strong></p><p>尽管 Redis 提供了 16 个 db，但只建议你使用 db0。为什么呢？</p><ol><li>在一个连接上操作多个 db 数据时，每次都需要先执行 SELECT，这会给 Redis 带来额外的压力</li><li>使用多个 db 的目的是，按不同业务线存储数据，那为何不拆分多个实例存储呢？拆分多个实例部署，多个业务线不会互相影响，还能提高 Redis 的访问性能</li><li>Redis Cluster 只支持 db0，如果后期你想要迁移到 Redis Cluster，迁移成本高</li></ol><p><strong>10) 使用读写分离 + 分片集群</strong></p><p>如果业务读请求量很大，那么可以采用部署多个从库的方式，实现读写分离，让 Redis 的从库分担读压力，进而提升性能。</p><p><img src="/posts/41948/640-1712768648600-6.webp" alt></p><p>如果业务写请求量很大，单个 Redis 实例已无法支撑这么大的写流量，那么此时你需要使用分片集群，分担写压力。</p><p><img src="/posts/41948/640-1712768648600-7.webp" alt></p><p><strong>11) 不开启 AOF 或 AOF 配置为每秒刷盘</strong></p><p>如果对于丢失数据不敏感的业务，我建议你不开启 AOF，避免 AOF 写磁盘拖慢 Redis 的性能。如果确实需要开启 AOF，那么建议配置为 appendfsync everysec，把数据持久化的刷盘操作，放到后台线程中去执行，尽量降低 Redis 写磁盘对性能的影响。</p><p><strong>12) 使用物理机部署 Redis</strong></p><p>Redis 在做数据持久化时，采用创建子进程的方式进行。而创建子进程会调用操作系统的 fork 系统调用，这个系统调用的执行耗时，与系统环境有关。虚拟机环境执行 fork 的耗时，要比物理机慢得多，所以Redis 应该尽可能部署在物理机上。</p><p><strong>13) 关闭操作系统内存大页机制</strong></p><p>Linux 操作系统提供了内存大页机制，其特点在于，每次应用程序向操作系统申请内存时，申请单位由之前的 4KB 变为了 2MB。</p><p>这会导致什么问题呢？当 Redis 在做数据持久化时，会先 fork 一个子进程，此时主进程和子进程共享相同的内存地址空间。当主进程需要修改现有数据时，会采用写时复制（Copy On Write）的方式进行操作，在这个过程中，需要重新申请内存。如果申请内存单位变为了 2MB，那么势必会增加内存申请的耗时，如果此时主进程有大量写操作，需要修改原有的数据，那么在此期间，操作延迟就会变大。</p><p><img src="/posts/41948/640-1712768648600-8.webp" alt></p><p>所以，为了避免出现这种问题，需要在操作系统上关闭内存大页机制。</p><h2 id="如何保证-Redis-的可靠性？"><a href="#如何保证-Redis-的可靠性？" class="headerlink" title="如何保证 Redis 的可靠性？"></a>如何保证 Redis 的可靠性？</h2><p>保证 Redis 可靠性其实并不难，但难的是如何做到「持续稳定」。</p><p>下面会从「资源隔离」、「多副本」、「故障恢复」这三大维度，分析保障 Redis 可靠性的最佳实践。</p><p><strong>1) 按业务线部署实例</strong></p><p>提升可靠性的第一步，就是「资源隔离」。最好按不同的业务线来部署 Redis 实例，这样当其中一个实例发生故障时，不会影响到其它业务。这种资源隔离的方案，实施成本是最低的，但成效却是非常大的。</p><p><strong>2) 部署主从集群</strong></p><p>如果只使用单机版 Redis，那么就会存在机器宕机服务不可用的风险。所以，你需要部署「多副本」实例，即主从集群，这样当主库宕机后，依旧有从库可以使用，避免了数据丢失的风险，也降低了服务不可用的时间。</p><p>在部署主从集群时，还需要注意，主从库需要分布在不同机器上，避免交叉部署。这么做的原因在于，通常情况下，Redis 的主库会承担所有的读写流量，所以我们一定要优先保证主库的稳定性，即使从库机器异常，也不要对主库造成影响。</p><p>而且，有时我们需要对 Redis 做日常维护，例如数据定时备份等操作，这时就可以只在从库上进行，这只会消耗从库机器的资源，也避免了对主库的影响。</p><p><strong>3) 合理配置主从复制参数</strong></p><p>在部署主从集群时，如果参数配置不合理，也有可能导致主从复制发生问题：</p><ul><li>主从复制中断</li><li>从库发起全量复制，主库性能受到影响</li></ul><p>在这方面有以下 2 点：</p><ol><li>设置合理的 repl-backlog 参数：过小的 repl-backlog 在写流量比较大的场景下，主从复制中断会引发全量复制数据的风险</li><li>设置合理的 slave client-output-buffer-limit：当从库复制发生问题时，过小的 buffer 会导致从库缓冲区溢出，从而导致复制中断</li></ol><p><strong>4) 部署哨兵集群，实现故障自动切换</strong></p><p>只部署了主从节点，但故障发生时是无法自动切换的，所以，你还需要部署哨兵集群，实现故障的「自动切换」。而且，多个哨兵节点需要分布在不同机器上，实例为奇数个，防止哨兵选举失败，影响切换时间。</p><p>以上这些就是保障 Redis「高可靠」实践优化，这些都是部署和运维层的优化。</p><h2 id="日常运维-Redis-需要注意什么？"><a href="#日常运维-Redis-需要注意什么？" class="headerlink" title="日常运维 Redis 需要注意什么？"></a>日常运维 Redis 需要注意什么？</h2><p><strong>1) 禁止使用 KEYS/FLUSHALL/FLUSHDB 命令</strong></p><p>执行这些命令，会长时间阻塞 Redis 主线程，危害极大，所以你必须禁止使用它。如果确实想使用这些命令：</p><ul><li>SCAN 替换 KEYS</li><li>4.0+版本可使用 FLUSHALL/FLUSHDB ASYNC，清空数据的操作放在后台线程执行</li></ul><p><strong>2) 扫描线上实例时，设置休眠时间</strong></p><p>不管是使用 SCAN 扫描线上实例，还是对实例做 bigkey 统计分析，在扫描时一定记得设置休眠时间。防止在扫描过程中，实例 OPS 过高对 Redis 产生性能抖动。</p><p><strong>3) 慎用 MONITOR 命令</strong></p><p>有时在排查 Redis 问题时，你会使用 MONITOR 查看 Redis 正在执行的命令。但如果 Redis OPS 比较高，那么在执行 MONITOR 会导致 Redis 输出缓冲区的内存持续增长，这会严重消耗 Redis 的内存资源，甚至会导致实例内存超过 maxmemory，引发数据淘汰。</p><p><img src="/posts/41948/640-1712768648600-9.webp" alt></p><p>所以在执行 MONITOR 命令时，一定要谨慎，尽量少用。</p><p><strong>4) 从库必须设置为 slave-read-only</strong></p><p>从库必须设置为 slave-read-only 状态，避免从库写入数据，导致主从数据不一致。除此之外，从库如果是非 read-only 状态，如果你使用的是 4.0 以下的 Redis，它存在这样的 Bug：</p><p><strong>从库写入了有过期时间的数据，不会做定时清理和释放内存。</strong></p><p>这会造成从库的内存泄露！这个问题直到 4.0 版本才修复，你在配置从库时需要格外注意。</p><p><strong>5) 合理配置 timeout 和 tcp-keepalive 参数</strong></p><p>如果因为网络原因，导致大量客户端连接与 Redis 意外中断，恰好 Redis 配置的 maxclients 参数比较小，此时有可能导致客户端无法与服务端建立新的连接（服务端认为超过了 maxclients）。</p><p>造成这个问题原因在于，客户端与服务端每建立一个连接，Redis 都会给这个客户端分配了一个 client fd。<strong>当客户端与服务端网络发生问题时，服务端并不会立即释放这个 client fd。</strong>什么时候释放呢？</p><p>Redis 内部有一个定时任务，会定时检测所有 client 的空闲时间是否超过配置的 timeout 值。如果 Redis 没有开启 tcp-keepalive 的话，服务端直到配置的 timeout 时间后，才会清理释放这个 client fd。</p><p>在没有清理之前，如果还有大量新连接进来，就有可能导致 Redis 服务端内部持有的 client fd 超过了 maxclients，这时新连接就会被拒绝。针对这种情况的优化建议是：</p><ol><li>不要配置过高的 timeout：让服务端尽快把无效的 client fd 清理掉</li><li>Redis 开启 tcp-keepalive：这样服务端会定时给客户端发送 TCP 心跳包，检测连接连通性，当网络异常时，可以尽快清理僵尸 client fd</li></ol><p><strong>6) 调整 maxmemory 时，注意主从库的调整顺序</strong></p><p>Redis 5.0 以下版本存在这样一个问题：<strong>从库内存如果超过了 maxmemory，也会触发数据淘汰。</strong></p><p>在某些场景下，从库是可能优先主库达到 maxmemory 的（例如在从库执行 MONITOR 命令，输出缓冲区占用大量内存），那么此时从库开始淘汰数据，主从库就会产生不一致。</p><p>要想避免此问题，在调整 maxmemory 时，一定要注意主从库的修改顺序：</p><ul><li>调大 maxmemory：先修改从库，再修改主库</li><li>调小 maxmemory：先修改主库，再修改从库</li></ul><p>直到 Redis 5.0，Redis 才增加了一个配置 replica-ignore-maxmemory，默认从库超过 maxmemory 不会淘汰数据，才解决了此问题。</p><h2 id="Redis-安全如何保证？"><a href="#Redis-安全如何保证？" class="headerlink" title="Redis 安全如何保证？"></a>Redis 安全如何保证？</h2><p>无论如何，在互联网时代，安全问题一定是我们需要随时警戒的。你可能听说过 Redis 被注入可执行脚本，然后拿到机器 root 权限的安全问题，都是因为在部署 Redis 时，没有把安全风险注意起来。针对这方面：</p><ol><li>不要把 Redis 部署在公网可访问的服务器上</li><li>部署时不使用默认端口 6379</li><li>以普通用户启动 Redis 进程，禁止 root 用户启动</li><li>限制 Redis 配置文件的目录访问权限</li><li>推荐开启密码认证</li><li>禁用/重命名危险命令（KEYS/FLUSHALL/FLUSHDB/CONFIG/EVAL）</li></ol><p>只要你把这些做到位，基本上就可以保证 Redis 的安全风险在可控范围内。</p><h2 id="如何预防-Redis-问题？"><a href="#如何预防-Redis-问题？" class="headerlink" title="如何预防 Redis 问题？"></a>如何预防 Redis 问题？</h2><p>要想提前预防 Redis 问题，你需要做好以下两个方面：</p><ol><li>合理的资源规划</li><li>完善的监控预警</li></ol><p>先来说资源规划。在部署 Redis 时，如果你可以提前做好资源规划，可以避免很多因为资源不足产生的问题：</p><ol><li>保证机器有足够的 CPU、内存、带宽、磁盘资源</li><li>提前做好容量规划，主库机器预留一半内存资源，防止主从机器网络故障，引发大面积全量同步，导致主库机器内存不足的问题</li><li>单个实例内存建议控制在 10G 以下，大实例在主从全量同步、RDB 备份时有阻塞风险</li></ol><p>再来看监控如何做。监控预警是提高稳定性的重要环节，完善的监控预警，可以把问题提前暴露出来，这样我们才可以快速反应，把问题最小化：</p><ol><li>做好机器 CPU、内存、带宽、磁盘监控，资源不足时及时报警，任意资源不足都会影响 Redis 性能</li><li>设置合理的 slowlog 阈值，并对其进行监控，slowlog 过多及时报警</li><li>监控组件采集 Redis INFO 信息时，采用长连接，避免频繁的短连接</li><li>做好实例运行时监控，重点关注 expired_keys、evicted_keys、latest_fork_usec 指标，这些指标短时突增可能会有阻塞风险</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;学习他人的经验，首先还是抛出问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我的 Redis 内存为什么增长这么快？&lt;/li&gt;
&lt;li&gt;为什么我的 Red
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群进化之路</title>
    <link href="https://joytsing.github.io/posts/51730/"/>
    <id>https://joytsing.github.io/posts/51730/</id>
    <published>2024-04-10T09:14:02.000Z</published>
    <updated>2024-04-10T14:38:41.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>我使用 Redis 的场景很简单，只使用单机版 Redis 会有什么问题吗？</li><li>我的 Redis 故障宕机了，数据丢失了怎么办？如何能保证我的业务应用不受影响？</li><li>为什么需要主从集群？它有什么优势？</li><li>什么是分片集群？我真的需要分片集群吗？</li><li>…</li></ul><p>高性能的 Redis 集群为了做到稳定、高性能，都采取了哪些优化方案，为什么要这么做？</p><h2 id="从最简单的开始：单机版-Redis"><a href="#从最简单的开始：单机版-Redis" class="headerlink" title="从最简单的开始：单机版 Redis"></a>从最简单的开始：单机版 Redis</h2><p>首先从最简单的场景开始。假设现在有一个业务应用，需要引入 Redis 来提高应用的性能，可以选择部署一个单机版的 Redis 来使用，就像这样：</p><p><img src="/posts/51730/640.webp" alt></p><p>这个架构非常简单，业务应用可以把 Redis 当做缓存来使用，从 MySQL 中查询数据，然后写入到 Redis 中，之后业务应用再从 Redis 中读取这些数据，由于 Redis 的数据都存储在内存中，所以这个速度飞快。</p><p>如果业务体量并不大，那这样的架构模型基本可以满足你的需求。是不是很简单？随着时间的推移，你的业务体量逐渐发展起来了，Redis 中存储的数据也越来越多，此时你的业务应用对 Redis 的依赖也越来越重。但是突然有一天Redis 因为某些原因宕机了，这时所有业务流量，都会打到后端 MySQL 上，这会导致 MySQL 压力剧增，严重的话甚至会压垮 MySQL。</p><p><img src="/posts/51730/640-1712746680741-3.webp" alt></p><p>这时你应该怎么办？首先肯定需要赶紧重启 Redis，让它可以继续提供服务。但是，因为之前 Redis 中的数据都在内存中，尽管你现在把 Redis 重启了，之前的数据也都丢失了。重启后的 Redis 虽然可以正常工作，但是由于 Redis 中没有任何数据，业务流量还是都会打到后端 MySQL 上，MySQL 的压力还是很大。</p><p>这可怎么办？有没有什么好的办法解决这个问题？既然 Redis 只把数据存储在内存中，那是否可以把这些数据也写一份到磁盘上呢？如果采用这种方式，当 Redis 重启时，我们把磁盘中的数据快速<strong>恢复</strong>到内存中，这样它就可以继续正常提供服务了。是的，这是一个很好的解决方案，这个把内存数据写到磁盘上的过程，就是「数据持久化」。</p><h2 id="数据持久化：有备无患"><a href="#数据持久化：有备无患" class="headerlink" title="数据持久化：有备无患"></a>数据持久化：有备无患</h2><p>数据持久化具体应该怎么做呢？最容易想到的一个方案是，Redis 每一次执行写操作，除了写内存之外，同时也写一份到磁盘上，就像这样：</p><p><img src="/posts/51730/640-1712746720874-7.webp" alt></p><p>但仔细想一下，这个方案有个问题：客户端的每次写操作，既需要写内存，又需要写磁盘，而写磁盘的耗时相比于写内存来说，肯定要慢很多！这势必会影响到 Redis 的性能。如何规避这个问题？</p><p>可以这样优化：Redis 写内存由主线程来做，写内存完成后就给客户端返回结果，然后 Redis 用另一个线程去写磁盘，这样就可以避免主线程写磁盘对性能的影响。这确实是一个好方案。除此之外，我们可以换个角度，思考一下还有什么方式可以持久化数据？</p><p>这时就要结合 Redis 的使用场景来考虑了。在使用 Redis 时，通常把它用作什么场景？缓存。把 Redis 当做缓存来用，意味着尽管 Redis 中没有保存全量数据，对于不在缓存中的数据，我们的业务应用依旧可以通过查询后端数据库得到结果，只不过查询后端数据的速度会慢一点而已，但对业务结果其实是没有影响的。基于这个特点，我们的 Redis 数据持久化还可以用「数据快照」的方式来做。</p><p>那什么是数据快照呢？简单来讲可以这么理解：</p><ol><li>把 Redis 想象成一个水杯，向 Redis 写入数据，就相当于往这个杯子里倒水</li><li>此时拿一个相机给这个水杯拍一张照片，拍照的这一瞬间，照片中记录到这个水杯中水的容量，就是水杯的数据快照</li></ol><p><img src="/posts/51730/640-1712746819053-12.webp" alt></p><p>也就是说，Redis 的数据快照，是记录某一时刻下 Redis 中的数据，然后只需要把这个数据快照写到磁盘上就可以了。它的优势在于，只在需要持久化时，把数据「一次性」写入磁盘，其它时间都不需要操作磁盘。基于这个方案可以<strong>定时</strong>给 Redis 做数据快照，把数据持久化到磁盘上。</p><p><img src="/posts/51730/640-1712746906562-15.webp" alt></p><p>其实，上面说的这些持久化方案，就是 Redis 的「RDB」和「AOF」：</p><ul><li>RDB：只持久化某一时刻的数据快照到磁盘上（创建一个子进程来做）</li><li>AOF：每一次写操作都持久到磁盘（主线程写内存，根据策略可以配置由主线程还是子线程进行数据持久化）</li></ul><p>它们的区别除了上面讲到的，还有以下特点：</p><ol><li>RDB 采用二进制 + 数据压缩的方式写磁盘，这样文件体积小，数据恢复速度也快</li><li>AOF 记录的是每一次写命令，数据最全，但文件体积大，数据恢复速度慢</li></ol><p>如果让你来选择持久化方案，可以这样选择：</p><ol><li>如果业务对于数据丢失不敏感，采用 RDB 方案持久化数据</li><li>如果业务对数据完整性要求比较高，采用 AOF 方案持久化数据</li></ol><p>假设业务对 Redis 数据完整性要求比较高，选择了 AOF 方案，那此时你又会遇到这些问题：</p><ol><li>AOF 记录每一次写操作，随着时间增长，AOF 文件体积会越来越大</li><li>这么大的 AOF 文件，在数据恢复时变得非常慢</li></ol><p>这怎么办？数据完整性要求变高了，恢复数据也变困难了？有没有什么方法，可以缩小文件体积？提升恢复速度呢？由于 AOF 文件中记录的都是每一次写操作，但对于同一个 key 可能会发生多次修改，只保留最后一次被修改的值，是不是也可以？这就是「AOF rewrite」，也可以把它理解为 AOF 「瘦身」。</p><p>可以对 AOF 文件定时 rewrite，避免这个文件体积持续膨胀，这样在恢复时就可以缩短恢复时间了。</p><p><img src="/posts/51730/640-1712746985484-18.webp" alt></p><p>再进一步思考一下，还有没有办法继续缩小 AOF 文件？回顾一下我们前面讲到的，RDB 和 AOF 各自的特点：</p><ol><li>RDB 以二进制 + 数据压缩方式存储，文件体积小</li><li>AOF 记录每一次写命令，数据最全</li></ol><p>可否利用它们各自的优势呢？当然可以，这就是 Redis 的「混合持久化」。具体来说，当 AOF rewrite 时，Redis 先以 RDB 格式在 AOF 文件中写入一个数据快照，再把在这期间产生的每一个写命令，追加到 AOF 文件中。因为 RDB 是二进制压缩写入的，这样 AOF 文件体积就变得更小了。</p><p><img src="/posts/51730/640-1712746995883-21.webp" alt></p><blockquote><p>Redis 4.0 以上版本才支持混合持久化。</p></blockquote><p>这么一番优化Redis再也不用担心实例宕机了，当发生宕机时就可以用持久化文件快速恢复 Redis 中的数据。</p><p>但这样就没问题了吗？仔细想一下，虽然我们已经把持久化的文件优化到最小了，但在恢复数据时依旧是需要时间的，在这期间你的业务应用还是会受到影响，这怎么办？有没有更好的方案？</p><p>一个实例宕机，只能用恢复数据来解决，那是否可以部署多个 Redis 实例，然后让这些实例数据保持实时同步，这样当一个实例宕机时，我们在剩下的实例中选择一个继续提供服务就好了。</p><h2 id="主从复制：多副本"><a href="#主从复制：多副本" class="headerlink" title="主从复制：多副本"></a>主从复制：多副本</h2><p>此时，可以部署多个 Redis 实例，架构模型就变成了这样：</p><p><img src="/posts/51730/640-1712759373096-24.webp" alt></p><p>我们这里把实时读写的节点叫做 master，另一个实时同步数据的节点叫做 slave，采用多副本的方案，它的优势是：</p><ol><li>缩短不可用时间：master 发生宕机，我们可以手动把 slave 提升为 master 继续提供服务</li><li>提升读性能：让 slave 分担一部分读请求，提升应用的整体性能</li></ol><p><img src="/posts/51730/640-1712759373096-25.webp" alt></p><p>这个方案不错，不仅节省了数据恢复的时间，还能提升性能，那它有什么问题吗？</p><p>它的问题在于：当 master 宕机时，我们需要「手动」把 slave 提升为 master，这个过程也是需要花费时间的。虽然比恢复数据要快得多，但还是需要人工介入处理。一旦需要人工介入，就必须要算上人的反应时间、操作时间，所以，在这期间业务应用依旧会受到影响。</p><p>怎么解决这个问题？我们是否可以把这个切换的过程，变成自动化呢？对于这种情况，我们需要一个「故障自动切换」机制，这就是我们经常听到的「哨兵」所具备的能力。</p><h2 id="哨兵：故障自动切换"><a href="#哨兵：故障自动切换" class="headerlink" title="哨兵：故障自动切换"></a>哨兵：故障自动切换</h2><p>现在，可以引入一个「观察者」，让这个观察者去实时监测 master 的健康状态，这个观察者就是「哨兵」。具体如何做？</p><ol><li>哨兵每间隔一段时间，询问 master 是否正常</li><li>master 正常回复，表示状态正常，回复超时表示异常</li><li>哨兵发现异常，发起主从切换</li></ol><p><img src="/posts/51730/640-1712759415184-30.webp" alt></p><p>但这里还有一个问题，如果 master 状态正常，但这个哨兵在询问 master 时，它们之间的网络发生了问题，那这个哨兵可能会误判。</p><p><img src="/posts/51730/640-1712759446267-33.webp" alt></p><p>这个问题怎么解决？答案是，可以部署多个哨兵，让它们分布在不同的机器上，它们一起监测 master 的状态，流程就变成了这样：</p><ol><li>多个哨兵每间隔一段时间，询问 master 是否正常</li><li>master 正常回复，表示状态正常，回复超时表示异常</li><li>一旦有一个哨兵判定 master 异常（不管是否是网络问题），就询问其它哨兵，如果多个哨兵（设置一个阈值）都认为 master 异常了，这才判定 master 确实发生了故障</li><li>多个哨兵经过协商后，判定 master 故障，则发起主从切换</li></ol><p>所以，我们用多个哨兵互相协商来判定 master 的状态，这样一来，就可以大大降低误判的概率。哨兵协商判定 master 异常后，这里还有一个问题：<strong>由哪个哨兵来发起主从切换呢？</strong></p><p>答案是，选出一个哨兵「领导者」，由这个领导者进行主从切换。问题又来了，这个领导者怎么选？在选举哨兵领导者时，我们可以制定这样一个选举规则：</p><ol><li>每个哨兵都询问其它哨兵，请求对方为自己投票</li><li>每个哨兵只投票给第一个请求投票的哨兵，且只能投票一次</li><li>首先拿到超过半数投票的哨兵，当选为领导者，发起主从切换</li></ol><p>其实，这个选举的过程就是我们经常听到的：分布式系统领域中的「共识算法」。</p><p>什么是共识算法？我们在多个机器部署哨兵，它们需要共同协作完成一项任务，所以它们就组成了一个「分布式系统」。在分布式系统领域，多个节点如何就一个问题达成共识的算法，就叫共识算法。在这个场景下，多个哨兵共同协商，选举出一个都认可的领导者，就是使用共识算法完成的。</p><p>这个算法还规定节点的数量必须是奇数个，这样可以保证系统中即使有节点发生了故障，剩余超过「半数」的节点状态正常，依旧可以提供正确的结果，也就是说，这个算法还兼容了存在故障节点的情况。</p><blockquote><p>共识算法在分布式系统领域有很多，例如 Paxos、Raft，哨兵选举领导者这个场景，使用的是 Raft 共识算法，因为它足够简单，且易于实现。</p></blockquote><p>现在，我们用多个哨兵共同监测 Redis 的状态，这样一来，就可以避免误判的问题了，架构模型就变成了这样：</p><p><img src="/posts/51730/640-1712759591360-36.webp" alt></p><p>随着时间的发展，业务体量开始迎来了爆炸性增长，此时架构模型，还能够承担这么大的流量吗？一起来分析一下：</p><ol><li>稳定性：Redis 故障宕机，我们有哨兵 + 副本，可以自动完成主从切换</li><li>性能：读请求量增长，我们可以再部署多个 slave，读写分离，分担读压力</li><li>性能：写请求量增长，但我们只有一个 master 实例，这个实例达到瓶颈怎么办？</li></ol><p>看到了么，当你的写请求量越来越大时，一个 master 实例可能就无法承担这么大的写流量了。要想完美解决这个问题，此时你就需要考虑使用「分片集群」了。</p><h2 id="分片集群：横向扩展"><a href="#分片集群：横向扩展" class="headerlink" title="分片集群：横向扩展"></a>分片集群：横向扩展</h2><p>什么是「分片集群」？</p><p>简单来讲，一个实例扛不住写压力，那我们是否可以部署多个实例，然后把这些实例按照一定规则组织起来，把它们当成一个整体，对外提供服务，这样不就可以解决集中写一个实例的瓶颈问题吗？</p><p>所以，现在的架构模型就变成了这样：</p><p><img src="/posts/51730/640-1712759631118-39.webp" alt></p><p>现在问题又来了，这么多实例如何组织呢？我们制定规则如下：</p><ol><li>每个节点各自存储一部分数据，所有节点数据之和才是全量数据</li><li>制定一个路由规则，对于不同的 key，把它路由到固定一个实例上进行读写</li></ol><p>而分片集群根据路由规则所在位置的不同，还可以分为两大类：</p><ol><li>客户端分片</li><li>服务端分片</li></ol><p>客户端分片指的是，key 的路由规则放在客户端来做，就是下面这样：</p><p><img src="/posts/51730/640-1712759646445-42.webp" alt></p><p>这个方案的缺点是，客户端需要维护这个路由规则，也就是说，你需要把路由规则写到你的业务代码中。如何做到不把路由规则耦合在业务代码中呢？你可以这样优化，把这个路由规则封装成一个模块，当需要使用时，集成这个模块就可以了。</p><p>这就是 Redis Cluster 的采用的方案。</p><p><img src="/posts/51730/640-1712759661868-45.webp" alt></p><blockquote><p>Redis Cluster 内置了哨兵逻辑，无需再部署哨兵。</p></blockquote><p>当使用 Redis Cluster 时，业务应用需要使用配套的 Redis SDK，这个 SDK 内就集成好了路由规则，不需要你自己编写了。</p><p>再来看服务端分片，这种方案指的是，路由规则不放在客户端来做，而是在客户端和服务端之间增加一个「中间代理层」，这个代理就是我们经常听到的 Proxy。而数据的路由规则，就放在这个 Proxy 层来维护。这样一来，你就无需关心服务端有多少个 Redis 节点了，只需要和这个 Proxy 交互即可。</p><p>Proxy 会把你的请求根据路由规则，转发到对应的 Redis 节点上，而且，当集群实例不足以支撑更大的流量请求时，还可以横向扩容，添加新的 Redis 实例提升性能，这一切对于你的客户端来说，都是透明无感知的。</p><p>业界开源的 Redis 分片集群方案，例如 Twemproxy、Codis 就是采用的这种方案。</p><p><img src="/posts/51730/640-1712759695847-48.webp" alt></p><blockquote><p>分片集群在数据扩容时，还涉及到了很多细节，这块内容不是本文章重点，所以暂不详述。</p></blockquote><p>至此，当使用分片集群后，对于未来更大的流量压力，都可以从容面对了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如何一步步构建一个稳定、高性能的 Redis 集群：</p><ul><li>首先，在使用最简单的单机版 Redis 时，我们发现当 Redis 故障宕机后，数据无法恢复的问题，因此想到了「数据持久化」，把内存中的数据也持久化到磁盘上一份，这样 Redis 重启后就可以从磁盘上快速恢复数据。</li><li>在进行数据持久化时，我们又面临如何更高效地将数据持久化到磁盘的问题。之后发现 Redis 提供了 RDB 和 AOF 两种方案，分别对应了数据快照和实时的命令记录。当我们对数据完整性要求不高时，可以选择 RDB 持久化方案。如果对于数据完整性要求较高，那么可以选择 AOF 持久化方案。</li><li>但是我们又发现，AOF 文件体积会随着时间增长变得越来越大，此时我们想到的优化方案是，使用 AOF rewrite 的方式对其进行瘦身，减小文件体积，再后来，我们发现可以结合 RDB 和 AOF 各自的优势，在 AOF rewrite 时使用两者结合的「混合持久化」方式，又进一步减小了 AOF 文件体积。</li><li>之后，我们发现尽管可以通过数据恢复的方式还原数据，但恢复数据也是需要花费时间的，这意味着业务应用还是会受到影响。我们进一步优化，采用「多副本」的方案，让多个实例保持实时同步，当一个实例故障时，可以手动把其它实例提升上来继续提供服务。</li><li>但是这样也有问题，手动提升实例上来，需要人工介入，人工介入操作也需要时间，我们开始想办法把这个流程变得自动化，所以我们又引入了「哨兵」集群，哨兵集群通过互相协商的方式，发现故障节点，并可以自动完成切换，这样就大幅降低了对业务应用的影响。</li><li>最后，我们把关注点聚焦在如何支撑更大的写流量上，所以，我们又引入了「分片集群」来解决这个问题，让多个 Redis 实例分摊写压力，未来面对更大的流量，我们还可以添加新的实例，横向扩展，进一步提升集群的性能。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我使用 Redis 的场景很简单，只使用单机版 Redis 会有什么问题吗？&lt;/li&gt;
&lt;li&gt;我的 Redis 故障宕机了，数
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>解决Redis缓存和数据库一致性问题</title>
    <link href="https://joytsing.github.io/posts/10748/"/>
    <id>https://joytsing.github.io/posts/10748/</id>
    <published>2024-04-10T08:29:14.000Z</published>
    <updated>2024-04-10T09:06:42.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>到底是更新缓存还是删缓存？</li><li>到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？</li><li>为什么要引入消息队列保证一致性？</li><li>延迟双删会有什么问题？到底要不要用？</li><li>…</li></ul><h2 id="引入缓存提高性能"><a href="#引入缓存提高性能" class="headerlink" title="引入缓存提高性能"></a>引入缓存提高性能</h2><p>如果业务处于起步阶段，流量非常小，那无论是读请求还是写请求，直接操作数据库即可，这时架构模型是这样的：</p><p><img src="/posts/10748/640.webp" alt></p><p>但随着业务量的增长，项目请求量越来越大，这时如果每次都从数据库中读数据，那肯定会有性能问题。这个阶段通常的做法是，引入「缓存」来提高读性能，架构模型就变成了这样：</p><p><img src="/posts/10748/640-1712737981539-1.webp" alt></p><p>当下优秀的缓存中间件，当属 Redis 莫属，它不仅性能非常高，还提供了很多友好的数据类型，可以很好地满足我们的业务需求。</p><p>但引入缓存之后，就会面临一个问题：<strong>之前数据只存在数据库中，现在要放到缓存中读取，具体要怎么存呢？</strong></p><p>最简单直接的方案是「全量数据刷到缓存中」：</p><ul><li>数据库的数据，全量刷入缓存（不设置失效时间）</li><li>写请求只更新数据库，不更新缓存</li><li>启动一个定时任务，定时把数据库的数据，更新到缓存中</li></ul><p><img src="/posts/10748/640-1712737981539-2.webp" alt></p><p>这个方案的优点是，所有读请求都可以直接「命中」缓存，不需要再查数据库，性能非常高。但缺点也很明显，有 2 个问题：</p><ol><li><strong>缓存利用率低</strong>：不经常访问的数据，还一直留在缓存中</li><li><strong>数据不一致</strong>：因为是「定时」刷新缓存，缓存和数据库存在不一致（取决于定时任务的执行频率）</li></ol><p>所以，这种方案一般更适合业务「体量小」，且对数据一致性要求不高的业务场景。</p><p>那如果我们的业务体量很大，怎么解决这 2 个问题呢？</p><h2 id="缓存利用率和一致性问题"><a href="#缓存利用率和一致性问题" class="headerlink" title="缓存利用率和一致性问题"></a>缓存利用率和一致性问题</h2><p>先来看第一个问题，如何提高缓存利用率？想要缓存利用率「最大化」，我们很容易想到的方案是，缓存中只保留最近访问的「热数据」。但具体要怎么做呢？</p><p>我们可以这样优化：</p><ul><li>写请求依旧只写数据库</li><li>读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存</li><li>同时，写入缓存中的数据，都设置失效时间</li></ul><p><img src="/posts/10748/640-1712738117920-9.webp" alt></p><p>这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「热数据」，缓存利用率得以最大化，再来看数据一致性问题。</p><p>要想保证缓存和数据库「实时」一致，那就不能再用定时任务刷新缓存了。所以，当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存。具体操作就是，修改一条数据时，不仅要更新数据库，也要连带缓存一起更新。但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：</p><ol><li>先更新缓存，后更新数据库</li><li>先更新数据库，后更新缓存</li></ol><p>哪个方案更好呢？先不考虑并发问题，正常情况下，无论谁先谁后，都可以让两者保持一致，但现在我们需要重点考虑「异常」情况。因为操作分为两步，那么就很有可能存在「第一步成功、第二步失败」的情况发生。这 2 种方案我们一个个来分析。</p><p><strong>1) 先更新缓存，后更新数据库</strong></p><p>如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。</p><p>虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。</p><p>这时用户会发现自己之前修改的数据又「变回去」了，对业务造成影响。</p><p><strong>2) 先更新数据库，后更新缓存</strong></p><p>如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。</p><p>这时用户会发现，自己刚刚修改了数据，但却看不到变更，一段时间过后，数据才变更过来，对业务也会有影响。可见，无论谁先谁后，但凡后者发生异常，就会对业务造成影响。那怎么解决这个问题呢？</p><p>除了操作失败问题，还有什么场景会影响数据一致性？<strong>并发问题</strong>。</p><h2 id="并发引发的一致性问题"><a href="#并发引发的一致性问题" class="headerlink" title="并发引发的一致性问题"></a>并发引发的一致性问题</h2><p>假设采用「先更新数据库，再更新缓存」的方案，并且两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：</p><blockquote><ol><li>线程 A 更新数据库（X = 1）</li><li>线程 B 更新数据库（X = 2）</li><li>线程 B 更新缓存（X = 2）</li><li>线程 A 更新缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。也就是说，A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。</p><blockquote><p>同样地，采用「先更新缓存，再更新数据库」的方案，也会有类似问题，这里不再详述。</p></blockquote><p>除此之外，我们从「缓存利用率」的角度来评估这个方案，也是不太推荐的。这是因为每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。</p><p>而且很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列「计算」得出一个值，才把这个值才写到缓存中。由此可见，这种「更新数据库 + 更新缓存」的方案，不仅缓存利用率不高，还会造成机器性能的浪费。</p><p>所以此时我们需要考虑另外一种方案：<strong>删除缓存</strong>。</p><h2 id="删除缓存可以保证一致性吗？"><a href="#删除缓存可以保证一致性吗？" class="headerlink" title="删除缓存可以保证一致性吗？"></a>删除缓存可以保证一致性吗？</h2><p>删除缓存对应的方案也有 2 种：</p><ol><li>先删除缓存，后更新数据库</li><li>先更新数据库，后删除缓存</li></ol><p>经过前面的分析我们已经得知，但凡「第二步」操作失败，都会导致数据不一致。重点来看「并发」问题。</p><p><strong>1) 先删除缓存，后更新数据库</strong></p><p>如果有 2 个线程要并发「读写」数据，可能会发生以下场景：</p><blockquote><ol><li>线程 A 要更新 X = 2（原值 X = 1）</li><li>线程 A 先删除缓存</li><li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</li><li>线程 A 将新值写入数据库（X = 2）</li><li>线程 B 将旧值写入缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。</p><p>可见，先删除缓存，后更新数据库，当发生「读+写」并发时，还是存在数据不一致的情况。</p><p><strong>2) 先更新数据库，后删除缓存</strong></p><p>依旧是 2 个线程并发「读写」数据：</p><blockquote><ol><li>缓存中 X 不存在（数据库 X = 1）</li><li>线程 A 读取数据库，得到旧值（X = 1）</li><li>线程 B 更新数据库（X = 2)</li><li>线程 B 删除缓存</li><li>线程 A 将旧值写入缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？概率「很低」，这是因为它必须满足 3 个条件：</p><ol><li>缓存刚好已失效</li><li>读请求 + 写请求并发</li><li>更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）</li></ol><p>仔细想一下，条件 3 发生的概率其实是非常低的。因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证一定程度的数据一致性。</p><p>所以应该采用这种方案，来操作数据库和缓存。解决了并发问题，我们继续来看前面遗留的，<strong>第二步执行「失败」导致数据不一致的问题</strong>。</p><h2 id="如何保证两步都执行成功？"><a href="#如何保证两步都执行成功？" class="headerlink" title="如何保证两步都执行成功？"></a>如何保证两步都执行成功？</h2><p>前面分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。</p><p><strong>保证第二步成功执行，就是解决问题的关键。</strong></p><p>想一下，程序在执行过程中发生异常，最简单的解决办法是什么？答案是：<strong>重试</strong>。</p><p>无论是先操作缓存，还是先操作数据库，但凡后者执行失败了就可以发起重试，尽可能地去做「补偿」。那这是不是意味着，只要执行失败，我们「无脑重试」就可以了呢？答案是否定的。现实情况往往没有想的这么简单，失败后立即重试的问题在于：</p><ul><li>立即重试很大概率「还会失败」</li><li>「重试次数」设置多少才合理？</li><li>重试会一直「占用」这个线程资源，无法服务其它客户端请求</li></ul><p>虽然想通过重试的方式解决问题，但这种「同步」重试的方案依旧不严谨。那更好的方案应该怎么做？答案是：<strong>异步重试</strong>。</p><p>把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。</p><p>到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。</p><p>所以，这里我们必须把重试或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：</p><ul><li><strong>消息队列保证可靠性</strong>：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）</li><li><strong>消息队列保证消息成功投递</strong>：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）</li></ul><p>至于写队列失败和消息队列的维护成本问题：</p><ul><li><strong>写队列失败</strong>：操作缓存和写消息队列，「同时失败」的概率其实是很小的</li><li><strong>维护成本</strong>：我们项目中一般都会用到消息队列，维护成本并没有新增很多</li></ul><p>所以，引入消息队列来解决这个问题，是比较合适的。这时架构模型就变成了这样：</p><p><img src="/posts/10748/640-1712738505781-12.webp" alt></p><p>如果不想在应用中去写消息队列，是否有更简单的方案，同时又可以保证一致性呢？方案还是有的，这就是近几年比较流行的解决方案：<strong>订阅数据库变更日志，再操作缓存</strong>。</p><p>具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。</p><p><img src="/posts/10748/640-1712738775748-15.webp" alt></p><p>订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：</p><ul><li><strong>无需考虑写消息队列失败情况</strong>：只要写 MySQL 成功，Binlog 肯定会有</li><li><strong>自动投递到下游队列</strong>：canal 自动把数据库变更日志「投递」给下游的消息队列</li></ul><p>当然，与此同时需要投入精力去维护 canal 的高可用和稳定性。</p><blockquote><p>如果你有留意观察很多数据库的特性，就会发现其实很多数据库都逐渐开始提供「订阅变更日志」的功能了，相信不远的将来，我们就不用通过中间件来拉取日志，自己写程序就可以订阅变更日志了，这样可以进一步简化流程。</p></blockquote><p>至此可以得出结论，想要保证数据库和缓存一致性，<strong>推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做</strong>。</p><h2 id="主从库延迟和延迟双删问题"><a href="#主从库延迟和延迟双删问题" class="headerlink" title="主从库延迟和延迟双删问题"></a>主从库延迟和延迟双删问题</h2><p>到这里，还有 2 个问题是没有重点分析过的。</p><p><strong>第一个问题</strong>，还记得前面讲到的「先删除缓存，再更新数据库」方案，导致不一致的场景么？</p><p>2 个线程要并发「读写」数据，可能会发生以下场景：</p><blockquote><ol><li>线程 A 要更新 X = 2（原值 X = 1）</li><li>线程 A 先删除缓存</li><li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</li><li>线程 A 将新值写入数据库（X = 2）</li><li>线程 B 将旧值写入缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。</p><p><strong>第二个问题</strong>：是关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题。</p><p>在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」其实也会导致不一致：</p><blockquote><ol><li>线程 A 更新主库 X = 2（原值 X = 1）</li><li>线程 A 删除缓存</li><li>线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）</li><li>从库「同步」完成（主从库 X = 2）</li><li>线程 B 将「旧值」写入缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。</p><p>这 2 个问题的核心在于：<strong>缓存都被回种了「旧值」</strong>。那怎么解决这类问题呢？最有效的办法就是，<strong>把缓存删掉</strong>。</p><p>但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：<strong>缓存延迟双删策略</strong>。按照延时双删策略，这 2 个问题的解决方案是这样的：</p><p><strong>解决第一个问题</strong>：在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。</p><p><strong>解决第二个问题</strong>：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。</p><p>这两个方案的目的，都是为了把缓存清掉，这样一来，下次就可以从数据库读取到最新值，写入缓存。但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？</p><ul><li>问题1：延迟时间要大于「主从复制」的延迟时间</li><li>问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间</li></ul><p><strong>这个时间在分布式和高并发场景下，其实是很难评估的</strong>。很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。采用这种方案，也只是尽可能保证一致性而已，极端情况下，还是有可能发生不一致。</p><p>所以实际使用中，建议采用「先更新数据库，再删除缓存」的方案，同时要尽可能地保证「主从复制」不要有太大延迟，降低出问题的概率。</p><h2 id="可以做到强一致吗？"><a href="#可以做到强一致吗？" class="headerlink" title="可以做到强一致吗？"></a>可以做到强一致吗？</h2><p>这些方案还是不够完美，我就想让缓存和数据库「强一致」，到底能不能做到呢？</p><p>其实很难。要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。相反，这时我们换个角度思考一下，我们引入缓存的目的是什么？没错，<strong>性能</strong>。一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。</p><p>而且，就拿我们前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到「中间状态」的数据。所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。虽然我们可以通过加「分布锁」的方式来实现，但我们要付出的代价，很可能会超过引入缓存带来的性能提升。</p><p>所以，既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。同时我们也要知道，缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、想要提高应用的性能，可以引入「缓存」来解决</p><p>2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」</p><p>3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生</p><p>4、在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案</p><p>5、在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性</p><p>6、在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率</p><p>换句话说，最佳实践则是：</p><ul><li>性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案</li><li>掌握缓存和数据库一致性问题，核心问题有 3 点：缓存利用率、并发、缓存 + 数据库一起成功问题</li><li>失败场景下要保证一致性，常见手段就是「重试」，同步重试会影响吞吐量，所以通常会采用异步重试的方案</li><li>订阅变更日志的思想，本质是把权威数据源（例如 MySQL）当做 leader 副本，让其它异质系统（例如 Redis / Elasticsearch）成为它的 follower 副本，通过同步变更日志的方式，保证 leader 和 follower 之间保持一致</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;到底是更新缓存还是删缓存？&lt;/li&gt;
&lt;li&gt;到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁安全之问</title>
    <link href="https://joytsing.github.io/posts/39535/"/>
    <id>https://joytsing.github.io/posts/39535/</id>
    <published>2024-04-09T14:39:06.000Z</published>
    <updated>2024-04-10T15:22:04.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先进行一个问题的抛出：</p><ul><li>基于 Redis 如何实现一个分布式锁？</li><li>Redis 分布式锁真的安全吗？</li><li>Redis 的 Redlock 有什么问题？一定安全吗？</li><li>业界争论 Redlock，到底在争论什么？哪种观点是对的？</li><li>分布式锁到底用 Redis 还是 Zookeeper？</li><li>实现一个有「容错性」的分布式锁，都需要考虑哪些问题？</li></ul><h2 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h2><p>在开始讲分布式锁之前，有必要简单介绍一下，为什么需要分布式锁？</p><p>与分布式锁相对应的是「单机锁」，我们在写多线程程序时，避免同时操作一个共享变量产生数据问题，通常会使用一把锁来「互斥」，以保证共享变量的正确性，其使用范围是在「同一个进程」中。如果换做是多个进程，需要同时操作一个共享资源，如何互斥呢？</p><p>例如，现在的业务应用通常都是微服务架构，这也意味着一个应用会部署多个进程，那这多个进程如果需要修改 MySQL 中的同一行记录时，为了避免操作乱序导致数据错误，此时，我们就需要引入「分布式锁」来解决这个问题了。</p><p><img src="/posts/39535/640.webp" alt></p><p>想要实现分布式锁，必须借助一个外部系统，所有进程都去这个系统上申请「加锁」。而这个外部系统，必须要实现「互斥」的能力，即两个请求同时进来，只会给一个进程返回成功，另一个返回失败（或等待）。</p><p>这个外部系统，可以是 MySQL，也可以是 Redis 或 Zookeeper。但为了追求更好的性能，通常会选择使用 Redis 或 Zookeeper 来做。下面就以 Redis 为主线，由浅入深，带你深度剖析一下，分布式锁的各种「安全性」问题。</p><h2 id="分布式锁怎么实现？"><a href="#分布式锁怎么实现？" class="headerlink" title="分布式锁怎么实现？"></a>分布式锁怎么实现？</h2><p>从最简单的开始讲起。</p><p>想要实现分布式锁，必须要求 Redis 有「互斥」的能力，我们可以使用 SETNX 命令，这个命令表示<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists，即如果 key 不存在，才会设置它的值，否则什么也不做。</p><p>两个客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁。</p><p>客户端 1 申请加锁，加锁成功：</p><pre><code>127.0.0.1:6379&gt; SETNX lock 1(integer) 1     // 客户端1，加锁成功</code></pre><p>客户端 2 申请加锁，因为它后到达，加锁失败：</p><pre><code>127.0.0.1:6379&gt; SETNX lock 1(integer) 0     // 客户端2，加锁失败</code></pre><p>此时，加锁成功的客户端，就可以去操作「共享资源」，例如，修改 MySQL 的某一行数据，或者调用一个 API 请求。操作完成后，还要及时释放锁，给后来者让出操作共享资源的机会。如何释放锁呢？</p><p>也很简单，直接使用 DEL 命令删除这个 key 即可：</p><pre><code>127.0.0.1:6379&gt; DEL lock // 释放锁(integer) 1</code></pre><p>这个逻辑非常简单，整体的路程就是这样：</p><p><img src="/posts/39535/640-1712760520184-3.webp" alt></p><p>但是，它存在一个很大的问题，当客户端 1 拿到锁后，如果发生下面的场景，就会造成「死锁」：</p><ol><li>程序处理业务逻辑异常，没及时释放锁</li><li>进程挂了，没机会释放锁</li></ol><p>这时，这个客户端就会一直占用这个锁，而其它客户端就「永远」拿不到这把锁了。怎么解决这个问题呢？</p><h2 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h2><p>很容易想到的方案是，在申请锁时，给这把锁设置一个「租期」。</p><p>在 Redis 中实现时，就是给这个 key 设置一个「过期时间」。这里我们假设，操作共享资源的时间不会超过 10s，那么在加锁时，给这个 key 设置 10s 过期即可：</p><pre><code>127.0.0.1:6379&gt; SETNX lock 1    // 加锁(integer) 1127.0.0.1:6379&gt; EXPIRE lock 10  // 10s后自动过期(integer) 1</code></pre><p>这样一来，无论客户端是否异常，这个锁都可以在 10s 后被「自动释放」，其它客户端依旧可以拿到锁。但这样真的没问题吗？还是有问题。</p><p>现在的操作，加锁、设置过期是 2 条命令，有没有可能只执行了第一条，第二条却「来不及」执行的情况发生呢？例如：</p><blockquote><ol><li>SETNX 执行成功，执行 EXPIRE 时由于网络问题，执行失败</li><li>SETNX 执行成功，Redis 异常宕机，EXPIRE 没有机会执行</li><li>SETNX 执行成功，客户端异常崩溃，EXPIRE 也没有机会执行</li></ol></blockquote><p>总之，这两条命令不能保证是原子操作（一起成功），就有潜在的风险导致过期时间设置失败，依旧发生「死锁」问题。怎么办？</p><p>在 Redis 2.6.12 版本之前，我们需要想尽办法，保证 SETNX 和 EXPIRE 原子性执行，还要考虑各种异常情况如何处理。但在 Redis 2.6.12 之后，Redis 扩展了 SET 命令的参数，用这一条命令就可以了：</p><pre><code>// 一条命令保证原子性执行127.0.0.1:6379&gt; SET lock 1 EX 10 NXOK</code></pre><p>这样就解决了死锁问题，也比较简单。试想这样一种场景：</p><blockquote><ol><li>客户端 1 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源的时间，「超过」了锁的过期时间，锁被「自动释放」</li><li>客户端 2 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源完成，释放锁（但释放的是客户端 2 的锁）</li></ol></blockquote><p>看到了么，这里存在两个严重的问题：</p><ol><li><strong>锁过期</strong>：客户端 1 操作共享资源耗时太久，导致锁被自动释放，之后被客户端 2 持有</li><li><strong>释放别人的锁</strong>：客户端 1 操作共享资源完成后，却又释放了客户端 2 的锁</li></ol><p>导致这两个问题的原因是什么？</p><p><strong>第一个问题，可能是评估操作共享资源的时间不准确导致的。</strong></p><p>例如，操作共享资源的时间「最慢」可能需要 15s，而我们却只设置了 10s 过期，那这就存在锁提前过期的风险。过期时间太短，那增大冗余时间，例如设置过期时间为 20s，这样总可以了吧？这样确实可以「缓解」这个问题，降低出问题的概率，但依旧无法「彻底解决」问题。</p><p>为什么？</p><p>原因在于，客户端在拿到锁之后，在操作共享资源时，遇到的场景有可能是很复杂的，例如，程序内部发生异常、网络请求超时等等。既然是「预估」时间，也只能是大致计算，除非你能预料并覆盖到所有导致耗时变长的场景，但这其实很难。有什么更好的解决方案吗？</p><p><strong>第二个问题在于，一个客户端释放了其它客户端持有的锁。</strong></p><p>想一下，导致这个问题的关键点在哪？重点在于，每个客户端在释放锁时，都是「无脑」操作，并没有检查这把锁是否还「归自己持有」，所以就会发生释放别人锁的风险，这样的解锁流程，很不「严谨」！如何解决这个问题呢？</p><h2 id="锁被别人释放怎么办"><a href="#锁被别人释放怎么办" class="headerlink" title="锁被别人释放怎么办?"></a>锁被别人释放怎么办?</h2><p>解决办法是：客户端在加锁时，设置一个只有自己知道的「唯一标识」进去。例如，可以是自己的线程 ID，也可以是一个 UUID（随机且唯一），这里我们以 UUID 举例：</p><pre><code>// 锁的VALUE设置为UUID127.0.0.1:6379&gt; SET lock $uuid EX 20 NXOK</code></pre><blockquote><p>这里假设 20s 操作共享时间完全足够，先不考虑锁自动过期的问题。</p></blockquote><p>之后，在释放锁时，要先判断这把锁是否还归自己持有，伪代码可以这么写：</p><pre><code>// 锁是自己的，才释放if redis.get(&quot;lock&quot;) == $uuid:    redis.del(&quot;lock&quot;)</code></pre><p>这里释放锁使用的是 GET + DEL 两条命令，这时，又会遇到我们前面讲的原子性问题了。</p><blockquote><ol><li>客户端 1 执行 GET，判断锁是自己的</li><li>客户端 2 执行了 SET 命令，强制获取到锁（虽然发生概率比较低，但我们需要严谨地考虑锁的安全性模型）</li><li>客户端 1 执行 DEL，却释放了客户端 2 的锁</li></ol></blockquote><p>由此可见，这两个命令还是必须要原子执行才行。怎样原子执行呢？Lua 脚本。可以把这个逻辑，写成 Lua 脚本，让 Redis 来执行。</p><p>因为 Redis 处理每一个请求是「单线程」执行的，在执行一个 Lua 脚本时，其它请求必须等待，直到这个 Lua 脚本处理完成，这样一来，GET + DEL 之间就不会插入其它命令了。</p><p><img src="/posts/39535/640-1712760824267-6.webp" alt></p><p>安全释放锁的 Lua 脚本如下：</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token operator">//</span> 判断锁是自己的，才释放<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">then</span>    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"DEL"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，这样一路优化，整个的加锁、解锁的流程就更「严谨」了。基于 Redis 实现的分布式锁，一个严谨的的流程如下：</p><blockquote><ol><li>加锁：SET lock_key $unique_id EX $expire_time NX</li><li>操作共享资源</li><li>释放锁：Lua 脚本，先 GET 判断锁是否归属自己，再 DEL 释放锁</li></ol></blockquote><p><img src="/posts/39535/640-1712760824267-7.webp" alt></p><p>好，有了这个完整的锁模型，让我们重新回到前面提到的第一个问题。锁过期时间不好评估怎么办？</p><h2 id="锁过期时间不好评估怎么办？"><a href="#锁过期时间不好评估怎么办？" class="headerlink" title="锁过期时间不好评估怎么办？"></a>锁过期时间不好评估怎么办？</h2><p>前面我们提到，锁的过期时间如果评估不好，这个锁就会有「提前」过期的风险。当时给的妥协方案是，尽量「冗余」过期时间，降低锁提前过期的概率。</p><p>这个方案其实也不能完美解决问题，那怎么办呢？</p><p>是否可以设计这样的方案：<strong>加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。</strong></p><p><img src="/posts/39535/640-1712761088227-12.webp" alt></p><p>基于 Redis 的实现分布式锁，前面遇到的问题，以及对应的解决方案：</p><ul><li><strong>死锁</strong>：设置过期时间</li><li><strong>过期时间评估不好，锁提前过期</strong>：守护线程，自动续期</li><li><strong>锁被别人释放</strong>：锁写入唯一标识，释放锁先检查标识，再释放</li></ul><p>还有哪些问题场景，会危害 Redis 锁的安全性呢？</p><p>之前分析的场景都是，锁在「单个」Redis 实例中可能产生的问题，并没有涉及到 Redis 的部署架构细节。而在使用 Redis 时，一般会采用<strong>主从集群 + 哨兵</strong>的模式部署，这样做的好处在于，当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。</p><p><strong>那当「主从发生切换」时，这个分布锁会依旧安全吗？</strong></p><p>试想这样的场景：</p><ol><li>客户端 1 在主库上执行 SET 命令，加锁成功</li><li>此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）</li><li>从库被哨兵提升为新主库，这个锁在新的主库上，丢失了！</li></ol><p><img src="/posts/39535/640-1712761172250-15.webp" alt></p><p>可见，当引入 Redis 副本后，分布锁还是可能会受到影响。怎么解决这个问题？</p><p>为此，Redis 的作者提出一种解决方案，就是我们经常听到的 <strong>Redlock（红锁）</strong>。</p><h2 id="Redlock-真的安全吗？"><a href="#Redlock-真的安全吗？" class="headerlink" title="Redlock 真的安全吗？"></a>Redlock 真的安全吗？</h2><p>Redlock 的方案基于 2 个前提：</p><ol><li>不再需要部署<strong>从库</strong>和<strong>哨兵</strong>实例，只部署<strong>主库</strong></li><li>但主库要部署多个，官方推荐至少 5 个实例</li></ol><p>也就是说，想用使用 Redlock，你至少要部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p><blockquote><p><strong>注意：不是部署 Redis Cluster，就是部署 5 个简单的 Redis 实例。</strong></p></blockquote><p><img src="/posts/39535/640-1712761502480-18.webp" alt></p><p>Redlock 具体如何使用呢？整体的流程是这样的，一共分为 5 步：</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 &gt;=3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p>其中有 4 个重点：</p><blockquote><ol><li>客户端在多个 Redis 实例上申请加锁</li><li>必须保证大多数节点加锁成功</li><li>大多数节点加锁的总耗时，要小于锁设置的过期时间</li><li>释放锁，要向全部节点发起释放锁请求</li></ol></blockquote><p>明白了 Redlock 的流程，我们来看 Redlock 为什么要这么做。</p><p><strong>1) 为什么要在多个实例上加锁？</strong></p><p>本质上是为了「容错」，部分实例异常宕机，剩余的实例加锁成功，整个锁服务依旧可用。</p><p><strong>2) 为什么大多数加锁成功，才算成功？</strong></p><p>多个 Redis 实例一起来用，其实就组成了一个「分布式系统」。</p><p>在分布式系统中，总会出现「异常节点」，所以，在谈论分布式系统问题时，需要考虑异常节点达到多少个，也依旧不会影响整个系统的「正确性」。</p><p>这是一个分布式系统「容错」问题，这个问题的结论是：<strong>如果只存在「故障」节点，只要大多数节点正常，那么整个系统依旧是可以提供正确服务的。</strong></p><blockquote><p>这个问题的模型，就是我们经常听到的「拜占庭将军」问题，感兴趣可以去看算法的推演过程。</p></blockquote><p><strong>3) 为什么步骤 3 加锁成功后，还要计算加锁的累计耗时？</strong></p><p>因为操作的是多个节点，所以耗时肯定会比操作单个实例耗时更久，而且，因为是网络请求，网络情况是复杂的，有可能存在<strong>延迟、丢包、超时</strong>等情况发生，网络请求越多，异常发生的概率就越大。</p><p>所以，即使大多数节点加锁成功，但如果加锁的累计耗时已经「超过」了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁就没有意义了。</p><p><strong>4) 为什么释放锁，要操作所有节点？</strong></p><p>在某一个 Redis 节点加锁时，可能因为「网络原因」导致加锁失败。</p><p>例如，客户端在一个 Redis 实例上加锁成功，但在读取响应结果时，网络问题导致<strong>读取失败</strong>，那这把锁其实已经在 Redis 上加锁成功了。</p><p>所以，释放锁时，不管之前有没有加锁成功，需要释放「所有节点」的锁，以保证清理节点上「残留」的锁。</p><p>好了，明白了 Redlock 的流程和相关问题，看似 Redlock 确实解决了 Redis 节点异常宕机锁失效的问题，保证了锁的「安全性」。</p><p>但事实真的如此吗？</p><h2 id="分布式专家-Martin-对于-Relock-的质疑"><a href="#分布式专家-Martin-对于-Relock-的质疑" class="headerlink" title="分布式专家 Martin 对于 Relock 的质疑"></a>分布式专家 Martin 对于 Relock 的质疑</h2><p>在他的文章中，主要阐述了 4 个论点：</p><p><strong>1) 分布式锁的目的是什么？</strong></p><p>Martin 表示，你必须先清楚你在使用分布式锁的目的是什么？他认为有两个目的。</p><p><strong>第一，效率。</strong></p><p>使用分布式锁的互斥能力，是避免不必要地做同样的两次工作（例如一些昂贵的计算任务）。如果锁失效，并不会带来「恶性」的后果，例如发了 2 次邮件等，无伤大雅。</p><p><strong>第二，正确性。</strong></p><p>使用锁用来防止并发进程互相干扰。如果锁失效，会造成多个进程同时操作同一条数据，产生的后果是<strong>数据严重错误、永久性不一致、数据丢失</strong>等恶性问题，就像给患者服用了重复剂量的药物，后果很严重。</p><p>他认为，如果你是为了前者——效率，那么使用单机版 Redis 就可以了，即使偶尔发生锁失效（宕机、主从切换），都不会产生严重的后果。而使用 Redlock 太重了，没必要。</p><p><strong>而如果是为了正确性，Martin 认为 Redlock 根本达不到安全性的要求，也依旧存在锁失效的问题！</strong></p><p><strong>2) 锁在分布式系统中会遇到的问题</strong></p><p>Martin 表示，一个分布式系统，更像一个复杂的「野兽」，存在着你想不到的各种异常情况。</p><p>这些异常场景主要包括三大块，这也是分布式系统会遇到的三座大山：<strong>NPC</strong>。</p><ul><li>N：Network Delay，网络延迟</li><li>P：Process Pause，进程暂停（GC）</li><li>C：Clock Drift，时钟漂移</li></ul><p>Martin 用一个进程暂停（GC）的例子，指出了 Redlock 安全性问题：</p><blockquote><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC（时间比较久）</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取到了 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到了锁，发生「冲突」</li></ol></blockquote><p><img src="/posts/39535/640-1712761809896-21.webp" alt="图片"></p><p>Martin 认为，GC 可能发生在程序的任意时刻，而且执行时间是不可控的。</p><blockquote><p>注：当然，即使是使用没有 GC 的编程语言，在发生网络延迟、时钟漂移时，也都有可能导致 Redlock 出现问题，这里 Martin 只是拿 GC 举例。</p></blockquote><p><strong>3) 假设时钟正确的是不合理的</strong></p><p>又或者，当多个 Redis 节点「时钟」发生问题时，也会导致 Redlock <strong>锁失效</strong>。</p><blockquote><ol><li>客户端 1 获取节点 A、B、C 上的锁，但由于网络问题，无法访问 D 和 E</li><li>节点 C 上的时钟「向前跳跃」，导致锁到期</li><li>客户端 2 获取节点 C、D、E 上的锁，由于网络问题，无法访问 A 和 B</li><li>客户端 1 和 2 现在都相信它们持有了锁（冲突）</li></ol></blockquote><p>Martin 觉得，Redlock 必须「强依赖」多个节点的时钟是保持同步的，一旦有节点时钟发生错误，那这个算法模型就失效了。</p><blockquote><p>即使 C 不是时钟跳跃，而是「崩溃后立即重启」，也会发生类似的问题。</p></blockquote><p>Martin 继续阐述，机器的时钟发生错误，是很有可能发生的：</p><ul><li>系统管理员「手动修改」了机器时钟</li><li>机器时钟在同步 NTP 时间时，发生了大的「跳跃」</li></ul><p>总之，Martin 认为，Redlock 的算法是建立在「同步模型」基础上的，有大量资料研究表明，同步模型的假设，在分布式系统中是有问题的。</p><p>在混乱的分布式系统的中，你不能假设系统时钟就是对的，所以，你必须非常小心你的假设。</p><p><strong>4) 提出 fecing token 的方案，保证正确性</strong></p><p>相对应的，Martin 提出一种被叫作 fecing token 的方案，保证分布式锁的正确性。</p><p>这个模型流程如下：</p><blockquote><ol><li>客户端在获取锁时，锁服务可以提供一个「递增」的 token</li><li>客户端拿着这个 token 去操作共享资源</li><li>共享资源可以根据 token 拒绝「后来者」的请求</li></ol></blockquote><p><img src="/posts/39535/640-1712761809897-22.webp" alt="图片"></p><p>这样一来，无论 NPC 哪种异常情况发生，都可以保证分布式锁的安全性，因为它是建立在「异步模型」上的。</p><p>而 Redlock 无法提供类似 fecing token 的方案，所以它无法保证安全性。</p><p>他还表示，<strong>一个好的分布式锁，无论 NPC 怎么发生，可以不在规定时间内给出结果，但并不会给出一个错误的结果。也就是只会影响到锁的「性能」（或称之为活性），而不会影响它的「正确性」。</strong></p><p>Martin 的结论：</p><p><strong>1、Redlock 不伦不类</strong>：它对于效率来讲，Redlock 比较重，没必要这么做，而对于正确性来说，Redlock 是不够安全的。</p><p><strong>2、时钟假设不合理</strong>：该算法对系统时钟做出了危险的假设（假设多个节点机器时钟都是一致的），如果不满足这些假设，锁就会失效。</p><p><strong>3、无法保证正确性</strong>：Redlock 不能提供类似 fencing token 的方案，所以解决不了正确性的问题。为了正确性，请使用有「共识系统」的软件，例如 Zookeeper。</p><p>好了，以上就是 Martin 反对使用 Redlock 的观点，看起来有理有据。</p><p>下面我们来看 Redis 作者 Antirez 是如何反驳的。</p><h2 id="Redis-作者-Antirez-的反驳"><a href="#Redis-作者-Antirez-的反驳" class="headerlink" title="Redis 作者 Antirez 的反驳"></a>Redis 作者 Antirez 的反驳</h2><p>在 Redis 作者的文章中，重点有 3 个：</p><p><strong>1) 解释时钟问题</strong></p><p>首先，Redis 作者一眼就看穿了对方提出的最为核心的问题：<strong>时钟问题</strong>。</p><p>Redis 作者表示，Redlock 并不需要完全一致的时钟，只需要大体一致就可以了，允许有「误差」。</p><p>例如要计时 5s，但实际可能记了 4.5s，之后又记了 5.5s，有一定误差，但只要不超过「误差范围」锁失效时间即可，这种对于时钟的精度要求并不是很高，而且这也符合现实环境。</p><p>对于对方提到的「时钟修改」问题，Redis 作者反驳到：</p><ol><li><strong>手动修改时钟</strong>：不要这么做就好了，否则你直接修改 Raft 日志，那 Raft 也会无法工作…</li><li><strong>时钟跳跃</strong>：通过「恰当的运维」，保证机器时钟不会大幅度跳跃（每次通过微小的调整来完成），实际上这是可以做到的</li></ol><blockquote><p>为什么 Redis 作者优先解释时钟问题？因为在后面的反驳过程中，需要依赖这个基础做进一步解释。</p></blockquote><p><strong>2) 解释网络延迟、GC 问题</strong></p><p>之后，Redis 作者对于对方提出的，网络延迟、进程 GC 可能导致 Redlock 失效的问题，也做了反驳：</p><p>我们重新回顾一下，Martin 提出的问题假设：</p><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取节点 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到锁，发生「冲突」</li></ol><p><img src="/posts/39535/640-1712761809896-21.webp" alt="图片"></p><p>Redis 作者反驳到，这个假设其实是有问题的，Redlock 是可以保证锁安全的。这是怎么回事呢？</p><p>还记得前面介绍 Redlock 流程的那 5 步吗？</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p><strong>注意，重点是 1-3，在步骤 3，加锁成功后为什么要重新获取「当前时间戳T2」？还用 T2 - T1 的时间，与锁的过期时间做比较？</strong></p><p>Redis 作者强调：如果在 1-3 发生了网络延迟、进程 GC 等耗时长的异常情况，那在第 3 步 T2 - T1，是可以检测出来的，如果超出了锁设置的过期时间，那这时就认为加锁会失败，之后释放所有节点的锁就好了！</p><p>Redis 作者继续论述，如果对方认为，发生网络延迟、进程 GC 是在步骤 3 之后，也就是客户端确认拿到了锁，去操作共享资源的途中发生了问题，导致锁失效，那这<strong>不止是 Redlock 的问题，任何其它锁服务例如 Zookeeper，都有类似的问题，这不在讨论范畴内。</strong></p><p>举个例子解释一下这个问题：</p><ol><li>客户端通过 Redlock 成功获取到锁（通过了大多数节点加锁成功、加锁耗时检查逻辑）</li><li>客户端开始操作共享资源，此时发生网络延迟、进程 GC 等耗时很长的情况</li><li>此时，锁过期自动释放</li><li>客户端开始操作 MySQL（此时的锁可能会被别人拿到，锁失效）</li></ol><p>Redis 作者这里的结论就是：</p><ul><li>客户端在拿到锁之前，无论经历什么耗时长问题，Redlock 都能够在第 3 步检测出来</li><li>客户端在拿到锁之后，发生 NPC，那 Redlock、Zookeeper 都无能为力</li></ul><p>所以，Redis 作者认为 Redlock 在保证时钟正确的基础上，是可以保证正确性的。</p><p><strong>3) 质疑 fencing token 机制</strong></p><p>Redis 作者对于对方提出的 fecing token 机制，也提出了质疑，主要分为 2 个问题:</p><p><strong>第一</strong>，这个方案必须要求要操作的「共享资源服务器」有拒绝「旧 token」的能力。</p><p>例如，要操作 MySQL，从锁服务拿到一个递增数字的 token，然后客户端要带着这个 token 去改 MySQL 的某一行，这就需要利用 MySQL 的「事物隔离性」来做。</p><pre><code>// 两个客户端必须利用事物和隔离性达到目的// 注意 token 的判断条件UPDATE table T SET val = $new_val WHERE id = $id AND current_token &lt; $token</code></pre><p>但如果操作的不是 MySQL 呢？例如向磁盘上写一个文件，或发起一个 HTTP 请求，那这个方案就无能为力了，这对要操作的资源服务器，提出了更高的要求。</p><p>也就是说，大部分要操作的资源服务器，都是没有这种互斥能力的。</p><p><strong>再者，既然资源服务器都有了「互斥」能力，那还要分布式锁干什么？</strong></p><p>所以，Redis 作者认为这个方案是站不住脚的。</p><p><strong>第二</strong>，退一步讲，即使 Redlock 没有提供 fecing token 的能力，但 Redlock 已经提供了随机值（就是前面讲的 UUID），利用这个随机值，也可以达到与 fecing token 同样的效果。</p><p>如何做呢？</p><blockquote><p>Redis 作者只是提到了可以完成 fecing token 类似的功能，但却没有展开相关细节，大概流程应该如下</p></blockquote><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端在操作共享资源之前，先把这个锁的 VALUE，在要操作的共享资源上做标记</li><li>客户端处理业务逻辑，最后，在修改共享资源时，判断这个标记是否与之前一样，一样才修改（类似 CAS 的思路）</li></ol><p>还是以 MySQL 为例，举个例子就是这样的：</p><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端要修改 MySQL 表中的某一行数据之前，先把锁的 VALUE 更新到这一行的某个字段中（这里假设为 current_token 字段)</li><li>客户端处理业务逻辑</li><li>客户端修改 MySQL 的这一行数据，把 VALUE 当做 WHERE 条件，再修改</li></ol><pre><code>UPDATE table T SET val = $new_val WHERE id = $id AND current_token = $redlock_value</code></pre><p>可见，这种方案依赖 MySQL 的事物机制，也达到对方提到的 fecing token 一样的效果。</p><p>但这里还有个小问题，是网友参与问题讨论时提出的：<strong>两个客户端通过这种方案，先「标记」再「检查+修改」共享资源，那这两个客户端的操作顺序无法保证啊？</strong></p><p>而用 Martin 提到的 fecing token，因为这个 token 是单调递增的数字，资源服务器可以拒绝小的 token 请求，保证了操作的「顺序性」！</p><p>Redis 作者对这问题做了不同的解释，他解释道：<strong>分布式锁的本质，是为了「互斥」，只要能保证两个客户端在并发时，一个成功，一个失败就好了，不需要关心「顺序性」。</strong></p><blockquote><p>前面 Martin 的质疑中，一直很关心这个顺序性问题，但 Redis 的作者的看法却不同。</p></blockquote><p>综上，Redis 作者的结论：</p><p><strong>1、作者同意对方关于「时钟跳跃」对 Redlock 的影响，但认为时钟跳跃是可以避免的，取决于基础设施和运维。</strong></p><p><strong>2、Redlock 在设计时，充分考虑了 NPC 问题，在 Redlock 步骤 3 之前出现 NPC，可以保证锁的正确性，但在步骤 3 之后发生 NPC，不止是 Redlock 有问题，其它分布式锁服务同样也有问题，所以不在讨论范畴内。</strong></p><h2 id="基于-Zookeeper-的锁安全吗？"><a href="#基于-Zookeeper-的锁安全吗？" class="headerlink" title="基于 Zookeeper 的锁安全吗？"></a>基于 Zookeeper 的锁安全吗？</h2><p>没用过，但是查询后知道，基于它实现的分布式锁是这样的：</p><ol><li>客户端 1 和 2 都尝试创建「临时节点」，例如 /lock</li><li>假设客户端 1 先到达，则加锁成功，客户端 2 加锁失败</li><li>客户端 1 操作共享资源</li><li>客户端 1 删除 /lock 节点，释放锁</li></ol><p>Zookeeper 不像 Redis 那样，需要考虑锁的过期时间问题，它是采用了「临时节点」，保证客户端 1 拿到锁后，只要连接不断，就可以一直持有锁。而且，如果客户端 1 异常崩溃了，那么这个临时节点会自动删除，保证了锁一定会被释放。</p><p><strong>不错，没有锁过期的烦恼，还能在异常时自动释放锁，是不是觉得很完美？</strong>其实不然。思考一下，客户端 1 创建临时节点后，Zookeeper 是如何保证让这个客户端一直持有锁呢？</p><p>原因就在于，<strong>客户端 1 此时会与 Zookeeper 服务器维护一个 Session，这个 Session 会依赖客户端「定时心跳」来维持连接。</strong>如果 Zookeeper 长时间收不到客户端的心跳，就认为这个 Session 过期了，也会把这个临时节点删除。</p><p><img src="/posts/39535/640-1712762020030-27.webp" alt="图片"></p><p>同样地，基于此问题，我们也讨论一下 GC 问题对 Zookeeper 的锁有何影响：</p><blockquote><ol><li>客户端 1 创建临时节点 /lock 成功，拿到了锁</li><li>客户端 1 发生长时间 GC</li><li>客户端 1 无法给 Zookeeper 发送心跳，Zookeeper 把临时节点「删除」</li><li>客户端 2 创建临时节点 /lock 成功，拿到了锁</li><li>客户端 1 GC 结束，它仍然认为自己持有锁（冲突）</li></ol></blockquote><p>可见，即使是使用 Zookeeper，也无法保证进程 GC、网络延迟异常场景下的安全性。</p><p><strong>这就是前面 Redis 作者在反驳的文章中提到的：如果客户端已经拿到了锁，但客户端与锁服务器发生「失联」（例如 GC），那不止 Redlock 有问题，其它锁服务都有类似的问题，Zookeeper 也是一样！</strong></p><p>所以，这里我们就能得出结论了：<strong>一个分布式锁，在极端情况下，不一定是安全的。</strong>如果业务数据非常敏感，在使用分布式锁时，一定要注意这个问题，不能假设分布式锁 100% 安全。</p><p>Zookeeper 的优点：</p><ol><li>不需要考虑锁的过期时间</li><li>watch 机制，加锁失败，可以 watch 等待锁释放，实现乐观锁</li></ol><p>但它的劣势是：</p><ol><li>性能不如 Redis</li><li>部署和运维成本高</li><li>客户端与 Zookeeper 的长时间失联，锁被释放问题</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>1) 到底要不要用 Redlock？</strong></p><p>前面也分析了，Redlock 只有建立在「时钟正确」的前提下，才能正常工作，如果你可以保证这个前提，那么可以拿来使用。但保证时钟正确并不是想的那么简单就能做到的。</p><p>在不使用Redlock的时候可以考虑使用主从+ 哨兵的模式 实现分布式锁。</p><p><strong>2) 如何正确使用分布式锁？</strong></p><p>在分析 Martin 观点时，它提到了 fecing token 的方案，虽然这种方案有很大的局限性，但对于保证「正确性」的场景，是一个非常好的思路。所以，我们可以把这两者结合起来用：</p><p><strong>1、使用分布式锁，在上层完成「互斥」目的，虽然极端情况下锁会失效，但它可以最大程度把并发请求阻挡在最上层，减轻操作资源层的压力。</strong></p><p><strong>2、但对于要求数据绝对正确的业务，在资源层一定要做好「兜底」，设计思路可以借鉴 fecing token 的方案来做。</strong></p><p>两种思路结合对于大多数业务场景，已经可以满足要求了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先进行一个问题的抛出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 Redis 如何实现一个分布式锁？&lt;/li&gt;
&lt;li&gt;Redis 分布式锁真的安全
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(七)</title>
    <link href="https://joytsing.github.io/posts/48821/"/>
    <id>https://joytsing.github.io/posts/48821/</id>
    <published>2024-04-09T09:04:07.000Z</published>
    <updated>2024-04-10T08:58:09.896Z</updated>
    
    <content type="html"><![CDATA[<p>在应用程序里，我们使用多少内存都是自己能掌握和控制的，但是纵观Linux整台服务器，除了应用程序以外，内核也会申请和管理大量的内存。</p><h3 id="一、相关实际问题"><a href="#一、相关实际问题" class="headerlink" title="一、相关实际问题"></a>一、相关实际问题</h3><ol><li>内核是如何管理内存的</li><li>如何查看内核使用的内存信息</li><li>服务器上一条ESTABLISH状态的空连接需要消耗多少内存</li><li>机器上出现了3万多个TIME_WAIT，内存开销会不会很大</li></ol><h3 id="二、Linux内核如何管理内存"><a href="#二、Linux内核如何管理内存" class="headerlink" title="二、Linux内核如何管理内存"></a>二、Linux内核如何管理内存</h3><p>内核针对自己的应用场景，使用了一种叫做SLAB/SLUB的内存管理机制。这种管理机制通过四个步骤把物理内存条管理起来，供内核申请和分配内核对象。</p><h4 id="1）node划分"><a href="#1）node划分" class="headerlink" title="1）node划分"></a>1）node划分</h4><p>早期的计算机中，内存控制器还没有整合到CPU，所有的内存访问都需要经过北桥芯片组来完成，即内存控制器集成在北桥中。<strong>CPU访存需要通过前端总线连接到北桥芯片，然后北桥芯片连接到内存，这样的架构被称为UMA（一致性内存访问）</strong>。总线模型保证了所有的内存访问都是一致的（即每个处理器共享相同的内存地址空间）。<strong>在UMA架构下，CPU和内存之间的通信全部都要通过前端总线，而提高性能的方式就是不断提高CPU、前端总线和内存的工作频率。</strong></p><p>而随着物理条件的限制，CPU朝着高频率的方向发展遇到了天花板，性能的提升开始供提高主频转向增加CPU数量（多核、多CPU）。<strong>而越来越多的 CPU 对前端总线的争用，使前端总线成为了瓶颈。为了消除 UMA 架构的瓶颈，NUMA（非一致性内存访问）架构诞生了。</strong>在NUMA架构下，<strong>每个CPU会有自己的独立的内存控制器，并且独立连接到一部分内存（直连的这部分内存称为本地内存），组成一个node，不同node之间通过QPI（Quick Path Interconnect）进行通信访问远程内存。</strong>如下图所示：</p><p><img src="/posts/48821/d4611b458796469c8caacfa92107d0b1.png" alt></p><p>在 NUMA 架构下，内存的访问出现了本地和远程的区别：访问远程内存的延时会明显高于访问本地内存。</p><blockquote><p>系统 boot 的时候，硬件会把 NUMA 信息发送给 os，如果系统支持 NUMA ，会发生以下几件事：</p><ul><li>获取 NUMA 配置信息</li><li>将 processors（不是 cores） 分成很多 nodes，一般是一个 processor 一个 node。</li><li>将 processor 附近的 memory 分配给它。</li><li>计算node 间通信的cost（距离）。</li></ul></blockquote><p>Linux 识别到 NUMA 架构后，每个进程、线程都会继承一个 numa policy，定义了可以使用那些CPU（甚至是那些 core），哪些内存可以使用，以及 policy 的强制程度，即是优先还是强制性只允许。<strong>每个 thread 被分配到了一个”优先” 的 node 上面运行</strong>，thread 可以在其他地方运行（如果 policy 允许的话），但是 os 会尝试让他在优先地 node 上面去运行。默认的内存分配方案是：<strong>优先从本地分配内存。如果本地内存不足，优先淘汰本地内存中无用的内存。使内存页尽可能地和调用线程处在同一个 node。</strong></p><blockquote><p>只是优先从本地分配内存，进程同样可以访问到其他内存条。因为在计算机系统中，物理内存地址是由内存管理单元（Memory Management Unit，MMU）管理的，它会把CPU发出的地址请求转换为实际的物理内存地址。即使系统中有多个内存条（也就是说，有多个物理内存块），MMU也会把它们看作是一个连续的地址空间进行管理。</p><p>当系统启动时，BIOS或者UEFI会检测所有的硬件设备，包括内存条。每个内存条的大小和位置信息会被记录在一个叫做内存映射（Memory Map）的数据结构中。这个内存映射会被传递给操作系统。</p><p>在操作系统启动时，它会读取这个内存映射，然后建立起自己的物理内存管理数据结构，如页帧数组。操作系统会把每个物理内存页的地址和状态（比如是否被使用，被哪个进程使用）记录在struct page的一个实例中。页帧数组中的每个元素对应物理内存中的一个页，页帧数组的索引直接映射到物理内存地址。</p><p>在多个内存条的情况下，页帧数组会涵盖所有的内存条。即使内存条在物理上是分离的，但在页帧数组中它们看起来是连续的。当一个物理页面被分配给一个进程时，操作系统会在页表中创建一个页表项，将虚拟地址映射到这个物理页面的地址。</p></blockquote><p>这种默认的分配策略一般情况下可能没有问题，但是对于一些需要分配大量内存的应用上可能会出现性能问题。如使用MySQL时，假如每个node有32G的内存，而MySQL配置了48G 的 innodb buffer pool，那么可能会出现尽管系统还有很多空余的内容，但是很多内存都被 swap 出去了。这就是因为默认的内存分配方案是优先从本地分配，所以当node0内存快被占满时，尽管node1还有很多内存，但是node0里面的内存还是会被swap出去。</p><blockquote><p>以上是硬件层面上的NUMA（hardware view），而作为软件层面的Linux，则对NUMA的概念进行了抽象。即便硬件上是一整块连续内存的UMA，Linux也可将其划分为若干的node（所有node其实是个软件上的概念）。同样，即便硬件上是物理内存不连续的NUMA，Linux也可将其视作UMA（software view）。</p><p>所以，在<a href="https://so.csdn.net/so/search?q=Linux系统&spm=1001.2101.3001.7020">Linux系统</a>中，你可以基于一个UMA的平台测试NUMA上的应用特性。从另一个角度，UMA就是只有一个node的特殊NUMA，所以两者可以统一用NUMA模型表示。</p></blockquote><h4 id="2）zone划分"><a href="#2）zone划分" class="headerlink" title="2）zone划分"></a>2）zone划分</h4><p>NUMA模型中，<strong>物理内存</strong>被划分为几个节点（node），一个node对应一个内存簇bank，即每个内存簇认为是一个节点。</p><p>首先，内存被划分为结点，每个节点关联到系统中的一个处理器。接着各个节点又被划分为内存管理区域，一个管理区域通过struct zone_struct描述，其被定义为zone_t，用以表示内存的某个范围。主要分为以下几种类型的内存管理区域：</p><ol><li>ZONE_DMA：地址段最低的一块内存区域（物理内存起始的16M），供IO设备DMA访问。<ul><li>一些使用 DMA 的外设并没有像 CPU 那样的 32 位地址总线，比如只有 16 位总线，就只能访问 64 KB 的空间，24 位总线就只能访问 16 MB 的空间，如果给 DMA 分配的内存地址超出了这个范围，设备就没法（寻址）访问了。也应该成为ZONE_DMA24</li></ul></li><li>ZONE_DMA32：到了 64 位系统，外设的寻址能力增强，因此又加入了一个 ZONE_DMA32，空间大小为 16MB 到 4GB</li><li>ZONE_NORMAL：可<strong>直接映射</strong>到内核的普通内存域（16M-896M），在X86-64架构下，DMA和DMA32之外的内存全部在NORMAL的zone里管理</li><li>ZONE_HIGHMEM：高端内存，内核不能直接使用（896M-4G），<strong>动态映射</strong>到内核空间3G+896M-4G的位置。即要访问的物理地址空间大于虚拟地址空间，不能直接建立映射的场景。适用于32位CPU系统，64位的CPU系统虚拟地址空间足够大，直接映射即可，所以都是NORMAL。</li></ol><p><img src="/posts/48821/969d18e411f3417abe1318c9b2349f45.png" alt></p><p>每个zone下都包含了许许多多个Page（页面），在Linux下一个页面的大小一般是4KB（处理器架构决定的，操作系统编译的时候固定下来）。</p><p>可以使用zoneinfo命令查看机器上zone的划分，也可以看到每个zone下所管理的页面有多少。</p><h4 id="3）基于伙伴系统管理空闲页面"><a href="#3）基于伙伴系统管理空闲页面" class="headerlink" title="3）基于伙伴系统管理空闲页面"></a>3）基于伙伴系统管理空闲页面</h4><blockquote><p>伙伴系统中的伙伴指的是两个内存块、大小相同、地址连续，同属于一个大块区域</p></blockquote><p>每个zone下面都有很多的页面，Linux使用伙伴系统对这些页面进行高效的管理。在内核中，表示zone的数据结构是struct zone。其下面的一个数组free_area管理了绝大部分可用的空闲页面。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MAX_ORDER 11</span><span class="token keyword">struct</span> zone<span class="token punctuation">{</span>    free_area free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>free_area是一个包含11个元素的数组。每一个元素分别代表不同大小（4KB、8KB、16KB、32KB…）的空闲可分配的连续内存链表。</strong></p><p>即每一个元素都代表一种大小的内存块，数组的索引表示了内存块包含的页框数量。例如，free_area[0]中存放的是单独的空闲页框（4KB），free_area[1]中存放的是包含两个页框的空闲内存块（8KB），等等。这种方式可以方便地查找和分配满足特定大小需求的内存块。</p><p><img src="/posts/48821/a74c3cf0ab4d4c61b2c5db5a79870151.png" alt></p><p>每个free_area元素都有一个或多个链表：</p><ol><li>MIGRATE_UNMOVABLE：表示不可移动的pages，例如内核数据结构的pages。</li><li>MIGRATE_RECLAIMABLE：表示可回收的pages，例如系统中的缓存，当内存紧张时可以回收其内存。</li><li>MIGRATE_MOVABLE：表示可移动的pages，例如用户进程的pages。当需要大块连续的内存空间，或者进行内存碎片整理时，可以移动这类page。</li><li>MIGRATE_PCPTYPES：表示特殊用途的pages，一般用于不可移动和可回收page的临时备份。</li><li>MIGRATE_HIGHATOMIC：表示高优先级的分配请求，这种类型的page只有在内存非常紧张时才会被使用。</li></ol><p>链表中的每一个元素都是一个空闲内存块。这些内存块在物理内存中是连续的，也就是说，它们包含的页框在物理内存中是紧邻的。这样，当内核需要分配一个连续的内存区域时，可以直接从这些链表中查找和分配。但要注意，虽然这些内存块在物理内存中是连续的，但在虚拟内存中可能并不连续。因为虚拟地址到物理地址的映射是通过页表完成的，不同的页框可以被映射到虚拟内存中的任意位置（不一定在相邻的页表项）。</p><blockquote><p>free_area数组里的链表元素存储了一个叫struct page的结构体。struct page是内核用来描述<strong>物理内存页</strong>的主要数据结构。</p><p>每个物理页在内核中都有一个对应的struct page实例。这个结构体包含了许多用于页管理的字段，如用于链接空闲页的链表节点字段等。内核可以通过这个结构体找到对应的物理页。为了映射物理内存和struct page实例，Linux内核使用了一种叫做mem_map的数组。这个数组的每个元素都是一个struct page实例，整个数组的顺序与物理内存页的顺序相同。因此，内核可以通过简单的指针运算在物理地址和对应的struct page实例之间进行转换。</p></blockquote><p>通过cat /proc/pagetypeinfo可以看到当前系统中伙伴系统各个尺寸的可用连续内存块数量。</p><p>内核提供分配器函数alloc_pages到上面的多个链表中寻找可用连续页面。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> page <span class="token operator">*</span> <span class="token function">alloc_pages</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如要申请8KB（连续两个页框的内存），<strong>在基于伙伴系统的内存分配中，有可能需要将大块内存拆分成两个小伙伴。在释放中，可能会将两个小伙伴合并，在此组成更大块的连续内存。</strong>具体的工作步骤：</p><ol><li>先到free_area[1]，即8KB的链表中查询</li><li>如果无可用，则到free_area[2]，即16KB的链表中查询</li><li>如果找到了则将其拆分成两个小伙伴，使用掉其中一个</li><li>将另一个小伙伴放置到8KB的链表中</li></ol><h4 id="4、slab分配器"><a href="#4、slab分配器" class="headerlink" title="4、slab分配器"></a>4、slab分配器</h4><p>到目前介绍的内存分配都是以页面4KB为单位的。而内核代码经常需要在运行时分配和释放小块的内存区域。如果每次都使用普通的页分配器（即每次分配至少一个页的内存）来完成，可能会浪费大量内存。为了更高效地分配小块内存，内核在伙伴系统之上又引入了一个专用的内存分配器slab（或叫slub）</p><p>这个分配器最大的特点就是<strong>一个slab内只分配特定大小、甚至是特定的对象，当一个对象释放内存后，另一个同类对象可以直接使用这块内存</strong>。通过这样的方式极大地降低了碎片发生的概率。</p><p>在SLAB分配器中，<strong>当内核需要频繁创建和销毁某种类型的对象时（比如文件描述符、进程描述符等），它会创建一个kmem_cache，并根据需要的对象大小进行初始化</strong>。<strong>每个kmem_cache都包含一些预分配的内存块（SLABs）</strong>，这些内存块的大小都与需要的对象大小相匹配。当内核代码需要分配一个新的对象时，可以直接从对应的kmem_cache中取出一个预先分配的内存块，而不需要每次都去进行页分配。同样，当一个对象被释放时，它的内存块可以被直接归还到kmem_cache中，以便再次使用。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> kmem_cache <span class="token punctuation">{</span>    <span class="token keyword">struct</span> kmem_cache_node <span class="token operator">*</span><span class="token operator">*</span>node<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> kmem_cache_node <span class="token punctuation">{</span>    <span class="token keyword">struct</span> list_head slabs_partial<span class="token punctuation">;</span>    <span class="token keyword">struct</span> list_head slabs_full<span class="token punctuation">;</span>    <span class="token keyword">struct</span> list_head slabs_free<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>一个kmem_cache可以有多个kmem_cache_node，每个kmem_cache_node代表该kmem_cache在一个特定的NUMA节点上的状态。</strong>NUMA是一种针对多处理器系统的内存架构，其主要思想是将物理内存划分为多个节点，每个处理器可以直接访问所有的内存，但访问不同节点的内存的延迟和带宽可能会有所不同。因此，在NUMA系统中，内存的分配策略可能会影响到程序的性能。为了在NUMA系统中更高效地管理内存，Linux内核引入了kmem_cache_node。在每个kmem_cache中，每个NUMA节点都有一个对应的kmem_cache_node。这个kmem_cache_node包含了该节点上的空闲对象列表，以及其他一些与该节点相关的信息。当从kmem_cache中分配或释放对象时，内核会优先考虑当前CPU对应的NUMA节点，这样可以提高内存访问的性能。</p><p><strong>每个kmem_cache_node中都有满、半满、空三个链表。每个链表节点都对应一个slab，一个slab由一个或多个内页也组成。</strong></p><p><strong>每一个slab内都保存的是同等大小的对象。</strong></p><p>当cache中内存不够时，会调用基于伙伴系统的分配器请求整页连续内存的分配。</p><p><img src="/posts/48821/c5a0449280aa42e593cf86d90c29092d.png" alt></p><p>内核中会有很多个kmem_cache存在，它们是在Linux初始化或者是运行的过程中分配出来的。其中有的是通用的，有的是专用的。</p><p><img src="/posts/48821/d06a875b50c649e5bb57d84ddfb1986d.png" alt></p><p>从图中可以<strong>看到socket_alloc内核对象都存在TCP的专用kmem_cache中</strong>。通过查看/proc/slabinfo可以查看所有的kmem_cahce。</p><p><strong>并不是所有的对象都会使用SLAB分配器进行分配。SLAB分配器是针对频繁分配和释放的小型对象设计的</strong>，比如内核中的各种数据结构（例如，文件描述符、信号量、进程描述符等）。对于这些对象，SLAB分配器可以显著提高分配效率，减少内存碎片，并提高缓存利用率。然而，对于大型对象（比如用户请求的大块内存），或者不常用的对象（即分配和释放不频繁的对象），直接使用页分配器（Page Allocator）或者伙伴系统（Buddy System）进行分配通常更为高效。页分配器可以处理任何大小的内存请求，但对于小型对象，可能会造成内存的浪费。</p><p>此外，用户空间的内存分配（例如，通过malloc()或者new进行的分配）通常不直接使用SLAB分配器。用户空间的内存分配通常由C库（例如，glibc）提供的内存分配器处理，这个分配器使用系统调用（例如，brk()或者mmap()）从内核获取或释放内存。</p><blockquote><p>Linux还提供了一个特别方便的命令slabtop来按照内存从大到小进行排列，可以用来分析slab内存开销。</p><p>此外slab管理器组件提供了若干接口函数方便使用：</p><ol><li>kmem_cache_create：创建一个基于slab的内核对象管理器。</li><li>kmem_cache_alloc：快速为某个对象申请内存。</li><li>kmem_cache_free：将对象占用的内存归还给slab分配器</li></ol></blockquote><h4 id="5）小结"><a href="#5）小结" class="headerlink" title="5）小结"></a>5）小结</h4><p>内核使用内存的方式：</p><ol><li>把所有内存条和CPU换分成node</li><li>把每一个node划分成zone</li><li>每个zone下都用伙伴系统管理空闲页面</li><li>内核提供slab分配器为自己专用</li></ol><p><strong>前三步是基础模块，为应用程序分配内存时的请求调页组件页能够用到，但是第四步就是内核给自己专用的了。</strong></p><h3 id="三、TCP连接相关内核对象"><a href="#三、TCP连接相关内核对象" class="headerlink" title="三、TCP连接相关内核对象"></a>三、TCP连接相关内核对象</h3><p>TCP连接建立的过程中，每申请一个内核对象也都需要到相应的缓存里申请一块内存。</p><h4 id="1）socket函数直接创建"><a href="#1）socket函数直接创建" class="headerlink" title="1）socket函数直接创建"></a>1）socket函数直接创建</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__sock_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分配socket对象</span>    sock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用协议族的创建函数创建sock对象</span>    err <span class="token operator">=</span> pf<span class="token operator">-></span><span class="token function">create</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-sock-inode-cache对象申请"><a href="#1-sock-inode-cache对象申请" class="headerlink" title="1. sock_inode_cache对象申请"></a>1. sock_inode_cache对象申请</h5><p>在sock_alloc函数中，申请了一个struct socket_alloc的内核对象。<strong>socket_alloc内核对象将socket和inode信息关联了起来。</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> socket_alloc <span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket socket<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inode vfs_inode<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在sock_alloc的实现逻辑中，最后就<strong>调用了kmem_cache_alloc从sock_inode_cache中申请了一个struct socket_alloc对象</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token function">sock_alloc_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket_alloc <span class="token operator">*</span>ei<span class="token punctuation">;</span>    <span class="token keyword">struct</span> socket_wq <span class="token operator">*</span>wq<span class="token punctuation">;</span>    ei <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>sock_inode_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ei<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    wq <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>wq<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>sock_inode_cache是专门用来存储struct socket_alloc的slab缓存</strong>，它是在init_inodecache中通过<code>kmem_cache(&quot;sock_inode_cache&quot;, sizeof(struct socket_alloc), ...)</code>初始化的。</p><p>另外还可以看到通过kmalloc申请了一个socket_wq，这是个用来记录在socket上等待事件的等待项。</p><h5 id="2-tcp对象申请"><a href="#2-tcp对象申请" class="headerlink" title="2. tcp对象申请"></a>2. tcp对象申请</h5><p>对于IPv4来说，inet协议族对应的create函数是inet_create，因此__sock_create中对pf-&gt;create的调用会执行到inet_create中去。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">inet_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 这个answer_prot其实就是tcp_prot</span>    answer_prot <span class="token operator">=</span> answer<span class="token operator">-></span>prot<span class="token punctuation">;</span>    sk <span class="token operator">=</span> <span class="token function">sk_alloc</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> PF_INET<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> answer_prot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">sk_alloc</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    sturct sock <span class="token operator">*</span>sk<span class="token punctuation">;</span>    sk <span class="token operator">=</span> <span class="token function">sk_prot_alloc</span><span class="token punctuation">(</span>prot<span class="token punctuation">,</span> priority <span class="token operator">|</span> __GFP_ZERO<span class="token punctuation">,</span> family<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">sk_prot_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> proto <span class="token operator">*</span>prot<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    slab <span class="token operator">=</span> prot<span class="token operator">-></span>slab<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>slab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      sk <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>slab<span class="token punctuation">,</span> priority <span class="token operator">&amp;</span> <span class="token operator">~</span>__GFP_ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个函数中，<strong>将会到TCP这个slab缓存中使用kmem_cache_alloc从slab中申请一个struct sock内核对象出来</strong>。TCP这个slab缓存是在协议栈初始化的时候在inet_init中使用<code>kmem_cache_create(prot-&gt;name, prot-&gt;obj_size, ...)</code>（这里prot是一个tcp_prot）初始化好的一个名为TCP、大小为sizeof(struct tcp_sock)的kmem_cache，并把它记到tcp_prot-&gt;slab的字段下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> proto tcp_prot <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"TCP"</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span>obj_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tcp_sock<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要记住的是，在<strong>TCP slab缓存中实际存放的是struct tcp_sock对象，是struct sock的扩展</strong>，由于tcp_sock、inet_connection_sock、inet_sock、sock是逐层嵌套的关系，所以tcp_sock是可以当作sock来使用的。</p><h5 id="3-dentry和flip对象申请"><a href="#3-dentry和flip对象申请" class="headerlink" title="3. dentry和flip对象申请"></a>3. dentry和flip对象申请</h5><p>回到socket系统调用的入口处，除了sock_create以外，还调用了一个sock_map_fd</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">sock_create</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sock_map_fd</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>0_CLOEXEC <span class="token operator">|</span> ONONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以此为入口将完成struct dentry的和struct file申请。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> dentry <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> dentry <span class="token operator">*</span>d_parent<span class="token punctuation">;</span>    <span class="token keyword">struct</span> qstr d_name<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inode <span class="token operator">*</span>d_inode<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> d_iname<span class="token punctuation">[</span>DNAME_INLINE_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内核初始化的时候创建好了一个dentry slab和flip slab缓存，所有的struct dentry对象和struct file对象都将由它们进行分配。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sock_map_fd</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> file <span class="token operator">*</span>newfile<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 1.申请dentry、file内核对象</span>    newfile <span class="token operator">=</span> <span class="token function">sock_alloc_file</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>newfile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 2.关联到socket及进程</span>      <span class="token function">fd_install</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> newfile<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> fd<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token function">sock_alloc_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dname<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 申请dentry</span>    path<span class="token punctuation">.</span>dentry <span class="token operator">=</span> <span class="token function">d_alloc_pseudo</span><span class="token punctuation">(</span>sock_mnt<span class="token operator">-></span>mnt_sb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 申请flip</span>    file <span class="token operator">=</span> <span class="token function">alloc_file</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">,</span> FMOD_READ <span class="token operator">|</span> FMODE_WRITE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>socket_file_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在sock_alloc_file中完成内核对象的申请，其中会去进行struct dentry和struct file两个内核对象的申请。</strong>dentry对象的申请最终同样是是调用到了kmem_cache_alloc函数（对应的slab缓存dentry在内核初始化时的dcache_init中创建的），而file对象的申请最终是调用了kmem_cache_zalloc函数进行分配（对应的slab缓存flip是在内核初始化时的files_init中创建的）</p><blockquote><p>kmem_cache_alloc()和kmem_cache_zalloc()都是用于从指定的kmem_cache中分配对象的函数。它们的主要区别在于，kmem_cache_zalloc()在分配内存后，会自动将内存区域初始化为0。</p><p>具体来说：</p><ul><li>kmem_cache_alloc()：从指定的kmem_cache分配一个对象的内存空间。返回的内存空间中的内容是不确定的，也就是说，它可能包含任何数据。调用者需要自己对内存进行初始化。</li><li>kmem_cache_zalloc()：从指定的kmem_cache分配一个对象的内存空间，并自动将整个内存区域初始化为0。这意味着调用者可以直接使用返回的内存，无需再进行初始化。</li></ul><p>在一些情况下，使用kmem_cache_zalloc()可能更方便，因为它可以确保内存区域的内容被初始化为0。然而，如果你知道你会立即覆盖整个内存区域的内容，那么使用kmem_cache_alloc()可能会更高效，因为它避免了不必要的内存初始化。</p></blockquote><h5 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h5><p>调用链：</p><ul><li>SYSCALL_DEFINE3<ul><li>sock_create<ul><li>__sock_create<ul><li>sock_alloc =&gt; =&gt; sock_alloc_inode：申请socket_alloc和socket_wq</li><li>inet_create<ul><li>sk_alloc =&gt; sk_prot_alloc：申请tcp_sock</li></ul></li></ul></li></ul></li><li>sock_map_fd<ul><li>sock_alloc_file<ul><li>d_alloc_pseudo =&gt; __d_alloc：申请dentry</li><li>alloc_file =&gt; get_empty_flip：申请file</li></ul></li></ul></li></ul></li></ul><p>socket系统调用完毕之后，在内核中就申请了配套的一组内核对象。这些内核对象并不是鼓励地存在，而是互相保留着和其他内存对象的关联关系。</p><p><img src="/posts/48821/6d424f2828a1426d973ef066379d1b47.png" alt></p><p>所有网络相关的操作，包括数据接收和发送等都以这些数据结构为基础来进行的</p><h4 id="2）服务端socket创建"><a href="#2）服务端socket创建" class="headerlink" title="2）服务端socket创建"></a>2）服务端socket创建</h4><p>除了直接创建socket意外，服务端还可以通过accept函数在接受连接请求时完成相关内核对象的创建。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE</span><span class="token punctuation">(</span>accept4<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr __user <span class="token operator">*</span><span class="token punctuation">,</span> upeerp_sockaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token operator">*</span>newsock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据fd查找到监听的socket</span>    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 申请并初始化新的socket</span>    newsock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    newsock<span class="token operator">-></span>type <span class="token operator">=</span> sock<span class="token operator">-></span>type<span class="token punctuation">;</span>    newsock<span class="token operator">-></span>ops <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 申请新的file对象，并设置到新的socket上</span>    newfile <span class="token operator">=</span> <span class="token function">sock_alloc_file</span><span class="token punctuation">(</span>newsock<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 接受连接</span>    err <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">accept</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> newsock<span class="token punctuation">,</span> sock<span class="token operator">-></span>file<span class="token operator">-></span>f_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将新文件添加到当前进程的打开文件列表</span>    <span class="token function">fd_install</span><span class="token punctuation">(</span>newfd<span class="token punctuation">,</span> newfile<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到socket_alloc、file、dentry对象的分配都是相同的方式，唯一的区别是tcp_sock对象是在第三次握手的时候创建的，所以这里在接收连接的时候直接从全连接队列拿出request_sock的sock成员就可以了，无需再单独申请。</p><h3 id="四、问题解答"><a href="#四、问题解答" class="headerlink" title="四、问题解答"></a>四、问题解答</h3><ol><li>内核是如何管理内存的：内核采用SLAB的方式来管理内存，总共分为四部<ul><li>把所有的内存条和CPU进行分组，组成node</li><li>把每一个node划分成多个zone</li><li>每个zone下都用伙伴系统来管理空闲页面</li><li>提供slab分配器来管理各种内核对象</li><li>前三步时基础模块，为应用程序分配内存时的请求调页组件也能够用到，而第四步是内核专用的。每个slab缓存都是用来存储固定大小，甚至是特定的一种内核对象。这样当一个对象释放内存后，另一个同类对象可以直接使用这块内存，几乎没有任何碎片。极大地提高了分配效率，同时降低了碎片率。</li></ul></li><li>如何查看内核使用的内存信息<ul><li>通过/proc/slabinfo可以看到所有的kmem_cache。</li><li>更方便的是slatop命令，它从大到小按照占用内存进行排列。</li></ul></li><li>服务器上一条ESTABLISH状态的空连接需要消耗多少内存：假设连接上绝大部分时间都是空闲的，也就是假设没有发送缓存区和接收缓存区的开销，那么一个socket大约需要如下几个内核对象<ul><li>struct socket_alloc：大约0.62KB， slab缓存名是sock_inode_cache</li><li>struct top_sock：大约1.94KB，slab缓存名是tcp</li><li>struct dentry：大约0.19KB，slab缓存名是dentry</li><li>struct file：大约为0.25KB，slab缓存名是flip</li><li>加上slab多少会存在一点碎片无法使用，这组内核对象的大小大约是3.3KB左右。所以即使一万条连接也只需要占用33MB的内存</li><li>至于CPU开销，没有数据包的接收和处理是不需要消耗CPU的。长连接上在没有数据传输的情况下，只有极少量的保护包传输，CPU开销可以忽略不计</li></ul></li><li>机器上出现了3万多个TIME_WAIT，内存开销会不会很大<ul><li>从内存的角度来考虑，一条TIME_WAIT状态的连接仅仅是0.4KB左右的内存而已</li><li>从端口的角度来考虑，占用的端口只是针对特定服务器来说是占用了，只要下次连接的服务端不一样（IP或者端口不一样），那么这个端口仍然可以用来发起TCP连接</li><li>只有在连接同一个server的时候端口占用才能算得上是问题。如果想解决这个问题可以考虑使用tcp_max_tw_buckets来限制TIME_WAIT连接总数，或者打开tcp_tw_recycle、tcp_tw_reuse来快速回收端口，或者干脆使用长连接代替频繁的短连接。</li></ul></li></ol><p><strong>拓展阅读</strong>：</p><p><a href="https://zhuanlan.zhihu.com/p/62795773">Linux 内核 101：NUMA架构 - 知乎 (zhihu.com)</a></p><p><a href="https://www.jianshu.com/p/0607c5f62c51">浅解NUMA机制 - 简书 (jianshu.com)</a></p><p><a href="https://www.cnblogs.com/linhaostudy/p/10006723.html">Linux内存描述之内存区域zone–Linux内存管理(三) - yooooooo - 博客园 (cnblogs.com)</a></p><p><a href="https://www.dingmos.com/index.php/archives/23/#cl-2">Linux 内核 | 内存管理——Slab 分配器 - 一丁点儿 (dingmos.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/68465952">Linux中的物理内存管理 [一] - 知乎 (zhihu.com)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在应用程序里，我们使用多少内存都是自己能掌握和控制的，但是纵观Linux整台服务器，除了应用程序以外，内核也会申请和管理大量的内存。&lt;/p&gt;
&lt;h3 id=&quot;一、相关实际问题&quot;&gt;&lt;a href=&quot;#一、相关实际问题&quot; class=&quot;headerlink&quot; title=&quot;一、
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议中三次握手和四次挥手</title>
    <link href="https://joytsing.github.io/posts/42952/"/>
    <id>https://joytsing.github.io/posts/42952/</id>
    <published>2024-04-07T12:35:56.000Z</published>
    <updated>2024-04-10T09:00:22.436Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、三次握手流程"><a href="#一、三次握手流程" class="headerlink" title="一、三次握手流程"></a>一、三次握手流程</h3><p>推荐<a href="https://www.coonote.com/tcpip/tcp-three-handshakes-four-waves.html">阅读这篇文章</a>：</p><ol><li>客户端调用connect系统调用，发出第一次握手<ul><li><strong>找到套接字</strong>：创建内核对象的时候，fd会跟file对象做通过fd_install关联起来，通过进程的fd_table就可以找到对应的file，而file的private指针就指向了socket对象，所以根据fd即可找到套接字</li><li><strong>判断当前套接字的状态</strong>：只有SS_UNCONNECTED状态（刚创建的套接字就是该状态）才会继续，其他状态都会报错<ul><li>注意此处是socket的状态，而不是sock的状态</li><li>会将socket状态更改为SS_CONNECTING</li></ul></li><li><strong>更改sock状态为TCP_SYN_SENT</strong></li><li><strong>绑定端口</strong>：如果当前套接没有bind端口（端口为0则表示没有绑定），则从ip_local_port_range的某一个随机位置开始循环遍历找到合适的端口，如果查询不到则抛出Cannot assign requested address的错误</li><li><strong>申请skb加入发送队列并设置syn数据包</strong>：将SYN标志位置为1，随机生成一个序列号，并设置MSS等字段，随后将数据包发送出去<ul><li>这里直接调用的是tcp_transmit_skb，而正常发送逻辑会从tcp_sendmsg开始，其中会检查当前套接字的状态，如果不是已建立或者CLOSE_WAIT，会等待连接建立</li></ul></li><li><strong>启动重传定时器</strong>：等到一定时间后收不到服务端的反馈的时候来开启重传。首次超时时间是在TCP_TIMEOUT_INIT宏中定义的，该值在Linux3.10版本是1秒， 在一些老版本中是3秒。每次超时时间为2的指数递增（1，2，4，8，16，32）</li></ul></li><li>服务端收到SYN包之后，发出第二次握手<ul><li><strong>找到套接字</strong>：skb通过软中断不断上传到tcp协议栈，根据数据报首部的IP地址和端口号查找对应的socket对象</li><li><strong>判断当前套接字的状态</strong>：这里会进入TCP_LISTEN的处理逻辑</li><li><strong>判断连接是否已经建立</strong>：检查是否有与这个SYN包的四元组相同的连接已经存在<ul><li>如果已经存在ESTABLISHED状态的连接，则丢弃该握手包</li><li>如果已经存在SYN_RCVD状态的连接，则可能是一个重传的SYN包，这个时候会继续一下逻辑</li></ul></li><li><strong>查找半连接队列</strong>：到套接字的半连接队列中查找是否存在对应的半连接对象，因为当前是第一次握手，所以显然队列中还不存在半连接对象</li><li><strong>创建半连接对象加入队列</strong>：会先检查半连接队列和全连接队列是否已满，如果数据包没有被丢弃则创建request_sock对象，将状态设置为TCP_SYN_RCVD<ul><li>如果半连接队列满了且还没有开启syn_cookies那么将直接把握手包丢弃</li><li>如果全连接队列已满且存在young ack则同样把握手包丢弃</li></ul></li><li><strong>构造synack包并发送</strong>：将ACK和SYN标志位都置为1，随机生成一个序列号，并将确认号设置为SYN包的序列号+1，同时设置MSS等字段，最后将数据包发送出去</li><li><strong>半连接对象入队</strong>：将半连接对象request_sock加入半连接队列</li><li><strong>开启重传定时器</strong></li></ul></li><li>客户端收到SYNACK包之后，发出第三次握手<ul><li><strong>找到套接字</strong>：skb通过软中断不断上传到tcp协议栈，根据数据报首部的IP地址和端口号查找对应的socket对象</li><li><strong>判断当前套接字的状态</strong>：这里会进入TCP_SYN_SENT的处理逻辑</li><li><strong>移除重传队列中的SYN包，停止计时器</strong></li><li><strong>更改sock状态为ESTABLISHED</strong></li><li><strong>初始化TCP连接的拥塞控制算法、接收缓存和发送缓存空间等信息</strong></li><li><strong>开启keep alive保活计时器</strong></li><li><strong>唤醒等待队列的进程</strong></li><li><strong>构造ACK包进行发送</strong>：判断是否满足TCP的延迟确认（Delayed ACK）机制，如果满足则和数据包一起发送</li></ul></li><li>服务端收到ACK包之后，完成连接建立<ul><li><strong>找到套接字</strong>：skb通过软中断不断上传到tcp协议栈，根据数据报首部的IP地址和端口号查找对应的socket对象</li><li><strong>判断当前套接字的状态</strong>：这里会进入TCP_LISTEN的处理逻辑（注意不是TCP_SYN_RCVD）</li><li><strong>查找半连接队列</strong>：这次是响应第三次握手，在上一次已经创建了半连接对象放置在队列中，所以这次可以<strong>从队列中拿到半连接对象</strong></li><li><strong>创建sock对象</strong>：判断socket的全连接队列是否满了，没满则根据半连接对象创建子sock<ul><li>会将sock状态设置为ESTABLISHED，并且关联到这个request_sock</li><li>随后将request_sock其从半连接队列移除，加入到全连接队列中</li></ul></li><li><strong>唤醒等待队列的进程</strong>：如果有进程调用accept等待连接的话，则会被唤醒<ul><li>唤醒之后进程从全连接队列中拿到request_sock</li><li>之后就可以根据request_sock中保存的tcp_sock来创建socket对象</li></ul></li></ul></li></ol><h3 id="二、为什么握手是三次"><a href="#二、为什么握手是三次" class="headerlink" title="二、为什么握手是三次"></a>二、为什么握手是三次</h3><p>如果不进行最后一次握手，即服务端返回synack报文之后就完成建立的话，那么在数据包延迟到达的情况下有可能出现问题。</p><ul><li>第一次握手包延迟：假如说客户端发起的SYN数据包因为网络延迟没有到达服务端，那么这时候它就收不到服务端的SYNACK报文，那么此时它就会超时重传SYN数据包。如果这次服务端收到了并回复了SYNACK报文，那么连接就算建立成功了。而在连接建立成功并且通讯完成又释放了之后，第一次因为延迟而没有到达服务端的SYN数据包这时候到达了，这时候服务端会以为是一个新的连接到达，于是再次响应一个SYNACK报文，因为只有两次握手，所以就建立了一条本不应该存在的连接。而如果此时使用的是三次握手，那么客户端收到这条SYNACK报文后则会将其丢弃，不会完成连接的建立。</li><li>第二次握手包延迟：如果服务端收到了客户端的SYN报文，而回传SYNACK包的时候超时了，那么如果此时是两次握手，服务端直接认为连接建立成功，而客户端会以为是自己的SYN报文没有到达服务端而重传SYN数据包，那么服务端会因为已经建立连接（自己认为已经建立过了）所以丢弃重传的SYN包，所以客户端这边永远都连不上。而如果此时使用的是三次握手，那么在SYNACK包超时之后，除了客户端重发SYN包，服务端也会重发SYNACK包。那么客户端收到重发的SYNACK包之后会发出ACK包，而服务端收到重发的SYN包后会再次发出SYNACK包。这时这个新的SYNACK包到达之后会因为序列号对不上而被客户端丢弃，而服务端收到ACK包之后就完成连接的建立。建立完成之后即使延迟的SYNACK包到达了客户端，也会同样被丢弃。</li><li>第三次握手包延迟（当然只可能在三次握手时出现）：客户端发出ACK报文之后是不会期待响应的，所以此时它会直接认为连接建立。而服务端会因为收不到ACK包而重传SYNACK包，那么客户端会再次发送ACK包，如果服务端收到则完成建立。如果重试多次后一直丢失，那么服务端会认为连接建立失败而关闭连接。后续如果客户端正常的发出数据包给服务端，则会收到RST包，从而意识到连接已经被关闭。也就是说没有必要有第四次握手，如果ACK包一直丢失不能建立连接，后续发送数据的时候就可以感知到。</li></ul><p><img src="/posts/42952/7179150385446631985.png" alt></p><h3 id="三、关闭连接的情况"><a href="#三、关闭连接的情况" class="headerlink" title="三、关闭连接的情况"></a>三、关闭连接的情况</h3><p>关闭连接有以下几种可能：</p><ol><li><strong>超时</strong>：如果在设定的超时时间内没有收到期望的ACK包或其他响应，TCP连接会被关闭。这是为了防止网络中的“僵尸连接”消耗系统资源。</li><li><strong>错误或异常</strong>：如果发生了某些错误或异常，例如网络错误、对方突然断线或程序崩溃等，TCP连接也会被关闭。</li><li><strong>主动关闭</strong>：如果应用程序调用了关闭连接的函数（例如close和shutdown），TCP连接也会被关闭。</li><li><strong>RST标志</strong>：如果收到一个带有RST（Reset）标志的TCP包，TCP连接也会被立即关闭。RST包通常在发生错误或异常时被发送，例如，收到了一个不应该收到的包，或者试图打开一个不存在的连接等。</li></ol><p>如果是发生了如网络错误、断线或程序崩溃等错误或异常，那么自己这边的系统可能关闭所有的网络接口，释放所有的网络相关的内存等（取决于操作系统和协议栈的实现），而对端发送的保活数据包将接收不到ACK，重试几次后，就会进行连接的关闭，这个时候是不会进行四次挥手的。</p><p>而如果是发生以下情况，就会发送一个带有RST标志的TCP包。收到带有RST标志的包的一方会立即关闭连接，而不需要执行常规的四次挥手过程。这种情况下，连接的关闭是非正常的，因为它并没有经过正常的关闭过程就被终止了。</p><ol><li><strong>收到了一个错误的序列号的数据包</strong>：在TCP连接中，每个数据包都有一个序列号，用来保证数据包的有序接收。如果收到了一个序列号不正确的数据包（即这个数据包的序列号不在期望的序列号范围内），TCP会发送一个RST数据包来重置连接</li><li><strong>应用程序强制关闭</strong>：应用程序在正常关闭一个TCP连接时，会通过操作系统发送一个FIN（Finish）标志的数据包，这将触发TCP的正常关闭流程，也就是所谓的”四次挥手”。然而，有一种特殊的情况，那就是”强制关闭”或”紧急关闭”。在某些情况下，例如，应用程序崩溃，或者用户想要立即关闭连接，而不等待四次挥手过程完成，操作系统会发送一个RST（Reset）标志的数据包来立即关闭连接。这种情况下，操作系统并不会等待对方的确认，连接会立即关闭。可以使用SO_LINGER选项来设置一个0延迟的linger时间以实现强制关闭</li><li><strong>网络层错误或异常</strong>：在某些网络层的错误或异常情况下，例如，网络接口出错或者IP路由失败，TCP可能会发送一个RST数据包来关闭连接。</li><li><strong>TCP层错误或异常</strong>：在某些TCP层的错误或异常情况下，例如，内存不足，无法创建新的数据包，或者处理到一半的数据包被意外丢失，TCP可能会发送一个RST数据包来关闭连接。</li></ol><p>也就是以上的情况其实都不会进行四次挥手，只有当正常进行连接的关闭才会进行四次挥手的逻辑。当应用程序A决定关闭一个TCP连接时，它会调用 close() 或 shutdown() 函数，这些函数在操作系统内部会发送一个FIN（Finish）标志的TCP数据包给对端B，这就开始了所谓的四次挥手过程。</p><h3 id="四、四次挥手流程"><a href="#四、四次挥手流程" class="headerlink" title="四、四次挥手流程"></a>四、四次挥手流程</h3><ol><li><p>主动方调用close或shutdown，发起第一次挥手</p><ul><li><strong>取消文件描述符和file对象指针的关联</strong>：即后续无法再使用这个文件描述符，shutdown不会关闭fd，所以仍需要调用close来关闭文件描述符<ul><li>lose在fd被多个进程持有时不会立马关闭连接，调用close只会让引用计数-1，需要等到socket的引用计数为0才会发送FIN报文</li><li>而shutdown会直接关闭连接</li></ul></li><li><strong>判断当前套接字状态</strong>：如果是LISTEN则直接设置为close，然后释放对象，结束流程</li><li><strong>释放接收队列</strong>：如果不是LISTEN状态则循环遍历接收队列，释放队列中的skb<ul><li>如果接收队列不为空，即释放了skb，则会发送一个RST来中断连接，然后更改套接字状态并释放相关资源，结束流程</li></ul></li><li><strong>判断是否设置了SO_LINGER</strong>：如果设置了该选项并且linger时间设置为0，那么也发送RST直接中断连接<ul><li>默认是没有设置该选项的，close方法不会阻塞的，在后台进行处理</li><li>如果设置为0，则立即关闭连接，发送缓冲区有未发送的数据则直接丢弃，直接进入CLOSED</li></ul></li><li><strong>发送FIN数据包</strong>：只有没有设置SO_LINGER或者设置了非0的linger才会来到这里<ul><li><strong>更新自身状态为FIN_WAIT_1（状态机中ESTABLISH的下一位）</strong></li><li><strong>遍历发送队列，如果其中有数据包未发送就在最后一个数据包设置FIN标志位，然后将所有数据包发送出去。</strong></li><li>如果设置了SO_LINGER，则进程进入阻塞，等待linger时间，如果超时仍然没有发完则会发送RST报文。</li><li>默认没有设置linger（不会阻塞）则会检测当前socket状态。如果是FIN_WAIT1（一般来说没有阻塞直接返回就是这个状态），就会查看孤儿socket数量是不是太多了，如果是则更改为CLOSE状态并发送RST直接关闭，不是则tcp_close函数到此基本结束</li></ul></li></ul></li><li><p>服务端收到FIN包之后，发起第二次挥手</p><ul><li><strong>找到套接字，检查到套接字状态</strong>：因为当前是ESTABLISHED状态，所以进入tcp_rcv_established，并在最终检测到数据报的FIN标志位为1而进入tcp_fin函数进行处理</li><li><strong>更改套接字状态</strong>：对于ESTABLISHED状态的套接字，会将其更改为CLOSE_WAIT状态</li><li><strong>内存清理</strong>：清空乱序队列中的数据包，并且根据当前的内存压力和套接字的内存使用情况来回收一部分内存</li><li><strong>唤醒阻塞的进程</strong>：通知在recv上等待的进程有数据可读，此时读取的返回结果会是0<ul><li>此时服务端已经知道对端已经关闭连接，然后就可以编写逻辑来决定何时调用close方法</li></ul></li><li><strong>发送ACK包给客户端</strong></li></ul></li><li><p>客户端收到ACK包</p><ul><li><strong>找到套接字，检查到套接字状态</strong>：因为当前的状态是TCP_FIN_WAIT1，所以会进去一个状态处理函数tcp_rcv_state_process（如果不是LISTEN或是ESTABLISHED就会进入这个函数）</li><li><strong>更改套接字状态</strong>：将自身的状态更改为TCP_FIN_WAIT2</li><li><strong>设置定时器</strong>：TMO+2MSL或者基于RTO计算超时<ul><li>超时后会直接变迁到closed状态，然后将套接字的发送端设置为关闭</li></ul></li><li><strong>唤醒阻塞在close上的进程</strong>：针对于设置了SO_LINGER的情况，被唤醒后继续执行close后续逻辑<ul><li>检测linger2是否大于等于0（TCP层面的，用于设定孤儿套接字在FIN_WAIT2状态的生存时间，如果没有配置则默认为tcp_fin_timeout，如果大于则等待一段时间来接收对端的FIN，如果小于0则立即关闭连接，并发送RST报文</li></ul></li></ul></li><li><p>服务端继续处理，发送数据包给客户端</p><ul><li><p>服务端在知道客户端关闭连接后还可以继续发送数据包</p></li><li><p>如果客户端关闭了读通道(close会都关闭)，那么客户端收到数据包后会发送RST数据包之后服务端直接进行关闭</p><p><img src="/posts/42952/aa1363297f2045bfb85055ee100d7a42.png" alt="在这里插入图片描述"></p></li><li><p>如果客户端只是关闭了写通道(shutdown可以只关闭写)，那么数据包会照常接收并返回ACK报文</p><p><img src="/posts/42952/bf95d06b15044605b0308d0dc5710f0b.png" alt="在这里插入图片描述"></p></li></ul></li><li><p>当服务端处理完毕之后，调用close方法，发起第三次挥手</p><ul><li><strong>释放接收队列</strong>：如果有skb释放或者socket设置了SO_LINGER选项且linger时间为0，那么还是发送RST</li><li><strong>更新套接字状态</strong> ：如果不是上面两种情况则继续更新到状态机的下一位，因为当前是CLOSE_WAIT，所以更新成LAST_ACK<ul><li>CLOSE_WAIT会在保活定时器超时后强行关闭连接，用于服务端一直没有主动关闭连接而客户端已经因为超时而关闭的情况。</li></ul></li><li><strong>发送FIN包给客户端</strong></li></ul></li><li><p>客户端收到FIN包之后，发起第四次挥手</p><ul><li><strong>发送ACK数据包</strong>：同样进入tcp_fin函数，发送ack包给服务端然</li><li><strong>更改套接字状态</strong>：为当前状态是TCP_FIN_WAIT2，更改至TIME_WAIT</li><li><strong>内存释放</strong>：time_wait状态时，原socket会被destroy，然后新创建一个inet_timewait_sock，在等待2MSL之后删除。</li></ul></li><li><p>服务端收到客户端的ACK包之后，完成四次挥手：<strong>将LAST_ACK更改为CLOSED，并且释放对象</strong></p></li></ol><p>如果两边同时发送FIN，那么在FIN_WAIT_1时收到对方的FIN，会进入CLOSING，之后收到ACK变成TIME_WAIT</p><h3 id="五、为什么挥手是四次"><a href="#五、为什么挥手是四次" class="headerlink" title="五、为什么挥手是四次"></a>五、为什么挥手是四次</h3><p>不同于握手，SYN和ACK可以同时发送。FIN表示的是自己没有数据要发了，而在客户端结束发送数据的时候，不一定服务端也结束了，所以没办法将FIN包和ACK包结合在一起发送。</p><p>对于可靠连接而言，ACK包是不可以省略的，每一个方向上的数据发送都应该得到对端的确认。并且假如说节省第二次挥手的ACK包，那么因为下一个FIN的时间是不确定的，有可能很久，那么实现的时候得让FIN_WAIT_1等待一个很久的时间。如果它是因为丢包了，那么重试也会需要一个很长的时间，这会导致close的时间非常的久。如果节省最后一个ACK包，也就是说被动方发出FIN之后就关闭，主动方收到FIN之后也直接关闭。那么有可能FIN包丢失了，所以导致被动方关闭了而主动方还在等待。</p><p>而最后需要进入TIME_WAIT状态等待2MSL的原因主要有两个：</p><ol><li>保证老的重复报文在网络中消逝：如果说没有TIME_WAIT两个2MSL，而客户端和服务端又基于原本的端口建立了新的连接，那么旧连接中可能有数据包延迟，没达到最大生存时间，所以还没被丢弃，这个时候到达了新的连接，并且正好在接收窗口中，那么此时会被误以为是正常的数据包，从而导致新的连接数据错乱。序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。所以通过设置2MSL，保证新连接建立的时候，旧连接在网络中残留的数据包都已经死亡了</li><li>如果主动关闭方的ACK丢失，那么被动方会重发FIN包，以允许主动方重发ACK，那么此时如果没有TIMEWAIT，则主动方已经关闭了，无法重发ACK报文，TCP协议栈会返回 RST 报文，RST其实是出现异常的时候才发送的数据包，这对于可靠的TCP协议而言不是一个比较优雅的关闭方式。</li></ol><p>如果出现过多的TIME_WAIT，想要缩短TIME_WAIT的时间，Linux 操作系统提供了两个可以系统参数来快速回收处于 <code>TIME_WAIT</code> 状态的连接（这两个参数都是默认关闭的），分别是<code>net.ipv4.tcp_tw_reuse</code>和<code>net.ipv4.tcp_tw_recycle</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、三次握手流程&quot;&gt;&lt;a href=&quot;#一、三次握手流程&quot; class=&quot;headerlink&quot; title=&quot;一、三次握手流程&quot;&gt;&lt;/a&gt;一、三次握手流程&lt;/h3&gt;&lt;p&gt;推荐&lt;a href=&quot;https://www.coonote.com/tcpip/tcp-t
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(六)</title>
    <link href="https://joytsing.github.io/posts/11832/"/>
    <id>https://joytsing.github.io/posts/11832/</id>
    <published>2024-04-07T09:03:59.000Z</published>
    <updated>2024-04-07T12:33:14.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、相关实际问题"><a href="#一、相关实际问题" class="headerlink" title="一、相关实际问题"></a>一、相关实际问题</h3><ol><li>为什么服务端程序都需要先listen一下</li><li>半连接队列和全连接队列长度如何确定</li><li>“Cannot assign requested address”这个报错是怎么回事</li><li>一个客户端端口可以同时用在两条连接上吗</li><li>服务端半/全连接队列满了会怎么样</li><li>新连接的soket内核对象是什么时候建立的</li><li>建立一条TCP连接需要消耗多长时间</li><li>服务器负载很正常，但是CPU被打到底了时怎么回事</li></ol><h3 id="二、深入理解listen"><a href="#二、深入理解listen" class="headerlink" title="二、深入理解listen"></a>二、深入理解listen</h3><h4 id="1）listen系统调用"><a href="#1）listen系统调用" class="headerlink" title="1）listen系统调用"></a>1）listen系统调用</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE2</span><span class="token punctuation">(</span>listen<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 根据fd查找socket内核对象</span>    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取内核参数net.core.somaxconn</span>      somaxconn <span class="token operator">=</span> <span class="token function">sock_net</span><span class="token punctuation">(</span>sock<span class="token operator">-></span>sk<span class="token punctuation">)</span><span class="token operator">-></span>core<span class="token punctuation">.</span>sysctl_somaxconn<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>backlog <span class="token operator">></span> somaxconn<span class="token punctuation">)</span>        backlog <span class="token operator">=</span> somaxconn<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用协议栈注册的listen函数</span>     err <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">listen</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用户态的<a href="https://so.csdn.net/so/search?q=socket&spm=1001.2101.3001.7020">socket</a>文件描述符只是一个整数而已，内核是没有办法直接使用的，所以首先就是先<strong>根据用户传入的文件描述符来查找对应的socket内核对象</strong>。</p><p>再接着获取了<strong>系统里的net.core.somaxconn内核参数的值，和用户传入的backlog作比较后取一个最小值</strong>传入下一步。</p><p><strong>所以虽然listen允许我们传入backlog（该值和半连接队列、全连接队列都有关系），但是会受到内核参数的限制。</strong></p><p>接着通过<strong>调用sock-&gt;ops-&gt;listen进入协议栈的listen函数</strong>。</p><blockquote><ol><li>文件描述表：<strong>进程级别</strong>。一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，<strong>PCB 内部有一个文件描述符表，记录着当前进程所有可用的文件描述符</strong>，也即当前进程所有打开的文件。</li><li>打开文件表：系统级别。<strong>内核对所有打开文件维护的一个描述表格，将表格中的每一项称为打开文件句柄</strong>。它<strong>存储了一个打开文件的所有相关信息</strong>，例如当前文件的偏移量，访问模式，状态等等。</li><li>inode：系统级别。<strong>文件系统中的每个文件都有自己的i-node信息</strong>，它包含文件类型，访问权限，文件属性等等。<br><img src="/posts/11832/065d37f6d7d44a75b2424affa394ae17.png" alt></li></ol><p><img src="/posts/11832/9b38462ae8ce460cb84a1706ea9e63f5.png" alt></p><p>fdtable对应用户已打开文件表，或者说<a href="https://so.csdn.net/so/search?q=文件描述符&spm=1001.2101.3001.7020">文件描述符</a>表，是进程私有的。它的成员fd是file指针数组的指针，其中数组的索引就是文件描述符，而数组元素就是file指针，或者说已打开文件句柄。一个struct file的实例代表一个打开的文件，当一个用户进程成功打开文件时，会创建次结构体，并包含调用者应用程序的文件访问属性，例如文件数据的偏移量、访问模式和特殊标志等。此对象映射到调用者的文件描述符表，作为调用者应用程序对文件的句柄。</p><p>通常数组的第一个元素（索引为0）是进程的标准输入文件，数组的第二个元素（索引为1）是进程的标准输出文件，数组的第三个元素（索引为2）是进程的标准错误文件。</p><p>查看进程允许打开的最大文件句柄数：<code>ulimit -n</code>；设置进程能打开的最大文件句柄数：<code>ulimit -n xxx</code>。</p><p><img src="/posts/11832/72723c4182ef4e628557ad49db706a3b.png" alt></p><p>以上说法是在linux中的概念，而在windows中句柄的概念对应的是linux中文件描述符的概念，都是一个非负的整数。</p></blockquote><h4 id="2）协议栈listen"><a href="#2）协议栈listen" class="headerlink" title="2）协议栈listen"></a>2）协议栈listen</h4><p>上文提到系统调用最后会通过sock-&gt;ops-&gt;listen进入协议栈的listen函数，对于AF_INET而言，指向的是inet_listen</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_listen</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 还不是listen状态（尚未listen过）</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>old_state <span class="token operator">!=</span> TCP_LISTEN<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 开始监听</span>    err <span class="token operator">=</span> <span class="token function">inet_csk_listen_start</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置全连接队列长度</span>    sk<span class="token operator">-></span>sk_max_ack_backlog <span class="token operator">=</span> backlog<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<strong>全连接队列的长度就是执行listen调用时传入的backlog和系统参数之间较小的那个值</strong>。所以如果再线上遇到了全连接队列溢出的问题，想加大该队列的长度，那么可能需要将它们都设置得更大。</p><p>回过头来看inet_csk_listen_start函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_csk_listen_start</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> nr_table_entries<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> inet_connection_sock <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// icsk->icsk_accept_queue时接收队列</span>    <span class="token comment" spellcheck="true">// 接收队列内核对象的申请和初始化</span>    <span class="token keyword">int</span> rc <span class="token operator">=</span> <span class="token function">reqsk_queue_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>icsk<span class="token operator">-></span>icsk_accept_queue<span class="token punctuation">,</span> nr_table_entries<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数再一开始就<strong>将struct sock对象强制转换成了inet_connection_sock，名叫icsk</strong>。之所以可以强制转换是因为inet_connection_sock是包含sock的。tcp_sock、inet_connection_sock、inet_sock、sock是逐层嵌套的关系，类似面向对象里继承的概念。而对于TCP的socket来说，sock对象实际上是一个tcp_sock。因此TCP的sock对象可以强制类型转换为tcp_sock、inet_connection_sock、inet_sock来使用。即子类转换为父类。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> tcp_sock <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* inet_connection_sock has to be the first member of tcp_sock */</span>    <span class="token keyword">struct</span> inet_connection_sock inet_conn<span class="token punctuation">;</span>    u16 tcp_header_len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Bytes of tcp header to send      */</span>    u16 xmit_size_goal_segs<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Goal for segmenting output packets */</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> inet_connection_sock <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* inet_sock has to be the first member! */</span>    <span class="token keyword">struct</span> inet_sock      icsk_inet<span class="token punctuation">;</span>    <span class="token keyword">struct</span> request_sock_queue icsk_accept_queue<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inet_bind_bucket   <span class="token operator">*</span>icsk_bind_hash<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> inet_sock <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* sk and pinet6 has to be the first two members of inet_sock */</span>    <span class="token keyword">struct</span> sock     sk<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> IS_ENABLED(CONFIG_IPV6)</span>    <span class="token keyword">struct</span> ipv6_pinfo   <span class="token operator">*</span>pinet6<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> socket <span class="token punctuation">{</span>    socket_state        state<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> sock     <span class="token operator">*</span>sk<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> proto_ops  <span class="token operator">*</span>ops<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>也可以由sock强制转换为tcp_sock，因为在套接字创建的时候，就是以struct tcp_sock作为大小进行分配的。也就是内核中的每个sock都是tcp_sock类型，而struct tcp_sock正好是最大的那个结构体，不会出现越界访问的情况。</p></blockquote><p>在接下来的一行reqsk_queue_alloc中实际上包含了两件重要的事情。一是接<strong>收队列数据结构的定义</strong>，二是<strong>接收队列的申请和初始化</strong>。</p><h4 id="3）接收队列定义"><a href="#3）接收队列定义" class="headerlink" title="3）接收队列定义"></a>3）接收队列定义</h4><p>icsk-&gt;icsk_accept_queue定义在inet_connection_sock下，是一个request_sock_queue类型的对象，是内核用来接收客户端请求的主要数据结构。我们平时说的全连接队列、半连接队列全都是在这个数据结构里实现的。</p><p><img src="/posts/11832/729eba138dc942e58206eaeee3a97113.png" alt></p><p>我们来看具体的代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> inet_connection_sock <span class="token punctuation">{</span>    <span class="token keyword">struct</span> inet_sock icsk_inet<span class="token punctuation">;</span>    <span class="token keyword">struct</span> request_sock_queue icsk_accept_queue<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> request_sock_queue <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 全连接队列</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>rskq_accept_head<span class="token punctuation">;</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>rskq_accept_tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 半连接队列</span>    <span class="token keyword">struct</span> listen_sock <span class="token operator">*</span>listen_opt<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> listen_sock <span class="token punctuation">{</span>    u8 max_qlen_log<span class="token punctuation">;</span>    u32 nr_table_entires<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>syn_table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于全连接队列来说，在它上面不需要进行复杂的查找工作，<strong>accept处理的时候只是先进先出地接受就好了</strong>。所以全连接队列通过rskq_accept_head和rskq_accept_tail以<strong>链表的形式来管理</strong>。</p><p>和半连接队列相关联的数据对象是listen_opt，它是listen_sock类型的。<strong>因为服务端需要在第三次握手时快速地查找出来第一次握手时留存的request_sock对象，所以其实是用了一个哈希表来管理</strong>，就是struct request_sock *syn_table[0]。max_qlen_log和nr_table_entries都和半连接队列的长度有关。</p><h4 id="4）接收队列申请和初始化"><a href="#4）接收队列申请和初始化" class="headerlink" title="4）接收队列申请和初始化"></a>4）接收队列申请和初始化</h4><p>了解了全/半连接队列数据结构后，再回到inet_csk_listen_start函数中。它<strong>调用了reqsk_queue_alloc来申请和初始化icsk_accept_queue这个接收队列</strong>。</p><p>在reqsk_queue_alloc这个函数中完成了接收队列request_sock_queue内核对象的创建和初始化。其中包括内存申请、半连接队列长度的计算、全连接队列头的初始化等等。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">reqsk_queue_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> request_sock_queue <span class="token operator">*</span>queue<span class="token punctuation">,</span> unsigend <span class="token keyword">int</span> nr_table_entries<span class="token punctuation">)</span><span class="token punctuation">{</span>    size_t lopt_size <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> listen_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> listen_sock <span class="token operator">*</span>lopt<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算半连接队列的长度</span>    nt_table_entries <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> nr_table_entries<span class="token punctuation">,</span> sysctl_max_syn_backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    nr_table_entries <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 为listen神奇对象申请内存，这里包括了半连接队列</span>    lopt_size <span class="token operator">+</span><span class="token operator">=</span> nr_table_entries <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sturct request_sock <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lopt_size <span class="token operator">></span> PAGE_SIZE<span class="token punctuation">)</span>        lopt <span class="token operator">=</span> <span class="token function">vzalloc</span><span class="token punctuation">(</span>lopt_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    lopt <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span>lopt_size<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 全连接队列头初始化</span>    queue<span class="token operator">-></span>rskq_accept_head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 半连接队列设置</span>    lopt<span class="token operator">-></span>nr_table_entries <span class="token operator">=</span> nr_table_entries<span class="token punctuation">;</span>    queue<span class="token operator">-></span>listen_opt <span class="token operator">=</span> lopt<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开头定义了一个struct listen_sock的指针，这个listen_sock就是我们平时经常说的半连接队列。接下来计算半连接队列的长度，计算出来实际大小后进行内存的申请。最后将全连接队列呕吐设置成了NULL，将半连接队列挂到了接收队列queue上。</p><blockquote><p>半连接队列上每个元素分配的是一个指针大小，实际指向的request_sock的内存还未分配。这其实是一个哈希表，真正的半连接用的request_sock对象是在握手的过程中分配的，计算完哈希值后挂到这个哈希表上。</p></blockquote><h4 id="5）半连接队列长度计算"><a href="#5）半连接队列长度计算" class="headerlink" title="5）半连接队列长度计算"></a>5）半连接队列长度计算</h4><p>reqsk_queue_alloc函数中计算了半连接队列的长度，因为有些复杂所以没有在前面展开，这里深入一下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">reqsk_queue_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> request_sock_queue <span class="token operator">*</span>queue<span class="token punctuation">,</span> unsigend <span class="token keyword">int</span> nr_table_entries<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算半连接队列的长度</span>    nr_table_entries <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> nr_table_entries<span class="token punctuation">,</span> sysctl_max_syn_backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    nr_table_entries <span class="token operator">=</span> <span class="token function">max_t</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> nr_table_entries<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nr_table_entries <span class="token operator">=</span> <span class="token function">roundup_pow_of_two</span><span class="token punctuation">(</span>nr_table_entries <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为了效率，不记录nr_table_entries而是记录2的N次幂等于nr_table_entries</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>kopt<span class="token operator">-></span>max_qlen_log <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> lopt<span class="token operator">-></span>max_qlen_log<span class="token punctuation">)</span> <span class="token operator">&lt;</span> nr_table_entries<span class="token punctuation">;</span> lopt<span class="token operator">-></span>max_qlen_log<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传进来的nr_table_entries在最初是用户传入的backlog和内核参数net.core.somaxconn二者之间的较小值。而在这个reqsk_queue_alloc函数里又将完成三次的对比和计算。</p><ul><li>min_t(u32, nr_table_entries, sysctl_max_syn_backlog)：和sysctl_max_syn_backlog内核对象比较，取较小值</li><li>max_t(u32, nr_table_entries, 8)：用来保证nr_table_entries不能比8小，避免传入太小的值导致无法建立连接</li><li>roundup_pow_of_two(nr_table_entries + 1)：用于上对齐到2的整数次幂</li></ul><p><strong>总的来说半连接队列的长度是min(backlog, somaxconn, tcp_max_syn_backlog)+1再向上取整到2的N次幂，但最小不能小于16。</strong></p><p>最后为了提升比较性能，内核并没有直接记录半连接队列的长度，而是采用了一种晦涩的方法，只记录其N次幂。即如果队列长度为16，则记录max_qlen_log为4，只需要直到它是为了提升性能的即可。</p><h4 id="6）小结"><a href="#6）小结" class="headerlink" title="6）小结"></a>6）小结</h4><p><strong>listen的主要工作其实就是申请和初始化接收队列，包括全连接队列和半连接队列。其中全连接队列是一个链表，而半连接队列由于需要快速地查找，所以使用的是一个哈希表。这两个队列是三次握手中很重要的两个数据结构，有了它们服务端才能正常相应来自客户端的三次握手。所以服务端都需要先调用listen才行。</strong></p><p>同时我们也知道了去内核时如何确定全连接队列和半连接队列的长度。</p><ol><li>全连接队列：min(backlog, net.core.somaxconn)</li><li>半连接队列：max(min(backlog, net.core.somaxconn, tcp_max_syn_backlog) + 1向上取整到2的幂次, 16)</li></ol><h3 id="三、深入理解connect"><a href="#三、深入理解connect" class="headerlink" title="三、深入理解connect"></a>三、深入理解connect</h3><p>客户端再发起连接的时候，创建一个socket，如何瞄准服务端调用connect就可以了，代码可以简单到只有两句。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">connect</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但这两行代码背后隐藏的技术细节却很多。</p><p><img src="/posts/11832/f96eece2281843df8f18c01b97d3d5af.png" alt></p><h4 id="1）connect调用链展开"><a href="#1）connect调用链展开" class="headerlink" title="1）connect调用链展开"></a>1）connect调用链展开</h4><p>当客户机调用connect函数的时候，进入系统调用</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>connect<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr __user <span class="token operator">*</span><span class="token punctuation">,</span> uservaddr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据用户fd查找内核中的socket对象</span>    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 进行connect</span>    err <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">connect</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> addlen<span class="token punctuation">,</span> sock<span class="token operator">-></span>file<span class="token operator">-></span>f_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理还是首先根据用户传入的文件描述符来查询对应的socket内核对象，如何再调用sock-&gt;ops-&gt;connect，对于AF_INET类型的socket而言，指向的是inet_stream_connect。而inet_stream_connect实际会去调用__inet_stream_connect</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__inet_stream_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-></span>sk<span class="token punctuation">;</span>    <span class="token function">witch</span><span class="token punctuation">(</span>sock<span class="token operator">-></span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>            err <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token keyword">case</span> SS_CONNECTED<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">// 此套接口已经和对端的套接口相连接了，即连接已经建立</span>        err <span class="token operator">=</span> <span class="token operator">-</span>EISCONN<span class="token punctuation">;</span>        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token keyword">case</span> SS_CONNECTING<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">// 此套接口正在尝试连接对端的套接口，即连接正在建立中</span>            err <span class="token operator">=</span> <span class="token operator">-</span>EALREADY<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> SS_UNCONNECTED<span class="token punctuation">:</span>        err <span class="token operator">=</span> sk<span class="token operator">-></span>sk_prot<span class="token operator">-></span><span class="token function">connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> uaddr<span class="token punctuation">,</span> addr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>          sock<span class="token operator">-></span>state <span class="token operator">=</span> SS_CONNECTING<span class="token punctuation">;</span>        err <span class="token operator">=</span> <span class="token operator">-</span>EINPROGRESS<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>刚创建完毕的socket的状态就是SS_UNCONNECTED，根据switch判断会去调用sk-&gt;sk_prot-&gt;connect</strong>，对于TCP socket而言，调用的是<strong>tcp_v4_connect</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> addr_len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置socket的状态为TCP_SYN_SENT</span>    <span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_SYN_SENT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 动态选择一个端口</span>    err <span class="token operator">=</span> <span class="token function">inet_hash_connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_death_row<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 函数用来根据sk中的信息，构建一个syn报文，并将它发送出去</span>    err <span class="token operator">=</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里会<strong>把socket的状态设置为TCP_SYN_SENT，再通过inet_hash_connect来动态地选择一个可用的端口</strong>。</p><h4 id="2）选择可用端口"><a href="#2）选择可用端口" class="headerlink" title="2）选择可用端口"></a>2）选择可用端口</h4><p>找到inet_hash_connect的源码，我们来看看到底端口时如何选择出来的。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_hash_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inet_timewait_death_row <span class="token operator">*</span>death_row<span class="token punctuation">,</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">__inet_hash_connect</span><span class="token punctuation">(</span>death_row<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> <span class="token function">inet_sk_port_offset</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> __inet_check_established<span class="token punctuation">,</span> __inet_hash_nolisten<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要关注一下调用__inet_hash_connect的两个参数 ：</p><ul><li>inet_sk_port_offset(sk)：这个函数根据要链接的目的IP和端口等信息生成一个随机数</li><li>__inet_check_established：检查是否和现有ESTABLISH状态的连接冲突的时候用的函数</li></ul><p>接着进入__inet_hash_connect函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__inet_hash_connect</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 是否绑定过端口</span>    <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> snum <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>inet_num<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取本地端口配置</span>    <span class="token function">inet_get_local_port_range</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>low<span class="token punctuation">,</span> <span class="token operator">&amp;</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>        remaing <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>snum<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 遍历查找</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> remaining<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        port <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> offset<span class="token punctuation">)</span> <span class="token operator">%</span> remaining<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保证了port会在范围之间</span>        <span class="token comment" spellcheck="true">// 查看是否是保留端口，是则跳过</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">inet_is_reserverd_local_port</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 查找和遍历已经使用的端口的哈希表链</span>         head <span class="token operator">=</span> <span class="token operator">&amp;</span>hinfo<span class="token operator">-></span>bhash<span class="token punctuation">[</span><span class="token function">inet_bhashfn</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> port<span class="token punctuation">,</span> hinfo<span class="token operator">-></span>bhash_size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">inet_bind_bucket_for_each</span><span class="token punctuation">(</span>tb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>head<span class="token operator">-></span>charin<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果端口已经使用</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">net_eq</span><span class="token punctuation">(</span><span class="token function">ib_net</span><span class="token punctuation">(</span>tb<span class="token punctuation">)</span><span class="token punctuation">,</span> net<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> tb<span class="token operator">-></span>port <span class="token operator">==</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 通过check_established继续检查是否可用</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">check_established</span><span class="token punctuation">(</span>death_row<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tw<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">goto</span> ok<span class="token punctuation">;</span>         <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 未使用的话</span>        tb <span class="token operator">=</span> <span class="token function">inet_bind_bukcet_create</span><span class="token punctuation">(</span>hinfo<span class="token operator">-></span>bind_bucket_cachep<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">goto</span> ok<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个函数中首先判断了inet_sk(sk)-&gt;inet_num，<strong>如果调用过bind，那么这个函数会选择好端口并设置在inet_num上，加入没有调用过bind，那么snum为0。</strong></p><p>接着调用inet_get_local_port_range，这个函数<strong>读取的是net.ipv4.ip_local_port_range这个内核参数，来读取管理员配置的可用的端口范围</strong>。</p><blockquote><p>该参数的默认值是32768-61000，意味着端口与总可用量是61000-32768=28232个。如果觉得这个数字不够用，那么可以通过修改net.ipve4.ip_local_port_range内参参数来重新设置。</p></blockquote><p>接下来进入for循环，其中offset是通过inet_sk_port_offset(sk)计算出来的随机数（是调用__inet_hash_connect时传进来的参数）。<strong>这段循环的作用就是从某个随机数开始，把整个可用端口范围遍历一遍，直到找到可用的端口为止</strong>。具体逻辑如下</p><ol><li>从随机数+low开始<strong>选取一个端口</strong></li><li><strong>判断端口是否是保留端口</strong>，即判断端口是否在net.ipv4.ip_local_reserved_ports中（如果因为某种原因不希望某些端口被内核使用则可以写入这个参数）</li><li><strong>获取已使用端口的哈希表</strong></li><li><strong>遍历哈希表判断端口是否被使用</strong>，如果没有找到则说明可以使用，已使用过则调用check_established（具体逻辑见下部分）</li><li>找到合适的端口：通过inet_bind_bucket_create<strong>申请一个inet_bind_bucket来记录端口已经使用了，并用哈希表的形式管理起来</strong>。</li><li>找不到合适的端口：<strong>返回-EADDRNOTAVAIL</strong>，也就是我们在用户程序上看到的Cannot assign requested address</li></ol><blockquote><p>所以如果遇到这个错误，应该想到去查一下net.ipv4.ip_local_port_range中设置的可用端口的范围是不是太小了。</p></blockquote><h4 id="3）端口被使用过怎么办"><a href="#3）端口被使用过怎么办" class="headerlink" title="3）端口被使用过怎么办"></a>3）端口被使用过怎么办</h4><p>在遍历已使用端口的哈希表时，对于已被使用的端口，会去<strong>调用check_established继续检查是否可用，如果这个函数返回0，则说明端口可以继续使用</strong>。</p><blockquote><p>对于TCP连接而言，维护的是一对四元组，分别由收发双方的端口号和ip地址决定，只要四元组中任意一个元素不同，都算是两条不同的连接。所以只要现有的TCP连接中四元组不与要建立的连接的其他三个元素完全一致，该端口就仍然可以使用。</p></blockquote><p>check_established实际上会去调用__inet_check_established</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__inet_check_established</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inet_timewait_death_row <span class="token operator">*</span>death_row<span class="token punctuation">,</span>                <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> __u16 lport<span class="token punctuation">,</span>                <span class="token keyword">struct</span> inet_timewait_sock <span class="token operator">*</span><span class="token operator">*</span>twp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找哈希桶</span>    ehash_bucket <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">inet_ehash_buket</span><span class="token punctuation">(</span>hinfo<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历看看有没有四元组一样的，一样的话就报错</span>    <span class="token function">sk_nulls_for_each</span><span class="token punctuation">(</span>sk2<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>head<span class="token operator">-></span>chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk2<span class="token operator">-></span>sk_hash <span class="token operator">!=</span> hash<span class="token punctuation">)</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">INET_MATCH</span><span class="token punctuation">(</span>sk2<span class="token punctuation">,</span> net<span class="token punctuation">,</span> acookie<span class="token punctuation">,</span> saddr<span class="token punctuation">,</span> daddr<span class="token punctuation">,</span> ports<span class="token punctuation">,</span> dif<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> not_unique<span class="token punctuation">;</span>    <span class="token punctuation">}</span>unique<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>not_uniqueue<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token operator">-</span>EADDRNOTAVAIL<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数首先找到inet_ehash_bucket（类似bhash，只不过这是所有ESTABLISH状态的socket组成的hash表），然后<strong>遍历整个哈希表，如果哈希值不相同则说明当前四元组不一致，如果哈希值相同则使用INET_MATCH进一步进行比较</strong>。如果匹配就是说明四元组完全一致，所以这个端口不可用，返回-EADDRNOTAVAIL，如果不匹配（四元组有一或以上个元素不一样）那么就返回0，表示该端口仍然可以用于建立新连接。</p><blockquote><p>INET_MATCH中除了将<strong>saddr、</strong>daddr、__ports进行了比较，还比较了一些其他项目，所以TCP连接还有五元组、七元组之类的说法。</p><p>一台客户机的最大建立的连接数并不是65535，只要有足够多的服务端，单机发出百万条连接没有任何问题。</p></blockquote><h4 id="4）发起SYN请求"><a href="#4）发起SYN请求" class="headerlink" title="4）发起SYN请求"></a>4）发起SYN请求</h4><p>找到可用的端口后，回到tcp_v4_connect，接下来会去调用tcp_connect来根据sk中的信息构建一个syn报文发送出去。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 申请并设置skb</span>    buff <span class="token operator">=</span> <span class="token function">alloc_skb_fclone</span><span class="token punctuation">(</span>MAX_TCP_HEADER <span class="token operator">+</span> <span class="token number">15</span><span class="token punctuation">,</span> sk<span class="token operator">-></span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tcp_init_nondata_skb</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> tp<span class="token operator">-></span>write_seq<span class="token operator">++</span><span class="token punctuation">,</span> TCPHDR_SYN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加到发送队列sk_write_queue</span>    <span class="token function">tcp_connect_queue_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 实际发出syn</span>    err <span class="token operator">=</span> tp<span class="token operator">-></span>fastopen_req <span class="token operator">?</span> <span class="token function">tcp_send_syn_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> sk<span class="token operator">-></span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 启动重传定时器</span>    <span class="token function">inet_csk_resetxmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">,</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_rto<span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tcp_connect一口气做了这么几件事：</p><ol><li><strong>申请一个skb，并将其设置为syn包</strong></li><li><strong>添加到发送队列上</strong></li><li><strong>调用tcp_transmit_skb将该包发出</strong>（同之前内核发送网络包的方式，传递给网络层）</li><li><strong>启动一个重传定时器，超时会重发</strong></li></ol><p><strong>该定时器的作用是等到一定时间后收不到服务端的反馈的时候来开启重传</strong>。首次超时时间是在TCP_TIMEOUT_INIT宏中定义的，该值在Linux3.10版本是1秒， 在一些老版本中是3秒。</p><blockquote><p>TCP在实现过程中，发送队列和重传队列都是sk_write_queue，这两个队列是一并处理的。</p></blockquote><h4 id="5）小结"><a href="#5）小结" class="headerlink" title="5）小结"></a>5）小结</h4><p><strong>客户端执行connect函数的时候，把本地socket状态设置成了TCP_SYN_SENT，选了一个可用的端口，接着发出SYN握手请求并启动重传定时器。</strong></p><p>在选择端口时，会随机地从ip_local_port_range指定的范围中选择一个位置开始循环遍历，找到可用端口后发出syn握手包，如果端口查找失败则抛出异常“Cannot assign requested address”。如果当前可用端口很充足，那么循环很快就可以退出。而如果ip_local_port_range中的端口快被用完了，那么这时候内核就大概率要把循环执行很多轮才能找到可用端口，<strong>这会导致connect系统调用的CPU开销上涨</strong>。</p><p><strong>而如果在connect之前使用了bind，将会使得connect系统调用时地端口选择方式无效，转而使用bind时确定的端口</strong>。即如果提前调用bind选了一个端口号，会先尝试使用该端口号，如果传入0也会自动选择一个。但默认情况下一个端口只会被使用一次，所以对于客户端角色的socket，不建议使用bind。</p><h3 id="四、完整TCP连接建立过程"><a href="#四、完整TCP连接建立过程" class="headerlink" title="四、完整TCP连接建立过程"></a>四、完整TCP连接建立过程</h3><p>在一次TCP连接建立（三次握手）的过程中，并不只是简单的状态的流转，还包括端口选择、半连接队列、syncookie、全连接队列、重传计时器等关键操作。</p><p>在三次握手的过程，服务端核心逻辑是创建socket绑定端口，listen监听，最后accept接收客户端的的请求；而客户端的核心逻辑是创建socket，然后调用connect连接服务端。</p><p>socket的创建、服务端的listen、客户端的connect在前面都已经讲解过了，那么这里从客户端connect发出syn包之后开始。客户端通过调用connect来发起连接。<strong>客户端在调用connect的时候，把本地socket状态设置成了TCP_SYN_SENT，选了一个可用的端口，接着发出SYN握手请求并启动重传定时器</strong>。</p><p><img src="/posts/11832/ba1fddf3fe0d459ab307d88650b4d73a.png" alt></p><h4 id="1）服务端响应SYN"><a href="#1）服务端响应SYN" class="headerlink" title="1）服务端响应SYN"></a>1）服务端响应SYN</h4><p>在服务端，所有的TCP包（包括客户端发来的SYN握手请求）都经过网卡、软中断进入tcp_v4_rcv。在该函数中根据网络包skb的TCP头信息中的目的IP信息查找当前处于listen状态的socket，然后继续进入tcp_v4_do_rcv处理握手过程（因为listen状态的socket不会收到的进入预处理队列。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 服务端收到第一步握手SYN或者第三步ACK都会走到这里</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_LISTEN） <span class="token punctuation">{</span>    <span class="token keyword">struct</span> sock <span class="token operator">*</span>nsk <span class="token operator">=</span> <span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nsk<span class="token punctuation">)</span>         <span class="token keyword">goto</span> discard<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nsk <span class="token operator">!=</span> sk<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_child_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> nsk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        rsk <span class="token operator">=</span> nsk<span class="token punctuation">;</span>        <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">,</span> skb<span class="token operator">-></span>len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      rsk <span class="token operator">=</span> sk<span class="token punctuation">;</span>      <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找listen socket的半连接队列</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>req <span class="token operator">=</span> <span class="token function">inet_csk_search_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> iph<span class="token operator">-></span>saddr<span class="token punctuation">,</span> iph<span class="token operator">-></span>daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">tcp_check_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在tcp_v4_do_rcv中判断当前socket是listen状态后，首先会到tcp_v4_hnd_req查看是否处于半连接队列</strong>。如果再半连接队列中没有找到对应的半连接对象，则会返回listen的socket(连接尚未创建)；如果找到了就将该半连接socket返回。服务端第一次响应SYN的时候，半连接队列自然没有对应的半连接对象，所以返回的是原listen的socket，即nsk == sk。</p><p><strong>在tcp_rcv_state_process里根据不同的socket状态进行不同的处理</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span>             <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">swich</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> TCP_LISTEN<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// 判断是否为syn握手包</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>th<span class="token operator">-></span>syn<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>icsk<span class="token operator">-></span>icsk_af_ops<span class="token operator">-></span><span class="token function">conn_request</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中conn_request是一个函数指针，指向tcp_v4_conn_request。<strong>服务端响应SYN的主要逻辑都在整个tcp_v4_conn_request里</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查看半连接队列是否满了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">inet_csk_reqsk_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    want_cookie <span class="token operator">=</span> <span class="token function">tcp_syn_flood_action</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token string">"TCP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>want_cookie<span class="token punctuation">)</span>        <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 在全连接队列满的情况下，如果有young_ack，那么直接丢弃</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inet_csk_reqsk_queue_young</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENOVERFLOWS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 分配request_sock内核对象</span>    req <span class="token operator">=</span> <span class="token function">inet_reqsk_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_request_sock_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造syn+ack包</span>    skb_synack <span class="token operator">=</span> <span class="token function">tcp_make_synack</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> req<span class="token punctuation">,</span> <span class="token function">fastopen_cookie_present</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>valid_foc<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&amp;</span>valid_foc <span class="token punctuation">:</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span>do_fastopen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 发送syn+ack响应</span>    err <span class="token operator">=</span> <span class="token function">ip_build_and_send_pkt</span><span class="token punctuation">(</span>skb_aynack<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> ireq<span class="token operator">-></span>loc_addr<span class="token punctuation">,</span> ireq<span class="token operator">-></span>rmt_addr<span class="token punctuation">,</span> ireq<span class="token operator">-></span>opt<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 添加到半连接队列，并开启计时器</span>    <span class="token function">inet_csk_reqsk_queue_hash_add</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> TCP_TIMEOUT_INIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里首先<strong>判断半连接队列是否满了</strong>，如果满了进入tcp_syn_flood_action去<strong>判断是否开启了tcp_syncookies内核参数</strong>。<strong>如果队列满且未开启tcp_syncookies，那么该握手包将被直接丢弃。</strong></p><blockquote><p>TCP Syn Cookie 是一个防止 SYN Flood 攻击的技术。当服务器接收到大量伪造的 SYN 请求时，可以消耗掉所有的连接资源，导致合法用户无法建立新的连接，这种攻击方式被称为 SYN Flood 攻击。SYN Flood 是一种 DoS（Denial of Service，服务拒绝）攻击。</p><p>这种技术的主要思想是不在服务器上为每个收到的 SYN 请求分配资源，而是通过计算一个 Cookie（实质上是一个哈希值），将这个 Cookie 作为 SYN-ACK 包的序列号发回客户端。当客户端回复 ACK 包时，服务器可以从 ACK 包的确认号中恢复出之前发送的 Cookie，从而验证这个连接请求是有效的。</p><p>这种方式可以有效抵御 SYN Flood 攻击，因为服务器不需要为每个 SYN 请求分配资源，伪造的 SYN 请求不会消耗服务器的资源。但是，SYN Cookie 技术也有一些局限性，例如它不兼容一些 TCP 的高级特性（如窗口缩放），并且在计算 Cookie 时也会消耗一些 CPU 资源</p></blockquote><p>接着<strong>判断全连接队列是否满了</strong>，因为全连接队列满也会导致握手异常，那干脆就在第一次握手的时候也判断了。<strong>如果全队列满了，且young_ack数量大于1的话，那么同样也是直接丢弃</strong>。</p><blockquote><p>young_ack是半连接队列里保存着的一个计时器，记录的是刚有SYN到达，没有被SYN_ACK重传定时器重传过SYN_ACK，同时也没有完成过三次握手的sock数量。</p><p>inet_csk_reqsk_queue_young(sk) &gt; 1这一判断，其实是在检查是否存在”年轻”的连接请求。如果存在这样的请求，而且全连接队列又已经满了，那么就会选择拒绝新的连接请求，以防止服务器过载。</p></blockquote><p>接下来是<strong>构造synack包</strong>，然后通过ip_build_and_send_pkt把它<strong>发送出去</strong>。</p><p>最后<strong>把当前的握手信息添加到半连接队列，并且启动计时器</strong>。计时器的作用是<strong>如果某个时间内还收不到客户端的第三次握手，服务端就会重传synack包</strong>。</p><blockquote><p>此时半连接队列中的request_sock的状态为SYN_RECV。等到服务器收到客户端的ACK报文，也就是三次握手完成后，request_sock 会被”升级”为一个完整的 sock 结构体，状态变为 ESTABLISHED。</p></blockquote><h4 id="2）客户端响应SYNACK"><a href="#2）客户端响应SYNACK" class="headerlink" title="2）客户端响应SYNACK"></a>2）客户端响应SYNACK</h4><p>客户端收到服务端发来的synack包的时候，由于自身状态是TCP_SYN_SENT，所以不会进入ESTABLISHED、LISTEN分支，同样进入tcp_rcv_state_process函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 服务端收到第一个SYN包</span>    <span class="token keyword">case</span> TCP_LISTEN<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 客户端第二次握手处理</span>        <span class="token keyword">case</span> TCP_SYN_SENT<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// 处理synack包</span>        queued <span class="token operator">=</span> <span class="token function">tcp_rcv_synsent_state_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> th<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tcp_rcv_synsent_state_process是客户端响应synack的主要逻辑</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tcp_rcv_synsent_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span>                 <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>tp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">tcp_ack</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> FLAG_SLOWPATH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 连接建立完成</span>    <span class="token function">tcp_finish_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_write_pending <span class="token operator">||</span>    icsk<span class="token operator">-></span>icsk_accept_queue<span class="token punctuation">.</span>rskq_defer_accept <span class="token operator">||</span>    icsk<span class="token operator">-></span>icsk_ack<span class="token punctuation">.</span>pingpong<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 延迟确认......</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">tcp_send_ack</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>tcp_ack(sk, skb, FLAG_SLOWPATH)：这行代码在收到SYN-ACK包后<strong>更新了socket的状态，包括序列号、确认号等</strong>。</p><ul><li><p>tcp_clean_rtx_queue：删除重传队列中已被确认的数据包，停止重传定时器</p><blockquote><p>在TCP协议中，当发送一个数据包时，发送方将这个数据包存储在重传队列中，并启动一个定时器。如果在定时器超时之前收到了这个数据包的确认（ACK），那么发送方就知道这个数据包已经成功地到达接收方，它就会从重传队列中删除这个数据包。否则，当定时器超时时，发送方就会重新发送这个数据包。</p><p>tcp_clean_rtx_queue函数就是处理这个重传队列的函数。它遍历重传队列，查看哪些数据包已经得到了确认，然后从重传队列中删除这些数据包。它还会计算网络的往返时间（RTT），以便于调整TCP的超时时间。</p><p>如果重传队列中的所有数据包都已经被确认，那么停止重传定时器。</p></blockquote></li></ul></li><li><p>tcp_finish_connect(sk, skb)：这行代码完成了TCP连接的建立。它<strong>将socket的状态从SYN_SENT改为ESTABLISHED，初始化TCP连接的拥塞控制算法、接收缓存和发送缓存空间等信息，开启keep alive计时器，然后唤醒等待连接完成的进程</strong>。</p><blockquote><p>Keep-alive计时器就是用于控制发送keep-alive数据包的计时器。通常，当一个TCP连接上没有任何数据包的传输时，我们就启动这个计时器。如果在计时器超时之前有新的数据包在这个连接上发送或接收，那么我们就重置计时器。如果计时器超时，那么我们就发送一个keep-alive数据包，并重新启动计时器等待响应。如果接收到了对这个数据包的响应，那么我们就知道连接仍然存在。如果在一定时间内没有收到响应，那么我们就假定连接已经断开，并将其关闭。</p></blockquote></li><li><p>满足TCP的延迟确认（Delayed ACK）机制：这种情况下，ACK包可能会和后续的数据包一起发送，以减少网络上的包的数量。</p></li><li><p>不满足延迟确认机制：立即调用tcp_send_ack(sk)，<strong>申请和构造ACK包然后发送出去</strong>。这个ACK包是对对方SYN-ACK包的确认，也是TCP三次握手的最后一步。</p></li></ol><p>即<strong>客户端响应来自服务端的synack时清除了connect时设置得重传定时器，把当前socket状态设置为ESTABLISHED，开启保活计时器然后发出第三次握手的ack确认</strong>。</p><h4 id="3）服务端响应ACK"><a href="#3）服务端响应ACK" class="headerlink" title="3）服务端响应ACK"></a>3）服务端响应ACK</h4><p>服务端响应第三次握手的ack时同样会进入tcp_v4_do_rcv。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 服务端收到第一步握手SYN或者第三步ACK都会走到这里</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_LISTEN） <span class="token punctuation">{</span>        <span class="token keyword">struct</span> sock <span class="token operator">*</span>nsk <span class="token operator">=</span> <span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nsk<span class="token punctuation">)</span>             <span class="token keyword">goto</span> discard<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nsk <span class="token operator">!=</span> sk<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_child_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> nsk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rsk <span class="token operator">=</span> nsk<span class="token punctuation">;</span>            <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于此处已经是第三次握手了，半连接队列里会存在第一次握手时留下的半连接信息，所以tcp_v4_hnd_req会在半连接队列里找到半连接request_sock对象后进入tcp_check_req</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找listen socket的半连接队列</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>req <span class="token operator">=</span> <span class="token function">inet_csk_search_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> iph<span class="token operator">-></span>saddr<span class="token punctuation">,</span> iph<span class="token operator">-></span>daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">tcp_check_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_check_req</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建子sock</span>    child <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_af_ops<span class="token operator">-></span><span class="token function">syn_recv_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 清理半连接队列</span>    <span class="token function">inet_csk_reqsk_queue_unlink</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_csk_reqsk_queue_removed</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加全连接队列</span>    <span class="token function">inet_csk_reqsk_queue_add</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数完成了以下工作：</p><ol><li><strong>判断接收队列是不是满了，没满则创建子sock（tcp_sock)</strong></li><li><strong>把request_sock从半连接队列删除</strong></li><li><strong>将request_sock添加到全连接队列链表的尾部，并与新创建的sock关联</strong></li></ol><p>因为是第三次握手所以返回了新的子sock，那么显然nsk!=sk，所以会执行<strong>tcp_child_process来为新的子sock进行一些初始化和处理工作</strong>，如设置TCP标志等，如果处理成功则会返回0。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_child_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>parent<span class="token punctuation">,</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span>child<span class="token punctuation">,</span>        <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> state <span class="token operator">=</span> child<span class="token operator">-></span>sk_state<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sock_owned_by_user</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret <span class="token operator">=</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">,</span> skb<span class="token operator">-></span>len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 进行状态处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> TCP_SYN_RECV <span class="token operator">&amp;&amp;</span> child<span class="token operator">-></span>sk_state <span class="token operator">!=</span> state<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 状态处理结束后socket的状态发生了变化</span>        <span class="token comment" spellcheck="true">// 调用sock_def_readable函数发送可读事件通告给listening socket，告知其可以进行accept系统调用</span>            parent<span class="token operator">-></span><span class="token function">sk_data_ready</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 新的socket被进行系统调用的进程锁定；因为这是新的socket，所以在tcp_v4_rcv加的锁不会起到保护新socket的作用</span>        <span class="token function">__sk_add_backlog</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 加入到后背队列</span>    <span class="token punctuation">}</span>    <span class="token function">bh_unlock_sock</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sock_put</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到其中再一次调用了tcp_rcv_state_process，然后唤醒等待队列上的进程。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 服务端收到第一次握手的SYN包</span>    <span class="token keyword">case</span> TCP_LISTEN<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 客户端第二次握手处理</span>        <span class="token keyword">case</span> TCP_SYN_SENT<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 服务端收到第三次握手的ACK包</span>    <span class="token keyword">case</span> TCP_SYN_RECV<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// 改变状态为连接</span>        <span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_ESTABLISHED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>服务端响应第三次握手ACK所做的工作就是把当前半连接对象删除，创建了新的sock后加入全连接队列，最后将新连接状态设置为ESTABLISHED。</strong></p><h4 id="4）服务端accept"><a href="#4）服务端accept" class="headerlink" title="4）服务端accept"></a>4）服务端accept</h4><p><strong>当服务端调用accept时主要的逻辑就是创建socket对象，然后从全连接队列中取出request_sock，将其中保存的第三次握手时创建的sock取出并与socket关联，随后释放request_sock。</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">inet_csk_accept</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 从全连接都列中获取</span>    <span class="token keyword">struct</span> request_sock_queue <span class="token operator">*</span>queue <span class="token operator">=</span> <span class="token operator">&amp;</span>icsk<span class="token operator">-></span>icsk_accept_queue<span class="token punctuation">;</span>    req <span class="token operator">=</span> <span class="token function">reqsk_queue_remove</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    newsk <span class="token operator">=</span> req<span class="token operator">-></span>sk<span class="token punctuation">;</span>    <span class="token keyword">return</span> newsk<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> request_sock <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 和其它struct request_sock对象形成链表</span>    <span class="token keyword">struct</span> request_sock        <span class="token operator">*</span>dl_next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Must be first member! */</span>    <span class="token comment" spellcheck="true">// SYN段中客户端通告的MSS</span>    u16                mss<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// SYN+ACK段已经重传的次数，初始化为0</span>    u8                retrans<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// SYN+ACK段的超时时间</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>            expires<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指向tcp_request_sock_ops,该函数集用于处理第三次握手的ACK段以及后续accept过程中struct tcp_sock对象的创建</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> request_sock_ops    <span class="token operator">*</span>rsk_ops<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 连接建立前无效，建立后指向创建的tcp_sock结构</span>    <span class="token keyword">struct</span> sock            <span class="token operator">*</span>sk<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>所以，accept的重点工作就是从已经建立好的全连接队列中取出一个返回给用户进程</strong></p><p><img src="/posts/11832/3f1980ac7a6f48858ab0a0eec4dbdb8c.png" alt></p><p>TCP连接建立的操作可以简单划分为两类：</p><ol><li>内核消耗CPU进行接收、发送或者处理，包括系统调用、软中断和上下文切换。它们的耗时基本是几微妙左右。</li><li>网络传输将包从一台机器上发出，经过各式各样的网络互联设备道到达目的及其。网络传输的耗时一般在几毫秒到几百毫秒，远超于本机CPU处理。</li></ol><p>由于网络传输耗时比双端CPU耗时要高1000倍不止，所以在正常的TCP连接建立过程中，一般堪虑网络延时即可。</p><p>一个RTT指的是包从一台服务器到另一台服务器的一个来回的延迟时间。从全局来看，TCP连接建立的网络耗时大约需要三次传输，再加上少许的双方CPU开销，总共大约比1.5倍RTT大一点点。</p><p>不过从客户端的角度来看，只要ACK包发出了，内核就认为连接建立成功，可以开始发送数据了。所以如果在客户端统计TCP连接建立耗时，只需要两次传输耗时——即比1个RTT多一点时间（从服务端视角来看也是同理）。</p><h3 id="五、异常TCP建立情况"><a href="#五、异常TCP建立情况" class="headerlink" title="五、异常TCP建立情况"></a>五、异常TCP建立情况</h3><h4 id="1）connect系统调用耗时失控"><a href="#1）connect系统调用耗时失控" class="headerlink" title="1）connect系统调用耗时失控"></a>1）connect系统调用耗时失控</h4><p>客户端在发起connect系统调用的的时候，主要工作就是端口选择。在选择的过程中有一个大循环，从ip_local_port_range的一个随机位置开始把这个范围遍历一遍，找到可用端口则退出循环。如果端口很充足，那么循环只需要执行少数几次就可以退出。但是如果端口消耗掉很多已经不充足，或者干脆就没有可用的了，那么这个循环就得执行很多遍。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_hash_connect</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">inet_get_local_range</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>low<span class="token punctuation">,</span> <span class="token operator">&amp;</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>    remaining <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> remaining<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 其中offset是一个随机数</span>    port <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> offset<span class="token punctuation">)</span> <span class="token operator">%</span> remaining<span class="token punctuation">;</span>        head <span class="token operator">=</span> <span class="token operator">&amp;</span>hinfo<span class="token operator">-></span>bhash<span class="token punctuation">[</span><span class="token function">inet_bhashfn</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> port<span class="token punctuation">,</span> hinfo<span class="token operator">-></span>bhash_size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加锁</span>    <span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 一大段端口选择逻辑，选择成功就goto ok，选择不成功就goto next_port</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    next_port<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// 解锁</span>           <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<strong>每次循环内部需要等待所以及在哈希表中执行多次的搜索。并且这里的锁是自旋锁，如果资源被占用，进程并不会挂起，而是占用CPU不断地尝试去获得锁</strong>。假设端口范围ip_local_port_range配置的是10000~30000，而且已经用尽了。那么每次当发起连接的时候，都需要把循环执行两万遍才退出。这时会涉及大量的哈希查找以及自旋锁等待开销，系统态CPU将出现大幅度上涨。</p><p>所以当connect系统调用的CPU大幅度上涨时，可以<strong>尝试修改内核常熟ipv4.ip_local_port_range多预留一些端口、改用长连接或者尽快回收TIME_WAIT等方式</strong>。</p><h4 id="2）第一次握手丢包"><a href="#2）第一次握手丢包" class="headerlink" title="2）第一次握手丢包"></a>2）第一次握手丢包</h4><p><strong>服务端在响应来自客户端的第一次握手请求的时候，会判断半连接队列和全连接队列是否溢出。如果发生溢出的，可能会直接将握手包丢弃，而不会反馈给客户端。</strong></p><h5 id="1-半连接队列满"><a href="#1-半连接队列满" class="headerlink" title="1. 半连接队列满"></a>1. 半连接队列满</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 看看半连接队列是否满了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">inet_csk_reqsk_queue_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    want_cookie <span class="token operator">=</span> <span class="token function">tcp_syn_flood_action</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token string">"TCP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>want_cookie<span class="token punctuation">)</span>        <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 看看全连接队列是否满了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>drop<span class="token punctuation">:</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENDROPS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在以上代码中<code>inet_csk_reqsk_is_full</code>如果返回true就表示半连接队列满了，另外<code>tcp_syn_flood_action</code>判断是否打开了内核参数<code>cp_syncookies</code>，如果未打开则返回false。</p><p>也就是说，<strong>如果半连接队列满了，而且没有开启tcp_syncookies，那么来自客户端的握手包将goto drop，即直接丢弃</strong>。</p><p>SYN Flood攻击就是通过耗光服务端上的半连接队列来使得正常的用户连接请求无法被响应。不过在现在的Linux内核里只要打开tcp_syncookies，半连接队列满了仍然可以保证正常握手的进行。</p><h5 id="2-全连接队列满"><a href="#2-全连接队列满" class="headerlink" title="2. 全连接队列满"></a>2. 全连接队列满</h5><p>当半连接队列判断通过以后，紧接着还由全连接队列的相关判断。如果满了服务端还是会丢弃它。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 看看半连接队列是否满了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 在全连接队列满的情况下，如果有young_ack，那么直接丢弃</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inet_csk_reqsk_queue_young</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENOVERFLOWS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sk_aceeptq_is_full</code>判断全连接队列是否满了，<code>inet_csk_reqsk_queue_young</code>判断有没有<code>young_ack</code>（未处理完的半连接请求）。<strong>如果全连接队列满且同时有<code>young_ack</code>，那么内核同样直接丢掉该SYN握手包</strong>。</p><h5 id="3-客户端发起重试"><a href="#3-客户端发起重试" class="headerlink" title="3. 客户端发起重试"></a>3. 客户端发起重试</h5><p>假设服务端发生了全/半连接队列溢出而导致的丢包，那么转换到客户端的视角来看就是SYN包没有任何响应。</p><p>因为客户端在发出握手包的时候，开启了一个重传定时器。如果收不到预期的synack，超时的逻辑就会开始执行。不过重传定时器的时间单位都是以秒来计算的，这意味着如果有握手重传发生，即使第一次重传就能成功，那接口最快响应也是一秒以后的事情了，这对接口耗时影响非常大。以下是connect系统调用关于重传的逻辑。</p><p><img src="/posts/11832/3b6012963a8e4ff49bd91356cc21bab5.png" alt></p><p>来详细看看重传的相关逻辑。客户端在connect系统调用发出SYN握手信号后就开启了重传定时器：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span>sruct sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 实际发出SYN</span>    err <span class="token operator">=</span> tp<span class="token operator">-></span>fastopen_req <span class="token operator">?</span> <span class="token function">tcp_send_syn_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span> <span class="token punctuation">:</span>       <span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> sk<span class="token operator">-></span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 启动重传定时器</span>    <span class="token function">inet_csk_reset_xmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">,</span>        <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_rto<span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其中inet_csk(sk)-&gt;icsk_rto是超时时间，该值初始化的时候被设置为TCP_TIMEOUT_INIT</strong>（1秒，在一些老版本的内核里为3秒）。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_connect_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化为TCP_TIMEOUT_INIT</span>    <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_rto <span class="token operator">=</span> TCP_TIMEOUT_INIT<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果能正常接收到服务端响应的synack，那么客户端的这个定时器会清除</strong>。这段逻辑在tcp_rearm_rto里，具体的调用顺序为tcp_rcv_state_process-&gt;tcp_rcv_synsent_state_process-&gt;tcp_ack-&gt;tcp_clean_rtx_queue-&gt;tcp_rearm_rto;</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_stream_rto</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">inet_csk_clear_xmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果服务端发生了丢包，那么定时器到时候会进入回调函数tcp_write_timer中进行重传（其实不只是握手，连接状态的超时重传也是在这里完成的）</strong>。</p><blockquote><p>其实不只是握手，连接状态的超时重传也是在这里完成的</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tcp_write_timer</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">tcp_write_timer_handler</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">tcp_write_timer_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 取出定时器类型</span>    event <span class="token operator">=</span> icsk<span class="token operator">-></span>icsk_pending<span class="token punctuation">;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">case</span> ICSK_TIME_RETRANS<span class="token punctuation">:</span>           <span class="token comment" spellcheck="true">// 清除定时器</span>        <span class="token comment" spellcheck="true">// icsk_pending用于标记一个 TCP 连接当前有哪些定时器是激活状态，是一个位掩码，每一位都对应一个特定的定时器</span>        icsk<span class="token operator">-></span>icsk_pending <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token function">tcp_retransmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里tcp_transmit_timer是重传的主要函数。在这里<strong>完成重传以及下一次定时器到期的时间设置</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_retransmit_timer</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 超过了重传次数则退出</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_write_timeout</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 重传</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tcp_retransmit_skb（sk<span class="token punctuation">,</span> <span class="token function">tcp_write_queue_head</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 重传失败</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 退出前重新设置下一次的超时时间</span>out_reset_timer<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">// 计算超时时间</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    icsk<span class="token operator">-></span>icsk_rto <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>icsk<span class="token operator">-></span>icsk_rto <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 设置</span>    <span class="token function">inet_csk_reset_xmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">,</span> icsk<span class="token operator">-></span>icsk_rto<span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>tcp_write_timeout用来判断是否重试过多，如果是则退出重试逻辑</strong>。</p><blockquote><p>对于SYN握手包主要的判断依据是net.ipv4_tcp_syn_retries（内核参数，对于一个新建连接，内核要发送多少个SYN连接请求才决定放弃。不应该大于255,默认值是5），但其实并不是简单的对比次数，而是转化成了时间进行对比。所以如果在线上看到了实际重传次数和对应内核参数不一致也不用太奇怪。</p></blockquote><p>接着<strong>调用tcp_retransmit_skb函数重发了发送队列里的头元素</strong>。</p><p>最后再次<strong>设置下一次超时的时间，为前一次时间的两倍</strong>。</p><h5 id="4-实际抓包结果"><a href="#4-实际抓包结果" class="headerlink" title="4. 实际抓包结果"></a>4. 实际抓包结果</h5><p>客户端发出TCP第一次握手之后，在1秒以后进行了第一次握手重试。重试仍然没有响应，那么接下来一次又分别在3秒、7秒、15秒、31秒和63秒等事件共重试了六次（我的tcp_syn_retries设置为6）。</p><p>当服务端第一次握手的时候出现了半/全连接队列溢出导致的丢包，那么接口响应的时间将会很久（只进行一次重试都需要一秒的时间），用户体验会受到很大的影响。并且如果某一个时间段内有多个进程/线程卡在了和Redis或者MySQL的握手连接上，那么可能会导致线程池剩下的线程数量不足以处理服务。</p><h4 id="3）第三次握手丢包"><a href="#3）第三次握手丢包" class="headerlink" title="3）第三次握手丢包"></a>3）第三次握手丢包</h4><p>客户端在收到服务器的synack相应的时候，就认为连接建立成功了，然后会将自己的连接状态设置为ESTABLISHED，发出第三次握手请求。但服务端在第三次握手的时候还有可能有意外发生。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找listen socket的半连接队列</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>req <span class="token operator">=</span> <span class="token function">inet_csk_search_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> iph<span class="token operator">-></span>saddr<span class="token punctuation">,</span> iph<span class="token operator">-></span>daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">tcp_check_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_check_req</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建子socket</span>    child <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_af_ops<span class="token operator">-></span><span class="token function">syn_recv_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 清理半连接队列</span>    <span class="token function">inet_csk_reqsk_queue_unlink</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_csk_reqsk_queue_removed</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加全连接队列</span>    <span class="token function">inet_csk_reqsk_queue_add</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在第三次握手时，首先从半连接队列里拿到半连接对象，之后通过tcp_check_req =&gt; inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock来创建子socket</p><p>这里syn_recv_sock是一个函数指针，在ipv4中指向了tcp_v4_syn_recv_sock。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_syn_recv_sock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断全连接队列是不是满了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">goto</span> exit_overflow<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述代码可以看出，<strong>第三次握手的时候，如果服务器全连接队列满了，来自客户端的ack握手包又被直接丢弃</strong>。</p><p><strong>由于客户端在发起第三次握手之后就认为连接建立了，所以如果第三次握手失败，是由服务端来重发synack（服务端发送synack之后启动了定时器，并将该半连接对象保存在了半连接队列中）</strong>。服务端等到半连接定时器到时后，想客户端重新发起synack，客户端收到后再重新恢复第三次握手。如果这个期间服务端全连接队列一直都是满的，那么服务端重试5次（受内核参数net.ipv4.tcp_synack_retries控制）后就放弃了。</p><p>客户端在发起第三次握手之后往往就开始发送数据，其实这个时候连接还没有真的建立起来。<strong>如果第三次握手失败了，那么它发出去的数据，包括重试都将被服务端无视</strong>，知道连接真正建立成功后才行。</p><h4 id="4）握手异常总结"><a href="#4）握手异常总结" class="headerlink" title="4）握手异常总结"></a>4）握手异常总结</h4><ol><li>端口不足：导致connect系统调用的时候过多地执行自旋锁等待与哈希查找，会引起CPU开销上涨。严重的情况下会耗光CPU，影响用户逻辑的执行。<ol><li>调整ip_local_port_range来尽量加大端口范围</li><li>尽量复用连接，使用长连接来削减频繁的握手处理</li><li>开启tcp_tw_reuse和tcp_tw_recycle</li></ol></li><li>服务端在第一次握手丢包（半连接队列满且tcp_syncookies为0 || 全连接队列满且有未完成的半连接请求）：客户端不断发起syn重试</li><li>服务端在第三次握手丢包（全连接队列满）：服务端不断发起synack重试</li></ol><p>握手重试对服务端影响很大，常见的解决方法如下：</p><ol><li>打开syncookies：防止SYN Flood攻击等</li><li>加大连接队列长度：全连接是min(backlog，net.core.somaxconn)，半连接是min(backlog，somaxconn，tcp_max_syn_backlog) + 1向上取整到2的幂次（且不小于16）</li><li>尽快调用accept</li><li>尽早拒绝：例如MySQL和Redis等服务器的内核参数tcp_abort_on_overflow设置为1，如果队列满了直接reset指令发送给客户端，告诉其不要继续等待。这时候客户端会收到错误“connection reset by peer”</li><li>尽量减少TCP连接的次数</li></ol><h3 id="六、如何查看是否有连接队列溢出发生"><a href="#六、如何查看是否有连接队列溢出发生" class="headerlink" title="六、如何查看是否有连接队列溢出发生"></a>六、如何查看是否有连接队列溢出发生</h3><h4 id="1）全连接队列溢出判断"><a href="#1）全连接队列溢出判断" class="headerlink" title="1）全连接队列溢出判断"></a>1）全连接队列溢出判断</h4><p>全连接队列溢出都会记录到ListenOverflows这个MIB（管理信息库），对应SNMP统计信息中的ListenDrops这一项。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查看半连接队列是否满了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 在全连接队列满的情况下，如果有young_ack，那么直接丢弃</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inet_csk_reqsk_queue_young</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENOVERFLOWS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>drop<span class="token punctuation">:</span><span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENDROPS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_syn_recv_sock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断全连接队列是不是满了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">goto</span> exit_overflow<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>exit_overflow<span class="token punctuation">:</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENOVERFLOWS<span class="token punctuation">)</span><span class="token punctuation">;</span>exit<span class="token punctuation">:</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENDROPS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到服务端在响应第一次握手和第三次握手的时候，在全队列满了时都会调用<code>NET_INC_STATS_BH</code>来增加<code>LINUX_MIB_LISTENOVERFLOWS</code>和<code>LINUX_MIB_LISTENDROPS</code>这两个MIB。</p><p>在proc.c中，这两个MIB会被整合到SNMP统计信息。</p><p>在执行netstat-s的时候，该工具会读取SNMP统计信息并展现出来。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#watch 'netstat -s | grep overflowed'</span>    <span class="token number">198</span> times the listen queue of a socket overflowed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过netstat -s输出中的xx times the listen queue如果查看到数字有变化，则说明一定是服务端上发生了全连接队列溢出了。</p><h4 id="2）半连接队列溢出判断"><a href="#2）半连接队列溢出判断" class="headerlink" title="2）半连接队列溢出判断"></a>2）半连接队列溢出判断</h4><p>半连接队列溢出时更新的是LINUX_MIB_LISTENDROPS这个MIB，然而不只是半连接队列发生溢出的时候会增加该值，全连接队列满了该值也会增加。所以根据netstat -s查看半连接队列是否溢出是不靠谱的。</p><p>对于半连接队列是否溢出这个问题，一般直接看服务器tcp_syncookies是不是1就行了。如果该值是1，那么根本不会发生半连接溢出丢包。而如果不是1，则建议改为1。</p><p>如果因为其他原因不想打开，那么除了netstat -s，也可以同时查看listen端口上的SYN_RECV的数量，如果该数量达到了半连接队列的长度（根据内核参数和自己传递的backlog可以计算出来）则可以确定有半连接队列溢出。</p><h3 id="七、问题解答"><a href="#七、问题解答" class="headerlink" title="七、问题解答"></a>七、问题解答</h3><ol><li>为什么服务端程序都需要先listen一下<ul><li>内核在响应listen调用的时候创建了半连接、全连接两个队列，这两个队列是三次握手中很重要的数据结构，有了它吗才能正常响应客户端的三次握手。所以服务器提供服务前都需要先listen一下才行。</li></ul></li><li>半连接队列和全连接队列长度如何确定<ul><li>半连接队列：max((min(backlog, somaxconn, tcp_max_syn_backlog) + 1)向上取整到2的幂次), 16)</li><li>全连接队列：min(backlog, somaxconn)</li></ul></li><li>“Cannot assign requested address”这个报错是怎么回事<ul><li>一条TCP连接由一个四元组构成，其中目的IP和端口以及自身的IP都是在连接建立前确定了的，只有自身的端口需要动态选择出来。客户端会在connect发起的时候自动选择端口号。具体的选择就是随机地从ip_local_port_range选择一个位置开始循环判断，跳过ip_local_reserver_ports里设置的要避开的端口，然后挨个判断是否可用。如果循环完也没有找到可用端口，就会抛出这个错误。</li></ul></li><li>一个客户端端口可以同时用在两条连接上吗<ul><li>connect调用在选择端口的时候如果端口没有被用上那就是可用的，但是如果被用过也不代表这个端口就不可用。</li><li>如果用过，则会去判断是否有老的连接四元组与当前要建立的这个新连接四元组完全一致，如果不完全一致则该端口仍然可用。</li></ul></li><li>服务端半/全连接队列满了会怎么样<ul><li>服务端响应第一次握手的时候会进行半连接队列和全连接队列是否满的判断<ul><li>如果半连接队列满了且未开启tcp_syncookies，丢弃握手包</li><li>如果全连接队列满了且存在young_acck，丢弃握手包</li></ul></li><li>服务端响应第三次握手的时候会进行全连接队列是否满的判断<ul><li>如果全连接队列满了则丢弃握手包</li></ul></li></ul></li><li>新连接的soket内核对象是什么时候建立的<ul><li>内核其实在第三次握手完毕的时候就把sock对象创建好了。在用户进程调用accept的时候，直接把该对象取出来，再包装一个socket对象就返回了。</li></ul></li><li>建立一条TCP连接需要消耗多长时间<ul><li>一般网络的RTT值根据服务器物理距离的不同大约是在零点几秒、几十毫秒之间。这个时间要比CPU本地的系统调用耗时长得多。所以正常情况下，在客户端或者是服务端看来，都基本上约等于一个RTT。</li><li>如果一旦出现了丢包，无论是那种原因，需要重传定时器来接入的话，耗时就最少要一秒了。</li></ul></li><li>服务器负载很正常，但是CPU被打到底了时怎么回事<ul><li>如果在端口极其不充足的情况下，connect系统调用的内部循环需要全部执行完毕才能判断出来没有端口可用。如果要发出的连接请求特别频繁，connect就会消耗掉大量的CPU。如果要发出的连接请求特别频繁，connect就会消耗掉大量的CPU。当服务器上的进程不多，但是每个进程都在疯狂的消耗CPU，这时候就会出现CPU被消耗光，但是服务器负载却不高的情况。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、相关实际问题&quot;&gt;&lt;a href=&quot;#一、相关实际问题&quot; class=&quot;headerlink&quot; title=&quot;一、相关实际问题&quot;&gt;&lt;/a&gt;一、相关实际问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;为什么服务端程序都需要先listen一下&lt;/li&gt;
&lt;li&gt;半连接队列和全连接队
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(五)</title>
    <link href="https://joytsing.github.io/posts/36379/"/>
    <id>https://joytsing.github.io/posts/36379/</id>
    <published>2024-04-05T09:03:52.000Z</published>
    <updated>2024-04-07T12:51:38.095Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、相关实际问题"><a href="#一、相关实际问题" class="headerlink" title="一、相关实际问题"></a>一、相关实际问题</h3><ol><li>127.0.0.1本机网络IO需要经过网卡吗</li><li>数据包在内核中是什么走向，和外网发送相比流程上有什么差别</li><li>访问本机服务时，使用127.0.0.1能比本机IP（例如192.168.x.x）快吗</li></ol><h3 id="二、跨机网络通信过程"><a href="#二、跨机网络通信过程" class="headerlink" title="二、跨机网络通信过程"></a>二、跨机网络通信过程</h3><p>在开始讲述本机通信过程之前，先回顾前面的跨机网络通信。</p><h4 id="1）跨机数据发送"><a href="#1）跨机数据发送" class="headerlink" title="1）跨机数据发送"></a>1）跨机数据发送</h4><p><img src="/posts/36379/905c9a70079c41958e9b0bf745ed53af.png" alt></p><ol><li>应用层：send/sendto</li><li>系统调用：（send=&gt;）<strong>sendto</strong><ol><li><strong>构造msghdr并赋值</strong>（用户待发送数据的指针、数据长度、发送标志等）</li><li>sock_sendmsg =&gt; __sock_sendmsg_nosec =&gt; <strong>sock-&gt;ops-&gt;sendmsg</strong></li></ol></li><li>协议栈：<strong>inet_sendmsg</strong>（AF_INET协议族对socck-&gt;ops-&gt;sendmsg的实现）<ul><li>传输层<ol><li><strong>sk-&gt;sk_prot-&gt;sendmsg</strong></li><li><strong>tcp_sendmsg</strong>（tcp协议对sk-&gt;sk_prot-&gt;sendmsg的实现）：<strong>数据拷贝到发送队列的skb</strong></li><li><strong>tcp_write_xmit：拥塞控制、滑动窗口、包分段</strong></li><li><strong>tcp_transmit_skb：拷贝skb、封装TCP头、调用网络层发送</strong></li></ol></li><li>网络层<ol><li><strong>ip_queue_xmit：查找socket缓存的路由表，没有则查找路由项并缓存，为skb设置路由表，封装IP头并发送</strong></li><li>ip_local_out =&gt; __ip_local_out =&gt; nf_hook：<strong>netfilter过滤</strong></li><li>skb_dst(skb)-&gt;output(skb)：找到skb路由表的dst条目，调用output方法</li><li>ip_output：<strong>简单的统计，再次执行netfilter过滤</strong>，回调ip_finish_output</li><li>ip_finish_output：<strong>校验数据包的长度，如果大于MTU，就会执行分片</strong></li><li>ip_finish_output2：调用邻居子系统定义的方法</li></ol></li></ul></li><li>邻居子系统<ol><li>rt_nexthop：<strong>获取路由下一跳的IP信息</strong></li><li>__ipv4_neigh_lookup_noref：<strong>根据下一条IP信息在arp缓存中查找邻居项</strong></li><li>__neigh_create：<strong>创建一个邻居项，并加入邻居哈希表</strong></li><li>dst_neigh_output =&gt; neighbour-&gt;output（实际指向neigh_resolve_output）：<ol><li><strong>封装MAC头（可能会先触发arp请求）</strong></li><li>调用dev_queue_xmit发送到下层</li></ol></li></ol></li><li>网络设备子系统<ol><li><strong>dev_queue_xmit：选择发送队列，获得排队规则，存在队列则调用__dev_xmit_skb</strong></li><li>__dev_xmit_skb：根据qdisc状态执行不同逻辑</li><li>q-&gt;enqueue：<strong>入队</strong></li><li><strong>__qdisc_run：开始发送</strong></li><li><strong>qdisc_restart *<em>=&gt; sch_direct_xmit =&gt; *</em>dev_hard_start_xmit</strong>：<strong>从队列取出一个skb并发送</strong></li><li>dev-&gt;netdev_ops-&gt;ndo_start_xmit：调用驱动里的发送回调函数，将数据包传给网卡设备</li></ol></li><li>驱动程序：igb_xmit_frame<ol><li>igb_xmit_frame_ring：<strong>获取发送环形数组队列下一个可用的缓冲区，挂上skb</strong></li><li>igb_tx_map：<strong>获取下一个描述符指针，将skb数据映射到网卡可访问的内存DMA区域</strong></li></ol></li><li>硬件发送<ol><li><strong>发送完毕触发硬中断通知CPU</strong></li><li>igb_msix_ring =&gt; napi_schedule =&gt; __raise_softirq_irqoff：硬中断处理，发起软中断</li><li>net_rx_action =&gt; igb_poll：软中断处理</li><li>igb_clean_tx_irq：<strong>释放skb，清除tx_buffer，清理DMA</strong></li></ol></li></ol><h4 id="2）跨机数据接收"><a href="#2）跨机数据接收" class="headerlink" title="2）跨机数据接收"></a>2）跨机数据接收</h4><ol><li>硬件<ol><li>网卡把帧DMA到内存</li><li>发起硬中断通知CPU</li></ol></li><li>驱动程序<ol><li>igb_msix_ring =&gt; napi_schedule =&gt; __raise_softirq_irqoff：硬中断处理，发起软中断</li><li>net_rx_action =&gt; igb_poll：软中断处理</li><li>igb_clean_rx_irq：<strong>从RingBuffer取出数据包进行初步处理、检查完整性等，并将其封装为sk_buff添加到网络接收队列</strong></li></ol></li><li>网络设备子系统：netif_receive_skb<ol><li>__netif_receive_skb_core：<strong>遍历ptype_all链表处理数据包（tcp_dump抓包点），遍历ptype_base哈希表处理数据包</strong></li><li>deliver_skb：根据上述遍历到的协议，<strong>传递给对应协议处理函数进行进一步的处理</strong>。例如IP数据包（ptype_base中）则将其传递给IP协议处理模块。</li></ol></li><li>网络协议栈处理：pt_prev-&gt;func<ul><li>网络层<ol><li>ip_rcv：<strong>通过Netfilter进行进一步处理</strong>，比如网络地址转换(NAT)、防火墙过滤等操作</li><li>ip_rcv_finish =&gt; ip_local_deliver_finish：使用inet_protos<strong>拿到协议的函数地址，根据包中的协议类型选择分发</strong>。在这里skb包将会进一步被派送到更上层的协议中，UDP或TCP</li></ol></li><li>传输层<ol><li>tcp_v4_rcv：<strong>获取tcp头和ip头，拿到目的ip地址和端口，找到对应的socket</strong></li><li>tcp_v4_do_rcv =&gt; tcp_rcv_established：<strong>将接收到的数据放到socket的接收队列尾部</strong>，并<strong>调用sk_data_ready来唤醒在socket上等待的用户进程</strong></li><li>sock_def_readable =&gt;autoremove_wake_function =&gt; default_wake_function：唤醒进程</li></ol></li></ul></li><li>用户进程<ol><li>系统调用recv =&gt; sock_recvmsg ==&gt; __sock_recvmsg ==&gt; __sock_recvmsg_nosec</li><li>sock-&gt;ops-&gt;recvmsg：在AF_INET中其指向的是inet_recvmsg</li><li>inet_recvmsg =&gt; sk-&gt;sk_prot-&gt;recvmsg：在SOCK_STREAM中它的实现是tcp_recvmsg</li><li>tcp_recvmsg：<strong>遍历接收队列，如果数据量不满足则阻塞进程</strong></li><li>sk_wait_data：<strong>定义了一个等待队列项wait</strong>，在这个新的等待队列项上<strong>注册了回调函数autoremove_wake_function</strong>，并把<strong>当前进程描述符current关联到其.private成员上，让出cpu进入睡眠</strong></li><li>睡眠===</li><li><strong>唤醒后继续遍历队列接收数据</strong></li></ol></li></ol><h4 id="3）跨机网络通信汇总"><a href="#3）跨机网络通信汇总" class="headerlink" title="3）跨机网络通信汇总"></a>3）跨机网络通信汇总</h4><p><img src="/posts/36379/371fb77993524d25960f79688ee38136.png" alt></p><h3 id="三、本机发送过程"><a href="#三、本机发送过程" class="headerlink" title="三、本机发送过程"></a>三、本机发送过程</h3><p>上面主要介绍了跨机时整个网络的发送过程， 而在本机网络IO过程中，会有一些差别。主要的差异有两部分，分别是路由和驱动程序。</p><h4 id="1）网络层路由"><a href="#1）网络层路由" class="headerlink" title="1）网络层路由"></a>1）网络层路由</h4><p><img src="/posts/36379/b6ad411f22094f07ad1c3b4739525ee4.png" alt></p><p>发送数据进入协议栈到达网络层的时候，网络层入口函数是ip_queue_xmit。在网络层里会进行路由选择，路由选择完毕再设置一些IP头，进行一些Netfilter的过滤，数据包分片等操作，然后将包交给邻居子系统。</p><p>对于本机网络IO来说，特殊之处在于<strong>在local路由表中就可以找到路由项，对应的设备都是用loopback网卡，也就是常说的lo设备</strong>。</p><p>我们重新回到之前网络层查找路由项的部分代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ip_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> flowi <span class="token operator">*</span>fl<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 检查socket中是否有缓存的路由表</span>    rt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> rtable<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">__sk_dst_check</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>rt <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 没有缓存则展开查找路由项并缓存到socket中</span>    rt <span class="token operator">=</span> <span class="token function">ip_route_output_ports</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">sk_setup_caps</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-></span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1234567891011</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查找路由项的函数时ip_route_output_ports，它经过层层调用，来到关键的部分——fib_lookup</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">fib_lookup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> flowi4 <span class="token operator">*</span>flp<span class="token punctuation">,</span> <span class="token keyword">struct</span> fib_result <span class="token operator">*</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> fib_table <span class="token operator">*</span>table<span class="token punctuation">;</span>    table <span class="token operator">=</span> <span class="token function">fib_get_table</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> RT_TABLE_LOCAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">fib_table_lookup</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> flp<span class="token punctuation">,</span> res<span class="token punctuation">,</span> FIB_LOOKUP_NOREF<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 查找与给定流（由flp指定）匹配的路由项，并将查找结果存储在res中。FIB_LOOKUP_NOREF是传递给此函数的标志，用于指定查找行为的一些细节。</span>    <span class="token comment" spellcheck="true">// 查找成功返回0</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> <span class="token function">fib_get_table</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> RT_TABLE_MAIN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">fib_table_lookup</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> flp<span class="token punctuation">,</span> res<span class="token punctuation">,</span> FIB_LOOKUP_NOREF<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span>ENETUNREACH<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">12345678910111213</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在fib_lookup中将<strong>会对local和main两个路由表展开查询，并且先查询local后查询main</strong>。我们在Linux上使用ip命令可以查看到这两个路由表，这里只看local路由表（因为本机网络IO查询到整个表就结束了）</p><pre class="line-numbers language-cmd"><code class="language-cmd">#ip route list table locallocal 10.143.x.y dev eth0 proto kernel scope host src 10.143.x.ylocal 127.0.0.1 dev lo proto kernel host src 127.0.0.1123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从上述结果可以看出127.0.0.1的路由在local路由表中就能够找到。</p><blockquote><p>上面路由表中10.143.x.y dev eth0是本机的局域网IP，虽然写的是dev eth0，但是其实内核在初始化local路由表的时候，把local路由表里所有的路由项都设置为了RTN_LOCAL。所以即使本机IP不用环回地址，内核在路由项查找的时候判断类型是RTN_LOCAL，仍然会使用net-&gt;loopback_dev，也就是lo虚拟网卡。</p><p>此处可以使用tcpdump -i eht0 port 8888以及telnet 10.143.x.y 8888进行验证，telnet后tcpdump并不会收到网络请求，因为发给的是lo。</p></blockquote><p>之后fib_lookup的工作完成，返回上一层__ip_route_output_key函数继续执行。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> rtable <span class="token operator">*</span><span class="token function">ip_route_output_key</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> flowi4 <span class="token operator">*</span>fl4<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fib_lookup</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> fl4<span class="token punctuation">,</span> <span class="token operator">&amp;</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>type <span class="token operator">==</span> RTN_LOCAL<span class="token punctuation">)</span> <span class="token punctuation">{</span>      dev_out <span class="token operator">=</span> net<span class="token operator">-></span>loopback_dev<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token number">12345678910</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对于本机的网络请求，设备将全部使用net-&gt;loopback_dev，也就是lo虚拟网卡。接下来的网络层仍然和跨机网络IO一样（所以本机网络IO如果skb大于MTU仍然会进行分片，不过lo虚拟网卡(65535)的MTU(1500)比Ethernet大得多），最终会经过ip_finish_output，进入邻居子系统的入口函数dst_neigh_output</strong>。</p><p>在邻居子系统函数中经过处理后，进入网络设备子系统（入口函数是dev_queue_xmit）</p><h4 id="2）网络设备子系统"><a href="#2）网络设备子系统" class="headerlink" title="2）网络设备子系统"></a>2）网络设备子系统</h4><p>网络设备子系统的入口函数是dev_queue_xmit，其中会<strong>判断是否有队列</strong>。<strong>对于有队列的物理设备，该函数进行了一系列复杂的排队等处理后，才调用dev_hard_start_xmit，从这个函数在进入驱动程序igb_xmit_frame来发送</strong>。在这个过程中还可能触发软中断进行发送。</p><p>但是<strong>对于启动状态的回环设备</strong>（q-&gt;enqueue判断为false）来说就简单多了，它<strong>没有队列的问题，直接进入dev_hard_start_xmit</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dev_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    q <span class="token operator">=</span> <span class="token function">rcu_dereference_bh</span><span class="token punctuation">(</span>txq_qdisc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">-></span>enqueue<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 回环设备这里返回false</span>      rc <span class="token operator">=</span> <span class="token function">__dev_xmit_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 开始回环设备处理</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>dev<span class="token operator">-></span>flags <span class="token operator">&amp;</span> IFF_UP<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">12345678910111213</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在dev_hard_start_xmit函数中还将调用设备驱动的操作函数，对<strong>于回环设备的而言，其“设备驱动”的操作函数ops-&gt;ndo_start_xmit指向的是loopback_xmit</strong>（不同于正常网络设备的igb_xmit_frame）。</p><p><img src="/posts/36379/031af9965aea406c88692f7ca8c55793.png" alt></p><p><img src="/posts/36379/dd2484c6c34746579ffd367efb80eec7.png" alt></p><h4 id="3）驱动程序"><a href="#3）驱动程序" class="headerlink" title="3）驱动程序"></a>3）驱动程序</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> netdev_tx_t <span class="token function">loopback_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> net_device <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 剥离掉和源socket的联系</span>    <span class="token function">skb_orphan</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用netif_rx</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">netif_rx</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span> <span class="token operator">==</span> NET_RX_SUCCESS<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>loopback_xmit中首先调用skb_orphan先把skb上的socket指针去掉了，接着调用netif_tx，在该方法中最终会执行到enqueue_to_backlog。</strong></p><blockquote><p>在本机IO发送的过程中，传输层下面的skb就不需要释放了，直接给接收方传过去就行。不过传输层的skb就节约不了，还是需要频繁地申请和释放。</p></blockquote><p><img src="/posts/36379/2c95c6ac11f046adab03100275efee3e.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">enqueue_to_backlog</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">int</span> cpu<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>qtail<span class="token punctuation">)</span><span class="token punctuation">{</span>    sd <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>softnet_data<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">__skb_queue_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>input_pkt_queue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">__napi_schedule</span><span class="token punctuation">(</span>sd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sd<span class="token operator">-></span>backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">12345678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>enqueue_to_backlog函数用于<strong>把要发送的skb插入softnet_data-&gt;input_pkt_queue队列</strong></p><p>具体步骤如下：</p><ol><li>sd = &amp;per_cpu(softnet_data, cpu)：获取给定 CPU 的softnet_data结构。这个结构保存了这个 CPU 的一些网络处理状态和数据，比如input_pkt_queue。</li><li>__skb_queue_tail(&amp;sd-&gt;input_pkt_queue, skb)：将数据包skb加入到input_pkt_queue队列的尾部。</li><li>__napi_schedule(sd, &amp;sd-&gt;backlog)：调度该函数来触发软中断处理这个队列。</li></ol><p>这里<strong>触发的软中断类型是NET_RX_SOFTIRQ</strong>，只有触发完软中断，发送过程才算完成了。</p><h3 id="四、本机接收过程"><a href="#四、本机接收过程" class="headerlink" title="四、本机接收过程"></a>四、本机接收过程</h3><p>发送过程触发软中断后，会进入软中断处理函数net_rx_action。</p><p><img src="/posts/36379/28e7da137a7845cbaab82ba100861be8.png" alt></p><p><strong>在跨机地网络包地接收过程中，需要经过硬中断，然后才能触发软中断。而在本机地网络IO过程中，由于并不真的过网卡，所以网卡地发送过程、硬中断就都省去了，直接从软中断开始。</strong></p><p>对于igb网卡来说，软中断中轮询调用的poll函数指向的是igb_poll函数。而对于loopback网卡来说，poll函数是process_backlog。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process_backlog</span><span class="token punctuation">(</span><span class="token keyword">struct</span> napi_struct <span class="token operator">*</span>napi<span class="token punctuation">,</span> <span class="token keyword">int</span> quota<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>skb <span class="token operator">=</span> <span class="token function">__skb_dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>process_queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">__netif_receive_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// skb_queue_splice_tail_init()函数用来将链表a(输入队列)的元素链接到链表b(处理队列)上</span>     <span class="token comment" spellcheck="true">// 形成一个新的链表b，并将原来a的头变成了空链表</span>     qlen <span class="token operator">=</span> <span class="token function">skb_queue_len</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>input_pkt_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>qlen<span class="token punctuation">)</span>        <span class="token function">skb_queue_splice_tail_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>input_pkt_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sd<span class="token operator">-></span>process_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1234567891011121314</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数用于反复处理队列中的数据包，直到队列为空或者处理的数据包数量达到了指定的配额（quota）。</p><p>在内层循环中，它使用 __skb_dequeue() 函数<strong>从 process_queue 中取出一个数据包，然后使用 __netif_receive_skb() 函数处理这个数据包</strong>。</p><p>在内层循环结束后，它<strong>检查 input_pkt_queue（输入数据包队列）是否还有剩余的数据包</strong>。如果有，它<strong>使用 skb_queue_splice_tail_init() 函数将 input_pkt_queue 中的数据包移动到 process_queue 中</strong>，然后在下一次内层循环中继续处理这些数据包。</p><p><strong>__netif_receive_skb用于将数据送往协议栈，在此之后的调用过程就和跨机网络的IO又一致了</strong>：__netif_receive_skb =&gt; __netif_receive_skb_core =&gt; deliver_skb，然后再将数据送入ip_rcv中进行后续操作。</p><p><img src="/posts/36379/e492262233c94d3ca37656becc5f263b.png" alt></p><h3 id="五、问题解答"><a href="#五、问题解答" class="headerlink" title="五、问题解答"></a>五、问题解答</h3><ol><li>127.0.0.1本机网络IO需要经过网卡吗<ul><li>不需要经过网卡，即使网卡拔了也可以正常使用本机网络</li></ul></li><li>数据包在内核中是什么走向，和外网发送相比流程上有什么差别<ul><li>节约了驱动上的一些开销。发送数据不需要静茹RingBuffer的驱动队列，直接把skb传给接收协议栈。</li><li>其他组件，包括系统调用、协议栈、设备子系统都经过了，甚至驱动程序也运行了，所以还是有一定的开销的。</li><li>如果想要再本机网络IO上绕开协议栈的开销，可以动用eBPF，用eBPF的sockmap和sk redirect可以达到真正不走协议栈的目的。</li></ul></li><li>访问本机服务时，使用127.0.0.1能比本机IP（例如192.168.x.x）快吗<ul><li>本机IP和127.0.0.1没有差别，都是走的环回设备lo</li><li>这是因为内核在设置IP的时候，把所有的本机IP都初始化到了local路由表里，类型写死了是RTN_LOCAL。所以后面的路由项选择的时候发现类型是RTN_LOCAL就会选择lo设备。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、相关实际问题&quot;&gt;&lt;a href=&quot;#一、相关实际问题&quot; class=&quot;headerlink&quot; title=&quot;一、相关实际问题&quot;&gt;&lt;/a&gt;一、相关实际问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;127.0.0.1本机网络IO需要经过网卡吗&lt;/li&gt;
&lt;li&gt;数据包在内核中是
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>有关Linux下的零拷贝技术</title>
    <link href="https://joytsing.github.io/posts/44422/"/>
    <id>https://joytsing.github.io/posts/44422/</id>
    <published>2024-04-02T09:16:35.000Z</published>
    <updated>2024-04-10T09:00:44.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>零拷贝技术是一种<code>IO</code>操作优化技术。可以快速高效地将数据从文件系统移动到网络接口，<strong>而不需要将其从内核空间复制到用户空间。</strong></p><h2 id="一-相关概念"><a href="#一-相关概念" class="headerlink" title="一. 相关概念"></a>一. 相关概念</h2><p>用户进行<code>IO</code>操作，其实也就是应用程序访问系统资源，即通过系统调用 或者中断（外中断、内中断）<strong>从而使得 <code>CPU</code> 从用户态转向内核态。</strong></p><p>系统调用其实就是一些函数，用于对文件和设备进行访问和控制。最常见的有两种：</p><ul><li><code>read</code>：从文件中读取内容。</li><li><code>write</code>：往文件中写入内容。</li></ul><h3 id="1-1-缓冲区"><a href="#1-1-缓冲区" class="headerlink" title="1.1 缓冲区"></a>1.1 缓冲区</h3><p>在复习<code>IO</code>模型相关的知识的时候，就遇到这么两个概念：</p><ul><li><strong>内核缓冲区。</strong></li><li><strong>用户缓冲区。</strong></li></ul><p>这个到底有什么区别呢？我们知道，我们的应用程序从磁盘上读取数据的时候，一般都是分成两步：</p><ol><li><strong>操作系统（内核）从磁盘上读取数据存到内核空间。</strong></li><li><strong>再把数据从内核空间拷贝到用户空间。</strong></li></ol><p>那么这个过程中就会涉及到<strong>两次</strong>数据读操作：</p><ol><li>从<strong>磁盘</strong>上读取。</li><li>从<strong>内存</strong>中读取。</li></ol><p>而<strong>访问磁盘的速度要远远小于访问内存的速度</strong>，那么整个读取数据的操作中耗费时长最长的阶段自然在磁盘读取上。因此出现了内核缓冲区以及对应的用户缓冲区。至于具体流程可以看另外几篇博文。</p><h4 id="1-1-1-内核缓冲区"><a href="#1-1-1-内核缓冲区" class="headerlink" title="1.1.1 内核缓冲区"></a>1.1.1 内核缓冲区</h4><p>内核缓冲区，其实可以从两个方向去理解：</p><ul><li><strong>缓冲</strong>：<code>Buffer</code>。</li><li><strong>缓存</strong>：<code>Cache</code>。</li></ul><p>它的作用如下：</p><ul><li><strong>数据预读（缓存功能）</strong>：当程序发起<code>read</code>系统调用的时候，<strong>内核会读更多磁盘上的数据，以备程序后续使用</strong>。（假设我的<code>read</code>请求可能只需要读<code>100KB</code>的数据，那么此时内核会读<code>200KB</code>，就是这个意思。）</li><li><strong>延时回写（缓冲功能）</strong>：当程序发起 <code>write</code> 系统调用时，<strong>内核并不会直接把数据写入到磁盘文件中，而是写入到缓冲区中。当缓冲区中的数据积累到一定程度，才将数据真正地刷新到磁盘中。</strong></li></ul><h4 id="1-1-2-用户缓冲区"><a href="#1-1-2-用户缓冲区" class="headerlink" title="1.1.2 用户缓冲区"></a>1.1.2 用户缓冲区</h4><p>用户缓冲区的作用和内核缓冲区一样，都是数据的预读以及延时回写。不过两者出现的目的还是不一样：</p><ul><li>内核缓冲区：主要处理的是内核空间和磁盘之间的数据传递，<strong>目的是减少访问磁盘的次数。</strong></li><li>用户缓冲区：主要处理的是用户空间和内核空间之间的数据传递，<strong>目的是减少系统调用的次数。</strong></li></ul><h3 id="1-2-DMA技术"><a href="#1-2-DMA技术" class="headerlink" title="1.2 DMA技术"></a>1.2 DMA技术</h3><p><code>DMA</code>的全称：<code>Direct Memory Access</code>，直接存储器访问。<code>DMA</code>传输<strong>将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。</strong></p><p>为什么要有<code>DMA</code>技术？我们来看下<code>IO</code>操作的前后流程对比：<br><img src="/posts/44422/929e089c44174984a067f1b11008629f.png" alt><br>总结就是：<strong><code>DMA</code>帮助<code>CPU</code>将数据从磁盘拷贝至内核缓冲区中，让<code>CPU</code>解放双手。</strong></p><h3 id="1-3-虚拟内存"><a href="#1-3-虚拟内存" class="headerlink" title="1.3 虚拟内存"></a>1.3 虚拟内存</h3><p>虚拟内存：<strong>即拿出一部分硬盘空间来充当内存使用</strong>，当内存占用完时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。一般虚拟内存都用来替代一部分物理内存的，有这么几个好处：</p><ol><li>多个虚拟内存可以指向同一个物理地址（<strong>多对一</strong>）。</li><li>虚拟内存空间可以远远大于物理内存空间（<strong>空间大</strong>）。</li></ol><h2 id="二-零拷贝"><a href="#二-零拷贝" class="headerlink" title="二. 零拷贝"></a>二. 零拷贝</h2><h3 id="2-1-传统文件传输流程"><a href="#2-1-传统文件传输流程" class="headerlink" title="2.1 传统文件传输流程"></a>2.1 传统文件传输流程</h3><p>我们用一个最基本的文件读取操作来看下流程，无非分为两个步骤：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">read</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> tmp_buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> tmp_buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>将磁盘上的文件读取出来。</li><li>将文件数据通过网络协议发送给客户端。</li></ol><p>流程图如下：</p><p><img src="/posts/44422/1.png" alt></p><p>这里能得到几个信息：</p><ol><li>期间完成了<strong>4次</strong>数据拷贝。</li><li>完成了<strong>4次</strong>的用户态和内核态之间的状态切换，我们简称上下文切换。</li></ol><p><strong>备注：每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。因此相当于2次上下文切换。</strong>问题就是：再这样的传统<code>IO</code>传输模型中，用户为了获取服务器上的某个数据，期间竟然有4次数据的搬运过程，<strong>而过多的数据拷贝会消耗CPU资源，在高并发的情况下更是大大降低了系统的性能。</strong></p><p><strong>如何减少用户态和内核态之间的上下文切换以及内存拷贝的次数”</strong> 成了提高文件传输性能的一个关键点。</p><h3 id="2-2-零拷贝技术原理"><a href="#2-2-零拷贝技术原理" class="headerlink" title="2.2 零拷贝技术原理"></a>2.2 零拷贝技术原理</h3><p>还记得上文提到的虚拟内存的概念吗？零拷贝技术中就用到了虚拟内存可以多对一的一个特性：<strong>将内核空间和用户空间的虚拟地址映射到同一个物理地址，这样在 I/O 操作时就不需要来回复制了。</strong></p><p>零拷贝实现的方式有多种：</p><ul><li><code>mmap + write</code></li><li><code>sendfile</code></li><li><code>sendfile+DMA收集</code></li><li><code>splice</code></li></ul><h4 id="2-2-1-mmap-write"><a href="#2-2-1-mmap-write" class="headerlink" title="2.2.1 mmap+ write"></a>2.2.1 mmap+ write</h4><p><code>mmap()</code>函数也是属于系统函数的一种，在 2.1 节当中，我们知道<code>read()</code>函数<strong>会把内核缓冲区的数据拷贝到用户的缓冲区里。</strong> 而<code>mmap()</code>函数就可以减少这一步开销，因为它会<strong>直接把内核缓冲区里的数据映射到用户空间。</strong>那么这种模式下，文件传输模型图就会有所改变：</p><p><img src="/posts/44422/795ab30d4d2d4ce6a807f2ca4ffc12df.png" alt></p><p><strong>具体过程如下：</strong></p><ul><li>应用进程调用了 mmap() 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li><li>应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li><li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul><p>可以看到：</p><ol><li>虽然说拷贝过程从原来的4次—-&gt;3次。</li><li>但是系统调用依旧是2次。原本：<code>read + write</code>。现在：<code>mmap + write</code>。</li></ol><h4 id="2-2-2-sendfile-amp-amp-sendfile-DMA收集"><a href="#2-2-2-sendfile-amp-amp-sendfile-DMA收集" class="headerlink" title="2.2.2 sendfile&amp;&amp;sendfile+DMA收集"></a>2.2.2 sendfile&amp;&amp;sendfile+DMA收集</h4><p><code>sendfile()</code>是一个专门发送文件的系统调用函数，由于 sendfile 仅仅对应一次系统调用，而传统文件操作则需要使用 read 以及 write 两个系统调用。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span>ssize_t <span class="token function">sendfile</span><span class="token punctuation">(</span><span class="token keyword">int</span> out_fd<span class="token punctuation">,</span> <span class="token keyword">int</span> in_fd<span class="token punctuation">,</span> off_t <span class="token operator">*</span>offset<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>out_fd</code>：目的端的文件描述符。</li><li><code>in_fd</code>：源端文件描述符。</li><li><code>offset</code>：源端数据偏移量。</li><li><code>count</code>：复制数据的长度。</li></ul><p>最终的返回是实际复制数据的长度。该函数的作用主要有两点：</p><ol><li>可以同时替代<code>read(</code>)和<code>write()</code>函数。<strong>即可以减少一次系统调用。</strong></li><li>通过<code>SG-DMA</code>控制器减少数据拷贝的次数。</li></ol><p>这个<code>SG</code>的前缀是什么意思呢？</p><blockquote><p><code>SG：scatter-gather</code>。其原理就是在内核空间 <code>Read Buffer</code> 和 <code>Socket Buffer</code> <strong>不做数据复制，而是将 <code>Read Buffer</code> 的内存地址、偏移量记录到相应的 <code>Socket Buffer</code> 中</strong>，这样就不需要复制。其本质和虚拟内存的解决方法思路一致，就是内存地址的记录。</p></blockquote><p>流程如下：</p><ol><li>通过 <code>DMA</code> 将磁盘上的数据拷贝到内核缓冲区里。</li><li>将缓冲区描述符和数据长度传到 <code>socket</code> 缓冲区，<strong><code>SG-DMA</code>控制器直接将内核缓存中的数据拷贝到网卡的缓冲区里，</strong> 因此不需要将内核缓冲区的数据拷贝到<code>socket</code>缓冲区中。</li></ol><p>如图：</p><p><img src="/posts/44422/cfd077077e0145938fa085f78daad0a5.png" alt></p><p>这就是零拷贝技术。即没有再内存层面去拷贝数据，整个过程中<code>CPU</code>都没有参与数据的拷贝，都是交给<code>DMA</code>来完成。</p><p>相对于传统的文件传输方式，零拷贝的优势：</p><ol><li>减少了2次上下文切换和数据拷贝。</li><li>2次的数据拷贝过程中，无需<code>CPU</code>参与，因此<code>CPU</code>可以在此期间做其他事情。</li></ol><p><strong>注意：零拷贝并不是说数据传输过程中拷贝的次数为0，而是指不存在内存层面的数据拷贝（一共2次）。</strong>因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</p><h4 id="2-2-3-splice方式"><a href="#2-2-3-splice方式" class="headerlink" title="2.2.3 splice方式"></a>2.2.3 splice方式</h4><p>splice系统调用是Linux 在 2.6 版本引入的，其不需要硬件支持，并且不再限定于socket上，实现两个普通文件之间的数据零拷贝。</p><p><code>splice</code> 调用和<code>sendfile</code> 非常相似，用户应用程序必须拥有两个已经打开的文件描述符，一个表示输入设备，一个表示输出设备。与<code>sendfile</code>不同的是，<code>splice</code>允许任意两个文件互相连接，而并不只是文件与<code>socket</code>进行数据传输。对于从一个文件描述符发送数据到<code>socket</code>这种特例来说，一直都是使用<code>sendfile</code>系统调用，而<code>splice</code>一直以来就只是一种机制，它并不仅限于<code>sendfile</code>的功能。也就是说 sendfile 是 splice 的一个子集。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>无论是传统的 I/O 方式，还是引入了零拷贝之后，2 次 <code>DMA copy</code>是都少不了的。因为两次 DMA 都是依赖硬件完成的。所以，所谓的零拷贝，都是为了减少 CPU copy 及减少了上下文的切换。</p><p>下图展示了各种零拷贝技术的对比图：</p><table><thead><tr><th></th><th>CPU拷贝</th><th>DMA拷贝</th><th>系统调用</th><th>上下文切换</th></tr></thead><tbody><tr><td>传统方法</td><td>2</td><td>2</td><td>read/write</td><td>4</td></tr><tr><td>内存映射</td><td>1</td><td>2</td><td>mmap/write</td><td>4</td></tr><tr><td>sendfile</td><td>1</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>scatter/gather copy</td><td>0</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>splice</td><td>0</td><td>2</td><td>splice</td><td>0</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;零拷贝技术是一种&lt;code&gt;IO&lt;/code&gt;操作优化技术。可以快速高效地将数据从文件系统移动到网络接口，&lt;strong&gt;而不需要将其从内核
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/categories/Linux/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>当Redis碰上消息队列</title>
    <link href="https://joytsing.github.io/posts/24283/"/>
    <id>https://joytsing.github.io/posts/24283/</id>
    <published>2024-04-02T09:03:55.000Z</published>
    <updated>2024-04-07T12:54:29.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一开始在不熟悉的时候当我听到Redis可以当消息队列来用是很奇怪的，后面了解才知道与专业的队列中间件相比各有优劣。</p><h2 id="List队列"><a href="#List队列" class="headerlink" title="List队列"></a>List队列</h2><p>如果你的业务需求足够简单，想把 Redis 当作队列来使用，肯定最先想到的就是使用 List 这个数据类型。因为 List 底层的实现就是一个「链表」，在头部和尾部操作元素，时间复杂度都是 O(1)，这意味着它非常符合消息队列的模型。如果把 List 当作队列，你可以这么来用。</p><p>生产者使用 LPUSH 发布消息：</p><pre class="line-numbers language-sh"><code class="language-sh">127.0.0.1:6379> LPUSH queue msg1(integer) 1127.0.0.1:6379> LPUSH queue msg2(integer) 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>消费者这一侧，使用 RPOP 拉取消息：</p><pre class="line-numbers language-sh"><code class="language-sh">127.0.0.1:6379> RPOP queue"msg1"127.0.0.1:6379> RPOP queue"msg2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个模型非常简单，也很容易理解。</p><p><img src="/posts/24283/640.webp" alt></p><p>但这里有个小问题，当队列中已经没有消息了，消费者在执行 RPOP 时，会返回 NULL。</p><pre class="line-numbers language-sh"><code class="language-sh">127.0.0.1:6379> RPOP queue(nil)   // 没消息了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而我们在编写消费者逻辑时，一般是一个「死循环」，这个逻辑需要不断地从队列中拉取消息进行处理，伪代码一般会这么写：</p><pre class="line-numbers language-sh"><code class="language-sh">while true:    msg = redis.rpop("queue")    // 没有消息，继续循环    if msg == null:        continue    // 处理消息    handle(msg)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果此时队列为空，那消费者依旧会频繁拉取消息，这会造成「CPU 空转」，不仅浪费 CPU 资源，还会对 Redis 造成压力。Redis 是否存在这样一种机制：如果队列为空，消费者在拉取消息时就「阻塞等待」，一旦有新消息过来，就通知我的消费者立即处理新消息呢？Redis 提供了「阻塞式」拉取消息的命令：BRPOP / BLPOP，这里的 B 指的是阻塞（Block）。</p><p><img src="/posts/24283/640-1711972064075-3.webp" alt></p><p>现在，你可以这样来拉取消息了：</p><pre class="line-numbers language-sh"><code class="language-sh">while true:    // 没消息阻塞等待，0表示不设置超时时间    msg = redis.brpop("queue", 0)    if msg == null:        continue    // 处理消息    handle(msg)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 BRPOP 这种阻塞式方式拉取消息时，还支持传入一个「超时时间」，如果设置为 0，则表示不设置超时，直到有新消息才返回，否则会在指定的超时时间后返回 NULL。这个方案不错，既兼顾了效率，还避免了 CPU 空转问题，一举两得。</p><blockquote><p>注意：如果设置的超时时间太长，这个连接太久没有活跃过，可能会被 Redis Server 判定为无效连接，之后 Redis Server 会强制把这个客户端踢下线。所以，采用这种方案，客户端要有重连机制。</p></blockquote><p>解决了消息处理不及时的问题，你可以再思考一下，这种队列模型，有什么缺点？我们一起来分析一下：</p><ol><li><strong>不支持重复消费</strong>：消费者拉取消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费，即不支持多个消费者消费同一批数据</li><li><strong>消息丢失</strong>：消费者拉取到消息后，如果发生异常宕机，那这条消息就丢失了</li></ol><p>第一个问题是功能上的，使用 List 做消息队列，它仅仅支持最简单的，一组生产者对应一组消费者，不能满足多组生产者和消费者的业务场景。</p><p>第二个问题就比较棘手了，因为从 List 中 POP 一条消息出来后，这条消息就会立即从链表中删除了。也就是说，无论消费者是否处理成功，这条消息都没办法再次消费了。</p><p>这也意味着，如果消费者在处理消息时异常宕机，那这条消息就相当于丢失了。针对这 2 个问题怎么解决呢？我们一个个来看。</p><h2 id="发布-订阅模型：Pub-Sub"><a href="#发布-订阅模型：Pub-Sub" class="headerlink" title="发布/订阅模型：Pub/Sub"></a>发布/订阅模型：Pub/Sub</h2><p>从名字就能看出来，这个模块是 Redis 专门是针对「发布/订阅」这种队列模型设计的。它正好可以解决前面提到的第一个问题：重复消费。即多组生产者、消费者的场景，我们来看它是如何做的：</p><p>Redis 提供了 PUBLISH / SUBSCRIBE 命令，来完成发布、订阅的操作。</p><p><img src="/posts/24283/640-1711972384594-6.webp" alt></p><p>假设你想开启 2 个消费者，同时消费同一批数据，就可以按照以下方式来实现。</p><p>首先，使用 SUBSCRIBE 命令，启动 2 个消费者，并「订阅」同一个队列。</p><pre><code>// 2个消费者 都订阅一个队列127.0.0.1:6379&gt; SUBSCRIBE queueReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;queue&quot;3) (integer) 1</code></pre><p>此时，2 个消费者都会被阻塞住，等待新消息的到来。之后，再启动一个生产者，发布一条消息。</p><pre><code>127.0.0.1:6379&gt; PUBLISH queue msg1(integer) 1</code></pre><p>这时，2 个消费者就会解除阻塞，收到生产者发来的新消息。</p><pre><code>127.0.0.1:6379&gt; SUBSCRIBE queue// 收到新消息1) &quot;message&quot;2) &quot;queue&quot;3) &quot;msg1&quot;</code></pre><p>看到了么，使用 Pub/Sub 这种方案，既支持阻塞式拉取消息，还很好地满足了多组消费者，消费同一批数据的业务需求。除此之外，Pub/Sub 还提供了「匹配订阅」模式，允许消费者根据一定规则，订阅「多个」自己感兴趣的队列。</p><pre><code>// 订阅符合规则的队列127.0.0.1:6379&gt; PSUBSCRIBE queue.*Reading messages... (press Ctrl-C to quit)1) &quot;psubscribe&quot;2) &quot;queue.*&quot;3) (integer) 1</code></pre><p>这里的消费者，订阅了 queue.* 相关的队列消息。之后，生产者分别向 queue.p1 和 queue.p2 发布消息。</p><pre><code>127.0.0.1:6379&gt; PUBLISH queue.p1 msg1(integer) 1127.0.0.1:6379&gt; PUBLISH queue.p2 msg2(integer) 1</code></pre><p>这时再看消费者，它就可以接收到这 2 个生产者的消息了。</p><pre><code>127.0.0.1:6379&gt; PSUBSCRIBE queue.*Reading messages... (press Ctrl-C to quit)...// 来自queue.p1的消息1) &quot;pmessage&quot;2) &quot;queue.*&quot;3) &quot;queue.p1&quot;4) &quot;msg1&quot;// 来自queue.p2的消息1) &quot;pmessage&quot;2) &quot;queue.*&quot;3) &quot;queue.p2&quot;4) &quot;msg2&quot;</code></pre><p><img src="/posts/24283/640-1711972490726-9.webp" alt></p><p>我们可以看到，Pub/Sub 最大的优势就是，支持多组生产者、消费者处理消息。讲完了它的优点，那它有什么缺点呢？Pub/Sub 最大问题是：<strong>丢数据</strong>。如果发生以下场景，就有可能导致数据丢失：</p><ol><li>消费者下线</li><li>Redis 宕机</li><li>消息堆积</li></ol><p>这与 Pub/Sub 的实现方式有很大关系。Pub/Sub 在实现时非常简单，它没有基于任何数据类型，也没有做任何的数据存储，它只是单纯地为生产者、消费者建立「数据转发通道」，把符合规则的数据，从一端转发到另一端，一个完整的发布、订阅消息处理流程是这样的：</p><ol><li>消费者订阅指定队列，Redis 就会记录一个映射关系：队列-&gt;消费者</li><li>生产者向这个队列发布消息，那 Redis 就从映射关系中找出对应的消费者，把消息转发给它</li></ol><p><img src="/posts/24283/640-1711972524653-12.webp" alt></p><p>整个过程中，没有任何的数据存储，一切都是实时转发的。这种设计方案，就导致了上面提到的那些问题。例如，如果一个消费者异常挂掉了，它再重新上线后，只能接收新的消息，在下线期间生产者发布的消息，因为找不到消费者，都会被丢弃掉。</p><p>如果所有消费者都下线了，那生产者发布的消息，因为找不到任何一个消费者，也会全部「丢弃」。所以，当你在使用 Pub/Sub 时，一定要注意：<strong>消费者必须先订阅队列，生产者才能发布消息，否则消息会丢失。</strong></p><p>这也是前面例子让消费者先订阅队列，之后才让生产者发布消息的原因。另外，因为 Pub/Sub 没有基于任何数据类型实现，所以它也不具备「数据持久化」的能力。也就是说，Pub/Sub 的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，Pub/Sub 的数据也会全部丢失。</p><p>最后来看 Pub/Sub 在处理「消息积压」时，为什么也会丢数据？当消费者的速度，跟不上生产者时，就会导致数据积压的情况发生。如果采用 List 当作队列，消息积压时，会导致这个链表很长，最直接的影响就是，Redis 内存会持续增长，直到消费者把所有数据都从链表中取出。但 Pub/Sub 的处理方式却不一样，当消息积压时，有可能会导致<strong>消费失败和消息丢失</strong>！</p><p>回到 Pub/Sub 的实现细节上来说。每个消费者订阅一个队列时，Redis 都会在 Server 上给这个消费者在分配一个「缓冲区」，这个缓冲区其实就是一块内存。生产者发布消息时，Redis 先把消息写到对应消费者的缓冲区中。之后，消费者不断地从缓冲区读取消息，处理消息。</p><p><img src="/posts/24283/640-1711972615643-15.webp" alt></p><p>问题就出在这个缓冲区上。因为这个缓冲区其实是有「上限」的（可配置），如果消费者拉取消息很慢，就会造成生产者发布到缓冲区的消息开始积压，缓冲区内存持续增长。如果超过了缓冲区配置的上限，此时，Redis 就会「强制」把这个消费者踢下线。这时消费者就会消费失败，也会丢失数据。如果看过 Redis 的配置文件，可以看到这个缓冲区的默认配置：<code>client-output-buffer-limit pubsub 32mb 8mb 60</code>。它的参数含义如下：</p><ul><li>32mb：缓冲区一旦超过 32MB，Redis 直接强制把消费者踢下线</li><li>8mb + 60：缓冲区超过 8MB，并且持续 60 秒，Redis 也会把消费者踢下线</li></ul><p>Pub/Sub 的这一点特点，是与 List 作队列差异比较大的。从这里你应该可以看出，<strong>List 其实是属于「拉」模型，而 Pub/Sub 其实属于「推」模型</strong>。List 中的数据可以一直积压在内存中，消费者什么时候来「拉」都可以。但 Pub/Sub 是把消息先「推」到消费者在 Redis Server 上的缓冲区中，然后等消费者再来取。当生产、消费速度不匹配时，就会导致缓冲区的内存开始膨胀，Redis 为了控制缓冲区的上限，所以就有了上面讲到的，强制把消费者踢下线的机制。好了，现在总结一下 Pub/Sub 的优缺点：</p><ol><li>支持发布 / 订阅，支持多组生产者、消费者处理消息</li><li>消费者下线，数据会丢失</li><li>不支持数据持久化，Redis 宕机，数据也会丢失</li><li>消息堆积，缓冲区溢出，消费者会被强制踢下线，数据也会丢失</li></ol><p>有没有发现，除了第一个是优点之外，剩下的都是缺点。所以，很多人看到 Pub/Sub 的特点后，觉得这个功能很「鸡肋」。也正是以上原因，Pub/Sub 在实际的应用场景中用得并不多。</p><blockquote><p>目前只有哨兵集群和 Redis 实例通信时，采用了 Pub/Sub 的方案，因为哨兵正好符合即时通讯的业务场景。</p></blockquote><p>当我们在使用一个消息队列时，希望它的功能如下：</p><ul><li>支持阻塞等待拉取消息</li><li>支持发布 / 订阅模式</li><li>消费失败，可重新消费，消息不丢失</li><li>实例宕机，消息不丢失，数据可持久化</li><li>消息可堆积</li></ul><p>Redis 除了 List 和 Pub/Sub 之外，还有符合这些要求的数据类型吗？在 Redis 5.0 版本， disque 功能移植到了 Redis 中，并给它定义了一个新的数据类型：<strong>Stream</strong>。</p><h2 id="趋于成熟的队列：Stream"><a href="#趋于成熟的队列：Stream" class="headerlink" title="趋于成熟的队列：Stream"></a>趋于成熟的队列：Stream</h2><p>首先，Stream 通过 XADD 和 XREAD 完成最简单的生产、消费模型：</p><ul><li>XADD：发布消息</li><li>XREAD：读取消息</li></ul><p>生产者发布 2 条消息：</p><pre><code>// *表示让Redis自动生成消息ID127.0.0.1:6379&gt; XADD queue * name zhangsan&quot;1618469123380-0&quot;127.0.0.1:6379&gt; XADD queue * name lisi&quot;1618469127777-0&quot;</code></pre><p>使用 XADD 命令发布消息，其中的「*」表示让 Redis 自动生成唯一的消息 ID。这个消息 ID 的格式是「时间戳-自增序号」。</p><p>消费者拉取消息：</p><pre><code>// 从开头读取5条消息，0-0表示从开头读取127.0.0.1:6379&gt; XREAD COUNT 5 STREAMS queue 0-01) 1) &quot;queue&quot;   2) 1) 1) &quot;1618469123380-0&quot;         2) 1) &quot;name&quot;            2) &quot;zhangsan&quot;      2) 1) &quot;1618469127777-0&quot;         2) 1) &quot;name&quot;            2) &quot;lisi&quot;</code></pre><p>如果想继续拉取消息，需要传入上一条消息的 ID：</p><pre><code>127.0.0.1:6379&gt; XREAD COUNT 5 STREAMS queue 1618469127777-0(nil)</code></pre><p>没有消息，Redis 会返回 NULL。</p><p><img src="/posts/24283/640-1711973118284-18.webp" alt></p><p>以上就是 Stream 最简单的生产、消费。</p><blockquote><p>这里不再重点介绍 Stream 命令的各种参数，凡是大写的单词都是「固定」参数，凡是小写的单词，都是可以自己定义的，例如队列名、消息长度等等，</p></blockquote><p>下面我们来看，针对前面提到的消息队列要求，Stream 都是如何解决的？</p><h3 id="1-Stream-是否支持「阻塞式」拉取消息？"><a href="#1-Stream-是否支持「阻塞式」拉取消息？" class="headerlink" title="1) Stream 是否支持「阻塞式」拉取消息？"></a><strong>1) Stream 是否支持「阻塞式」拉取消息？</strong></h3><p>可以，在读取消息时，只需要增加 BLOCK 参数即可。</p><pre><code>// BLOCK 0 表示阻塞等待，不设置超时时间127.0.0.1:6379&gt; XREAD COUNT 5 BLOCK 0 STREAMS queue 1618469127777-0</code></pre><p>这时，消费者就会阻塞等待，直到生产者发布新的消息才会返回。</p><h3 id="2-Stream-是否支持发布-订阅模式？"><a href="#2-Stream-是否支持发布-订阅模式？" class="headerlink" title="2) Stream 是否支持发布 / 订阅模式？"></a><strong>2) Stream 是否支持发布 / 订阅模式？</strong></h3><p>Stream 通过以下命令完成发布订阅：</p><ul><li>XGROUP：创建消费者组</li><li>XREADGROUP：在指定消费组下，开启消费者拉取消息</li></ul><p>下面我们来看具体如何做？首先，生产者依旧发布 2 条消息：</p><pre><code>127.0.0.1:6379&gt; XADD queue * name zhangsan&quot;1618470740565-0&quot;127.0.0.1:6379&gt; XADD queue * name lisi&quot;1618470743793-0&quot;</code></pre><p>之后，我们想要开启 2 组消费者处理同一批数据，就需要创建 2 个消费者组：</p><pre><code>// 创建消费者组1，0-0表示从头拉取消息127.0.0.1:6379&gt; XGROUP CREATE queue group1 0-0OK// 创建消费者组2，0-0表示从头拉取消息127.0.0.1:6379&gt; XGROUP CREATE queue group2 0-0OK</code></pre><p>消费者组创建好之后，我们可以给每个「消费者组」下面挂一个「消费者」，让它们分别处理同一批数据。第一个消费组开始消费：</p><pre><code>// group1的consumer开始消费，&gt;表示拉取最新数据127.0.0.1:6379&gt; XREADGROUP GROUP group1 consumer COUNT 5 STREAMS queue &gt;1) 1) &quot;queue&quot;   2) 1) 1) &quot;1618470740565-0&quot;         2) 1) &quot;name&quot;            2) &quot;zhangsan&quot;      2) 1) &quot;1618470743793-0&quot;         2) 1) &quot;name&quot;            2) &quot;lisi&quot;</code></pre><p>同样地，第二个消费组开始消费：</p><pre><code>// group2的consumer开始消费，&gt;表示拉取最新数据127.0.0.1:6379&gt; XREADGROUP GROUP group2 consumer COUNT 5 STREAMS queue &gt;1) 1) &quot;queue&quot;   2) 1) 1) &quot;1618470740565-0&quot;         2) 1) &quot;name&quot;            2) &quot;zhangsan&quot;      2) 1) &quot;1618470743793-0&quot;         2) 1) &quot;name&quot;            2) &quot;lisi&quot;</code></pre><p>我们可以看到，这 2 组消费者，都可以获取同一批数据进行处理了。这样一来，就达到了多组消费者「订阅」消费的目的。</p><p><img src="/posts/24283/640-1711973188270-21.webp" alt></p><h3 id="3-消息处理时异常，Stream-能否保证消息不丢失，重新消费？"><a href="#3-消息处理时异常，Stream-能否保证消息不丢失，重新消费？" class="headerlink" title="3) 消息处理时异常，Stream 能否保证消息不丢失，重新消费？"></a><strong>3) 消息处理时异常，Stream 能否保证消息不丢失，重新消费？</strong></h3><p>除了上面拉取消息时用到了消息 ID，这里为了保证重新消费，也要用到这个消息 ID。当一组消费者处理完消息后，需要执行 XACK 命令告知 Redis，这时 Redis 就会把这条消息标记为「处理完成」。</p><pre><code>// group1下的 1618472043089-0 消息已处理完成127.0.0.1:6379&gt; XACK queue group1 1618472043089-0</code></pre><p><img src="/posts/24283/640-1711973483264-24.webp" alt></p><p>如果消费者异常宕机，肯定不会发送 XACK，那么 Redis 就会依旧保留这条消息。待这组消费者重新上线后，Redis 就会把之前没有处理成功的数据，重新发给这个消费者。这样一来，即使消费者异常，也不会丢失数据了。</p><pre><code>// 消费者重新上线，0-0表示重新拉取未ACK的消息127.0.0.1:6379&gt; XREADGROUP GROUP group1 consumer1 COUNT 5 STREAMS queue 0-0// 之前没消费成功的数据，依旧可以重新消费1) 1) &quot;queue&quot;   2) 1) 1) &quot;1618472043089-0&quot;         2) 1) &quot;name&quot;            2) &quot;zhangsan&quot;      2) 1) &quot;1618472045158-0&quot;         2) 1) &quot;name&quot;            2) &quot;lisi&quot;</code></pre><h3 id="4-Stream-数据会写入到-RDB-和-AOF-做持久化吗？"><a href="#4-Stream-数据会写入到-RDB-和-AOF-做持久化吗？" class="headerlink" title="4) Stream 数据会写入到 RDB 和 AOF 做持久化吗？"></a><strong>4) Stream 数据会写入到 RDB 和 AOF 做持久化吗？</strong></h3><p>Stream 是新增加的数据类型，它与其它数据类型一样，每个写操作，也都会写入到 RDB 和 AOF 中。我们只需要配置好持久化策略，这样的话，就算 Redis 宕机重启，Stream 中的数据也可以从 RDB 或 AOF 中恢复回来。</p><h3 id="5-消息堆积时，Stream-是怎么处理的？"><a href="#5-消息堆积时，Stream-是怎么处理的？" class="headerlink" title="5) 消息堆积时，Stream 是怎么处理的？"></a><strong>5) 消息堆积时，Stream 是怎么处理的？</strong></h3><p>当消息队列发生消息堆积时，一般只有 2 个解决方案：</p><ol><li>生产者限流：避免消费者处理不及时，导致持续积压</li><li>丢弃消息：中间件丢弃旧消息，只保留固定长度的新消息</li></ol><p>而 Redis 在实现 Stream 时，采用了第 2 个方案。在发布消息时，你可以指定队列的最大长度，防止队列积压导致内存爆炸。</p><pre><code>// 队列长度最大10000127.0.0.1:6379&gt; XADD queue MAXLEN 10000 * name zhangsan&quot;1618473015018-0&quot;</code></pre><p>当队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息。这么来看，Stream 在消息积压时，如果指定了最大长度，还是有可能丢失消息的。</p><blockquote><p>除了以上介绍到的命令，Stream 还支持查看消息长度（XLEN）、查看消费者状态（XINFO）等命令，使用也比较简单，你可以查询官方文档了解一下，这里就不过多介绍了。</p></blockquote><p>Redis 的 Stream 几乎覆盖到了消息队列的各种场景，<strong>既然它的功能这么强大，这是不是意味着，Redis 真的可以作为专业的消息队列中间件来使用呢？</strong>原因在于 Redis 本身的一些问题，如果把其定位成消息队列，还是有些欠缺的。到这里，就不得不把 Redis 与专业的队列中间件做对比了。</p><h2 id="与专业的消息队列对比"><a href="#与专业的消息队列对比" class="headerlink" title="与专业的消息队列对比"></a>与专业的消息队列对比</h2><p>其实，一个专业的消息队列，必须要做到两大块：</p><ol><li>消息不丢</li><li>消息可堆积</li></ol><p>前面我们讨论的重点，很大篇幅围绕的是第一点展开的。这里我们换个角度，从一个消息队列的「使用模型」来分析一下，怎么做，才能保证数据不丢？使用一个消息队列，其实就分为三大块：<strong>生产者、队列中间件、消费者</strong>。</p><p><img src="/posts/24283/640-1711973586474-27.webp" alt="图片"></p><p>消息是否会发生丢失，其重点也就在于以下 3 个环节：</p><ol><li>生产者会不会丢消息？</li><li>消费者会不会丢消息？</li><li>队列中间件会不会丢消息？</li></ol><h3 id="1-生产者会不会丢消息？"><a href="#1-生产者会不会丢消息？" class="headerlink" title="1) 生产者会不会丢消息？"></a><strong>1) 生产者会不会丢消息？</strong></h3><p>当生产者在发布消息时，可能发生以下异常情况：</p><ol><li>消息没发出去：网络故障或其它问题导致发布失败，中间件直接返回失败</li><li>不确定是否发布成功：网络问题导致发布超时，可能数据已发送成功，但读取响应结果超时了</li></ol><p>如果是情况 1，消息根本没发出去，那么重新发一次就好了。</p><p>如果是情况 2，生产者没办法知道消息到底有没有发成功？所以，为了避免消息丢失，它也只能继续重试，直到发布成功为止。</p><blockquote><p>生产者一般会设定一个最大重试次数，超过上限依旧失败，需要记录日志报警处理。</p></blockquote><p>也就是说，生产者为了避免消息丢失，只能采用失败重试的方式来处理。但发现没有？这也意味着消息可能会重复发送。在使用消息队列时，要保证消息不丢，宁可重发，也不能丢弃。</p><p>那消费者这边，就需要多做一些逻辑了。对于敏感业务，当消费者收到重复数据数据时，要设计幂等逻辑，保证业务的正确性。从这个角度来看，生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。所以，无论是 Redis 还是专业的队列中间件，生产者在这一点上都是可以保证消息不丢的。</p><h3 id="2-消费者会不会丢消息？"><a href="#2-消费者会不会丢消息？" class="headerlink" title="2) 消费者会不会丢消息？"></a><strong>2) 消费者会不会丢消息？</strong></h3><p>这种情况就是我们前面提到的，消费者拿到消息后，还没处理完成，就异常宕机了，那消费者还能否重新消费失败的消息？要解决这个问题，消费者在处理完消息后，必须「告知」队列中间件，队列中间件才会把标记已处理，否则仍旧把这些数据发给消费者。</p><p>这种方案需要消费者和中间件互相配合，才能保证消费者这一侧的消息不丢。无论是 Redis 的 Stream，还是专业的队列中间件，例如 RabbitMQ、Kafka，其实都是这么做的。所以，从这个角度来看，Redis 也是合格的。</p><h3 id="3-队列中间件会不会丢消息？"><a href="#3-队列中间件会不会丢消息？" class="headerlink" title="3) 队列中间件会不会丢消息？"></a><strong>3) 队列中间件会不会丢消息？</strong></h3><p>前面 2 个问题都比较好处理，只要客户端和服务端配合好，就能保证生产端、消费端都不丢消息。但是如果队列中间件本身就不可靠呢？毕竟生产者和消费这都依赖它，如果它不可靠，那么生产者和消费者无论怎么做，都无法保证数据不丢。在这个方面，Redis 其实没有达到要求。</p><p>Redis 在以下 2 个场景下，都会导致数据丢失。</p><ol><li>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能</li><li>主从复制也是异步的，主从切换时，也存在丢失数据的可能（从库还未同步完成主库发来的数据，就被提成主库）</li></ol><p>基于以上原因我们可以看到，<strong>Redis 本身的无法保证严格的数据完整性</strong>。所以，如果把 Redis 当做消息队列，在这方面是有可能导致数据丢失的。再来看那些专业的消息队列中间件是如何解决这个问题的？</p><p>像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时，一般是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，以此保证消息的完整性。这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。也正因为如此，RabbitMQ、Kafka在设计时也更复杂。毕竟，它们是专门针对队列场景设计的。但 Redis 的定位则不同，它的定位更多是当作缓存来用，它们两者在这个方面肯定是存在差异的。</p><p><strong>4) 消息积压怎么办？</strong></p><p>因为 Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。所以，Redis 的 Stream 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。</p><p>但 Kafka、RabbitMQ 这类消息队列就不一样了，它们的数据都会存储在磁盘上，磁盘的成本要比内存小得多，当消息积压时，无非就是多占用一些磁盘空间，相比于内存，在面对积压时也会更加「坦然」。</p><p>综上，我们可以看到，把 Redis 当作队列来使用时，始终面临的 2 个问题：</p><ol><li>Redis 本身可能会丢数据</li><li>面对消息积压，Redis 内存资源紧张</li></ol><p>到这里，Redis 是否可以用作队列，这个答案你应该会比较清晰了。如果业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。而且，Redis 相比于 Kafka、RabbitMQ，部署和运维也更加轻量。如果业务场景对于数据丢失非常敏感，写入量非常大，消息积压时会占用很多的机器资源，那么建议使用专业的消息队列中间件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/posts/24283/640-1711973975871-30.webp" alt></p><p><strong>在面对技术选型时，不要不经过思考就觉得哪个方案好，哪个方案不好</strong>。需要根据具体场景具体分析，业务功能角度和技术资源角度，如果本来做的东西就不复杂或者团队都不熟悉专业的消息队列，如果贸然使用这些组件，当发生故障时，排查问题也会变得很困难，甚至会阻碍业务的发展，那还不如选择自己顺手的兵器而不是去用屠龙刀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;一开始在不熟悉的时候当我听到Redis可以当消息队列来用是很奇怪的，后面了解才知道与专业的队列中间件相比各有优劣。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(四)</title>
    <link href="https://joytsing.github.io/posts/34895/"/>
    <id>https://joytsing.github.io/posts/34895/</id>
    <published>2024-04-02T09:00:23.000Z</published>
    <updated>2024-04-07T12:51:59.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核是如何发送网络包的"><a href="#内核是如何发送网络包的" class="headerlink" title="内核是如何发送网络包的"></a>内核是如何发送网络包的</h2><h3 id="1）网络包发送过程总览"><a href="#1）网络包发送过程总览" class="headerlink" title="1）网络包发送过程总览"></a>1）网络包发送过程总览</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bind</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listen</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 接收用户请求</span>    <span class="token function">read</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用户请求处理</span>    <span class="token function">dosomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 给用户返回结果</span>    <span class="token function">send</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中，调用send之后内核是怎样把数据包发送出去的？</p><p><img src="/posts/34895/7889902380838845028.png" alt></p><p>如上图所示，可以看到用户数据被拷贝到内核态，然后经过协议栈处理后进入RingBuffer。随后网卡驱动真正将数据发送了出去。当发送完成的时候，是通过硬中断来通知CPU，然后清理RingBuffer。</p><p>总体的流程图如下：</p><p><img src="/posts/34895/8223474428938309457.png" alt></p><p>虽然数据这时已经发送完毕，但是其实还有一件重要的事情没有做，那就是释放缓存队列等内存。</p><p>那内核是如何知道什么时候才能释放内存的呢，当然是等网络发送完毕之后。网卡在发送完毕的时候，会给 CPU 发送一个硬中断来通知 CPU。更完整的流程看图：</p><p><img src="/posts/34895/6645374755730163142.png" alt></p><h3 id="2）网卡启动准备"><a href="#2）网卡启动准备" class="headerlink" title="2）网卡启动准备"></a>2）网卡启动准备</h3><p>现在的服务器上的网卡一般都是支持多队列的。每一个队列都是由一个RingBuffer表示的，开启了多队列以后的网卡就会对应有多个RingBuffer，如下图所示：</p><p><img src="/posts/34895/5740764547427485556.png" alt></p><p>网卡在启动时最重要的任务之一就是分配和初始化RingBuffer，接下来看看网卡启动时分配传输队列<code>RingBuffer</code>的实际过程。在网卡启动的时候，会调用<code>__igb_open</code>函数，<code>RingBuffer</code>就是在这里分配的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__igb_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net_device <span class="token operator">*</span>netdev<span class="token punctuation">,</span> bool resuming<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> igb_adapter <span class="token operator">*</span>adapter <span class="token operator">=</span> <span class="token function">netdev_priv</span><span class="token punctuation">(</span>netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 分配传输描述符数组</span>    err <span class="token operator">=</span> <span class="token function">igb_setup_all_tx_resources</span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 分配接收描述符数组</span>    err <span class="token operator">=</span> <span class="token function">igb_setup_all_rx_resources</span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 开启全部队列</span>    <span class="token function">netif_tx_start_all_queues</span><span class="token punctuation">(</span>netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的<code>__igb_open</code>函数调用<code>igb_setup_all_tx_resources</code>分配所有的传输<code>RingBuffer</code>，调用<code>igb_setup_all_rx_resources</code>分配所有的接收<code>RingBuffer</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">igb_setup_all_tx_resources</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_adapter <span class="token operator">*</span>adapter<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 有几个队列就构造几个RingBuffer</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adapter<span class="token operator">-></span>num_tx_queues<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        err <span class="token operator">=</span> <span class="token function">igb_setup_tx_resources</span><span class="token punctuation">(</span>adapter<span class="token operator">-></span>tx_ring<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>真正的<code>RingBuffer</code>构造过程是在<code>igb_setup_tx_resources</code>中完成的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span><span class="token keyword">int</span> <span class="token function">igb_setup_tx_resources</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_ring <span class="token operator">*</span>tx_ring<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.申请igb_tx_buffer数组内存</span>    size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_tx_buffer<span class="token punctuation">)</span> <span class="token operator">*</span> tx_ring<span class="token operator">-></span>count<span class="token punctuation">;</span>    tx_ring<span class="token operator">-></span>tx_buffer_info <span class="token operator">=</span> <span class="token function">vzalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 2.申请e1000_adv_tx_desc DMA数组内存</span>    tx_ring<span class="token operator">-></span>size <span class="token operator">=</span> tx_ring<span class="token operator">-></span>count <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">union</span> e1000_adv_tx_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    tx_ring<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-></span>size<span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tx_ring<span class="token operator">-></span>desc <span class="token operator">=</span> <span class="token function">dma_alloc_coherent</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> tx_ring<span class="token operator">-></span>size<span class="token punctuation">,</span>                       <span class="token operator">&amp;</span>tx_ring<span class="token operator">-></span>dma<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 3.初始化队列成员</span>    tx_ring<span class="token operator">-></span>next_to_use <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    tx_ring<span class="token operator">-></span>next_to_clean <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述源码可以看到，一个传输RingBuffer的内部也不仅仅是一个环形队列数组：</p><ul><li><code>igb_tx_buffer</code>数组：这个数组是内核使用的，通过<code>vzalloc</code>申请</li><li><code>e1000_adv_tx_desc</code>数组：这个数组是网卡硬件使用的，通过<code>dma_alloc_coherent</code>分配</li></ul><p>这个时候它们之间还没有啥联系。将来在发送的时候，这两个环形数组中相同位置的指针将都将指向同一个 skb。这样，内核和硬件就能共同访问同样的数据了，内核往 skb 里写数据，网卡硬件负责发送。</p><p><img src="/posts/34895/6701590266695649995.png" alt></p><p>最后调用<code>netif_tx_start_all_queues</code>开启队列。另外，硬中断的处理函数<code>igb_msix_ring</code>其实也是在<code>__igb_open</code>中注册的</p><h3 id="3）数据从用户进程到网卡的详细过程"><a href="#3）数据从用户进程到网卡的详细过程" class="headerlink" title="3）数据从用户进程到网卡的详细过程"></a>3）数据从用户进程到网卡的详细过程</h3><h4 id="1）send系统调用实现"><a href="#1）send系统调用实现" class="headerlink" title="1）send系统调用实现"></a>1）send系统调用实现</h4><p>send系统调用的源码位于net/socket.c中。在这个系统调用里，内部其实真正使用的是sendto系统调用。主要干了两件事情：</p><ol><li>在内核中把真正的socket找出来，在这个对象里记录着各种协议栈的函数地址</li><li>构造一个struct msghdr对象，把用户传入的数据，比如buffer地址、数据长度什么的，都装进去</li></ol><p><img src="/posts/34895/5127322427803208878.png" alt></p><p>有了上面的了解，我们再看起源码就要容易许多了。源码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/socket.c</span><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>send<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> buff<span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> len<span class="token punctuation">,</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">sys_sendto</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> len<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">SYSCALL_DEFINE6</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//1.根据 fd 查找到 socket</span> sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2.构造 msghdr</span> <span class="token keyword">struct</span> msghdr msg<span class="token punctuation">;</span> <span class="token keyword">struct</span> iovec iov<span class="token punctuation">;</span> iov<span class="token punctuation">.</span>iov_base <span class="token operator">=</span> buff<span class="token punctuation">;</span> iov<span class="token punctuation">.</span>iov_len <span class="token operator">=</span> len<span class="token punctuation">;</span> msg<span class="token punctuation">.</span>msg_iovlen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> msg<span class="token punctuation">.</span>msg_iov <span class="token operator">=</span> <span class="token operator">&amp;</span>iov<span class="token punctuation">;</span> msg<span class="token punctuation">.</span>msg_flags <span class="token operator">=</span> flags<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//3.发送数据</span> <span class="token function">sock_sendmsg</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码可以看到，我们在用户态使用的 send 函数和 sendto 函数其实都是 sendto 系统调用实现的。send 只是为了方便，封装出来的一个更易于调用的方式而已。在 sendto 系统调用里，首先根据用户传进来的 socket 句柄号来查找真正的 socket 内核对象。接着把用户请求的 buff、len、flag 等参数都统统打包到一个 struct msghdr 对象中。</p><p>接着调用了 sock_sendmsg =&gt; <strong>sock_sendmsg ==&gt; __sock_sendmsg_nosec。在</strong>sock_sendmsg_nosec 中，调用将会由系统调用进入到协议栈，我们来看它的源码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/socket.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">__sock_sendmsg_nosec</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">return</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">sendmsg</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2）传输层处理"><a href="#2）传输层处理" class="headerlink" title="2）传输层处理"></a>2）传输层处理</h4><p><strong>传输层拷贝</strong></p><p>在进入协议栈inet_sendmsg以后，内核接着会找到socket上的具体协议发送函数。对于TCP协议来说，那就是tcp_sendmsg（同样也是通过socket内核对象找到的）</p><p>在这个函数中，内核会申请一个内核态的skb内存，将用户待发送的数据拷贝进去。注意，这个时候不一定会真正开始发送，如果没有达到发送条件，很可能这次调用直接就返回了，大概过程如下图所示：</p><p><img src="/posts/34895/6212660484899004570.png" alt></p><p>在进入协议栈inet_sendmsg以后，内核接着会找到sock中具体的协议处理函数，对于TCP协议而言，sk_prot操作函数集实例为tcp_prot，其中.sendmsg的实现为tcp_sendmsg（对于UDP而言中的为udp_sendmsg）。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_sendmsg</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> sk<span class="token operator">-></span>sk_prot<span class="token operator">-></span><span class="token function">sendmsg</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">tcp_sendmsg</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment" spellcheck="true">// 获取用户传递过来的数据和标志</span>iov <span class="token operator">=</span> msg<span class="token operator">-></span>msg_iov<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用户数据地址</span>iovlen <span class="token operator">=</span> msg<span class="token operator">-></span>msg_iovlen<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数据块数为1</span>flags <span class="token operator">=</span> msg<span class="token operator">-></span>msg_flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 各种标志</span>copied <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 已拷贝到发送队列的字节数</span><span class="token comment" spellcheck="true">// 遍历用户层的数据块</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">--</span>iovlen <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 待发送数据块的长度</span>size_t seglen <span class="token operator">=</span> iov<span class="token operator">-></span>len<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 待发送数据块的地址</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>from <span class="token operator">=</span> iov<span class="token operator">-></span>iov_base<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 指向下一个数据块</span>iovlen<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">while</span><span class="token punctuation">(</span>seglen <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> copy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> size_goal<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 单个skb最大的数据长度</span>    skb <span class="token operator">=</span> <span class="token function">tcp_write_queue_tail</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取发送队列最后一个skb</span>    <span class="token comment" spellcheck="true">// 用于返回发送队列第一个数据包，如果不是NULL说明还有未发送的数据</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_send_head</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    copy <span class="token operator">=</span> max <span class="token operator">-</span> skb<span class="token operator">-></span>len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 该skb还可以存放的字节数</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 需要申请新的skb</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>copy <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 发送队列的总大小大于等于发送缓存的上限，或尚发送缓存中未发送的数据量超过了用户的设置值，进入等待</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sk_stream_memory_free</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">goto</span> wait_for_sndbuf<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 申请一个skb</span>    skb <span class="token operator">=</span> <span class="token function">sk_stream_alloc_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token function">select_size</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> sg<span class="token punctuation">)</span><span class="token punctuation">,</span> sk<span class="token operator">-></span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 把skb添加到sock的发送队列尾部</span>    <span class="token function">skb_entail</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>copy <span class="token operator">></span> seglen<span class="token punctuation">)</span>    copy <span class="token operator">=</span> seglen<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// skb的线性数据区中有足够的空间</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">skb_availroom</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    copy <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> copy<span class="token punctuation">,</span> <span class="token function">skb_availroom</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将用户空间的数据拷贝到内核空间，同时计算校验和</span>    err <span class="token operator">=</span> <span class="token function">skb_add_data_nocache</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> from<span class="token punctuation">,</span> copy<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token keyword">goto</span> do_fault<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 线性数据区用完，使用分页区</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数的实现逻辑比较复杂，代码总只显示了skb拷贝的相关部分，总体逻辑如下：</p><ol><li>如果使用了TCP Fast Open，则会在发送SYN包的同时带上数据</li><li>如果连接尚未建好，不处于ESTABLISHED或者CLOSE_WAIT状态则进程进入睡眠，等待三次握手的完成</li><li>获取当前的MSS（最大报文长度）和size_goal（一个理想的TCP数据包大小，受MTU、MSS、TCP窗口大小影响）<ul><li>如果网卡支持GSO（利用网卡分片），size_goal会是MSS的整数倍</li></ul></li><li><strong>遍历用户层的数据块数组</strong><ol><li><strong>获取发送队列的最后一个skb，如果是尚未发送的，且长度未到达size_goal，那么向这个skb继续追加数据</strong></li><li><strong>否则申请一个新的skb来装载数据</strong><ol><li>如果发送队列的总大小大于等于发送缓存的上限，或者发送缓存中尚未发送的数据量超过了用户的设置值：设置发送时发送缓存不够的标志，进入等待</li><li>申请一个skb，其线性区的大小为通过select_size()得到的线性数据区中TCP负荷的大小和最大的协议头长度，申请失败则等待可用内存</li><li>前两步成功则更新skb的TCP控制块字段，把skb加入发送队列队尾，增加发送队列的大小，减少预分配缓存的大小</li></ol></li><li><strong>将数据拷贝至skb中</strong><ol><li><strong>如果skb的线性数据区还有剩余，就复制到线性数据区同时计算校验和</strong></li><li><strong>如果已经用完则使用分页区</strong><ol><li>检查分页区是否有可用空间，没有则申请新的page，申请失败则说明内存不足，之后会设置TCP内存压力标志，减小发送缓冲区的上限，睡眠等待内存</li><li>判断能否往最后一个分页追加数据，不能追加时，检查分页数是否已经达到了上限或网卡是否不支持分散聚合，如果是的话就将skb设置为PSH标志，然后回到4.2中重新申请一个skb来继续填装数据</li><li>从系统层面判断此次分页发送缓存的申请是否合法</li><li>拷贝用户空间的数据到skb的分页中，同时计算校验和。更新skb的长度字段，更新sock的发送队列大小和预分配缓存</li><li>如果把数据追加到最后一个分页了，更新最后一个分页的数据大小。否则初始化新的分页</li></ol></li></ol></li><li>拷贝成功后更新：发送队列的最后一个序号、skb的结束序号、已经拷贝到发送队列的数据量</li><li>发送数据<ol><li>如果所有数据都拷贝好了就退出循环进行发送</li><li>如果skb还可以继续装填数据或者发送的是带外数据那么就继续拷贝数据先不发送</li><li>如果为发送的数据已经超过最大窗口的一半则设置PUSH标志后尽可能地将发送队列中的skb发送出去</li><li>如果当前skb就是发送队列中唯一一个skb，则将这一个skb发送出去</li><li><em>如果上述过程中出现缓存不足，且已经有数据拷贝到发送队列了也直接发送</em></li></ol></li></ol></li></ol><blockquote><p>这里的发送数据只是指调用tcp_push或者tcp_push_one（情况4）或者__tcp_push_pending_frames（情况3）尝试发送，并不一定真的发送到网络（tcp_sendmsg主要任务只是将应用程序的数据封装成网络数据包放到发送队列）。</p><p>数据何时实际被发送到网络，取决于许多因素，包括但不限于：</p><ul><li>TCP的拥塞控制算法：TCP使用了复杂的拥塞控制算法来防止网络过载。如果TCP判断网络可能出现拥塞，它可能会延迟发送数据。</li><li>发送窗口的大小：TCP使用发送窗口和接收窗口来控制数据的发送和接收。如果发送窗口已满（即已发送但未被确认的数据量达到了发送窗口的大小），那么TCP必须等待接收到确认信息后才能发送更多的数据。</li><li>网络设备（如网卡）的状态：如果网络设备繁忙或出现错误，数据可能会被暂时挂起而无法立即发送。</li></ul><p>struct sk_buff（常简称为skb）在Linux网络栈中表示一个网络包。它有两个主要的数据区用来存储数据，分别是线性数据区（linear data area）和分页区（paged data area）。</p><ol><li>线性数据区（linear data area）: 这个区域连续存储数据，并且能够容纳一个完整的网络包的所有协议头，比如MAC头、IP头和TCP/UDP头等。除了协议头部，线性数据区还可以包含一部分或全部的数据负载。每个skb都有一个线性数据区。</li><li>分页区（paged data area）: 一些情况下，为了优化内存使用和提高性能，skb的数据负载部分可以存储在一个或多个内存页中，而非线性数据区。分页区的数据通常只包含数据负载部分，不包含协议头部。如果一个skb的数据全部放入了线性数据区，那么这个skb就没有分页区。</li></ol><p>这种设计的好处是，对于大的数据包，可以将其数据负载部分存储在分页区，避免对大块连续内存的分配，从而提高内存使用效率，减少内存碎片。另外，这种设计也可以更好地支持零拷贝技术。例如，当网络栈接收到一个大数据包时，可以直接将数据包的数据负载部分留在原始的接收缓冲区（即分页区），而无需将其拷贝到线性数据区，从而节省了内存拷贝的开销。</p></blockquote><p><strong>传输层发送</strong></p><p><img src="/posts/34895/6494688155226641158.png" alt></p><p>上面的发送数据步骤，不论是调用__tcp_push_pending_frames还是tcp_push_one，最终都会执行到<strong>tcp_write_xmit</strong>（在网络协议中学到滑动窗口、拥塞控制就是在这个函数中完成的），函数的主要逻辑如下：</p><ol><li>如果要发送多个数据段则先发送一个路径mtu探测</li><li><strong>检测拥塞窗口的大小</strong>，如果窗口已满（通过窗口大小-正在网络上传输的包数目判断）则不发送</li><li><strong>检测当前报文是否完全在发送窗口内</strong>，如果不是则不发送</li><li><strong>判断是否需要延时发送</strong>（取决于拥塞窗口和发送窗口）</li><li><strong>根据需要对数据包进行分段</strong>（取决于拥塞窗口和发送窗口）</li><li><strong>tcp_transmit_skb发送数据包</strong></li><li>如果push_one则结束循环，否则继续遍历队列发送</li><li>结束循环后如果本次有数据发送，则对TCP拥塞窗口进行检查确认</li></ol><p>这里我们只关注发送的主过程，其他部分不过多展开，即来到<strong>tcp_transmit_skb</strong>函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">int</span> clone_it<span class="token punctuation">,</span> gfp_t gfp_mask<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.克隆新的skb出来</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>clone_it<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     skb <span class="token operator">=</span> <span class="token function">skb_clone</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> gfp_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2.封装TCP头</span>    th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    th<span class="token operator">-></span>source <span class="token operator">=</span> inet<span class="token operator">-></span>inet_sport<span class="token punctuation">;</span>    th<span class="token operator">-></span>dest <span class="token operator">=</span> inet<span class="token operator">-></span>inet_dport<span class="token punctuation">;</span>    th<span class="token operator">-></span>window <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    th<span class="token operator">-></span>urg <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 3.调用网络层发送接口</span>    err <span class="token operator">=</span> icsk<span class="token operator">-></span>icsk_af_ops<span class="token operator">-></span><span class="token function">xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inet<span class="token operator">-></span>cort<span class="token punctuation">.</span>fl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一件事就是先<strong>克隆一个新的skb</strong>，因为skb后续在调用网络层，最后到达网卡发送完成的时候，这个skb会被释放掉。而<strong>TCP协议是支持丢失重传的，在收到对方的ACK之前，这个skb不能被删除掉。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是skb的一个拷贝</strong>。等收到ACK再真正删除。</p><p>第二件事是修<strong>改skb的TCP头</strong>，根据实际情况把TCP头设置好。实际上<strong>skb内部包含了网络协议中所有的头，在设置TCP头的时候，只是把指针指向skb合适的位置</strong>。后面设置IP头的时候，再把指针挪动一下即可，避免了频繁的内存申请和拷贝，提高效率。</p><p>tcp_transmit_skb是发送数据位于传输层的最后一步，调用了网络层提供的发送接口icsk-&gt;icsk_Af_ops-&gt;queue_xmit()之后就可以进入网络层进行下一层的操作了。</p><h4 id="3）网络层发送处理"><a href="#3）网络层发送处理" class="headerlink" title="3）网络层发送处理"></a>3）网络层发送处理</h4><p><img src="/posts/34895/7977866705463715655.png" alt></p><p>在tcp_ipv4中，queue_xmit指向的是ip_queue_xmit，具体实现如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ip_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> flowi <span class="token operator">*</span>fl<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 检查socket中是否有缓存的路由表</span>    rt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> rtable<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">__sk_dst_check</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>rt <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 没有缓存则展开查找路由项并缓存到socket中</span>    rt <span class="token operator">=</span> <span class="token function">ip_route_output_ports</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">sk_setup_caps</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-></span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 为skb设置路由表</span>    <span class="token function">skb_dst_set_noref</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-></span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置IP头</span>    iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    ip<span class="token operator">-></span>protocol <span class="token operator">=</span> sk<span class="token operator">-></span>sk_protocol<span class="token punctuation">;</span>    iph<span class="token operator">-></span>ttl <span class="token operator">=</span> <span class="token function">ip_select_ttl</span><span class="token punctuation">(</span>inet<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-></span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    ip<span class="token operator">-></span>frag_off <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token function">ip_copy_addr</span><span class="token punctuation">(</span>iph<span class="token punctuation">,</span> f14<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 发送</span>    <span class="token function">ip_local_out</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数主要做的就是<strong>找到该把这个包发往哪，并构造好IP包头</strong>。它会去查询socket中是否有缓存的路由表，如果有则直接构造包头，如果没有就去查询并缓存到sokect，然后为skb设置路由表，最后封装ip头，发往ip_local_out函数。</p><p>ip_local_out中主要会经过__ip_local_out =&gt; nf_hook 的过程<strong>进行netfilter的过滤</strong>。如果使用iptables配置了一些规则，那么这里将检测到是否命中规则，然后进行相应的操作，如网络地址转换、数据包内容修改、数据包过滤等。如果设置了非常复杂的netfilter规则，则在这个函数会导致进程CPU的开销大增。经过netfilter处理之后，（忽略其他部分）调用dst_output(skb)函数。</p><p>dst_output会去调用skb_dst(skb)-&gt;output(skb)，即<strong>找到skb的路由表</strong>（dst条目），然后<strong>调用路由表的output方法</strong>。这里是个函数指针，指向的是ip_output方法。</p><p>在ip_output方法中首先会进行一些<strong>简单的统计工作</strong>，随后<strong>再次执行netfilter过滤</strong>。过滤通过之后<strong>回调ip_finish_output</strong>。</p><p>在ip_finish_output中，会<strong>校验数据包的长度，如果大于MTU，就会执行分片</strong>。MTU的大小是通过MTU发现机制确定，在以太网中为1500字节。分片会带来两个问题：</p><ol><li>需要进行额外的处理，会有性能开销</li><li>只要一个分片丢失，整个包都要重传</li></ol><p>如果不需要分片则调用ip_finish_output2函数，根据下一跳的IP地址查找邻居项，找不到就创建一个，然后发给下一层——邻居子系统。</p><p>总体过程如下：</p><ol><li>ip_queue_xmit<ol><li>查找并设置路由项</li><li>设置IP头</li></ol></li><li>ip_local_out：netfilter过滤</li><li>ip_output<ol><li>统计工作</li><li>再次netfilter过滤</li></ol></li><li>ip_finish_output<ol><li>大于MTU的话进行分片</li><li>调用ip_finish_output2</li></ol></li></ol><h4 id="4）邻居子系统"><a href="#4）邻居子系统" class="headerlink" title="4）邻居子系统"></a>4）邻居子系统</h4><p><img src="/posts/34895/698520973817362620.png" alt></p><p><strong>邻居子系统是位于网络层和数据链路层中间的一个系统，其作用是为网络层提供一个下层的封装，让网络层不用关心下层的地址信息，让下层来决定发送到哪个MAC地址。</strong></p><blockquote><p>邻居子系统不位于协议栈net/ipv4/目录内，而是位于net/core/neighbour.c，因为无论对于ipv4还是ipv6都需要使用该模块</p></blockquote><p>在邻居子系统中主要<strong>查找或者创建邻居项</strong>，在创建邻居项时有可能会发出实际的arp请求。然后<strong>封装MAC头</strong>，将发生过程再<strong>传递给更下层的网络设备子系统</strong>。</p><p>ip_finish_output2的实现逻辑大致流程如下：</p><ol><li>rt_nexthop：<strong>获取路由下一跳的IP信息</strong></li><li>__ipv4_neigh_lookup_noref：<strong>根据下一条IP信息在arp缓存中查找邻居项</strong></li><li>__neigh_create：<strong>创建一个邻居项，并加入邻居哈希表</strong></li><li>dst_neight_output =&gt; neighbour-&gt;output（实际指向neigh_resolve_output）：<ol><li><strong>封装MAC头（可能会先触发arp请求）</strong></li><li><strong>调用dev_queue_xmit发送到下层</strong></li></ol></li></ol><h4 id="5）网络设备子系统"><a href="#5）网络设备子系统" class="headerlink" title="5）网络设备子系统"></a>5）网络设备子系统</h4><p>邻居子系统通过dev_queue_xmit进入网络设备子系统，dev_queue_xmit的工作逻辑如下</p><ol><li><strong>选择发送队列</strong></li><li><strong>获取排队规则</strong></li><li><strong>存在队列则调用__dev_xmit_skb继续处理</strong></li></ol><p>在前面讲过，网卡是有多个发送队列的，所以首先需要选择一个队列进行发送。队列的选择首先是通过获取用户的XPS配置（为队列绑核），如果没有配置则调用skb_tx_hash去计算出选择的队列。接着会根据与此队列关联的qdisc得到该队列的排队规则。</p><p><img src="/posts/34895/3920606513907107361.png" alt></p><p>最后会根据是否存在队列（如果是发给回环设备或者隧道设备则没有队列）来决定后续数据包流向。对于存在队列的设备会进入__dev_xmit_skb函数。</p><blockquote><p>在Linux网络子系统中，qdisc（Queueing Discipline，队列规则）是一个用于管理网络包排队和发送的核心组件。它决定了网络包在发送队列中的排列顺序，以及何时从队列中取出包进行发送。qdisc还可以应用于网络流量控制，包括流量整形（traffic shaping）、流量调度（traffic scheduling）、流量多工（traffic multiplexing）等。</p><p>Linux提供了许多预定义的qdisc类型，包括：</p><ul><li>pfifo_fast：这是默认的qdisc类型，提供了基本的先入先出（FIFO）队列行为。</li><li>mq：多队列时的默认类型，本身并不进行任何数据包的排队或调度，而是为网络设备的每个发送队列创建和管理一个子 qdisc。</li><li>tbf (Token Bucket Filter)：提供了基本的流量整形功能，可以限制网络流量的速率。</li><li>htb (Hierarchical Token Bucket)：一个更复杂的流量整形qdisc，可以支持多级队列和不同的流量类别。</li><li>sfq (Stochastic Fairness Queueing)：提供了公平队列调度，可以防止某一流量占用过多的带宽。</li></ul><p>每个网络设备（如eth0、eth1等）都有一个关联的qdisc，用于管理这个设备的发送队列。用户可以通过tc（traffic control）工具来配置和管理qdisc。</p><p>对于支持多队列的网卡，Linux内核为发送和接收队列分别分配一个qdisc。每个qdisc独立管理其对应的队列，包括决定队列中的数据包发送顺序，应用流量控制策略等。这样，可以实现每个队列的独立调度和流量控制，提高整体网络性能。</p><p>我们可以说，<strong>对于支持多队列的网卡，内核中的每个发送队列都对应一个硬件的发送队列（也就是 Ring Buffer）</strong>。选择哪个内核发送队列发送数据包，也就决定了数据包将被放入哪个 Ring Buffer。<strong>数据包从 qdisc 的发送队列出队后，会被放入 Ring Buffer，然后由硬件发送到网络线路上。所以，Ring Buffer 在发送路径上位于发送队列之后。</strong></p><p>将struct sock的发送队列和网卡的Ring Buffer之间设置一个由qdisc（队列规则）管理的发送队列，可以提供更灵活的网络流量控制和调度策略，以适应不同的网络环境和需求。</p><p>下面是一些具体的原因：</p><ol><li><strong>流量整形和控制</strong>：qdisc可以实现各种复杂的排队规则，用于控制数据包的发送顺序和时间。这可以用于实现流量整形（比如限制数据的发送速率以避免网络拥塞）和流量调度（比如按照优先级或服务质量（QoS）要求来调度不同的数据包）。</li><li><strong>对抗网络拥塞</strong>：qdisc可以通过管理发送队列，使得在网络拥塞时可以控制数据的发送，而不是简单地将所有数据立即发送出去，这可以避免网络拥塞的加剧。</li><li><strong>公平性</strong>：在多个网络连接共享同一个网络设备的情况下，qdisc可以确保每个连接得到公平的网络带宽，而不会因为某个连接的数据过多而饿死其他的连接。</li><li><strong>性能优化</strong>：qdisc可以根据网络设备的特性（例如，对于支持多队列（Multi-Queue）的网卡）和当前的网络条件来优化数据包的发送，以提高网络的吞吐量和性能。</li></ol></blockquote><p>__dev_xmit_skb分为三种情况：</p><ol><li>qdisc停用：释放数据并返回代码设置为NET_XMIT_DROP</li><li>qdisc允许绕过排队系统&amp;&amp;没有其他包要发送&amp;&amp;qdisc没有运行：绕过排队系统，调用sch_direct_xmit发送数据</li><li>其他情况：正常排队<ol><li>调用q-&gt;enqueue入队</li><li>调用__qdisc_run开始发送</li></ol></li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">__qdisc_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Qdisc <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> quota <span class="token operator">=</span> weight_p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 循环从队列取出一个skb并发送</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">qdisc_restart</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果quota耗尽或其他进程需要CPU则延后处理</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>quota <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> need_resched<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将触发一次NET_TX_SOFTIRQ类型的softirq</span>        <span class="token function">__netif_shcedule</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述代码中可以看到，<strong>while循环不断地从队列中取出skb并进行发送，这个时候其实占用的都是用户进程系统态时间sy，只有当quota用尽或者其他进程需要CPU的时候才触发软中断进行发送</strong>。</p><p>这就是为什么服务器上查看/proc/softirqs，一般NET_RX要比NET_TX大得多的原因。<strong>对于接收来说，都要经过NET_RX软中断，而对于发送来说，只有系统配额用尽才让软中断上</strong>。</p><p>这里我们聚焦于qdisc_restart函数上，这个函数用于从qdisc队列中取包并发给网络驱动</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">qdisc_restart</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Qdisc <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb <span class="token operator">=</span> <span class="token function">dequeue_skb</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>skb<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token function">sch_direct_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> root_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用 dequeue_skb() <strong>从 qdisc 中取出要发送的 skb</strong>。如果队列为空，返回 0， 这将导致上层的 qdisc_restart() 返回 false，继而退出 while 循环。</p><p>如果拿到了skb则<strong>调用sch_direct_xmit继续发送</strong>，该函数会<strong>调用dev_hard_start_xmit，进入驱动程序发包，如果无法发送则重新入队</strong>。</p><p>即整个__qdisc_run的整体逻辑为：while 循环调用 qdisc_restart()，后者取出一个 skb，然后尝试通过 sch_direct_xmit() 来发送；sch_direct_xmit 调用 dev_hard_start_xmit 来向驱动程序进行实际发送。任何无法发送的 skb 都重新入队，将在 NET_TX softirq 中进行发送。</p><h4 id="6）软中断调度"><a href="#6）软中断调度" class="headerlink" title="6）软中断调度"></a>6）软中断调度</h4><p>上一部分中如果发送网络包的时候CPU耗尽了，会调用进入<strong>netif_schedule，该函数会进入</strong>netif_reschedule，<strong>将发送队列设置到softnet_data上，并最终发出一个NET_TX_SOFTIRQ类型的软中断</strong>。软中断是由内核进程运行的，该进程会进入net_tx_action函数，在该函数中能<strong>获得发送队列，并最终也调用到驱动程序的入口函数dev_hard_start_xmit</strong>。</p><p><img src="/posts/34895/8847982115340149470.png" alt></p><p>从触发软中断开始以后发送数据消耗的CPU就都显示在si中，而不会消耗用户进程的系统时间</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">net_tx_action</span><span class="token punctuation">(</span><span class="token keyword">struct</span> softirq_action <span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> softnet_data <span class="token operator">*</span>sd <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">__get_cpu_var</span><span class="token punctuation">(</span>softnet_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果softnet_data设置了发送队列</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sd<span class="token operator">-></span>output_queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 将head指向第一个qdisc</span>       head <span class="token operator">=</span> sd<span class="token operator">-></span>output_queue<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历所有发送队列</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> Qdisc <span class="token operator">*</span>q <span class="token operator">=</span> head<span class="token punctuation">;</span>         head <span class="token operator">=</span> head<span class="token operator">-></span>next_sched<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 处理数据</span>        <span class="token function">qdisc_run</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">qdisc_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Qdisc <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">qdisc_run_begin</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token function">__qdisc_run</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到软中断的处理中，最后和前面一样都是调用了<strong>qdisc_run。也就是说不管是在qdisc_restart中直接处理，还是软中断来处理，最终实际都会来到dev_hard_start_xmit（</strong>qdisc_run =&gt; qdisc_restart =&gt; dev_hard_start_xmit）。</p><h4 id="7）igb网卡驱动发送"><a href="#7）igb网卡驱动发送" class="headerlink" title="7）igb网卡驱动发送"></a>7）igb网卡驱动发送</h4><p>通过前面的介绍可知，<strong>无论对于用户进程的内核态，还是对于软中断上下文，都会调用网络设备子系统的dev_hard_start_xmit函数</strong>，在这个函数中，会<strong>调用驱动里的发送函数igb_xmit_frame</strong>。在驱动函数里，会<strong>将skb挂到RingBuffer上</strong>，驱动调用完毕，<strong>数据包真正从网卡发送出去</strong>。</p><p><img src="/posts/34895/2639590539896627397.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> net_device <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> netdev_queue <span class="token operator">*</span>txq<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取设备的回调函数ops</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> net_device_ops <span class="token operator">*</span> ops <span class="token operator">=</span> dev<span class="token operator">-></span>netdev_ops<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取设备支持的功能列表</span>    features <span class="token operator">=</span> <span class="token function">netif_skb_features</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用驱动的ops里的发送回调函数ndo_start_xmit将数据包传给网卡设备</span>    skb_len <span class="token operator">=</span> skb<span class="token operator">-></span>len<span class="token punctuation">;</span>    rc <span class="token operator">=</span> ops<span class="token operator">-></span><span class="token function">ndo_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里ndo_start_xmit是网卡驱动要实现的函数，igb网卡驱动中的实现是igb_xmit_frame（在网卡驱动程序初始化的时候赋值的）。igb_xmit_frame主要会去调用igb_xmit_frame_ring函数</p><p><img src="/posts/34895/1444488744580676143.png" alt></p><pre class="line-numbers language-c"><code class="language-c">netdev_tx_t <span class="token function">igb_xmit_frame_ring</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> igb_ring <span class="token operator">*</span>tx_ring<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取TX queue中下一个可用缓冲区的信息</span>    first <span class="token operator">=</span> <span class="token operator">&amp;</span>tx_ring<span class="token operator">-></span>tx_buffer_info<span class="token punctuation">[</span>tx_ring<span class="token operator">-></span>next_to_use<span class="token punctuation">]</span><span class="token punctuation">;</span>    first<span class="token operator">-></span>skb <span class="token operator">=</span> skb<span class="token punctuation">;</span>    first<span class="token operator">-></span>bytecount <span class="token operator">=</span> skb<span class="token operator">-></span>len<span class="token punctuation">;</span>    first<span class="token operator">-></span>gso_segs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 准备给设备发送的数据</span>    <span class="token function">igb_tx_map</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> first<span class="token punctuation">,</span> hdr_len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">igb_tx_map</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_ring <span class="token operator">*</span>tx_ring<span class="token punctuation">,</span> <span class="token keyword">struct</span> igb_tx_buffer <span class="token operator">*</span>first<span class="token punctuation">,</span> <span class="token keyword">const</span> u8 hdr_len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取下一个可用的描述符指针</span>    tx_desc <span class="token operator">=</span> <span class="token function">IGB_TX_DESC</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为skb->data构造内存映射，以允许设备通过DMA从RAM中读取数据</span>    dma <span class="token operator">=</span> <span class="token function">dma_map_single</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-></span>dev<span class="token punctuation">,</span> skb<span class="token operator">-></span>data<span class="token punctuation">,</span> size<span class="token punctuation">,</span> DMA_TO_DEVICE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历该数据包的所有分片，为skb的每个分片生成有效映射</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>frag <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">skb_shinfo</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-></span>frags<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> flag<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    tx_desc<span class="token operator">-></span>read<span class="token punctuation">.</span>buffer_addr <span class="token operator">=</span> <span class="token function">cpu_to_le64</span><span class="token punctuation">(</span>dma<span class="token punctuation">)</span><span class="token punctuation">;</span>        tx_desc<span class="token operator">-></span>read<span class="token punctuation">.</span>cmd_type_len <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>      tx_desc<span class="token operator">-></span>read<span class="token punctuation">.</span>olinfo_status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 设置最后一个descriptor</span>    cmd_type <span class="token operator">|</span><span class="token operator">=</span> size <span class="token operator">|</span> IGB_TXD_DCMD<span class="token punctuation">;</span>    tx_desc<span class="token operator">-></span>read<span class="token punctuation">.</span>cmd_type_len <span class="token operator">=</span> <span class="token function">cpu_to_le32</span><span class="token punctuation">(</span>cmd_type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在这里从网卡的发送队列的RingBuffer上取下来一个元素，并将skb挂到元素上。然后使用igb_tx_map函数将skb数据映射到网卡可访问的内存DMA区域。</strong></p><blockquote><p>这里可以理解为&amp;tx_ring-&gt;tx_buffer_info[tx_ring-&gt;next_to_use]拿到了RingBuffer发送队列中指针数组（前文提到的igb_tx_buffer，网卡启动的时候创建的供内核使用的数组）的下一个可用的元素，然后为其填充skb、byte_count等数据。</p><p>填充完成之后，获取描述符数组（前文提到的e1000_adv_tx_desc，网卡启动的时候创建的供网卡使用的数组）的下一个可用元素。</p><p>调用dma_map_single函数创建内存和设备之间的DMA映射，tx_ring-&gt;dev是设备的硬件描述符，即网卡，skb-&gt;data是要映射的地址，size是映射的数据的大小，即数据包的大小，DMA_TO_DEVICE是指映射的方向，这里是数据将从内存传输到设备，返回的调用结果是一个DMA地址，存储在dma变量中，设备可以直接通过这个地址访问到skb的数据。</p><p>最后就是为前面拿到的描述符填充信息，将dma赋值给buffer_addr，网卡使用的时候就是从这里拿到数据包的地址。</p></blockquote><p>当所有需要的描述符都建好，且skb的所有数据都映射到DMA地址后，驱动就会进入到它的最后一步，触发真实的发送。</p><blockquote><p>到目前为止我们可以这么理解：</p><p>应用程序将数据发送到 socket，这些数据会被放入与 sock 中的发送队列。然后，网络协议栈（例如 TCP 或 UDP）将这些数据从 socket 的发送队列中取出，往下层封装，然后将这些数据包放入由 qdisc 管理的设备发送队列中。最后，这些数据包将从设备发送队列出队，放置到RingBuffer的指针数组中，通过dma将数据包的地址映射到可供网卡访问的内存DMA区域，由硬件读取后发送到网络上。</p></blockquote><h3 id="4）RingBuffer内存回收"><a href="#4）RingBuffer内存回收" class="headerlink" title="4）RingBuffer内存回收"></a>4）RingBuffer内存回收</h3><p>当数据发送完以后，其实工作并没有结束，因为内存还没有清理。<strong>当发送完成的时候，网卡设备会触发一个硬中断（硬中断会去触发软中断）来释放内存</strong>。</p><p><img src="/posts/34895/8196118784844985864.png" alt></p><p>这里需要注意的就是，<strong>虽然是数据发送完成通知，但是硬中断触发的软中断是NET_RX_SOFTIRQ</strong>，这也就是为什么软中断统计中RX要高于TX的另一个原因。</p><p>硬中断中会向softnet_data添加poll_list，<strong>软中断中轮询后调用其poll回调函数</strong>，具体实现是igb_poll，其会<strong>在q_vector-&gt;tx.ring存在时去调用igb_clean_tx_irq</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> bool <span class="token function">igb_clean_tx_irq</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_q_vector <span class="token operator">*</span>q_vector<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 释放skb</span>    <span class="token function">dev_kfree_skb_any</span><span class="token punctuation">(</span>tx_buffer<span class="token operator">-></span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 清除tx_buffer数据</span>    tx_buffer<span class="token operator">-></span>skb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将tx_buffer指定的DMA缓冲区的长度设置为0</span>    <span class="token function">dma_unmap_len_set</span><span class="token punctuation">(</span>tx_buffer<span class="token punctuation">,</span> len <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 清除最后的DMA位置，解除映射</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tx_desc <span class="token operator">!=</span> eop_desc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实逻辑无非就是清理了skb（其中data保存的数据包没有释放），解决了DMA映射等，到了这一步传输才算基本完成。</p><p>当然因为传输层需要保证可靠性，所以数据包还没有删除，此时还有前面的拷贝过的skb指向它，它得等到收到对方的ACK之后才会真正删除。</p><p><img src="/posts/34895/8261733188501617381.png" alt></p><h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ol><li>查看内核发送数据消耗的CPU时应该看sy还是si<ul><li>在网络包发送过程中，用户进程（在内核态）完成了绝大部分的工作，甚至连调用驱动的工作都干了。只有当内核态进程被切走前才会发起软中断。发送过程中百分之九十以上的开销都是在用户进程内核态消耗掉的，只有一少部分情况才会触发软中断，有软中断ksoftirqd内核线程来发送。</li><li>所以在监控网络IO对服务器造成的CPU开销的时候，不能近看si，而是应该把si、sy（内核占用CPU时间比例）都考虑进来。</li></ul></li><li>在服务器上查看/proc/softirqs，为什么NET_RX要比NET_TX大得多<ul><li>对于读来说，都是要经过NET_RX软中断的，都走ksoftirqd内核线程。而对于发送来说，绝大部份工作都是在用户进程内核态处理了，只有系统态配额用尽才会发出NET_TX，让软中断处理。</li><li>当数据发送完以后，通过硬中断的方式来通知驱动发送完毕。但是硬中断无论是有数据接收还是发送完毕，触发的软中断都是NET_RX_SOFTIRQ而不是NET_TX_SOFTIRQ。</li></ul></li><li>发送网络数据的时候都涉及那些内存拷贝操作<ul><li>这里只指内存拷贝</li><li>内核申请完skb之后，将用户传递进来的buffer里的数据拷贝到skb。如果数据量大，这个拷贝操作还是开销不小的。</li><li>从传输层进入网络层时。每个skb都会被克隆出一个新的副本，目的是保存原始的skb，当网络对方没有发挥ACK的时候还可以重新发送，易实现TCP中要求的可靠传输。不过这次只是浅拷贝，只拷贝skb描述符本身，所指向的数据还是复用的。</li><li>第三次拷贝不是必须的，只有当IP层发现skb大于MTU时才需要进行，此时会再申请额外的skb，并将原来的skb拷贝成多个小的skb。</li></ul></li><li>零拷贝到底是怎么回事<ul><li>如果想把本机的一个文件通过网络发送出去，需要先调用read将文件读到内存，之后再调用send将文件发送出去</li><li>假设数据之前没有读去过，那么read系统调用需要两次拷贝才能到用户进程的内存。第一次是从硬盘DMA到Page Cache。第二次是从Page Cache拷贝到内存。send系统调用也同理，先CPU拷贝到socket发送队列，之后网卡进行DMA拷贝。</li><li>如果要发送的数据量较大，那么就需要花费不少的时间在数据拷贝上。而sendfile就是内核提供的一个可用来减少发送文件时拷贝开销的一个技术方案。在sendfile系统调用里，数据不需要拷贝到用户空间，在内核态就能完成发送处理，减少了拷贝的次数。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内核是如何发送网络包的&quot;&gt;&lt;a href=&quot;#内核是如何发送网络包的&quot; class=&quot;headerlink&quot; title=&quot;内核是如何发送网络包的&quot;&gt;&lt;/a&gt;内核是如何发送网络包的&lt;/h2&gt;&lt;h3 id=&quot;1）网络包发送过程总览&quot;&gt;&lt;a href=&quot;#1）网络包发
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Cpp的异常处理额外开销是个啥</title>
    <link href="https://joytsing.github.io/posts/14820/"/>
    <id>https://joytsing.github.io/posts/14820/</id>
    <published>2024-04-01T13:48:57.000Z</published>
    <updated>2024-04-01T14:12:35.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在哪本书（忘了哪本还是哪个讲座）里面看到，打开异常的话会让最终编译出的程序体积扩大三分之一，还会拖慢运行速度，所以C++的异常到底有多慢，以及它为什么这么慢。</p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>要了解异常处理到底做了什么，我们需要深入到汇编语言来看看编译器到底如何生成代码。我们以下面这一段简单的代码为例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noinline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">auto</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，我们使用<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/">Compiler Explorer</a>分析一下它生成的汇编：</p><pre class="line-numbers language-assembly"><code class="language-assembly">foo(int):                                # @foo(int)        push    rbx        mov     ebx, edi        test    edi, edi        js      .LBB0_2        inc     ebx        mov     eax, ebx        pop     rbx        ret.LBB0_2:        mov     edi, 4        call    __cxa_allocate_exception@PLT        mov     dword ptr [rax], ebx        mov     rsi, qword ptr [rip + typeinfo for int@GOTPCREL]        mov     rdi, rax        xor     edx, edx        call    __cxa_throw@PLT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码是使用x86-64 clang 17.0.1生成的，编译选项为<code>-O2 -std=c++20</code>。这段代码非常简单，所以我们很容易可以分析出汇编代码与源代码的对应关系。对于不抛出异常的部分，代码的执行是这样的：</p><pre class="line-numbers language-assembly"><code class="language-assembly">        inc     ebx        mov     eax, ebx        pop     rbx        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这段汇编代码所作的事情就是<code>value += 1</code>，然后返回<code>value</code>。可以看到，在不抛出异常的路径下并没有引入任何影响执行速度的因素。</p><p><code>.LBB0_2</code>段对应了<code>throw value</code>的代码。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>thrown_object <span class="token operator">=</span> <span class="token function">__cxa_allocate_exception</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token comment" spellcheck="true">/* sizeof(int) */</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>thrown_object <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token function">__cxa_throw</span><span class="token punctuation">(</span>thrown_object<span class="token punctuation">,</span> typeinfo_for_int<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以，抛出异常的额外开销也就是这两次函数调用了。我们来看一下<code>__cxa_allocate_exception</code>与<code>__cxa_throw</code>这两个函数具体做了什么。</p><h3 id="cxa-allocate-exception"><a href="#cxa-allocate-exception" class="headerlink" title="__cxa_allocate_exception"></a><code>__cxa_allocate_exception</code></h3><p>以LLVM libcxxabi为例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//  Allocate a __cxa_exception object, and zero-fill it.</span><span class="token comment" spellcheck="true">//  Reserve "thrown_size" bytes on the end for the user's exception</span><span class="token comment" spellcheck="true">//  object. Zero-fill the object. If memory can't be allocated, call</span><span class="token comment" spellcheck="true">//  std::terminate. Return a pointer to the memory to be used for the</span><span class="token comment" spellcheck="true">//  user's exception object.</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">__cxa_allocate_exception</span><span class="token punctuation">(</span>size_t thrown_size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    size_t actual_size <span class="token operator">=</span> <span class="token function">cxa_exception_size_from_exception_thrown_size</span><span class="token punctuation">(</span>thrown_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Allocate extra space before the __cxa_exception header to ensure the</span>    <span class="token comment" spellcheck="true">// start of the thrown object is sufficiently aligned.</span>    size_t header_offset <span class="token operator">=</span> <span class="token function">get_cxa_exception_offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>raw_buffer <span class="token operator">=</span>        <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">__aligned_malloc_with_fallback</span><span class="token punctuation">(</span>header_offset <span class="token operator">+</span> actual_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> raw_buffer<span class="token punctuation">)</span>        std<span class="token operator">::</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    __cxa_exception <span class="token operator">*</span>exception_header <span class="token operator">=</span>        <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>__cxa_exception <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>raw_buffer <span class="token operator">+</span> header_offset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">::</span><span class="token function">memset</span><span class="token punctuation">(</span>exception_header<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> actual_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">thrown_object_from_cxa_exception</span><span class="token punctuation">(</span>exception_header<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数的注释已经把它所作的事情解释得很清楚了，不过我还是解释一下这段代码所作的事情： </p><ol><li>计算真正需要申请内存的大小（<code>header_offset + actual_size</code>）</li><li>尝试进行<code>aligned_malloc</code></li><li>如果<code>aligned_malloc</code>失败，则<code>std::terminate()</code></li><li>将申请的内存清零（只清零用于存放被抛出对象的部分，header部分不清零）</li></ol><p>所以这段代码约等于进行了一次<code>calloc</code>，其引入的主要开销也就是内存分配了。</p><h3 id="cxa-throw"><a href="#cxa-throw" class="headerlink" title="__cxa_throw"></a><code>__cxa_throw</code></h3><p>还是以LLVM libcxxabi为例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*After constructing the exception object with the throw argument value,the generated code calls the __cxa_throw runtime library routine. Thisroutine never returns.The __cxa_throw routine will do the following:* Obtain the __cxa_exception header from the thrown exception object address,which can be computed as follows: __cxa_exception *header = ((__cxa_exception *) thrown_exception - 1);* Save the current unexpected_handler and terminate_handler in the __cxa_exception header.* Save the tinfo and dest arguments in the __cxa_exception header.* Set the exception_class field in the unwind header. This is a 64-bit valuerepresenting the ASCII string "XXXXC++\0", where "XXXX" is avendor-dependent string. That is, for implementations conforming to thisABI, the low-order 4 bytes of this 64-bit value will be "C++\0".* Increment the uncaught_exception flag.* Call _Unwind_RaiseException in the system unwind library, Its argument is thepointer to the thrown exception, which __cxa_throw itself received as an argument.__Unwind_RaiseException begins the process of stack unwinding, describedin Section 2.5. In special cases, such as an inability to find ahandler, _Unwind_RaiseException may return. In that case, __cxa_throwwill call terminate, assuming that there was no handler for theexception.*/</span><span class="token keyword">void</span><span class="token function">__cxa_throw</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>thrown_object<span class="token punctuation">,</span> std<span class="token operator">::</span>type_info <span class="token operator">*</span>tinfo<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dest<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    __cxa_eh_globals <span class="token operator">*</span>globals <span class="token operator">=</span> <span class="token function">__cxa_get_globals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    __cxa_exception<span class="token operator">*</span> exception_header <span class="token operator">=</span> <span class="token function">cxa_exception_from_thrown_object</span><span class="token punctuation">(</span>thrown_object<span class="token punctuation">)</span><span class="token punctuation">;</span>    exception_header<span class="token operator">-</span><span class="token operator">></span>unexpectedHandler <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">get_unexpected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    exception_header<span class="token operator">-</span><span class="token operator">></span>terminateHandler  <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">get_terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    exception_header<span class="token operator">-</span><span class="token operator">></span>exceptionType <span class="token operator">=</span> tinfo<span class="token punctuation">;</span>    exception_header<span class="token operator">-</span><span class="token operator">></span>exceptionDestructor <span class="token operator">=</span> dest<span class="token punctuation">;</span>    <span class="token function">setOurExceptionClass</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>exception_header<span class="token operator">-</span><span class="token operator">></span>unwindHeader<span class="token punctuation">)</span><span class="token punctuation">;</span>    exception_header<span class="token operator">-</span><span class="token operator">></span>referenceCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// This is a newly allocated exception, no need for thread safety.</span>    globals<span class="token operator">-</span><span class="token operator">></span>uncaughtExceptions <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Not atomically, since globals are thread-local</span>    exception_header<span class="token operator">-</span><span class="token operator">></span>unwindHeader<span class="token punctuation">.</span>exception_cleanup <span class="token operator">=</span> exception_cleanup_func<span class="token punctuation">;</span>    <span class="token function">_Unwind_RaiseException</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>exception_header<span class="token operator">-</span><span class="token operator">></span>unwindHeader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  This only happens when there is no handler, or some unexpected unwinding</span>    <span class="token comment" spellcheck="true">//     error happens.</span>    <span class="token function">failed_throw</span><span class="token punctuation">(</span>exception_header<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与<code>__cxa_allocate_exception</code>相同，<code>__cxa_throw</code>函数的注释也写得很清楚了（PS：LLVM的注释写得真不错）。让我们来看看它干了什么：</p><ol><li>从<code>thrown_object</code>中拿到<code>__cxa_exception</code>。还记得吗，<code>__cxa_allocate_exception</code>申请内存时包含了<code>__cxa_exception</code>的header与被抛出的对象。<code>thrown_object</code>指向被抛出的对象，向前偏移header的大小即可拿到<code>__cxa_exception</code>对象的地址。</li><li>填充<code>__cxa_exception</code>的header；</li><li>调用<code>_Unwind_RaiseException</code>；</li><li>如果<code>_Unwind_RaiseException</code>调用成功，则不返回。否则，异常处理失败，调用<code>std::terminate()</code>。</li></ol><p><code>__cxa_exception</code>的header主要包含了各种处理函数的函数指针，以及异常对象的RTTI信息。填充header的过程基本就是几次赋值，以及一次<code>memcpy</code>（<code>setOurExceptionClass</code>的主要流程）。栈回溯等主要流程由<code>_Unwind_RaiseException</code>开始。</p><h2 id="栈回溯"><a href="#栈回溯" class="headerlink" title="栈回溯"></a>栈回溯</h2><p><code>_Unwind_RaiseException</code>函数是Itanium ABI定义的异常处理函数，它函数是语言无关的，其他语言也可以使用这个函数实现异常处理等功能。Itanium ABI在Base ABI中定义了一系列函数，在抛出异常这里我们只关心<code>_Unwind_RaiseException</code>。</p><p>我们继续展开<code>_Unwind_RaiseException</code>看看它做了什么，它是在<code>libunwind</code>中实现的：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/// Called by __cxa_throw.  Only returns if there is a fatal error.</span>_LIBUNWIND_EXPORT _Unwind_Reason_Code<span class="token function">_Unwind_RaiseException</span><span class="token punctuation">(</span>_Unwind_Exception <span class="token operator">*</span>exception_object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">_LIBUNWIND_TRACE_API</span><span class="token punctuation">(</span><span class="token string">"_Unwind_RaiseException(ex_obj=%p)"</span><span class="token punctuation">,</span>                         <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>exception_object<span class="token punctuation">)</span><span class="token punctuation">;</span>    unw_context_t uc<span class="token punctuation">;</span>    unw_cursor_t cursor<span class="token punctuation">;</span>    <span class="token function">__unw_getcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>uc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Mark that this is a non-forced unwind, so _Unwind_Resume()</span>    <span class="token comment" spellcheck="true">// can do the right thing.</span>    exception_object<span class="token operator">-></span>private_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    exception_object<span class="token operator">-></span>private_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// phase 1: the search phase</span>    _Unwind_Reason_Code phase1 <span class="token operator">=</span> <span class="token function">unwind_phase1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>uc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cursor<span class="token punctuation">,</span> exception_object<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>phase1 <span class="token operator">!=</span> _URC_NO_REASON<span class="token punctuation">)</span>        <span class="token keyword">return</span> phase1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// phase 2: the clean up phase</span>    <span class="token keyword">return</span> <span class="token function">unwind_phase2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>uc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cursor<span class="token punctuation">,</span> exception_object<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如上面的代码所示，栈回溯包含两个阶段：<code>unwind_phase1</code>与<code>unwind_phase2</code>。第一阶段会遍历整个栈以查找Exception Handler，除此之外什么也不会做。如果没有找到Exception Handler，则应当终止程序。不过<code>libunwind</code>本身不会直接调用<code>std::terminate()</code>，而是返回<code>_URC_END_OF_STACK</code>并由调用者决定如何终止程序。在第二阶段才会回溯并清理栈。</p><p>这意味着，如果有异常被抛出，但没有被捕获，那么显然不会进入到第二阶段，也就是不会进行栈回溯，栈上对象的析构函数不会被执行。需要注意的是，对于未捕获异常时的栈回溯行为，C++标准规定这是由具体实现决定的。对于Itanium ABI而言，栈回溯不会被执行，但对于其他ABI而言则未必。</p><p><code>unwind_phase1</code>与<code>unwind_phase2</code>的代码都比较长，这里就不贴代码了，我会简要叙述一下它们的实现过程，感兴趣的话可以在<a href="https://link.zhihu.com/?target=https%3A//github.com/llvm/llvm-project/blob/28c29fbec3057692a7985819d799a9e5d47eb2d1/libunwind/src/UnwindLevel1.c%23L420">GitHub</a>找到它们的实现。</p><h3 id="unwind-phase1"><a href="#unwind-phase1" class="headerlink" title="unwind_phase1"></a><code>unwind_phase1</code></h3><p>在<code>unwind_phase1</code>中，代码会不断循环执行一段代码，来查找Exception Handler，直到找到Exception Handler或者到达栈的底部。这段循环的代码步骤如下：</p><ol><li>使用<code>__unw_step</code>函数，使cursor指向下一个栈帧；</li><li>使用<code>__unw_get_proc_info</code>函数，检查当前栈帧是否有需要执行的代码；</li></ol><ul><li>如果找到了要执行的代码，则检查是否要停在当前栈帧（可能找到了Exception Handler）；<ul><li>如果这段要执行的代码要求停在当前栈帧，则说明找到了Exception Handler，标记当前栈帧并返回；</li><li>否则继续循环。</li></ul></li><li>如果没有找到要执行的代码，则继续循环。</li></ul><p>不难想到，“可能的Exception Handler”就是C++代码中的<code>catch</code>了。在检查<code>catch</code>块是否与当前异常对象所匹配时，会对比RTTI信息等，所以如果回滚过程中找到了很多<code>catch</code>，会对<code>unwind_phase1</code>的性能有较大的影响。</p><h3 id="unwind-phase2"><a href="#unwind-phase2" class="headerlink" title="unwind_phase2"></a><code>unwind_phase2</code></h3><p><code>unwind_phase2</code>与<code>unwind_phase1</code>的代码非常类似，也是在循环中不断执行代码来回溯栈，只不过它所做的事情要稍微多一点：</p><ol><li>使用<code>__unw_step_stage2</code>函数，使cursor指向下一个栈帧；</li><li>使用<code>__unw_get_reg</code>获取当前栈帧的<code>sp</code>寄存器（stack pointer）；</li><li>使用<code>__unw_get_proc_info</code>函数，获取当前栈帧的信息；</li></ol><ul><li>如果当前栈帧有要执行的代码，则告诉它目前正在进行栈回溯；</li><li>如果当前栈帧是第一阶段标记的栈帧，则告诉它这是被标记的栈帧；</li><li>尝试执行这段代码：<ul><li>如果这段代码执行后，通知调用者应当继续回溯（返回<code>_URC_CONTINUE_UNWIND</code>），则继续循环；</li><li>如果这段代码执行后，通知调用者回溯到此为止，则尝试resume控制权（调用<code>__unw_phase2_resume</code>）。</li></ul></li></ul><p>很有趣的一点是，<code>libunwind</code>中的函数在调用具体的异常处理函数时全部是通过函数指针实现的，这一点保证了它能够做到语言无关。具体的栈清理等代码由C++的前端编译器生成，并以函数指针的形式传递给<code>libunwind</code>，这给了编译器前端很大的自由度。</p><h2 id="捕获和处理异常"><a href="#捕获和处理异常" class="headerlink" title="捕获和处理异常"></a>捕获和处理异常</h2><p>我们还是以一段简单的代码为例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">__attribute</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noinline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">auto</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">foo</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">int</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Get error %d\n"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/">Compiler Explorer</a>分析一下它生成的汇编：</p><pre class="line-numbers language-assembly"><code class="language-assembly">bar(int):                                # @bar(int)        push    rax        call    foo(int)        pop     rcx        ret        mov     rdi, rax        call    __cxa_begin_catch@PLT        mov     esi, dword ptr [rax]        lea     rdi, [rip + .L.str]        xor     eax, eax        call    printf@PLT        call    __cxa_end_catch@PLT        mov     eax, -1        pop     rcx        ret.Ltmp19:                                # TypeInfo 1        .long   .L_ZTIi.DW.stub-.Ltmp19.L.str:        .asciz  "Get error %d\n"DW.ref.__gxx_personality_v0:        .quad   __gxx_personality_v0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，在不需要执行<code>catch</code>的情况下，<code>bar</code>函数只有4行汇编：</p><pre class="line-numbers language-assembly"><code class="language-assembly">bar(int):                                # @bar(int)        push    rax        call    foo(int)        pop     rcx        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而<code>catch</code>生成的代码显然被直接塞到了<code>ret</code>指令的后面。<code>catch</code>部分首先调用了<code>__cxa_begin_catch</code>，然后开始执行<code>printf</code>，最后调用<code>__cxa_end_catch</code>函数后回到了正常的代码路径上。除此之外，编译器还生成了一些其他的信息：<code>Ltmp19</code>段存储了RTTI信息，<code>DW.ref.__gxx_personality_v0</code>段存储了一个函数指针<code>__gxx_personality_v0</code>。这些东西又是什么？</p><h3 id="Personality-Routine"><a href="#Personality-Routine" class="headerlink" title="Personality Routine"></a>Personality Routine</h3><p>因为不知道怎么翻译比较好所以就保持原名了。</p><p>正如上文所述，<code>libunwind</code>使用函数指针的回调函数来具体实现栈清理等功能。<code>__gxx_personality_v0</code>即为<code>libc++abi</code>与<code>libsupc++</code>的Personality Routine（是个函数）。<code>libunwind</code>中Personality Routine的声明如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">_Unwind_Reason_Code</span> <span class="token punctuation">(</span><span class="token operator">*</span>__personality_routine<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token keyword">int</span> version<span class="token punctuation">,</span>         _Unwind_Action actions<span class="token punctuation">,</span>         uint64 exceptionClass<span class="token punctuation">,</span>         <span class="token keyword">struct</span> _Unwind_Exception <span class="token operator">*</span>exceptionObject<span class="token punctuation">,</span>         <span class="token keyword">struct</span> _Unwind_Context <span class="token operator">*</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>actions</code>参数用于表示要执行的操作，<code>exceptionObject</code>与<code>context</code>则分别表示异常对象与目前的上下文。<code>__gxx_personality_v0</code>的具体实现可以在<a href="https://link.zhihu.com/?target=https%3A//github.com/llvm/llvm-project/blob/28c29fbec3057692a7985819d799a9e5d47eb2d1/libcxxabi/src/cxa_personality.cpp%23L861-L1000">libcxxabi</a>找到。这部分代码所作的事情基本就是根据<code>action</code>选择执行相应的操作，<del>具体的实现我懒得看了</del>。</p><p>有了Personality Routine之后，还需要将其传递给<code>libunwind</code>，在DWARF中这是通过<code>.eh_frame</code>段实现的。栈帧和Personality Routine都存储在<code>.eh_frame</code>段中，<code>libunwind</code>自己会从<code>.eh_frame</code>段中查找。</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>最后我们来讨论一下<code>__cxa_begin_catch</code>与<code>__cxa_end_catch</code>。<code>__cxa_begin_catch</code>的代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*This routine can catch foreign or native exceptions.  If native, the exceptioncan be a primary or dependent variety.  This routine may remain blissfullyignorant of whether the native exception is primary or dependent.If the exception is native:* Increment's the exception's handler count.* Push the exception on the stack of currently-caught exceptions if it is not  already there (from a rethrow).* Decrements the uncaught_exception count.* Returns the adjusted pointer to the exception object, which is stored in  the __cxa_exception by the personality routine.If the exception is foreign, this means it did not originate from one of throwroutines.  The foreign exception does not necessarily have a __cxa_exceptionheader.  However we can catch it here with a catch (...), or with a callto terminate or unexpected during unwinding.* Do not try to increment the exception's handler count, we don't know where  it is.* Push the exception on the stack of currently-caught exceptions only if the  stack is empty.  The foreign exception has no way to link to the current  top of stack.  If the stack is not empty, call terminate.  Even with an  empty stack, this is hacked in by pushing a pointer to an imaginary  __cxa_exception block in front of the foreign exception.  It would be better  if the __cxa_eh_globals structure had a stack of _Unwind_Exception, but it  doesn't.  It has a stack of __cxa_exception (which has a next* in it).* Do not decrement the uncaught_exception count because we didn't increment it  in __cxa_throw (or one of our rethrow functions).* If we haven't terminated, assume the exception object is just past the  _Unwind_Exception and return a pointer to that.*/</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token function">__cxa_begin_catch</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> unwind_arg<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    _Unwind_Exception<span class="token operator">*</span> unwind_exception <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Unwind_Exception<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>unwind_arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> native_exception <span class="token operator">=</span> <span class="token function">__isOurExceptionClass</span><span class="token punctuation">(</span>unwind_exception<span class="token punctuation">)</span><span class="token punctuation">;</span>    __cxa_eh_globals<span class="token operator">*</span> globals <span class="token operator">=</span> <span class="token function">__cxa_get_globals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// exception_header is a hackish offset from a foreign exception, but it</span>    <span class="token comment" spellcheck="true">//   works as long as we're careful not to try to access any __cxa_exception</span>    <span class="token comment" spellcheck="true">//   parts.</span>    __cxa_exception<span class="token operator">*</span> exception_header <span class="token operator">=</span>            <span class="token function">cxa_exception_from_exception_unwind_exception</span>            <span class="token punctuation">(</span>                <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Unwind_Exception<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>unwind_exception<span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>native_exception<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Increment the handler count, removing the flag about being rethrown</span>        exception_header<span class="token operator">-</span><span class="token operator">></span>handlerCount <span class="token operator">=</span> exception_header<span class="token operator">-</span><span class="token operator">></span>handlerCount <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span>            <span class="token operator">-</span>exception_header<span class="token operator">-</span><span class="token operator">></span>handlerCount <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> exception_header<span class="token operator">-</span><span class="token operator">></span>handlerCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  place the exception on the top of the stack if it's not already</span>        <span class="token comment" spellcheck="true">//    there by a previous rethrow</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>exception_header <span class="token operator">!=</span> globals<span class="token operator">-</span><span class="token operator">></span>caughtExceptions<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            exception_header<span class="token operator">-</span><span class="token operator">></span>nextException <span class="token operator">=</span> globals<span class="token operator">-</span><span class="token operator">></span>caughtExceptions<span class="token punctuation">;</span>            globals<span class="token operator">-</span><span class="token operator">></span>caughtExceptions <span class="token operator">=</span> exception_header<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        globals<span class="token operator">-</span><span class="token operator">></span>uncaughtExceptions <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Not atomically, since globals are thread-local</span>        <span class="token keyword">return</span> exception_header<span class="token operator">-</span><span class="token operator">></span>adjustedPtr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Else this is a foreign exception</span>    <span class="token comment" spellcheck="true">// If the caughtExceptions stack is not empty, terminate</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>globals<span class="token operator">-</span><span class="token operator">></span>caughtExceptions <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        std<span class="token operator">::</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Push the foreign exception on to the stack</span>    globals<span class="token operator">-</span><span class="token operator">></span>caughtExceptions <span class="token operator">=</span> exception_header<span class="token punctuation">;</span>    <span class="token keyword">return</span> unwind_exception <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然这段代码看起来很长，但其并不复杂。这段代码首先对native和foreign异常进行了判断。<code>libcxxabi</code>不处理foreign异常，所以当其捕获到foreigh异常时，直接调用<code>std::terminate()</code>。如果捕获到了native异常，则维护异常对象的引用计数，以及全局异常对象的状态。其中大部分的操作都是对各种计数进行加减操作。</p><p><code>__cxa_end_catch</code>所作的事情与<code>__cxa_begin_catch</code>类似，也是维护异常对象的状态，这里就不再赘述了。感兴趣的话请自行阅读<code>libcxxabi</code>的源码吧。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简要总结一下Itanium ABI抛出和捕获异常的主要流程：</p><p>抛出异常</p><ol><li>申请内存，用于存放<code>__cxa_exception</code>与异常对象；</li><li><code>_Unwind_RaiseException</code>查找Exception Handler。这个过程可能需要频繁比较RTTI信息；</li><li><code>_Unwind_RaiseException</code>回溯并释放栈对象。这个过程可能需要频繁查找<code>.eh_frame</code>段；</li></ol><p>捕获异常</p><ol><li>交还控制权，<code>__cxa_begin_catch</code>维护异常状态；</li><li>执行<code>catch</code>部分的代码；</li><li>执行<code>__cxa_end_catch</code>，维护异常状态，捕获异常结束。</li></ol><p>从中可以大致看出，抛出异常以及栈回溯会占用异常处理的大部分时间。比较耗费性能的部分有：申请和释放堆内存、比较RTTI信息、以及栈回溯。如果和返回错误码进行比较的话，考虑多层传递错误码的情况，函数返回本身也需要依次析构栈上的对象。这样考虑的话，异常的<strong>栈回溯</strong>也没有带来很大的额外时间开销。</p><h3 id="空间开销"><a href="#空间开销" class="headerlink" title="空间开销"></a>空间开销</h3><p>异常带来的额外空间开销主要是<code>.eh_frame</code>，其中RTTI要占很大一部分。对于比较大型的软件而言，异常和RTTI对二进制大小的影响还是很大的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在哪本书（忘了哪本还是哪个讲座）里面看到，打开异常的话会让最终编译出的程序体积扩大三分之一，还会拖慢运行速度，所以C++的异常到底有多慢，以
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中的memory order</title>
    <link href="https://joytsing.github.io/posts/13357/"/>
    <id>https://joytsing.github.io/posts/13357/</id>
    <published>2024-04-01T09:08:07.000Z</published>
    <updated>2024-04-02T09:08:52.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Memory Order不难理解，需要的只是重新建立一种世界观，需要的只是强迫自己接受那些从来没关注过的东西，就像两个铁球同时落地一样。</p><p><img src="/posts/13357/image-20240402164630777.png" alt></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>1）store buffer，这个是用于存储cpu产生的临时值，它是cpu的私有区，其它核是看不到的，换句话讲，它会导致在整个系统中，同一个内存值数据，它会有多个副本的存在，也就是会出现不同的cpu看到的值是不一样的，也就是会导致数据一致性问题。</p><p>2）invalidate queue，这个一般在弱序系统中比较常见，它用于加速类似MESI这种cache一致性协议的共识过程，比如说，cpu0在同步store buffer数据到cache时，它会发送Read Invalidate消息，而cpu1并不是立即处理的，它可以先把Read Invalidate的消息先放在invalidate queue里，然后就立马回应ACK返回了，这样处理的好处就是，对于cpu0来说 ，它能更快处理Read Invalidate的共识过程，但是导致的结果，就是cpu1它因为不是及时处理的，所以对于cpu1来说，它看到的值可能不是最新的，也就是它会导致跟store buffer存在一样的问题，数据一致性问题。</p><p>3）cache，对于cache来说，不同系统结构采取的方式有可能不一样，l1 cache，l2cache，有些系统甚至有l3 cache，l4 cache，甚至有victim cache等等，各cache之间数据处理策略也会有差异，比如有些采用inclusive方式，有些采用exclusive方式，甚至有些采用NINE方式，也就是混合模式，Non-Inclusive-Non-Exclusive方式。虽然cache的实现方式多种多样，但是有一点是通识的，进入cache后，可以认为数据进入了公共可见区，也就是但凡进入cache的数据，都会走一个cache cycle，它会根据不同策略，做处理。但这里要明白的是，虽然数据进入了公共可见区，但读端是不是立即能读取到这个值，还取决于读端的硬件结构，比如上面说的Invalidate queue的存在，所以对于这样的弱序系统来说，对于读端，要想读取公共可见区的同一个值，它都需要使用内存屏障来做同步处理，而不是简单的一个汇编读就可以了。</p><h2 id="什么是-Memory-Order"><a href="#什么是-Memory-Order" class="headerlink" title="什么是 Memory Order"></a>什么是 Memory Order</h2><p>简单来说，就是 CPU 访问内存的顺序。为什么要研究这个顺序呢？因为 CPU 并不是按照我们写的程序的先后顺序来访问内存的，在编译和执行阶段，都会进行一定程度的指令重排，CPU 随便乱序执行，以提升执行效率。</p><h2 id="为什么感知不到-Memory-Order"><a href="#为什么感知不到-Memory-Order" class="headerlink" title="为什么感知不到 Memory Order"></a>为什么感知不到 Memory Order</h2><p>我们在日常不考虑 Memory Order 写代码的时候，想用原子变量就直接 <code>atomic&lt;int&gt;</code> ，然后对这个变量做运算。实际上，C++ 在这里规定，不显式的写 <code>memory_order_xxx</code> ，就已经隐含了最强的 Memory Order。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> b<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread A</span>a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread B</span><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 A 线程，我写了 a 在 b 之前 set，那么读到了 b 的时候，a 的值肯定已经被 set 过了。实际上，在 C++ 的语义上，允许更弱的内存模型，如果这里不用默认的最强 Memory Order，而用相对最弱的 relaxed，Thread B 中的 assert 是有可能 fail 的。</p><p>另外，在单线程内，编译器也遵循 as-if 规则，不会做让程序员感知到影响执行效果的优化。</p><h2 id="C-语义"><a href="#C-语义" class="headerlink" title="C++ 语义"></a>C++ 语义</h2><p>ref：<a href="https://zh.cppreference.com/w/cpp/atomic/memory_order">std::memory_order - cppreference.com</a></p><p>在 C++ 语义上，一共暴露了 4 种 Memory Order：</p><ol><li>relaxed</li><li>release-acquire</li><li>release-consume</li><li>sc (sequential consistency)</li></ol><h3 id="relaxed"><a href="#relaxed" class="headerlink" title="relaxed"></a>relaxed</h3><p>其中，relaxed 最好理解，在 C++ 语义层面，允许任何 reorder。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// x == 0 &amp;&amp; y == 0</span><span class="token comment" spellcheck="true">// Thread 1:</span>r1 <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// A</span>x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>r1<span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// B</span><span class="token comment" spellcheck="true">// Thread 2:</span>r2 <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// C </span>y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// D</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里面，CD 可以 reorder，因此可能的执行顺序是 DABC，这样 r1 和 r2 可以都是 42。</p><h3 id="release-acquire"><a href="#release-acquire" class="headerlink" title="release-acquire"></a>release-acquire</h3><p>假设在 A 线程 release store x 变量，在 B 线程 acquire load x 变量。在 C++ 语义层面，可以确保：</p><ol><li>如果 B 线程的 acquire load x 能看到 x 变量被 release store x 了，那么 B 线程的这个 acquire load x 可以看到 A 线程在 release store x 之前的所有 store。</li><li>B 线程在 acquire load x 之后的所有 load，都可以看到这个 acquire load x。</li></ol><p>总结这两点，得出一个更强的结论：如果 B 线程的 acquire load x 能看到 x 变量被 release store x 了，那么 B 线程在 acquire load x 之后的所有 load ，都可以看到 A 线程 release store x 之前所有的 store。</p><p>同时，还有：</p><ol><li>在 acquire 线程中，任何 acquire load 之后的读写不能拿到 acquire load 之前。</li><li>在 release 线程中，任何 release store 之前的读写不能拿到 release store 之后。</li></ol><h3 id="release-consume"><a href="#release-consume" class="headerlink" title="release-consume"></a>release-consume</h3><p>与 release-acquire 不同的是，<code>release-consume</code> 可以只同步依赖的变量。也就是说，在 consume load x 的时候，保证能看到<code>x.store(k, mo_release)</code>之前所有与 k 有关的变量 store 即可。</p><h3 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h3><p>sc 比 release-acquire 更强，拥有 total order。</p><p>具体强在 2 个例子。</p><p>第一个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// a == 0 &amp;&amp; b == 0</span><span class="token comment" spellcheck="true">// Thread 1</span>x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread 2</span>y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread 3</span><span class="token keyword">int</span> a <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread 4</span><span class="token keyword">int</span> c <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> d <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，如果采取 release-acquire 模式，thread 3 和 thread 4 的视图可能会不一样。在 Thread 3 中，x 可以早于 y load；而在 Thread 4 中，y 可以早于 x load。因此，可能 a == c == 1；而 b == d == 0。两个线程可能两者会维护不一样的视图，没有 total order，只要满足 release-acquire 原则就行了。</p><p>而如果采取 <code>memory_order_seq_cst</code> ，必须全局维护一个视图，不可能存在上述情况。</p><p>第二个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// x == 0 &amp;&amp; y == 0</span><span class="token comment" spellcheck="true">// Thread 1</span>x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> c <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread 2</span>y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> d <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回忆一下，release-acquire 只要求：在 acquire 线程中，任何 acquire load 之后的读写不能拿到 acquire load 之前；在 release 线程中，任何 release store 之前的读写不能拿到 release store 之后。但是有一种 reorder 是允许的，就是可以把 store 拿到 load 之后，把 load 拿到 store 之前。如上：Thread 1 和 Thread 2 都可以把 load 拿到 store 之前，得到 c == d == 0。</p><p>而如果采取 <code>memory_order_seq_cst</code> ，同样地，必须全局维护一个视图，不可能存在上述情况。</p><h2 id="Use-Cases"><a href="#Use-Cases" class="headerlink" title="Use Cases"></a>Use Cases</h2><p>对于 relaxed 语义而言，最常见的应用是各种计数器。因为对计数器的 store 和 load，几乎不依赖其他任何变量，就单纯的 emit 一下即可。</p><p>对于 acquire-release 而言，最常见的是在有锁编程：lock 的时候，必须是先获取锁，然后再访问数据； unlock 的时候，必须先写完数据，再释放锁。这就是典型的 acquire-release 语义。</p><p>对于 sc，当依赖多个变量的时候，可能必须要求这些变量有 total order，每个线程持有不同的视图可能会造成非预期的错误。</p><p>例如：</p><ol><li>Thread A 的逻辑是，while 死循环，当 x == true 的时候退出死循环，判断 y 是不是 true，是 true 的话 ++z。</li><li>Thread B 的逻辑是，while 死循环，当 y == true 的时候退出死循环，判断 x 是不是 true，是 true 的话 ++z。</li></ol><p>这里，如果用 acquire-release 语义，并且 x 和 y 是单独的两个线程来 store，就很有可能，在 Thread A 看来 x == true &amp;&amp; y == false。在 Thread B 看来 y == true &amp;&amp; x == false。这样 z 一次都没有 ++。</p><p>因此“当一个变量的访问，依赖其他 &gt;= 2 个变量的判断条件”的时候，这 &gt;= 2 个变量最好都用 sc 保护。</p><h2 id="x86-Memory-Order-语义"><a href="#x86-Memory-Order-语义" class="headerlink" title="x86 Memory Order 语义"></a>x86 Memory Order 语义</h2><p>并不是所有的 ISA 都支持任何程度的 reorder，有些 ISA 的默认 memory order 也可能足够强，例如 x86。</p><p>x86 并不是 relaxed memory model，而是异常的 strong，甚至可以保证 total store order。</p><p>x86 的 memory order 语义如下：</p><ol><li>load-load 和 store-store 都不能 reorder。</li><li>load-store 不能 reorder。</li><li>store-load 可以 reorder。</li><li>thread a 的 store 和 thread b 的 store，在 thread a 和 thread b 中可以看到不同的顺序。</li><li>thread a 的 store 和 thread b 的 store，在 thread c 和 thread d 中必须看到一致的顺序。</li><li>store 的可见性可以传递。</li><li>store 和 load 指令，都不能在 lock 指令前后 reorder。</li></ol><h2 id="C-Memory-Order-语义和-x86-Memory-Order-语义的对应关系"><a href="#C-Memory-Order-语义和-x86-Memory-Order-语义的对应关系" class="headerlink" title="C++ Memory Order 语义和 x86 Memory Order 语义的对应关系"></a>C++ Memory Order 语义和 x86 Memory Order 语义的对应关系</h2><p>当编程语言的语义要求比 ISA 强的时候（编程语言不允许某种 reorder，而 ISA 默认是允许的），ISA 需要对指令进行额外的 barrier 包装以支持编程语言的语义。</p><p>反之，如果 ISA 默认支持的语义足够强，ban 掉的情况比编程语言的语义要求的还多，那么就不需要 ISA 生成额外的指令了。只是编程语言的语义中承认的“哪种情况可以 reorder”，在 ISA 层面上有可能不会发生。</p><h3 id="relaxed-1"><a href="#relaxed-1" class="headerlink" title="relaxed"></a>relaxed</h3><p>对于 relaxed，C++ 规定任何语句都可以 reorder，然而 x86 限制了 load-load、load-store、store-store 都不能 reorder。因此对于 relaxed 而言，指定了 relaxed 的 store 和 load 指令，只剩下了 store-load 可以 reorder。因此上面 C++ 语义中，relaxed 举的例子是不可能发生的。</p><p>当然地，为了实现 relaxed 语义，不需要任何额外指令。</p><h3 id="release-acquire-1"><a href="#release-acquire-1" class="headerlink" title="release-acquire"></a>release-acquire</h3><p>对于 x86 而言，由于不存在 store-store、load-load reorder，因此直接保证了“acquire load 可以看到 release store 之前的所有 store”以及“acquire load 之后的所有 load 都可以看到这个 acquire load” 这两个在 C++ Memory Order 语义上对 acquire-release 的要求，不需要任何额外指令。</p><p>另外，x86 语义是允许 store-load reorder（见 x86 memory order 语义 3）。不过，不用担心 x86 这个允许 reorder 的设定比较宽松，以至于 x86 上需要更多的同步指令来实现 release-acquire 语义——事实上，release-acquire 语义本身也是允许 store-load reorder 的</p><ol><li>acquire 语义是，任何 acquire 之后的读写不能拿到 load 前面，限制了 load-load 和 load-store 不能 reorder。</li><li>release 语义是，任何 release 之前的读写不能拿到 store 后面，限制了 load-store 和 store-store 不能 reorder。</li></ol><p>正好，acqurie-release 语义没限制 x86 语义允许的 store-load reorder。store 可以拿到 load 后面，load 也可以拿到 store 前面。因此，acquire-release 语义，对于 x86 来讲，是天然支持的，不需要额外指令。</p><p>可以认为，每一条 x86 的指令都是保证 release-acquire 语义的。</p><h3 id="release-consume-1"><a href="#release-consume-1" class="headerlink" title="release-consume"></a>release-consume</h3><p>普遍理性而论，正经的编译器和 ISA 都尊重这种数据依赖的先后顺序。唯一不尊重的就是 DEC Alpha。不需要太考虑 release-consume，直接当成 release-acquire 来看待。</p><p>因此，和 acquire-release 语义一样，对于 x86 来讲，不需要额外指令。</p><h3 id="sc-1"><a href="#sc-1" class="headerlink" title="sc"></a>sc</h3><p>最强内存顺序memory_order_seq_cst会补充x86 不满足 存储-加载顺序的缺失。</p><h2 id="x86-Memory-Order-语义和-x86-Memory-Ordering-硬件模型的对应关系"><a href="#x86-Memory-Order-语义和-x86-Memory-Ordering-硬件模型的对应关系" class="headerlink" title="x86 Memory Order 语义和 x86 Memory Ordering 硬件模型的对应关系"></a>x86 Memory Order 语义和 x86 Memory Ordering 硬件模型的对应关系</h2><p>关于上述 x86 Memory Order 语义，有以下的硬件解释：</p><h3 id="load-load、store-store-和-load-store-都不能-reorder"><a href="#load-load、store-store-和-load-store-都不能-reorder" class="headerlink" title="load-load、store-store 和 load-store 都不能 reorder"></a>load-load、store-store 和 load-store 都不能 reorder</h3><p>由于 load 操作是原子的、瞬发的，因此 load-load、load-store 是不能 reorder 的。</p><p>由于 Write Buffer 是 FIFO 的，而且 Write Buffer flush 到 Shared Memory 也是按照 FIFO 有序的，并且 Shared Memory 保证强一致性，任何 flush 都可以被瞬间看到，因此 store-store 是不能 reorder 的。</p><h3 id="store-load-可以-reorder"><a href="#store-load-可以-reorder" class="headerlink" title="store-load 可以 reorder"></a>store-load 可以 reorder</h3><p>体现在硬件上，是由于 store-load 指令可以拆成 3 部分：</p><ol><li>把 x 放到 Write Buffer</li><li>瞬时的 load y</li><li>把 Write Buffer flush 到 Shared Memory</li></ol><p>因此其他线程从最终的表现来看（只有 flush 到 Shared Memory，其他线程才能看到），是先 load 了 y，后 store 了 x。</p><h3 id="thread-a-的-store-和-thread-b-的-store，在-thread-a-和-thread-b-中可以看到不同的顺序"><a href="#thread-a-的-store-和-thread-b-的-store，在-thread-a-和-thread-b-中可以看到不同的顺序" class="headerlink" title="thread a 的 store 和 thread b 的 store，在 thread a 和 thread b 中可以看到不同的顺序"></a>thread a 的 store 和 thread b 的 store，在 thread a 和 thread b 中可以看到不同的顺序</h3><p>体现在硬件上，由于 Write Buffer flush 的时间不确定，因此，Thread a 的 store，目前还在 Thread a 的 Write Buffer 中，没有写到 Shared Memory；同时，Thread b 的 store，目前还在 Thread b 的 Write Buffer 中，没有写到 Shared Memory。</p><p>此时，Thread a 可以看到自己最近的 store，而 Thread b 可以看到自己最近的 store，而互相的 store 是看不到的。</p><h3 id="thread-a-的-store-和-thread-b-的-store，在-thread-c-和-thread-d-中必须看到一致的顺序"><a href="#thread-a-的-store-和-thread-b-的-store，在-thread-c-和-thread-d-中必须看到一致的顺序" class="headerlink" title="thread a 的 store 和 thread b 的 store，在 thread c 和 thread d 中必须看到一致的顺序"></a>thread a 的 store 和 thread b 的 store，在 thread c 和 thread d 中必须看到一致的顺序</h3><p>由于 Thread c 看到了 Thread a 的 store，说明 Thread a 的 store 已经 flush 到了 Shared Memory 中。而 Shared Memory 是强一致的，Thread c 能看到的瞬间，Thread d 必须能看到。并且 Write Buffer 的 flush 操作是有序的，所以 store 如果被其他 Thread 看见了，那么此时这个 store 必然是有 total order 的。</p><h3 id="store-的可见性可以传递"><a href="#store-的可见性可以传递" class="headerlink" title="store 的可见性可以传递"></a>store 的可见性可以传递</h3><p>如果 Thread 2 看到了 Thread 1 的 store，那么 Thread 3 必然也可以看到 Thread 1 的 store，这是 Shared Memory 是强一致的直接结论。</p><h3 id="任何-store-和-load-指令，都不能在-lock-指令前后-reorder"><a href="#任何-store-和-load-指令，都不能在-lock-指令前后-reorder" class="headerlink" title="任何 store 和 load 指令，都不能在 lock 指令前后 reorder"></a>任何 store 和 load 指令，都不能在 lock 指令前后 reorder</h3><p>由于 LOCK 指令上一个全局的 Memory 锁，因此没有人可以读写任何 Memory，之后的读写都是 ban 掉的。而 LOCK 的同时，当前 Thread 的 Write Buffer 全部 flush 到 Shared Memory，因此 LOCK 释放的时候，可以保证当前 Thread 任何 store 命令都执行完了，而 load 命令是瞬发的，本来就会在任何指令之前执行完。</p><p>基本上可以认为，把上图中的 Write Buffer 拿掉（或者说，每次 store 都写穿 Write Buffer，直接到内存里），那么上面的硬件模型，就是天然满足 sc 的，所有指令都有 sc 语义保证，根本不需要 Lock 这个东西。</p><p>同样的，也可以说，x86 模型就是 sc 的模型加上了一个 FIFO Write Buffer，以及为了支持 sc 语义，能够让 store 原子地写穿 FIFO Write Buffer 的一个 Lock。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>推荐阅读这个回答：<a href="https://www.zhihu.com/question/24301047/answer/3408781900">如何理解 C++11 的六种 memory order？</a>，同时，除了无锁并发外很少使用这个，<strong>不是必要掌握!</strong>，从 <a href="https://blog.hidva.com/2017/10/18/go-c-atomic/">The Go Memory Model</a> 可以看到, golang 是非常不鼓励使用基于原子操作来实现同步的:</p><blockquote><p><em>Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.</em><br><em>To serialize access, protect the data with channel operations or other synchronization primitives such as those in the sync and sync/atomic packages.</em><br><em>If you must read the rest of this document to understand the behavior of your program, you are being too clever.</em><br><em>Don’t be clever.</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Memory Order不难理解，需要的只是重新建立一种世界观，需要的只是强迫自己接受那些从来没关注过的东西，就像两个铁球同时落地一样。&lt;/
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浅析Cpp中的SFINAE</title>
    <link href="https://joytsing.github.io/posts/51621/"/>
    <id>https://joytsing.github.io/posts/51621/</id>
    <published>2024-04-01T09:05:48.000Z</published>
    <updated>2024-04-01T13:30:43.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SFINAE（Substitution Failure Is Not An Error，替换失败并非错误）一听就非常高级，什么是“替换”？这里的替换，实际上指的正是模板实例化；也就是说，当模板实例化失败时，编译器并不认为这是一个错误。这个概念晦涩难懂，因为它牵扯到编译器对模板的处理，而且很多时候不知道怎么去用（唉，语言学家），下面通过一个例子先学习下。</p><h2 id="进化之路"><a href="#进化之路" class="headerlink" title="进化之路"></a>进化之路</h2><h3 id="cpp-11"><a href="#cpp-11" class="headerlink" title="cpp 11"></a><strong>cpp 11</strong></h3><p>在正式编写代码前要介绍一个重要的库 <code>#include &lt;type_traits&gt;</code>。</p><p>该库是模板编程中最重要核心的库之一，若缺少本库就不会有如此丰富强大的泛型编程的实现。</p><p><strong>std:: enable_if&lt;&gt;</strong></p><p>此模板可以说是 SFINA 的灵魂一般的存在。</p><p>我们的目的是让模板参数符合某一种约束条件，而 enable_if 可以根据约束条件进行特定展开。根据这一特点，可以对模板的展开进行限制。具体的：</p><ul><li>如果满足约束条件，在 enable_if 中会存在等同于 T 的公开成员 <code>typedef type</code></li><li>如果不满足条件，则没有此 <code>typedef type</code></li></ul><p>std:: enable_if 可能的实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">></span><span class="token keyword">struct</span> enable_if <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> enable_if<span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>std:: is_xxx&lt;&gt;</strong></p><p>这是在 type_traits 中的一系列模板，这类模板可以对模板参数进行特定条件判断符合与否。</p><ul><li>若符合确定条件，则提供等于 <code>true</code> 的成员常量 <code>value</code></li><li>若不成功，则提供等于 <code>false</code> 的成员常量 <code>value</code></li></ul><blockquote><p>而对于本示例，我们可以使用<code>std::is_integral&lt;T&gt;</code>，本模板可以判断T是否为整数类型。<br>如果是整数类型，则要求展开失败，否则展开成功。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">namespace</span> my <span class="token punctuation">{</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 引入第二个模板参数     * 根据第二个模板参数展开失败与否     * 决定是否最终使用该模板     */</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Iter<span class="token punctuation">,</span>         <span class="token keyword">typename</span> SFINA <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span><span class="token operator">!</span>std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span>Iter<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span>    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当<code>my::vector&lt;Type&gt; vec0(5, val);</code>进行模板匹配时候，首先会找到<code>vector(Iter begin, Iter end)</code>并尝试展开，但该模板的第二个参数约束<code>Iter</code>不是整形类型时，才能展开成功。因此再重新寻找其他的匹配函数。</p><h3 id="cpp-14-cpp-17"><a href="#cpp-14-cpp-17" class="headerlink" title="cpp 14 ~ cpp 17"></a><strong>cpp 14 ~ cpp 17</strong></h3><p>对于每次写<code>std::is_integral&lt;T&gt;::value</code>和<code>std::enable_if&lt;B&gt;::type</code>都比较麻烦。因此 cpp 14 建议可以通过另一个简单的符号表示该内容。也就是<code>type trait variable templates</code>的概念。直到 cpp 17 才在正式标准中进行了全面的完善。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// cpp14</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token operator">></span><span class="token keyword">using</span> enable_if_t <span class="token operator">=</span> <span class="token keyword">typename</span> enable_if<span class="token operator">&lt;</span>B<span class="token punctuation">,</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// cpp17</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> is_integral_v <span class="token operator">=</span> is_integral<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此我们可以得到以下的简洁版本。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">namespace</span> my <span class="token punctuation">{</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 相对于cpp11更加简洁的写法     * 同时第二个模板参数没有具体使用到，可以省略成一个匿名形式     */</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Iter<span class="token punctuation">,</span>         <span class="token keyword">typename</span> <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span><span class="token operator">!</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>Iter<span class="token operator">>></span><span class="token operator">></span>    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cpp-20"><a href="#cpp-20" class="headerlink" title="cpp 20"></a><strong>cpp 20</strong></h3><p>c++ 是一门不断发展的现代语言，在 cpp 20 中提出了概念和约束到标准中。</p><p><strong>requires</strong></p><p><code>requires</code> 是一个关键字。可以直接在模板函数中进行使用。</p><p>requires是在template和函数体之间编写，提升可代码可阅读性。</p><p>注意一点，requires 子句需要是一个初等表达式 或者 带括号的表达式。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;concepts></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">namespace</span> my <span class="token punctuation">{</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用 requires 关键字</span>    <span class="token comment" spellcheck="true">// 直接写出约束条件</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Iter<span class="token operator">></span>    <span class="token function">requires</span> <span class="token punctuation">(</span><span class="token operator">!</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>Iter<span class="token operator">></span><span class="token punctuation">)</span>    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>concept</strong></p><p><code>concept</code> 是一个关键字。可以通过该关键字定义一个基于模板参数的约束条件。再将该约束条件运用到具体的模板函数中。</p><p>这样可以使约束条件和具体的模板函数进行分离，大大化简编码的复杂度。同时这个约束条件可以进行复用，再次减少了代码的冗余度。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;concepts></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">namespace</span> my <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 定义一个约束条件</span><span class="token comment" spellcheck="true">// 约束为不能是整形数值</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span>concept IterType <span class="token operator">=</span> <span class="token operator">!</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>Type<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 直接写定义的约束条件</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span>IterType Iter<span class="token operator">></span>    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>requires 表达式</strong></p><p><code>requires 表达式</code> 是将上述的<code>concept</code>和<code>requires</code>结合使用。</p><p>requires 表达式的编写形式与函数编写非常相似，将约束条件挨个写在requires后的大括号域内。</p><p>这种展现形式简洁明了，容易扩充。能同时兼具单独使用<code>concept</code>和<code>requires</code>的优点。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;concepts></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">namespace</span> my <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// requires 表达式</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span>concept IterType <span class="token operator">=</span> requires <span class="token punctuation">{</span>     std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>Type<span class="token operator">></span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用 requires 表达式</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span>IterType Iter<span class="token operator">></span>    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>假如设计一个加法接口，可以对两个基础类型数据、两个支持加法的自定义类型数据、两个相同容器里的数据、两个相同类型的数组里的数据进行加操作，应当怎么做？这个加法接口有两个输入，返回相加后的结果，对于数组或者容器类型的数据返回的是逐个相加的结果。</p><p>根据这个要求，我们首先可以写出以下的函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>T <span class="token function">add</span><span class="token punctuation">(</span> T a<span class="token punctuation">,</span> T b <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样写会带来一个问题：当形参a和b不是相同的类型的时候，会造成匹配不上的结果</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时编译器会报错：</p><pre class="line-numbers language-cpp"><code class="language-cpp">main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">13</span><span class="token operator">:</span><span class="token number">21</span><span class="token operator">:</span> error<span class="token operator">:</span> no matching function <span class="token keyword">for</span> call to ‘<span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span><span class="token punctuation">)</span>’  <span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token operator">^</span>main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">4</span><span class="token operator">:</span><span class="token number">3</span><span class="token operator">:</span> note<span class="token operator">:</span> candidate<span class="token operator">:</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> T <span class="token function">add</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> T<span class="token punctuation">)</span> T <span class="token function">add</span><span class="token punctuation">(</span> T a<span class="token punctuation">,</span> T b <span class="token punctuation">)</span>   <span class="token operator">^</span><span class="token operator">~</span><span class="token operator">~</span>main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">4</span><span class="token operator">:</span><span class="token number">3</span><span class="token operator">:</span> note<span class="token operator">:</span>   <span class="token keyword">template</span> argument deduction<span class="token operator">/</span>substitution failed<span class="token operator">:</span>main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">13</span><span class="token operator">:</span><span class="token number">21</span><span class="token operator">:</span> note<span class="token operator">:</span>   deduced conflicting types <span class="token keyword">for</span> parameter ‘T’ <span class="token punctuation">(</span>‘<span class="token keyword">int</span>’ <span class="token operator">and</span> ‘<span class="token keyword">float</span>’<span class="token punctuation">)</span>  <span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到我们在调用add方法的时候，我们的模板函数钟的T只有一种类型，没办法推导出两种类型，编译失败。</p><p>我们接着对这个函数进行改进，让它能够支持两种类型的输入，我们想着既然一个模板参数对应一个类型，那么我们再加一个模板参数不就可以对应两个不同类型的参数了吗，答案是可以的，正当我们兴奋的想写下这个函数的时候，问题来了，返回类型怎么写？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>返回类型？<span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当两个不同类型的值相加的时候，怎么确定函数的返回类型呢，我们知道一般我们写一个float的数和int类型的数相加得到的一定是一个float数，但是在模板中输入有成千上万种可能，我们没办法写出一个具体的类型来指代。这种事情最好还是让编译器来自己决定，那就是<strong>尾置返回类型：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">decltype</span><span class="token punctuation">(</span> a <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的auto只是一个占位符，并不是指实际的类型，真正的类型是靠<code>decltype</code>来推导出来的，<code>decltype</code>是c++11之后引入的关键词，作用是在编译期推导出括号里的表达式、变量或者类型本身的类型。这里它会自动推导出表达式( a + b )的类型，并取代前面的auto作为返回值类型。</p><p>在c++14之后，这个函数可以取消尾置返回类型，auto也具备了自动推导返回值类型的能力：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里一切都很好，我们这个模板函数可以支持两种不同类的输入，并且能够自动推导返回类型了，但是这还不够，因为对于容器类型的数据来说，我们还没办法对其进行支持，因此我们要写一个可以支持两个容器类型数据加法的重载函数模板：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// #接口实现2</span><span class="token punctuation">{</span>    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，会选择接口实现2而不是接口实现1</span><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> c1 <span class="token punctuation">)</span> std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>val<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok; 输出 2 4 6 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，这里的Container1和Container2是模板模板参数。T1和T2是模板模板参数中的具体参数。接口实现2可以看成是对接口实现1的重载，在调用时，如果输入是两个容器类型的数据，编译器会认为接口实现2匹配的更好，从而实例化接口实现2的函数模板。</p><p>但是这样同时会带来新的问题，当我们想对两个由自定义的模板类定义的对象操作add接口的时候，会出现棘手的现象。</p><h2 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h2><p>首先，只考虑有接口实现1的情况下，我们自己定义了一个模板类，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token function">B</span><span class="token punctuation">(</span> <span class="token keyword">const</span> T b_ <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">b</span><span class="token punctuation">(</span> b_ <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> B rhs <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 加法运算符重载1</span>        <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">B</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>        <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> B<span class="token operator">&lt;</span>U<span class="token operator">></span> rhs <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 加法运算符重载2 </span>        <span class="token punctuation">{</span>                <span class="token keyword">return</span> B<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意这里让编译器去决定加法之后的模板参数类型是什么</span>        <span class="token punctuation">}</span>        T b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们重载了加法运算符，让它得以支持加法操作，同时我们还实现了一个加法运算符的模板函数重载，让这个类型的变量能对不同的T类型实现加法操作，譬如:</p><pre class="line-numbers language-cpp"><code class="language-cpp">B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">;</span>a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，a1和a2是相同类型的数据,调用加法运算符重载1</span>B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> a3<span class="token punctuation">;</span>a1 <span class="token operator">+</span> a3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，a1和a3不是相同类型的数据，调用加法运算符重载2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在一个只考虑有接口实现1的版本中，我们调用add方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1<span class="token punctuation">;</span>   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1<span class="token punctuation">;</span>   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, a1和b1虽然是不同的类型，但是因为重载了运算符，可以做加法</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在一个既有接口实现1又有接口实现2的版本中，我们调用add方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// #接口实现2</span><span class="token punctuation">{</span>    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现2上</span>   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>   <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error，编译器同样会匹配到接口实现2，但是B类型中没有begin,end等函数，报错</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们本来想让接口实现1只为基础类型或者支持加法的自定义类型服务，而让接口实现2为容器类型服务的。现在好了，在为自定义模板类型的变量调用接口的时候，也会匹配到接口实现2上去，与我们的预期大大不同。</p><p>这个问题的根本原因在于我们的接口实现2的形参在与实参进行匹配的时候，因为我们的自定义类型是模板类，与模板模板参数匹配的更好，这样编译器会优先决策匹配的更好的模板函数实现，而这整个过程就是有c++<strong>重载决议机制</strong>实现的。</p><p>那我们有没有办法去人为的控制这种重载呢，让最终的调用能够选择正确的匹配函数呢？答案是可以的，这就是我们要利用SFINAE机制来做的事情了，而这正是本文接下来要说的重点。</p><p>在讲SFINAE之前，我们要大致了解一下我们实现的这个add接口从定义到实例化再到最终调用编译器做了哪些事情，这有助于后面理解SFINAE机制。</p><h2 id="实例化过程"><a href="#实例化过程" class="headerlink" title="实例化过程"></a>实例化过程</h2><ol><li>两阶段命名查找(<strong>Two-Phase Name Lookup</strong>)</li></ol><p>在c++中，将各种变量、函数、模板等命名分为受限型命名(qualified name)，非受限型命名(unqualified name)，依赖型命名(dependent name)，非依赖型命名(non-dependent)几种。所谓受限型命名，指的是在作用域符(::)或者成员访问运算符(-&gt;和.)之后的名称（即属于类成员或者命名空间内的变量或者函数）。非受限型命名则是除了受限型名之外的名称。依赖型命名是指以某种方式依赖于模板参数的名称。相同的，非依赖型命名就是不属于依赖性名称的名称。</p><p>我们这里的add接口在调用的时候既没有用作用域符，也没有用成员访问运算符，因此是一个非受限型名称，同时add接口又依赖模板参数，因此也属于依赖性名称，因此可以称之为unqulified dependent name。对于这类名称，编译器在首次看到的时候会先对其进行一次查找，这时候由于模板还没有实例化，这个时候找到的只是这个add函数的“蓝图”，即我们所写的函数模板，这个阶段只能对其做基础的模板解析和语法检查，等模板经历了实参推导和替换之后，才会生成实际的函数，这时候还需要在进行一次查找以找到实例化后的函数，这个过程就是<strong>两阶段命名查找</strong>。</p><p>第一阶段的命名查找一般使用普通查找规则(Ordinary Lookup rule)，第二阶段会使用著名的<code>实参依赖</code>(Aurgument Dependent Lookup, ADL)查找规则来进行查找，具体的原理不是本文的重点，这里不再深入，有兴趣的朋友可以自己去了解。通过命名查找机制找到的实例化之后的函数会放入<strong>重载集</strong>中(Overload Set)，随后会以候选者的角色送入重载决议中进行裁决。</p><ol start="2"><li>两阶段编译检查(Two-Phase Translation)</li></ol><p>两阶段编译检查是配合两阶段命名查找的一种机制，同样以add接口为例，在第一次查找这个函数模板的时候，会对其进行解析，同时检查它的语法合法性，这时候不管类型是不是支持加法操作，编译器都不会报错，因为编译器此时还不知道模板的参数具体是什么。</p><p>在第二阶段命名查找之后，编译器已经能够找到了add模板实例化之后函数，经过重载决议之后，编译器会从这些实例化函数中选取一个最合适的重载函数作为最终要执行的函数，这时候会进行第二阶段的编译器检查，这时候检查就会更加严格，会检查函数内部的表达式是否能够成立，例如上面的例子中：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现2上</span>   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>   <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error，编译器同样会匹配到接口实现2，但是B类型中没有begin,end等函数，报错</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中的auto c2 = add( a2, b2 ); 就是在这个第二段编译检查阶段才报错的。</p><ol start="3"><li>模板实参推导(Template Argument Deduction, TAD)</li></ol><p>为啥需要模板实参推导这个机制呢？最主要的原因是我们想要在使用add这个模板函数的时候要像使用普通函数一样简单，虽然可以通过显示的指定模板的参数来调用，但是这种方法显得非常的繁琐。我们先举一个简单的例子来直观感受一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span> T t <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// f&lt;int>(1); 模板参数T被推导为int</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// f&lt;double>(1.1); 模板参数T被推导为double</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// error: T cannot be duduced</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上模板实参推导涉及到许许多多的内容，会遇到诸如类型退化、左值引用传参、右值引用传参、万能引用、完美转发、可变参数等诸多情况，模板实参推导的规则非常复杂，其原理也不在本文中详细说明。</p><ol start="4"><li>模板实参替换(Template Argument Substitution, TAS)</li></ol><p>在用推导出的实参替换模板参数之后，再使用推导出来的类型替换模板参数，从而完成实例化一个函数模板的过程。</p><p>这里就要讲到本文的重点了：<strong>参数替换过程中，并不总是能够替换成功</strong>的，举个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span> T a <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 重载1</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span> T<span class="token operator">::</span>value_type a <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 重载2</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">test</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 重载2替换失败，选择重载1</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里编译器会通过命名查找机制找到重载1和重载2两种函数模板，然后模板参数T都可以被推导为int类型，但是由于int类型中没有value_type这个类型，会造成参数替换失败，此时编译器并不会立即报错，只是将其从重载集中移除，后面的重载决议也就不会再选择它，这个机制就是SFINAE。</p><p>我们利用这种机制可以<strong>实现对模板参数类型的限制</strong>，也可以通过强行<strong>禁用某些模板</strong>来实现人为的重载选择。</p><ol start="5"><li>重载决议</li></ol><p>重载决议的核心就是在重载集中找到唯一的一个与调用情况最优匹配的实现函数，如果重载决议找不到最匹配的函数，则编译器会报” no matching function for call to xxx”的错误。</p><h2 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h2><p>我们的思路是想利用SFINAE机制来让下面这个调用：</p><pre class="line-numbers language-cpp"><code class="language-cpp">B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span><span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>排除掉接口实现2，方法是强行让编译器对这个调用在和接口实现2的函数模板进行模板实参替换的时候失败，这样重载决议中就会忽略掉这个模板实现，从而让它选择接口实现1。具体的实现需要借助标准模板库里提供的两个工具：<code>std::enable_if</code>以及<code>std::voit_t;</code></p><p>enable_if的一个可能的实现是这样的（参考cppreference）:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">></span><span class="token keyword">struct</span> enable_if <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> enable_if<span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">using</span> type <span class="token operator">=</span> T<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token operator">></span><span class="token keyword">using</span> enable_if_t <span class="token operator">=</span> <span class="token keyword">typename</span> enable_if<span class="token operator">&lt;</span>B<span class="token punctuation">,</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// c++14：别名而已，可以少写一个type</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个元函数是一个类型萃取(Type Trait)，在模板的第一个参数B为true的时候，它的type成员会返回一个类型：如果没有第二个模板参数，返回类型是默认的void，否则，返回的是其第二个参数的类型。如果参数B为false的时候，其成员类型是未定义的，根据SFINAE机制，编译期会忽略包含该std::enable_if_t&lt;&gt;表达式的模板。说人话：</p><p>意思就是我们可以设立一个条件，当条件满足的时候，就让编译器生成这个函数实例，否则忽略它。非常方便！<strong>我们只要在我们的add接口实现2上去用这个工具判断输入的模板实参是不是容器类型就行了，如果是容器类型，那么就实例化这个函数模板，如果不是，则忽略它。</strong></p><p>那么问题就变成了怎么去判断输入类型是不是容器类型。我们可以简单的认为一个类中如果有迭代器，并且具有begin()或者end()这样的成员方法，那么这就是一个容器类型（当然并不严谨，因为stack和queue中并没有迭代器，这里只是作为一个例子，并不考虑这种情况，严谨点的也可以单独将stack和queue拎出来做特化处理即可，问题都不大）。</p><p>我们可以利用成员探测技术（Detecting Members）来让编译器在自己去探测一个类型是否具有迭代器成员和begin()成员。我们可以写出下面这种元函数代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 判断类型否是一个容器类型的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_container_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 普通版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 偏特化版本</span><span class="token keyword">struct</span> is_container_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">:</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::void_t也是一种利用SFINAE机制实现的元函数，它的一种可能的实现如下所示（参考cppreference）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token keyword">using</span> void_t <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它就是一个别名模板（alias template），是void类型的一个别名，但是它的模板参数是一个可变参数，这同时也是一个可变参数模板（variable template）。这个元函数的意思是它可以接收任意个类型作为模板参数，编译器会在实参替换阶段检查看你输入的每个类型能否被替换成功，如果替换失败，编译器会忽略这个模板。</p><p>回到我们这个判断类型否是一个容器类型的元函数里，如果模板参数T1和T2中含有iterator类型，并且有begin()函数，那么std::void_t中的模板参数可以被替换成功，从而void_t类型就成了void的别名，进一步的编译器会选择is_container_type这个模板类的偏特化版本。注意这里偏特化的版本继承了std::true_type这个类（这是个语法糖），这个类里面有个编译期布尔常量value，其值为true。</p><p>如果模板参数T1和T2中没有iterator类型或者没有begin()函数，那么std::void_t中模板参数会替换失败，但是由于SFINAE，编译器不会报错，此时编译器会选择is_container_type这个模板类的普通版本，这个普通版本继承了std::false_type这个类，这里类里面的编译期布尔常量value的值为false。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_container_type<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">>></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, 打印1</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_container_type<span class="token operator">&lt;</span>B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">>></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印0</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_container_type<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以把这个判断类型的元函数与std::enable_if_t结合在一起来对类型做一些限制，从而可以帮助编译器排除一些模板，选择正确的模板。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 判断类型否是一个容器类型的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_container_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 普通版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 偏特化版本</span><span class="token keyword">struct</span> is_container_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">:</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_container_type<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">>></span><span class="token operator">::</span>value<span class="token punctuation">,</span> Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// #接口实现2</span><span class="token punctuation">{</span>    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现2上</span>   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>   <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，由于B类型不是容器类型，编译器会匹配到接口实现1上</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题解决！现在我们可以让B<T>这种自定义的模板类的数据在调用add接口的时候不再匹配到接口实现1上去了。这就是SFINAE机制的强大威力。</T></p><p>但是对于接口的提供者来说，这还远远不够，因为你永远不知道用户在调用这个接口的时候会传进去个什么玩意，我们必须对输入的类型做一些限制：a. 比如我们这里的接口实现1中，我们不能允许两个不支持加法操作的类型数据传进来，b. 同样在接口实现2中，我们不能允许两个异型容器进行加法操作。</p><p>针对条件a，我们仿照仿照上面的方法可以写出判断两个类型是否支持加法的元函数，针对b，我们可以写出判断两个容器类型是否是同型容器的元函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 判断两个类型是否支持加法的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_add_supported_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 如果支持加法，is_add_supported_type继承的value = 1</span><span class="token keyword">struct</span> is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">::</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断两个容器是否是相同类型容器的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token operator">></span><span class="token keyword">struct</span> is_same_container_type<span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> value <span class="token operator">=</span> std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 测试</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_add_supported_type<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印1</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">>></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, 打印0，两个容器不支持直接加</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_same_container_type<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, 打印1</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_same_container_type<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token punctuation">,</span> std<span class="token operator">::</span>list<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ok, 打印0, vector和list不是同型容器</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里的判断两个容器是否是同型容器的元函数中用到了std::is_same_v，这个元函数属于预测型萃取，可以用来判断两个类型是否相同，其源码为：（参考cppreference）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span><span class="token keyword">struct</span> is_same <span class="token operator">:</span> std<span class="token operator">::</span>false_type <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token operator">:</span> std<span class="token operator">::</span>true_type <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span> <span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> is_same_v <span class="token operator">=</span> is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// c++ 17</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们利用上面所写的两个元函数来改进我们的接口：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 判断两个类型是否支持加法的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_add_supported_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 如果支持加法，is_add_supported_type继承的value = 1</span><span class="token keyword">struct</span> is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">::</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 判断类型否是一个容器类型的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_container_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 普通版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 偏特化版本</span><span class="token keyword">struct</span> is_container_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">:</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断两个容器是否是相同类型容器的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token operator">></span><span class="token keyword">struct</span> is_same_container_type<span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> value <span class="token operator">=</span> std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_container_type<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">>></span><span class="token operator">::</span>value <span class="token operator">&amp;&amp;</span> is_same_container_type<span class="token operator">&lt;</span>Container1<span class="token punctuation">,</span> Container2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// #接口实现2</span><span class="token punctuation">{</span>    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> a0 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token keyword">float</span> b0 <span class="token operator">=</span> <span class="token number">20.2</span><span class="token punctuation">;</span>   <span class="token keyword">auto</span> c0 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0<span class="token punctuation">,</span> b0 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, a0 和 b0是可加的</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现2上</span>   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>   <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现1上</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写到这里发现这个接口已经像那么回事了，但是还是存在问题，因为我们针对容器类型的函数模板中，使用了emplace_back这个函数，不幸的是并不是所有的容器类型里面都支持这个函数，比如std::set，std::map里面只有insert方法。我们需要根据容器类型里有没有emplace_back函数来区分处理。这时候，可以先写一个判断类型中是否有emplace_back方法的元函数，然后利用<strong>编译期if</strong>来分别做处理：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 判断类型中是否有emplace_back成员的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> has_emplace_back_method <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> has_emplace_back_method<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token operator">:</span> std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// # 改进后的接口实现2</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_container_type<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">>></span><span class="token operator">::</span>value <span class="token operator">&amp;&amp;</span> is_same_container_type<span class="token operator">&lt;</span>Container1<span class="token punctuation">,</span> Container2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// </span><span class="token punctuation">{</span>    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 编译期if，由于我们事先已经约束了Container1和Container2是同型容器，因此只要判断一个就行</span>        <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 测试</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> b2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 也可以支持了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译期if是在c++17标准之后引入的东西，与std::enable_if其实非常类似，其原理也是利用了SFINAE机制，在某些时候甚至可以和std::enable_if互换着用。比如这里如果不用编译期if表达式的话，我们可以再写一个针对具有insert方法的容器类型的重载函数模板，通过std::enable_if来控制编译器选择哪个模板来实例化。</p><p>编译期if的好处是可以根据条件来启用或禁止某些特定语句，而不用像std::enable_if一样重新写一个模板，此外它的可读性更好一些。</p><p>当我们觉得这个函数接口已经写完了的时候，又发现了重大的问题，我们这个接口虽然对容器类型的数据很好的支持了，但是对数组却不支持，好家伙，这是万万不能行的。不过问题其实不大，我们只要对数组类型的数据整一个特化的版本就好了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N1<span class="token punctuation">,</span> <span class="token keyword">int</span> N2<span class="token operator">></span><span class="token keyword">struct</span> min_val <span class="token comment" spellcheck="true">// 元函数：求两个数中的最小值</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> value <span class="token operator">=</span> N1 <span class="token operator">&lt;</span> N2 <span class="token operator">?</span> N1 <span class="token operator">:</span> N2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 元函数：求两个数中的最大值</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">max_val</span><span class="token punctuation">(</span> <span class="token keyword">int</span> N1<span class="token punctuation">,</span> <span class="token keyword">int</span> N2 <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 常量表达式,C++14</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> N1 <span class="token operator">></span> N2 <span class="token operator">?</span> N1 <span class="token operator">:</span> N2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 针对数组类型的模板特化</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">int</span> N1<span class="token punctuation">,</span>         <span class="token keyword">typename</span> T2<span class="token punctuation">,</span> <span class="token keyword">int</span> N2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span><span class="token function">add</span><span class="token punctuation">(</span> <span class="token function">T1</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">T2</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span>N2<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注意这里要用static修饰要返回用结果变量，不然你返回一个临时变量的指针，运行时会出错</span>    <span class="token keyword">static</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span><span class="token function">max_val</span><span class="token punctuation">(</span> N1<span class="token punctuation">,</span> N2 <span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> min_val<span class="token operator">&lt;</span>N1<span class="token punctuation">,</span> N2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N1<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 处理剩余的元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N2<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回数组退化后的指针(注意c++是不允许返回数组类型的)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>min_val和max_val是典型的值元编程技巧，可以用来在编译期间进行值计算。其中常量表达式可读性更好一些。</p><p>到这里，我们的add接口才算是写完了，现在将完整的代码贴在下面供大家参考：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> MY_ADD_H</span><span class="token macro property">#<span class="token directive keyword">define</span> MY_ADD_H</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token comment" spellcheck="true">// 判断两个类型是否支持加法的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_add_supported_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 如果支持加法，is_add_supported_type继承的value = 1</span><span class="token keyword">struct</span> is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">::</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 判断类型否是一个容器类型的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_container_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 普通版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 偏特化版本</span><span class="token keyword">struct</span> is_container_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">:</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断两个容器是否是相同类型容器的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token operator">></span><span class="token keyword">struct</span> is_same_container_type<span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> value <span class="token operator">=</span> std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断类型中是否有emplace_back成员的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> has_emplace_back_method <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> has_emplace_back_method<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token operator">:</span> std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// # 改进后的接口实现2</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_container_type<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">>></span><span class="token operator">::</span>value <span class="token operator">&amp;&amp;</span> is_same_container_type<span class="token operator">&lt;</span>Container1<span class="token punctuation">,</span> Container2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// </span><span class="token punctuation">{</span>    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 编译期if，由于我们事先已经约束了Container1和Container2是同型容器，因此只要判断一个就行</span>        <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N1<span class="token punctuation">,</span> <span class="token keyword">int</span> N2<span class="token operator">></span><span class="token keyword">struct</span> min_val <span class="token comment" spellcheck="true">// 元函数：求两个数中的最小值</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> value <span class="token operator">=</span> N1 <span class="token operator">&lt;</span> N2 <span class="token operator">?</span> N1 <span class="token operator">:</span> N2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 元函数：求两个数中的最大值</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">max_val</span><span class="token punctuation">(</span> <span class="token keyword">int</span> N1<span class="token punctuation">,</span> <span class="token keyword">int</span> N2 <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 常量表达式,C++14</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> N1 <span class="token operator">></span> N2 <span class="token operator">?</span> N1 <span class="token operator">:</span> N2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 针对数组类型的模板特化版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">int</span> N1<span class="token punctuation">,</span>         <span class="token keyword">typename</span> T2<span class="token punctuation">,</span> <span class="token keyword">int</span> N2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span><span class="token function">add</span><span class="token punctuation">(</span> <span class="token function">T1</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">T2</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span>N2<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span><span class="token function">max_val</span><span class="token punctuation">(</span> N1<span class="token punctuation">,</span> N2 <span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> min_val<span class="token operator">&lt;</span>N1<span class="token punctuation">,</span> N2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N1<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 处理剩余的元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N2<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回数组退化后的指针</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"my_add.h"</span></span><span class="token keyword">struct</span> A<span class="token punctuation">{</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">A</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a_ <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span> a_ <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    A <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> A<span class="token operator">&amp;</span> rhs <span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">A</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>a <span class="token operator">+</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token function">B</span><span class="token punctuation">(</span> <span class="token keyword">const</span> T b_ <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">b</span><span class="token punctuation">(</span> b_ <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> B rhs <span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token comment" spellcheck="true">// 加法运算符重载1</span>        <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">B</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>        <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> B<span class="token operator">&lt;</span>U<span class="token operator">></span> rhs <span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token comment" spellcheck="true">// 加法运算符重载2 </span>        <span class="token punctuation">{</span>                <span class="token keyword">return</span> B<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意这里让编译器去决定加法之后的模板参数类型是什么</span>        <span class="token punctuation">}</span>        T b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a0 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">float</span> b0 <span class="token operator">=</span> <span class="token number">2.1</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c0 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0<span class="token punctuation">,</span> b0 <span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>c0<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印3.1</span>    A <span class="token function">a1</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b1</span><span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>c1<span class="token punctuation">.</span>a<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印30</span>    B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a2</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> <span class="token function">b2</span><span class="token punctuation">(</span> <span class="token number">22.2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>c2<span class="token punctuation">.</span>b<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印30.2</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a0_vec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b0_vec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c0_vec <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0_vec<span class="token punctuation">,</span> b0_vec <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印2, 4, 6, 4</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> c0_vec <span class="token punctuation">)</span> std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>val<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a0_set <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b0_set <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c0_set <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0_set<span class="token punctuation">,</span> b0_set <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印2, 4, 6, 4</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> c0_set <span class="token punctuation">)</span> std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>val<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">a1_vec</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">b1_vec</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c1_vec <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1_vec<span class="token punctuation">,</span> b1_vec <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>    <span class="token keyword">int</span> a0_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> b0_array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c0_array <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0_array<span class="token punctuation">,</span> b0_array <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印2, 4, 6, 4</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>c0_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>     A a1_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    A b1_array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c1_array <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1_array<span class="token punctuation">,</span> b1_array <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上就是我们为了实现一个范型的add接口所做的全部工作，当然了可以发现template那写的一坨阅读性非常差，所以在C++20版本中添加了新的特性: concept和require，赞美20。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;SFINAE（Substitution Failure Is Not An Error，替换失败并非错误）一听就非常高级，什么是“替换”？这
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(三)</title>
    <link href="https://joytsing.github.io/posts/7859/"/>
    <id>https://joytsing.github.io/posts/7859/</id>
    <published>2024-04-01T09:03:35.000Z</published>
    <updated>2024-04-07T12:55:51.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>说实话，这章我没太看懂，可能还是需要反复多次阅读。</p><h2 id="内核和用户进程协作之epoll"><a href="#内核和用户进程协作之epoll" class="headerlink" title="内核和用户进程协作之epoll"></a>内核和用户进程协作之epoll</h2><p>IO多路复用机制可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。这里的复用指的是对进程的复用，在Linux上多路复用方案有select、poll、epoll。它们三个中的epoll的性能表现是最优秀的，能支持的并发量也最大，epoll的简单示例如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">listen</span><span class="token punctuation">(</span>lfd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cfd1 <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cfd2 <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    efd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>efd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> cfd1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>efd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> cfd2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">epoll_wait</span><span class="token punctuation">(</span>efd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中和epoll相关的函数是如下三个：</p><ul><li><code>epoll_create</code>：创建一个epoll对象</li><li><code>epoll_ctl</code>：向epoll对象添加要管理的连接</li><li><code>epoll_wait</code>：等待其管理的连接上的IO事件</li></ul><h3 id="1）epoll内核对象的创建"><a href="#1）epoll内核对象的创建" class="headerlink" title="1）epoll内核对象的创建"></a>1）epoll内核对象的创建</h3><p>在用户进程调用<code>epoll_create</code>时，内核会创建一个<code>struct eventpoll</code>内核对象，并把它关联到当前进程的已打开文件列表中，如下图所示：</p><p><img src="/posts/7859/d729732bab9941f7a1cfbc568da0ae79.png" alt></p><p>对于<code>struct eventpoll</code>对象，更详细的结构如下图所示：</p><p><img src="/posts/7859/4ee694ad35ed48768bd42f30c1e12cb3.png" alt></p><p><code>poll_create</code>源码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>epoll_create1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> error<span class="token punctuation">,</span> fd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 创建一个eventpoll对象</span>    error <span class="token operator">=</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>struct eventpoll</code>的定义如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">struct</span> eventpoll <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// sys_epollo_wait用到的等待队列</span>    wait_queue_head_t wq<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 接收就绪的描述符都会放到这里</span>    <span class="token keyword">struct</span> list_head rdllist<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每个epollo对象中都有一棵红黑树</span>    <span class="token keyword">struct</span> rb_root rbr<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>eventpoll</code>这个结构体的几个成员的含义如下：</p><ul><li><code>wq</code>：等待队列链表。软中断数据就绪的时候会通过wq来找到阻塞在epoll对象上的用户进程</li><li><code>rbr</code>：一棵红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll内部使用了一棵红黑树。通过这棵树来管理用户进程添加进来的所有socket连接</li><li><code>rdllist</code>：就绪的描述符的链表。当有连接就绪的时候，内核会把就绪的连接放到rdllist链表里。这样应用进程只需要判断链表就能找出就绪连接，而不用去遍历整棵树</li></ul><p><code>eventpoll</code>初始化工作在<code>ep_alloc</code>中完成：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> eventpoll <span class="token operator">*</span><span class="token operator">*</span>pep<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 申请eventpoll内存</span>    ep <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ep<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 初始化等待队列头</span>    <span class="token function">init_waitqueue_head</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_waitqueue_head</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>poll_wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化就绪队列</span>    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>rdllist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化红黑树指针</span>    ep<span class="token operator">-></span>rbr <span class="token operator">=</span> RB_ROOT<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）为epoll添加socket"><a href="#2）为epoll添加socket" class="headerlink" title="2）为epoll添加socket"></a>2）为epoll添加socket</h3><p><strong>理解这一步是理解整个epoll的关键</strong>。为了简单起见，这里只考虑使用EPOLL_CTL_ADD添加socket，先忽略删除和更新。假设现在和客户端的多个连接的socket都创建好了，也创建好了epoll内核对象。在使用epoll_ctl注册每一个socket的时候，内核会做如下三件事情：</p><ol><li>分配一个红黑树节点对象<code>epitem</code></li><li>将等待事件添加到<code>socket</code>的等待队列中，其回调函数是<code>ep_poll_callback</code></li><li>将<code>epitem</code>插入epoll对象的红黑树</li></ol><p>通过<code>epoll_ctl</code>添加两个<code>socket</code>以后，这些内核数据结构最终在进程中的关系大致如下图所示：</p><p><img src="/posts/7859/acb2653d9cef4aa39b77adf579812f64.png" alt></p><p>来看看socket是如何添加到epoll对象里的，找到<code>epoll_ctl</code>的源码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>epoll_ctl<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span>        <span class="token keyword">struct</span> epoll_event __user <span class="token operator">*</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token operator">*</span>tfile<span class="token punctuation">;</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 根据epfd找到eventpoll内核对象</span>    file <span class="token operator">=</span> <span class="token function">fget</span><span class="token punctuation">(</span>epfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 根据socket句柄号,找到其file内核对象</span>    tfile <span class="token operator">=</span> <span class="token function">fget</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    ep <span class="token operator">=</span> file<span class="token operator">-></span>private_data<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>op<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> EPOLL_CTL_ADD<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>epi<span class="token punctuation">)</span> <span class="token punctuation">{</span>            epds<span class="token punctuation">.</span>events <span class="token operator">|</span><span class="token operator">=</span> POLLERR <span class="token operator">|</span> POLLHUP<span class="token punctuation">;</span>            error <span class="token operator">=</span> <span class="token function">ep_insert</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> <span class="token operator">&amp;</span>epds<span class="token punctuation">,</span> tfile<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span>            error <span class="token operator">=</span> <span class="token operator">-</span>EEXIST<span class="token punctuation">;</span>        <span class="token function">clear_tfile_check_list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>epoll_ctl</code>中首先根据传入fd找到<code>eventpoll</code>、<code>socket</code>相关的内核对象。对于<code>EPOLL_CTL_ADD</code>操作来说，会执行到<code>ep_insert</code>函数。所有的注册都是在这个函数中完成的:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event <span class="token operator">*</span>event<span class="token punctuation">,</span>             <span class="token keyword">struct</span> file <span class="token operator">*</span>tfile<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> epitem <span class="token operator">*</span>epi<span class="token punctuation">;</span>    <span class="token keyword">struct</span> ep_pqueue epq<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 1.分配并初始化epitem</span>    <span class="token comment" spellcheck="true">// 分配一个epi对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>epi <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>epi_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 对分配的epi对象进行初始化</span>    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-></span>pwqlist<span class="token punctuation">)</span><span class="token punctuation">;</span>    epi<span class="token operator">-></span>ep <span class="token operator">=</span> ep<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// epi->ffd中存了句柄号和struct file对象地址</span>    <span class="token function">ep_set_ffd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-></span>ffd<span class="token punctuation">,</span> tfile<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 2.设置socket等待队列</span>    <span class="token comment" spellcheck="true">// 定义并初始化ep_pqueue对象</span>    epq<span class="token punctuation">.</span>epi <span class="token operator">=</span> epi<span class="token punctuation">;</span>    <span class="token function">init_poll_funcptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epq<span class="token punctuation">.</span>pt<span class="token punctuation">,</span> ep_ptable_queue_proc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用ep_ptable_queue_proc注册回调函数</span>    <span class="token comment" spellcheck="true">// 实际注入的函数为ep_poll_callback</span>    revents <span class="token operator">=</span> <span class="token function">ep_item_poll</span><span class="token punctuation">(</span>epi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>epq<span class="token punctuation">.</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 3.将epi插入eventpoll对象的红黑树中</span>    <span class="token function">ep_rbtree_insert</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> epi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分配并初始化epitem</strong></p><p>对于每一个socket，调用epoll_ctl的时候，都会为之分配一个epitem。该结构的主要数据结构如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">struct</span> epitem <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 红黑树节点</span>    <span class="token keyword">struct</span> rb_node rbn<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// socket文件描述信息</span>    <span class="token keyword">struct</span> epoll_filefd ffd<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 等待队列</span>    <span class="token keyword">struct</span> list_head pwqlist<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 所归属的eventpoll对象</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对<code>epitem</code>进行一些初始化，首先在<code>epi-&gt;ep = ep;</code>这行代码中将其ep指针指向<code>eventpoll</code>对象。另外用要添加的socket的file、fd来填充<code>epi-&gt;ffd</code>。<code>epitem</code>初始化后的关联关系如下图所示：</p><p><img src="/posts/7859/e853a1e1e9434c3dacc8fad82620a8bb.png" alt></p><p>其中使用到的ep_set_ffd函数如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">ep_set_ffd</span><span class="token punctuation">(</span><span class="token keyword">struct</span> epoll_filefd <span class="token operator">*</span>ffd<span class="token punctuation">,</span>                  <span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>    ffd<span class="token operator">-></span>file <span class="token operator">=</span> file<span class="token punctuation">;</span>    ffd<span class="token operator">-></span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>设置socket等待队列</strong></p><p>在创建<code>epitem</code>并初始化之后，<code>ep_insert</code>中第二件事情就是设置socket对象上的等待任务队列，并把函数<code>fs/eventpoll.c</code>文件下的<code>ep_poll_callback</code>设置为数据就绪时候的回调函数，如下图所示：</p><p><img src="/posts/7859/21c97a7247f140ce8953faa75e349dd3.png" alt></p><p>先来看<code>ep_item_poll</code>：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">ep_item_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> epitem <span class="token operator">*</span>epi<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>pt<span class="token punctuation">)</span><span class="token punctuation">{</span>    pt<span class="token operator">-></span>_key <span class="token operator">=</span> epi<span class="token operator">-></span>event<span class="token punctuation">.</span>events<span class="token punctuation">;</span>    <span class="token keyword">return</span> epi<span class="token operator">-></span>ffd<span class="token punctuation">.</span>file<span class="token operator">-></span>f_op<span class="token operator">-></span><span class="token function">poll</span><span class="token punctuation">(</span>epi<span class="token operator">-></span>ffd<span class="token punctuation">.</span>file<span class="token punctuation">,</span> pt<span class="token punctuation">)</span> <span class="token operator">&amp;</span> epi<span class="token operator">-></span>event<span class="token punctuation">.</span>events<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里调用了socket下的<code>file-&gt;f_op-&gt;poll</code>，这个函数实际上是<code>sock_poll</code>：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/socket.c</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">sock_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>wait<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    sock <span class="token operator">=</span> file<span class="token operator">-></span>private_data<span class="token punctuation">;</span>    <span class="token keyword">return</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">poll</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sock-&gt;ops-&gt;poll</code>指向的是<code>tcp_poll</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp.c</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">tcp_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>wait<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-></span>sk<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">sock_poll_wait</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token function">sk_sleep</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在sock_poll_wait的第二个参数传参前，先调用了sk_sleep函数。<strong>在这个函数里它获取了sock对象下的等待队列列表头wait_queue_head_t，稍后等待队列项就插到这里</strong>。这里稍微注意下，是socket的等待队列，不是epoll对象的。下面来看sk_sleep源码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/net/sock.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> wait_queue_head_t <span class="token operator">*</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket_wq<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token function">rcu_dereference_raw</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_wq<span class="token punctuation">)</span><span class="token operator">-></span>wait<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着真正进入<code>sock_poll_wait</code>:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/net/sock.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">sock_poll_wait</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>filp<span class="token punctuation">,</span>        wait_queue_head_t <span class="token operator">*</span>wait_address<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">poll_wait</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> wait_address<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// include/linux/poll.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">poll_wait</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span> filp<span class="token punctuation">,</span> wait_queue_head_t <span class="token operator">*</span> wait_address<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>_qproc <span class="token operator">&amp;&amp;</span> wait_address<span class="token punctuation">)</span>        p<span class="token operator">-></span><span class="token function">_qproc</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> wait_address<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的<code>qproc</code>是个函数指针，它在前面的<code>init_poll_funcptr</code>调用时设置成了<code>ep_ptable_queue_proc</code>函数，<code>ep_ptable_queue_proc</code>源码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ep_ptable_queue_proc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> wait_queue_head_t <span class="token operator">*</span>whead<span class="token punctuation">,</span>                 poll_table <span class="token operator">*</span>pt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> epitem <span class="token operator">*</span>epi <span class="token operator">=</span> <span class="token function">ep_item_from_epqueue</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> eppoll_entry <span class="token operator">*</span>pwq<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>epi<span class="token operator">-></span>nwait <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pwq <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>pwq_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化回调方法</span>        <span class="token function">init_waitqueue_func_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pwq<span class="token operator">-></span>wait<span class="token punctuation">,</span> ep_poll_callback<span class="token punctuation">)</span><span class="token punctuation">;</span>        pwq<span class="token operator">-></span>whead <span class="token operator">=</span> whead<span class="token punctuation">;</span>        pwq<span class="token operator">-></span>base <span class="token operator">=</span> epi<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将ep_poll_callback放入socket等待队列whead(注意不是epollo等待队列)</span>        <span class="token function">add_wait_queue</span><span class="token punctuation">(</span>whead<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pwq<span class="token operator">-></span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pwq<span class="token operator">-></span>llink<span class="token punctuation">,</span> <span class="token operator">&amp;</span>epi<span class="token operator">-></span>pwqlist<span class="token punctuation">)</span><span class="token punctuation">;</span>        epi<span class="token operator">-></span>nwait<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        epi<span class="token operator">-></span>nwait <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在ep_ptable_queue_proc函数中，新建了一个等待队列项，并注册其回调函数为ep_poll_callback函数，然后再将这个等待项添加到socket的等待队列中</strong>。</p><p>在前面介绍阻塞式的系统调用recvfrom时，由于需要在数据就绪的时候唤醒用户进程，所以等待对象项的private会设置成当前用户进程描述符current。而这里的socket是交给epoll来管理的，不需要在一个socket就绪的时候就唤醒进程，所以这里的q-&gt;private没有什么用就设置成了NULL</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/linux/wait.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">init_waitqueue_func_entry</span><span class="token punctuation">(</span>wait_queue_t <span class="token operator">*</span>q<span class="token punctuation">,</span>                    wait_queue_func_t func<span class="token punctuation">)</span><span class="token punctuation">{</span>    q<span class="token operator">-></span>flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>private <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>func <span class="token operator">=</span> func<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，等待队列项中仅将回调函数q-&gt;func设置为<code>ep_poll_callback</code>。后面讲到“数据来了”时，软中断将数据收到socket的接收队列后，会通过注册的这个<code>ep_poll_callback</code>函数来回调，进而通知epoll对象</p><p><strong>插入红黑树</strong></p><p>分配完epitem对象后，紧接着把它插入红黑树。一个插入了一些socket描述符的epoll里的红黑树示意图如下图所示：</p><p><img src="/posts/7859/e3ef503e34e049939a418227510c40f2.png" alt></p><p>这里使用红黑树是为了让epoll在查找效率、插入效率、内存开销等多个方法比较均衡。</p><h3 id="3）epoll-wait之等待接收"><a href="#3）epoll-wait之等待接收" class="headerlink" title="3）epoll_wait之等待接收"></a>3）epoll_wait之等待接收</h3><p><code>epoll_wait</code>做的事情不复杂，当它被调用时，它观察<code>eventpoll-&gt;rdllist</code>链表里有没有数据。有数据就返回，没有数据就创建一个等待队列项，将其添加到<code>eventpoll</code>的等待队列上，然后把自己阻塞掉:</p><p><img src="/posts/7859/cc452e808acd4f80bbd1c9be43a08b56.png" alt></p><p>其源代码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>epoll_wait<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event __user <span class="token operator">*</span><span class="token punctuation">,</span> events<span class="token punctuation">,</span>        <span class="token keyword">int</span><span class="token punctuation">,</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    error <span class="token operator">=</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> events<span class="token punctuation">,</span> maxevents<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event __user <span class="token operator">*</span>events<span class="token punctuation">,</span>           <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    wait_queue_t wait<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>fetch_events<span class="token punctuation">:</span>    <span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1.判断就绪队列上有没有事件就绪</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ep_events_available</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 2.定义等待事件关联当前进程</span>        <span class="token function">init_waitqueue_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wait<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.把新waitqueue添加到epoll->wq链表</span>        <span class="token function">__add_wait_queue_exclusive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>wq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 4.让出CPU,主动进入睡眠状态</span>            <span class="token function">set_current_state</span><span class="token punctuation">(</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ep_events_available</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span> <span class="token operator">||</span> timed_out<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> <span class="token operator">-</span>EINTR<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">schedule_hrtimeout_range</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> slack<span class="token punctuation">,</span> HRTIMER_MODE_ABS<span class="token punctuation">)</span><span class="token punctuation">)</span>                timed_out <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">__remove_wait_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>wq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">set_current_state</span><span class="token punctuation">(</span>TASK_RUNNING<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>判断就绪队列上有没有事件就绪</strong></p><p>首先调用ep_events_available来判断就绪链表中是否有可处理的事件</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">ep_events_available</span><span class="token punctuation">(</span><span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>rdllist<span class="token punctuation">)</span> <span class="token operator">||</span> ep<span class="token operator">-></span>ovflist <span class="token operator">!=</span> EP_UNACTIVE_PTR<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>定义等待事件关联当前进程</strong></p><p>假设确实没有就绪的连接，那接着会进入init_waitqueue_entry中定义等待任务，并把current（当前进程）添加到waitqueue上</p><blockquote><p>当没有IO事件的时候，epollo也会阻塞调当前进程，因为没有事情可做了占着CPU也没什么意义。epoll本身是阻塞的，但一般会把socket设置成非阻塞</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/linux/wait.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">init_waitqueue_entry</span><span class="token punctuation">(</span>wait_queue_t <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">struct</span> task_struct <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    q<span class="token operator">-></span>flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>private <span class="token operator">=</span> p<span class="token punctuation">;</span>    q<span class="token operator">-></span>func <span class="token operator">=</span> default_wake_function<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里的回调函数名称是default_wake_function。后面讲到“数据来了”时将会调用该函数</p><p><strong>添加到等待队列</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/linux/wait.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__add_wait_queue_exclusive</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span>                          wait_queue_t <span class="token operator">*</span>wait<span class="token punctuation">)</span><span class="token punctuation">{</span>    wait<span class="token operator">-></span>flags <span class="token operator">|</span><span class="token operator">=</span> WQ_FLAG_EXCLUSIVE<span class="token punctuation">;</span>    <span class="token function">__add_wait_queue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里把定义的等待事件添加到了epoll对象的等待队列中</p><p><strong>让出CPU主动进入睡眠状态</strong></p><p>通过set_current_state把当前进程设置为可打断。调用schedule_hrtimeout_range让出CPU，主动进入睡眠状态</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/hrtimer.c</span><span class="token keyword">int</span> __sched <span class="token function">schedule_hrtimeout_range</span><span class="token punctuation">(</span>ktime_t <span class="token operator">*</span>expires<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> delta<span class="token punctuation">,</span>                     <span class="token keyword">const</span> <span class="token keyword">enum</span> hrtimer_mode mode<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">schedule_hrtimeout_range_clock</span><span class="token punctuation">(</span>expires<span class="token punctuation">,</span> delta<span class="token punctuation">,</span> mode<span class="token punctuation">,</span>                          CLOCK_MONOTONIC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> __sched<span class="token function">schedule_hrtimeout_range_clock</span><span class="token punctuation">(</span>ktime_t <span class="token operator">*</span>expires<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> delta<span class="token punctuation">,</span>                   <span class="token keyword">const</span> <span class="token keyword">enum</span> hrtimer_mode mode<span class="token punctuation">,</span> <span class="token keyword">int</span> clock<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在schedule中选择下一个进程调度</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> __sched <span class="token function">__schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    next <span class="token operator">=</span> <span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">context_switch</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4）数据来了"><a href="#4）数据来了" class="headerlink" title="4）数据来了"></a>4）数据来了</h3><p>在前面<code>epoll_ctl</code>执行的时候，内核为每一个socket都添加了一个等待队列项。在<code>epoll_wait</code>运行完的时候，又在<code>event poll</code>对象上添加了等待队列元素</p><p><img src="/posts/7859/d8159be603374ed28e8871b2107cd864.png" alt></p><ul><li>socket-&gt;sock-&gt;sk_data_ready设置的就绪处理函数是sock_def_readable</li><li>在socket的等待队列中，其回调函数是<code>ep_poll_callback</code>，private指向的是空指针null</li><li>在eventpoll的等待队列项中，其回调函数是<code>default_wake_function</code>，private指向的是等待该事件的用户进程</li></ul><p><strong>将数据接收到任务队列</strong></p><p>从TCP协议栈的处理入口函数tcp_v4_rcv开始：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_ipv4.c</span><span class="token keyword">int</span> <span class="token function">tcp_v4_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 获取TCP头</span>    th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取IP头</span>    iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 根据数据包头中的IP、端口信息查找到对应的socket</span>    sk <span class="token operator">=</span> <span class="token function">__inet_lookup_skb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_hashinfo<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> th<span class="token operator">-></span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// socket未被用户锁定</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sock_owned_by_user</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tcp_prequeue</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span>                ret <span class="token operator">=</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在tcp_v4_rcv中首先根据收到的网络包的header里的source和dest信息在本机上查找对应的socket。找到以后，直接接入接收的主体函数<code>tcp_v4_do_rcv</code>:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_ipv4.c</span><span class="token keyword">int</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 执行连接状态下的数据处理  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tcp_rcv_established</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">,</span> skb<span class="token operator">-></span>len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rsk <span class="token operator">=</span> sk<span class="token punctuation">;</span>            <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 其他非ESTABLISH状态的数据包处理</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设处理的是ESTABLISH状态下的包，这样就又进入tcp_rcv_established函数中进行处理了</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_input.c</span><span class="token keyword">int</span> <span class="token function">tcp_rcv_established</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span>            <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token comment" spellcheck="true">// 将数据接收到队列中</span>                eaten <span class="token operator">=</span> <span class="token function">tcp_queue_rcv</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> tcp_header_len<span class="token punctuation">,</span>                              <span class="token operator">&amp;</span>fragstolen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true">// 数据准备好,唤醒socket上阻塞掉的进程  </span>            sk<span class="token operator">-></span><span class="token function">sk_data_ready</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>tcp_rcv_established</code>中通过调用<code>tcp_queue_rcv</code>函数完成了将接收数据放到socket的接收队列上，如下图所示：</p><p><img src="/posts/7859/be296fe2204c4232ab641f4bfc0b3a46.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_input.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> __must_check <span class="token function">tcp_queue_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">int</span> hdrlen<span class="token punctuation">,</span>          bool <span class="token operator">*</span>fragstolen<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 把接收到的数据放到socket的接收队列的尾部 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>eaten<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">__skb_queue_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-></span>sk_receive_queue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">skb_set_owner_r</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> eaten<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查找就绪回调函数</strong></p><p>调用<code>tcp_queue_rcv</code>完成接收之后，接着再调用<code>sk_data_ready</code>来唤醒在socket上等待的用户进程。在“socket的直接创建”中讲到的<code>sock_init_data</code>函数，已经把<code>sk_data_ready</code>设置成了<code>sock_def_readable</code>函数了。它是默认的数据就绪处理函数。</p><p>当socket上数据就绪时，内核将以<code>sock_def_readable</code>这个函数为入口，找到<code>epoll_ctl</code>添加socket时在其上设置的回调函数<code>ep_poll_callback</code>，如下图所示：</p><p><img src="/posts/7859/5d80e29b7219487986e1ba01f822843c.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/sock.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sock_def_readable</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket_wq <span class="token operator">*</span>wq<span class="token punctuation">;</span>    <span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wq <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_wq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断等待队列不为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wq_has_sleeper</span><span class="token punctuation">(</span>wq<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 执行等待队列项上的回调函数</span>        <span class="token function">wake_up_interruptible_sync_poll</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wq<span class="token operator">-></span>wait<span class="token punctuation">,</span> POLLIN <span class="token operator">|</span> POLLPRI <span class="token operator">|</span>                        POLLRDNORM <span class="token operator">|</span> POLLRDBAND<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sk_wake_async</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> SOCK_WAKE_WAITD<span class="token punctuation">,</span> POLL_IN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">rcu_read_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点看<code>wake_up_interruptible_sync_poll</code>，看一下内核是怎么找到等待队列项里注册的回调函数的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/linux/wait.h</span><span class="token macro property">#<span class="token directive keyword">define</span> wake_up_interruptible_sync_poll(x, m)                \    __wake_up_sync_key((x), TASK_INTERRUPTIBLE, 1, (void *) (m))</span><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">void</span> <span class="token function">__wake_up_sync_key</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span>            <span class="token keyword">int</span> nr_exclusive<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>    <span class="token keyword">int</span> wake_flags <span class="token operator">=</span> WF_SYNC<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>nr_exclusive<span class="token punctuation">)</span><span class="token punctuation">)</span>        wake_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__wake_up_common</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> nr_exclusive<span class="token punctuation">,</span> wake_flags<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着进入<code>__wake_up_common</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__wake_up_common</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span>            <span class="token keyword">int</span> nr_exclusive<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    wait_queue_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token function">list_for_each_entry_safe</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token operator">-></span>task_list<span class="token punctuation">,</span> task_list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> flags <span class="token operator">=</span> curr<span class="token operator">-></span>flags<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> wake_flags<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> WQ_FLAG_EXCLUSIVE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token operator">--</span>nr_exclusive<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>__wake_up_common</code>中，选出等待队列里注册的某个元素<code>curr</code>，回调其<code>curr-&gt;func</code>。之前调用<code>ep_insert</code>的时候，把这个func设置成<code>ep_poll_callback</code>了</p><p><strong>执行socket就绪回调函数</strong></p><p>找到了socket等待队列项里注册的函数<code>ep_poll_callback</code>，接着软中断就会调用它</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll_callback</span><span class="token punctuation">(</span>wait_queue_t <span class="token operator">*</span>wait<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> sync<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 获取wait对应的epitem</span>    <span class="token keyword">struct</span> epitem <span class="token operator">*</span>epi <span class="token operator">=</span> <span class="token function">ep_item_from_wait</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取epitem对应的eventpoll结构体</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep <span class="token operator">=</span> epi<span class="token operator">-></span>ep<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ep_is_linked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-></span>rdllink<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.将当前epitem添加到eventpoll的就绪队列中</span>        <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-></span>rdllink<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ep<span class="token operator">-></span>rdllist<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ep_pm_stay_awake_rcu</span><span class="token punctuation">(</span>epi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2.查看eventpoll的等待队列上是否有等待</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">waitqueue_active</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>wq<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">wake_up_locked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>ep_poll_callback</code>中根据等待任务队列上额外的base指针可以找到epitem，进而也可以找到<code>eventpoll</code>对象</p><p>它做的第一件事就是<strong>把自己的epitem添加到epoll的就绪队列中</strong>。接着它又会查看eventpoll对象上的的等待队列里是否有等待项（epoll_wait执行的时候会设置）。如果没有等待项，软中断的事情就做完了。如果有等待项，那就找到等待项里设置的回调函数，如下图所示：</p><p><img src="/posts/7859/4628c0dcfefd440caf263025cc6884f2.png" alt></p><p>依次调用<code>wake_up_locked() =&gt; __wake_up_locked() =&gt; __wake_up_common</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__wake_up_common</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span>            <span class="token keyword">int</span> nr_exclusive<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    wait_queue_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token function">list_for_each_entry_safe</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token operator">-></span>task_list<span class="token punctuation">,</span> task_list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> flags <span class="token operator">=</span> curr<span class="token operator">-></span>flags<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> wake_flags<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> WQ_FLAG_EXCLUSIVE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token operator">--</span>nr_exclusive<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>__wake_up_common</code>离，调用<code>curr-&gt;func</code>。这里的func是在<code>epoll_wait</code>时传入的<code>default_wake_function</code>函数</p><p><strong>执行epoll就绪通知</strong></p><p>在<code>default_wake_function</code>中找到等待队列项里的进程描述符，然后唤醒它，如下图所示：</p><p><img src="/posts/7859/0b82cf2b217c40d9a7fe80dba85acf32.png" alt="img"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">int</span> <span class="token function">default_wake_function</span><span class="token punctuation">(</span>wait_queue_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span>              <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">try_to_wake_up</span><span class="token punctuation">(</span>curr<span class="token operator">-></span>private<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> wake_flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等待队列项curr-&gt;private指针是在对象上等待而被阻塞掉的进程。将epoll_wait进程推入可运行队列，等待内核重新调度进程。当这个进程重新运行后，从epoll_wait阻塞时暂停的代码处继续执行。把rdlist中就绪的事件返回给用户进程</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event __user <span class="token operator">*</span>events<span class="token punctuation">,</span>           <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">__remove_wait_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>wq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">set_current_state</span><span class="token punctuation">(</span>TASK_RUNNING<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>check_events<span class="token punctuation">:</span>    eavail <span class="token operator">=</span> <span class="token function">ep_events_available</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 给用户进程返回就绪事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res <span class="token operator">&amp;&amp;</span> eavail <span class="token operator">&amp;&amp;</span>        <span class="token operator">!</span><span class="token punctuation">(</span>res <span class="token operator">=</span> <span class="token function">ep_send_events</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> events<span class="token punctuation">,</span> maxevents<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timed_out<span class="token punctuation">)</span>        <span class="token keyword">goto</span> fetch_events<span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从用户角度来看，epoll_wait只是多等了一会儿而已，但执行流程还是顺序的。</p><h3 id="5）小结"><a href="#5）小结" class="headerlink" title="5）小结"></a>5）小结</h3><p>epoll的整个工作流程总结如下图所示：</p><p><img src="/posts/7859/e15f9f2df8b645fe996a7e5ffaec561b.png" alt></p><p>其中软中断回调时的回调函数调用关系整理如下：</p><pre><code>sock_def_readable: sock对象初始化时设置的    =&gt; ep_poll_callback: 调用epll_ctl时添加到socket上的        =&gt; default_wake_function: 调用epoll_wait时设置到epoll上的</code></pre><p>总结一下，epoll相关的函数里内核运行环境分两部分：</p><ul><li>用户进程内核态。调用<code>epoll_wait</code>等函数时会将进程写入内核态来执行。这部分代码负责查看接收队列，以及负责把当前进程阻塞掉，让出CPU</li><li>硬、软中断上下文。在这些组件中，将包从网卡接收过来进行处理，然后放到socket的接收队列。对于epoll来说，再找到socket关联的epitem，并把它添加到epoll对象的就绪链表中。这个时候再捎带检查一下epoll上是否有被阻塞的进程，如果有唤醒它</li></ul><p><strong>在实践中，只要活儿足够多，epoll_wait根本不会让进程阻塞</strong>。用户进程会一直干活儿，一直干活儿，直到<code>epoll_wait</code>里实在没活儿可干的时候才主动让出CPU。这就是epoll高效的核心原因所在。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1）阻塞到底是怎么一回事？</strong></p><p>阻塞其实说的是<strong>进程因为等待某个事件而主动让出CPU挂起的操作</strong>。在网络IO中，当进程等待socket上的数据时，如果数据还没有到来，那就把当前进程状态从TASK_RUNNING修改为TASK_INTERRUPTIBLE，然后主动让出CPU。由调度器来调度下一个就绪状态的进程来执行</p><p>所以，在分析某个技术方案是不是阻塞的时候，关键要看进程有没有放弃CPU。如果放弃了，那就是阻塞。如果没放弃，那就是非阻塞。事实上，recvfrom也可以设置成非阻塞。在这种情况下，如果socket上没有数据到达，调用直接返回空，而不是挂起等待</p><p><strong>2）同步阻塞IO都需要哪些开销？</strong></p><p>同步阻塞IO的开销主要有以下这些：</p><ul><li>进程通过recv系统调用接收一个socket上的数据时，如果数据没有到达，进程就被从CPU上拿下来，然后再换上另一个进程。这导致一次进程上下文切换的开销</li><li>当连接上的数据就绪的时候，睡眠的进程又会被唤醒，又是一次进程切换的开销</li><li>一个进程同时只能等待一条连接，如果有很多并发，则需要很多进程。每个进程都将占用大于几MB的内存</li></ul><p><strong>3）多路复用epoll为什么就能提高网络性能？</strong></p><p>epoll高性能最根本的原因是<strong>极大程度地减少了无用的进程上下文切换，让进程更专注地处理网络请求</strong></p><p>在内核的硬、软中断上下文中，包从网卡接收过来进行处理，然后放到socket的接收队列。再找到socket关联的epitem，并把它添加到epoll对象的就绪链表中</p><p>在用户进程中，通过调用epoll_wait来查看就绪链表中是否有事件到达，如果有，直接走进行处理。处理完毕再次调用epoll_wait。在高并发的实践中，主要活儿足够多，epoll_wait根本不会让进程阻塞。用户进程会一直干活儿，一直干活儿，直到epoll_wait里实在没活儿可干的时候才主动让出CPU。这就是epoll高效的核心原因所在</p><p>至于红黑树，仅仅是提高了epoll查找、添加、删除socket时的效率而已，不算epoll在高并发场景高性能的根本原因</p><p><strong>4）epoll也是阻塞的？</strong></p><p>例如，一个epoll对象下添加了一万个客户端连接的socket。假设所有这些socket上都还没有数据到达，这个时候进程调用epoll_wait发现没有任何事情可干。这种情况下用户进程就会被阻塞掉，而这种情况是完全正常的，没有工作需要处理，那还占着CPU是没有道理的</p><p>阻塞不会导致低性能，过多过频繁的阻塞才会。epoll的阻塞和它的高性能并不冲突</p><p><strong>5）为什么Redis的网络性能很突出？</strong></p><p>Redis在网络IO性能上表现非常突出，单进程的服务器在极限情况下可以达到10万的QPS</p><p>Redis的事件循环可以简化到用如下伪代码来表示</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    job <span class="token operator">=</span> <span class="token function">epollo_wait</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">do_job</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Redis的主要业务逻辑就是在本机内存上的数据结构的读写，几乎没有网络IO和磁盘IP，单个请求处理起来很快。所以它把主服务器程序干脆就做成了单进程的，这样省去了多进程之间协作的负担，也很大程序减少了进程切换。进程主要的工作过程就是调用epoll_wait等待事件，有了事件以后处理，处理完之后再调用epoll_wait。一直工作，一直工作，直到实在没有请求需要处理，或者进程时间片到的时候才让出CPU。工作效率发挥到了极致</p><p><strong>推荐阅读：</strong></p><p>Linux五种I/O模型：<a href="https://wiyi.org/linux-io-model.html">带你彻底理解Linux五种I/O模型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;说实话，这章我没太看懂，可能还是需要反复多次阅读。&lt;/p&gt;
&lt;h2 id=&quot;内核和用户进程协作之epoll&quot;&gt;&lt;a href=&quot;#内核和用户
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(二)</title>
    <link href="https://joytsing.github.io/posts/36369/"/>
    <id>https://joytsing.github.io/posts/36369/</id>
    <published>2024-04-01T08:14:07.000Z</published>
    <updated>2024-04-01T16:03:56.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="socket的创建"><a href="#socket的创建" class="headerlink" title="socket的创建"></a>socket的创建</h2><p>socket函数调用执行完之后，用户层面看到返回的是一个整数型的句柄，但其实内核在内部创建了一系列socket相关的内核对象。它们互相之间的关系如下图所示：</p><p><img src="/posts/36369/4138aa4c844b498a8441d75227fac969.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/socket.c</span><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    retval <span class="token operator">=</span> <span class="token function">sock_create</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sock_create是创建socket的主要位置，其中sock_create又调用了<code>__sock_create</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/socket.c</span><span class="token keyword">int</span> <span class="token function">__sock_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span>             <span class="token keyword">struct</span> socket <span class="token operator">*</span><span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> err<span class="token punctuation">;</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> net_proto_family <span class="token operator">*</span>pf<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 分配socket对象</span>    sock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 获得每个协议族的操作表  </span>    pf <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>net_families<span class="token punctuation">[</span>family<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 调用指定协议族的创建函数,对于AF_INET对应的是inet_create</span>    err <span class="token operator">=</span> pf<span class="token operator">-></span><span class="token function">create</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>__sock_create</code>里，首先调用<code>sock_alloc</code>来分配一个<code>struct socket</code>内核对象，接着获取协议族的操作函数表，并调用其<code>create</code>方法。对于<code>AF_INET</code>协议族来说，执行到的是<code>inet_create</code>方法</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/af_inet.c</span><span class="token keyword">static</span> <span class="token keyword">struct</span> inet_protosw inetsw_array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token punctuation">{</span>        <span class="token punctuation">.</span>type <span class="token operator">=</span>       SOCK_STREAM<span class="token punctuation">,</span>        <span class="token punctuation">.</span>protocol <span class="token operator">=</span>   IPPROTO_TCP<span class="token punctuation">,</span>        <span class="token punctuation">.</span>prot <span class="token operator">=</span>       <span class="token operator">&amp;</span>tcp_prot<span class="token punctuation">,</span>        <span class="token punctuation">.</span>ops <span class="token operator">=</span>        <span class="token operator">&amp;</span>inet_stream_ops<span class="token punctuation">,</span>        <span class="token punctuation">.</span>no_check <span class="token operator">=</span>   <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span>flags <span class="token operator">=</span>      INET_PROTOSW_PERMANENT <span class="token operator">|</span>                  INET_PROTOSW_ICSK<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">inet_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span>               <span class="token keyword">int</span> kern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inet_protosw <span class="token operator">*</span>answer<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inet_sock <span class="token operator">*</span>inet<span class="token punctuation">;</span>    <span class="token keyword">struct</span> proto <span class="token operator">*</span>answer_prot<span class="token punctuation">;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">list_for_each_entry_rcu</span><span class="token punctuation">(</span>answer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inetsw<span class="token punctuation">[</span>sock<span class="token operator">-></span>type<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>protocol <span class="token operator">==</span> answer<span class="token operator">-></span>protocol<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>protocol <span class="token operator">!=</span> IPPROTO_IP<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>IPPROTO_IP <span class="token operator">==</span> protocol<span class="token punctuation">)</span> <span class="token punctuation">{</span>                protocol <span class="token operator">=</span> answer<span class="token operator">-></span>protocol<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>IPPROTO_IP <span class="token operator">==</span> answer<span class="token operator">-></span>protocol<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        err <span class="token operator">=</span> <span class="token operator">-</span>EPROTONOSUPPORT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 将inet_stream_ops赋到socket->ops上</span>    sock<span class="token operator">-></span>ops <span class="token operator">=</span> answer<span class="token operator">-></span>ops<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取tcp_prot</span>    answer_prot <span class="token operator">=</span> answer<span class="token operator">-></span>prot<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 分配sock对象,并把tcp_prot赋到sock->sk_prot上</span>    sk <span class="token operator">=</span> <span class="token function">sk_alloc</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> PF_INET<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> answer_prot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 对sock对象进行初始化</span>    <span class="token function">sock_init_data</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>inet_create</code>中，根据类型<code>SOCK_STREAM</code>查找到对于TCP定义的操作方法实现集合<code>inet_stream_ops</code>和<code>tcp_prot</code>，并把它们分别设置到socket-&gt;ops和sock-&gt;sk_prot上，如下图所示：</p><p><img src="/posts/36369/64d39a9bc891437eb300b02a93b9b160.png" alt></p><p>再往下看到了<code>sock_init_data</code>。在这个方法中将socket中的<code>sk_data_ready</code>函数指针进行了初始化，设置为默认<code>sock_def_readable</code>，如下图所示：</p><p><img src="/posts/36369/f78159063cb74376a6bf3deffd74ae0b.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/sock.c</span><span class="token keyword">void</span> <span class="token function">sock_init_data</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    sk<span class="token operator">-></span>sk_data_ready    <span class="token operator">=</span>    sock_def_readable<span class="token punctuation">;</span>    sk<span class="token operator">-></span>sk_write_space    <span class="token operator">=</span>    sock_def_write_space<span class="token punctuation">;</span>    sk<span class="token operator">-></span>sk_error_report    <span class="token operator">=</span>    sock_def_error_report<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>当软中断上收到数据包时通过调用sk_data_ready函数指针（实际被设置成了sock_def_readable()）来唤醒在socket上等待的进程</strong>。后面讲到“软中断模块”时可以看到这一过程。</p><p>至此，一个tcp对象，确切的说是AF_INET协议族下SOCKET_STREAM对象就算创建完成了。<strong>这里花费了一次socket系统调用的开销</strong></p><h2 id="内核和用户进程协作之阻塞方式"><a href="#内核和用户进程协作之阻塞方式" class="headerlink" title="内核和用户进程协作之阻塞方式"></a>内核和用户进程协作之阻塞方式</h2><p>在同步阻塞IO模型中，先是用户进程发起创建socket的指令，然后切换到内核态完成了内核对象的初始化。接下来，Linux在数据包的接收上，是硬中断和ksoftirqd线程在进行处理。当ksoftirqd线程处理完以后，再通知相关的用户进程。从用户进程创建socket，到一个网络包抵达网卡被用户进程接收，同步阻塞IO总体上的流程如下图所示：</p><p><img src="/posts/36369/f5a1fc855ce94cd4b42ee99db2335854.png" alt></p><h3 id="1）等待接收消息"><a href="#1）等待接收消息" class="headerlink" title="1）等待接收消息"></a>1）等待接收消息</h3><p>clib库recv函数会执行recvform系统调用。进入系统调用后，用户进程就进入了内核态，执行一系列的内核协议层函数，然后到socket对象的接收队列中查看是否有数据，没有的话就把是自己添加到socket对应的等待队列里。最后让出CPU，操作系统会选择下一个就绪状态的进程来执行。整个流程如下图所示：</p><p><img src="/posts/36369/a32a158245774f2f9ac1a0b7c61f2b6f.png" alt></p><p>接下来根据源码来看更具体的细节。其中<strong>要关注的重点是recvfrom最后是怎么把自己的进程阻塞掉的</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/socket.c</span><span class="token function">SYSCALL_DEFINE6</span><span class="token punctuation">(</span>recvfrom<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> ubuf<span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> size<span class="token punctuation">,</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr __user <span class="token operator">*</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span>        <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> addr_len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 根据用户传入的fd找到socket对象</span>    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    err <span class="token operator">=</span> <span class="token function">sock_recvmsg</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来的调用顺序为：<code>sock_recvmsg</code> =&gt; <code>__sock_recvmsg</code> =&gt; <code>__sock_recvmsg_nosec</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/socket.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">__sock_recvmsg_nosec</span><span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span>                       <span class="token keyword">struct</span> msghdr <span class="token operator">*</span>msg<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">recvmsg</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用socket对象ops里的<code>recvmsg</code>，<code>recvmsg</code>指向的是<code>inet_recvmsg</code>方法:</p><p><img src="/posts/36369/f06e527b9a0b40a789fcad59bccb51d7.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/af_inet.c</span><span class="token keyword">int</span> <span class="token function">inet_recvmsg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> msghdr <span class="token operator">*</span>msg<span class="token punctuation">,</span>         size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    err <span class="token operator">=</span> sk<span class="token operator">-></span>sk_prot<span class="token operator">-></span><span class="token function">recvmsg</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> MSG_DONTWAIT<span class="token punctuation">,</span>                   flags <span class="token operator">&amp;</span> <span class="token operator">~</span>MSG_DONTWAIT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里又遇到一个函数指针，这次调用的是<code>socket</code>对象里<code>sk_prot</code>下的recvmsg方法，<code>recvmsg</code>方法对应的是<code>tcp_recvmsg</code>方法:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp.c</span><span class="token keyword">int</span> <span class="token function">tcp_recvmsg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> msghdr <span class="token operator">*</span>msg<span class="token punctuation">,</span>        size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> nonblock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>addr_len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> copied <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 遍历接收队列接收数据</span>        <span class="token function">skb_queue_walk</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-></span>sk_receive_queue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>copied <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">release_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">lock_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// 没有收到足够数据,启用sk_wait_data阻塞当前进程</span>            <span class="token function">sk_wait_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>skb_queue_walk</code>在访问sock对象下的接收队列，如下图所示：</p><p><img src="/posts/36369/df07ff2eed16473ab4f570e85d5e0b3b.png" alt></p><p>如果没有收到数据，或者收到的不够多，则调用<code>sk_wait_data</code>把当前进程阻塞掉</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/sock.c</span><span class="token keyword">int</span> <span class="token function">sk_wait_data</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>timeo<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> rc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前进程(current)关联到所定义的等待队列项上</span>    <span class="token function">DEFINE_WAIT</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 调用sk_sleep获取sock对象下的wait</span>    <span class="token comment" spellcheck="true">// 并准备挂起,将当前进程设置为可打断(INTERRUPTIBLE)</span>    <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span> TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_bit</span><span class="token punctuation">(</span>SOCK_ASYNC_WAITDATA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sk<span class="token operator">-></span>sk_socket<span class="token operator">-></span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 通过调用schedule_timeout让出CPU,然后进行睡眠</span>    rc <span class="token operator">=</span> <span class="token function">sk_wait_event</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> timeo<span class="token punctuation">,</span> <span class="token operator">!</span><span class="token function">skb_queue_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-></span>sk_receive_queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面再来详细看看<code>sk_wait_data</code>是怎样把当前进程给阻塞掉的，如下图所示：</p><p><img src="/posts/36369/0b984f9cc2ff43aa9d2d66ba1645dafb.png" alt></p><p>首先在<code>DEFINE_WAIT</code>宏下，定义了一个等待队列项wait。在这个新的等待队列项上，注册了回调函数<code>autoremove_wake_function</code>，并把当前进程描述符<code>current</code>关联到其<code>.private</code>成员上：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/linux/wait.h</span><span class="token macro property">#<span class="token directive keyword">define</span> DEFINE_WAIT_FUNC(name, function)                \    wait_queue_t name = {                        \        .private    = current,                \        .func        = function,                \        .task_list    = LIST_HEAD_INIT((name).task_list),    \    }</span><span class="token macro property">#<span class="token directive keyword">define</span> DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>紧接着在<code>sk_wait_data</code>中调用<code>sk_sleep</code>获取socket对象下的等待队列列表头<code>wait_queue_head_t</code>，<code>sk_sleep</code>源码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/net/sock.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> wait_queue_head_t <span class="token operator">*</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket_wq<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token function">rcu_dereference_raw</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_wq<span class="token punctuation">)</span><span class="token operator">-></span>wait<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着调用<code>prepare_to_wait</code>来把新定义的等待队列项wait插入sock对象的等待队列</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/wait.c</span><span class="token keyword">void</span> <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span> wait_queue_t <span class="token operator">*</span>wait<span class="token punctuation">,</span> <span class="token keyword">int</span> state<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>    wait<span class="token operator">-></span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>WQ_FLAG_EXCLUSIVE<span class="token punctuation">;</span>    <span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wait<span class="token operator">-></span>task_list<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">__add_wait_queue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_current_state</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这样后面当内核收完数据产生就绪事件的时候，就可以查找socket等待队列上的等待项，进而可以找到回调函数和在等待该socket就绪事件的进程了</strong>。最后调用<code>sk_wait_event</code>让出CPU，进程将进入睡眠状态，<strong>这会产生一次进程上下文切换的开销，这个开销是昂贵的，大约需要消耗几个微妙的CPU时间</strong></p><h3 id="2）软中断模块"><a href="#2）软中断模块" class="headerlink" title="2）软中断模块"></a>2）软中断模块</h3><p>前文讲到了网络包到网卡后是怎么被网卡接收，最后再交由软中断处理的，这里直接从TCP协议的接收函数tcp_v4_rcv看起，总体接收流程如下图所示：</p><p><img src="/posts/36369/f304dc56834a411ea0dfdc7c04629678.png" alt></p><p>软中断（也就是Linux里的<code>ksoftirqd</code>线程）里收到数据以后，发现是TCP包就会执行tcp_v4_rcv函数。接着往下，如果是ESTABLISH状态下的数据包，则最后会把数据拆出来放到对应socket的接收队列中，然后调用<code>sk_data_ready</code>来唤醒用户进程</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_ipv4.c</span><span class="token keyword">int</span> <span class="token function">tcp_v4_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 获取tcp header</span>    th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取ip header</span>    iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 根据数据包header中的IP、端口信息查找到对应的socket</span>    sk <span class="token operator">=</span> <span class="token function">__inet_lookup_skb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_hashinfo<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> th<span class="token operator">-></span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// socket未被用户锁定</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sock_owned_by_user</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tcp_prequeue</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span>                ret <span class="token operator">=</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>tcp_v4_rcv</code>中，首先根据收到的网络包的header里的source和dest信息在本机上查询对应的socket。找到以后，调用<code>tcp_v4_do_rcv</code>函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_ipv4.c</span><span class="token keyword">int</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 执行连接状态下的数据处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tcp_rcv_established</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">,</span> skb<span class="token operator">-></span>len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rsk <span class="token operator">=</span> sk<span class="token punctuation">;</span>            <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 其他非ESTABLISH状态的数据包处理</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设处理的是ESTABLISH状态下的包，这样就进入<code>tcp_rcv_established</code>函数进行处理</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_input.c</span><span class="token keyword">int</span> <span class="token function">tcp_rcv_established</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span>            <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token comment" spellcheck="true">// 接收数据放到队列中</span>                eaten <span class="token operator">=</span> <span class="token function">tcp_queue_rcv</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> tcp_header_len<span class="token punctuation">,</span>                              <span class="token operator">&amp;</span>fragstolen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true">// 数据准备好,唤醒socket上阻塞掉的进程</span>            sk<span class="token operator">-></span><span class="token function">sk_data_ready</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>tcp_rcv_established</code>中通过调用<code>tcp_queue_rcv</code>函数，完成了将接收到的数据放到socket的接收队列上，如下图所示：</p><p><img src="/posts/36369/7d9dbe546d864cb2bd23ec6d2b032f09.png" alt></p><p>函数<code>tcp_queue_rcv</code>的源码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_input.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> __must_check <span class="token function">tcp_queue_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">int</span> hdrlen<span class="token punctuation">,</span>          bool <span class="token operator">*</span>fragstolen<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 把接收到的数据放到socket的接收队列的尾部  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>eaten<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">__skb_queue_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-></span>sk_receive_queue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">skb_set_owner_r</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> eaten<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>调用<code>tcp_queue_rcv</code>接收完成之后，接着调用<code>sk_data_ready</code>来唤醒在<code>socket</code>上等待的用户进程</strong>。这又是一个函数指针。在前面”socket的直接创建“的部分，讲到在创建socket的流程里执行到的<code>sock_init_data</code>函数已经把<code>sk_data_ready</code>指针设置成了<code>sock_def_readable</code>函数了。它是默认的数据就绪处理函数:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/sock.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sock_def_readable</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket_wq <span class="token operator">*</span>wq<span class="token punctuation">;</span>    <span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wq <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_wq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 有进程在此socket的等待队列</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wq_has_sleeper</span><span class="token punctuation">(</span>wq<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 唤醒等待队列上的进程</span>        <span class="token function">wake_up_interruptible_sync_poll</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wq<span class="token operator">-></span>wait<span class="token punctuation">,</span> POLLIN <span class="token operator">|</span> POLLPRI <span class="token operator">|</span>                        POLLRDNORM <span class="token operator">|</span> POLLRDBAND<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sk_wake_async</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> SOCK_WAKE_WAITD<span class="token punctuation">,</span> POLL_IN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">rcu_read_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>sock_def_readable</code>中再一次访问到了<code>sock-&gt;sk_wq</code>下的wait。在前面”等待接收消息“的部分调用<code>recvform</code>时，在执行过程的最后，通过<code>DEFINE_WAIT(wait)</code>将当前进程关联的等待队列添加到<code>sock-&gt;sk_wq</code>下的wait里了。那接下来就是调用<code>wake_up_interruptible_sync_poll</code>来唤醒在socket上因为等待数据而被阻塞掉的进程了，如下图所示：</p><p><img src="/posts/36369/72989810ecd540b9aa8e7bffb88661c9.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/linux/wait.h</span><span class="token macro property">#<span class="token directive keyword">define</span> wake_up_interruptible_sync_poll(x, m)                \    __wake_up_sync_key((x), TASK_INTERRUPTIBLE, 1, (void *) (m))</span><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">void</span> <span class="token function">__wake_up_sync_key</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span>            <span class="token keyword">int</span> nr_exclusive<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>    <span class="token keyword">int</span> wake_flags <span class="token operator">=</span> WF_SYNC<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>nr_exclusive<span class="token punctuation">)</span><span class="token punctuation">)</span>        wake_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__wake_up_common</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> nr_exclusive<span class="token punctuation">,</span> wake_flags<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>__wake_up_common</code>实现唤醒。该函数调用的参数<code>nr_exclusive</code>传入的是1，这里指的是<strong>即使有多个进程都阻塞在同一个socket上，也只会唤醒一个进程。其作用是为了避免惊群，而不是把所有的进程都唤醒</strong>:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__wake_up_common</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span>            <span class="token keyword">int</span> nr_exclusive<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    wait_queue_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token function">list_for_each_entry_safe</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token operator">-></span>task_list<span class="token punctuation">,</span> task_list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> flags <span class="token operator">=</span> curr<span class="token operator">-></span>flags<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> wake_flags<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> WQ_FLAG_EXCLUSIVE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token operator">--</span>nr_exclusive<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>__wake_up_common</code>中找出一个等待队列项curr，然后调用其<code>curr-&gt;func</code>。在前面”等待接收消息“的部分recv函数执行的时候，使用DEFINE_WAIT()定义等待队列项时，内核把<code>curr-&gt;func</code>设置成了<code>autoremove_wake_function</code>:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/wait.c</span><span class="token keyword">int</span> <span class="token function">autoremove_wake_function</span><span class="token punctuation">(</span>wait_queue_t <span class="token operator">*</span>wait<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> sync<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">default_wake_function</span><span class="token punctuation">(</span>wait<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> sync<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>        <span class="token function">list_del_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wait<span class="token operator">-></span>task_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>autoremove_wake_function</code>中，调用了<code>default_wake_function</code>:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">int</span> <span class="token function">default_wake_function</span><span class="token punctuation">(</span>wait_queue_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span>              <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">try_to_wake_up</span><span class="token punctuation">(</span>curr<span class="token operator">-></span>private<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> wake_flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用<code>try_to_wake_up</code>时传入的<code>task_struct</code>是<code>curr-&gt;private</code>，这个就是因为等待而被阻塞的进程项。当这个函数执行完的时候，<strong>在socket上等待而被阻塞的进程就被推入可运行队列里了，这又将产生一次进程上下文切换的开销</strong></p><h3 id="3）同步阻塞总结"><a href="#3）同步阻塞总结" class="headerlink" title="3）同步阻塞总结"></a>3）同步阻塞总结</h3><p>同步阻塞方式接收网络包的整个过程分为两部分：</p><ul><li>第一部分是我们自己的代码所在的进程，我们调用的socket()函数会进入内核态创建必要内核对象。recv()函数在进入内核态以后负责查看接收队列，以及在没有数据可处理的时候把当前进程阻塞掉，让出CPU</li><li>第二部分是硬中断、软中断（系统线程ksoftirqd）。在这些组件中，将包处理完后会放到socket的接收队列中。然后根据socket内核对象找到其等待队列中正在因为等待而被阻塞掉的进程，把它唤醒</li></ul><p>同步阻塞总体流程如下图所示：</p><p><img src="/posts/36369/44d7544c1ccf4c3b8e6b829bff932d82.png" alt></p><p>每次一个进程专门为了等一个socket上的数据就被从CPU上拿下来，然后换上另一个进程，如下图所示。等到数据准备好，睡眠的进程又被唤醒，总共产生两次进程上下文切换开销：</p><p><img src="/posts/36369/5d306322d4674b01b1cfe470e9964113.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;socket的创建&quot;&gt;&lt;a href=&quot;#socket的创建&quot; class=&quot;headerlink&quot; title=&quot;socket的创建&quot;&gt;&lt;/a&gt;socket的创建&lt;/h2&gt;&lt;p&gt;socket函数调用执行完之后，用户层面看到返回的是一个整数型的句柄，但其实内核在内
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Redis为什么变慢了</title>
    <link href="https://joytsing.github.io/posts/54676/"/>
    <id>https://joytsing.github.io/posts/54676/</id>
    <published>2024-03-31T07:43:11.000Z</published>
    <updated>2024-03-31T11:03:38.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>为什么我的 Redis 突然慢了一波，之后又恢复正常了？</li><li>为什么我的 Redis 稳定运行了很久，突然从某个时间点开始变慢了？</li></ul><p>之前在笔记中也说了，Redis重要的是怎么用和优化以及怎么排查问题，而不是那点基础知识，首先声明一下，这个笔记是对极客时间里蒋德钧的Redis核心技术与实战的拙劣模仿，如何有新的认知了解的话欢迎讨论。</p><h2 id="先问是不是，再问为什么"><a href="#先问是不是，再问为什么" class="headerlink" title="先问是不是，再问为什么"></a>先问是不是，再问为什么</h2><p> 首先可能会很奇怪，Redis 是否真的变慢了我不是从请求和服务上早就知道了吗，还用问是不是？这个逻辑首先有个前提，导致服务速度下降以及业务服务 API 响应延迟变长不一定是Redis的锅，可能是其他模块的问题，比较高效的做法是，在服务内部集成<strong>链路追踪</strong>，也就是在服务访问外部依赖的出入口，记录下每次请求外部依赖的响应延时。</p><p><img src="/posts/54676/640.webp" alt></p><p>如果确实是了，先排查业务服务到 Redis 这条链路，变慢的原因可能也有 2 个：</p><ol><li>业务服务器到 Redis 服务器之间的网络存在问题，例如网络线路质量不佳，网络数据包在传输时存在延迟、丢包等情况</li><li>Redis 本身存在问题，需要进一步排查是什么原因导致 Redis 变慢</li></ol><p>如果是第一个就是网络的问题，那么所有该服务器上的服务都会变慢发生网络延迟的问题，这种情况下不属于咱们讨论的问题。如果确实是Redis本身出现问题了，这时候要开始排查，首先先做一下对照实验，对 Redis 进行基准性能测试，了解 Redis 在生产环境服务器上的基准性能。具体只需要下面这样就可以测试出这个实例 60 秒内的最大响应延迟：</p><pre class="line-numbers language-sh"><code class="language-sh">$ redis-cli -h 127.0.0.1 -p 6379 --intrinsic-latency 60Max latency so far: 1 microseconds.Max latency so far: 15 microseconds.Max latency so far: 17 microseconds.Max latency so far: 18 microseconds.Max latency so far: 31 microseconds.Max latency so far: 32 microseconds.Max latency so far: 59 microseconds.Max latency so far: 72 microseconds.1428669267 total runs (avg latency: 0.0420 microseconds / 42.00 nanoseconds per run).Worst run took 1429x longer than the average latency.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果可以看到，这 60 秒内的最大响应延迟为 72 微秒（0.072毫秒）。还可以使用以下命令，查看一段时间内 Redis 的最小、最大、平均访问延迟：</p><pre class="line-numbers language-sh"><code class="language-sh">$ redis-cli -h 127.0.0.1 -p 6379 --latency-history -i 1min: 0, max: 1, avg: 0.13 (100 samples) -- 1.01 seconds rangemin: 0, max: 1, avg: 0.12 (99 samples) -- 1.01 seconds rangemin: 0, max: 1, avg: 0.13 (99 samples) -- 1.01 seconds rangemin: 0, max: 1, avg: 0.10 (99 samples) -- 1.01 seconds rangemin: 0, max: 1, avg: 0.13 (98 samples) -- 1.00 seconds rangemin: 0, max: 1, avg: 0.08 (99 samples) -- 1.01 seconds range...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了对照组后就可以知道是否是真的变慢了，所以具体来说流程如下：</p><ol><li>在相同配置的服务器上，测试一个正常 Redis 实例的基准性能</li><li>找到你认为可能变慢的 Redis 实例，测试这个实例的基准性能</li><li>如果你观察到，这个实例的运行延迟是正常 Redis 基准性能的 2 倍以上(多少看个人经验和服务内容)，即可认为这个 Redis 实例确实变慢了</li></ol><p>如果确认是 Redis 变慢了，那如何排查是哪里发生了问题呢？</p><h2 id="使用了复杂度高的命令"><a href="#使用了复杂度高的命令" class="headerlink" title="使用了复杂度高的命令"></a>使用了复杂度高的命令</h2><p>第一步，需要去查看一下 Redis 的慢日志（slowlog）。Redis 提供了慢日志命令的统计功能，它记录了有哪些命令在执行时耗时比较久。查看 Redis 慢日志之前需要设置慢日志的阈值。例如，设置慢日志的阈值为 5 毫秒，并且保留最近 500 条慢日志记录：</p><pre class="line-numbers language-sh"><code class="language-sh"># 命令执行耗时超过 5 毫秒，记录慢日志CONFIG SET slowlog-log-slower-than 5000# 只保留最近 500 条慢日志CONFIG SET slowlog-max-len 500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>设置完成之后，所有执行的命令如果操作耗时超过了 5 毫秒，都会被 Redis 记录下来。此时，你可以执行以下命令，就可以查询到最近记录的慢日志：</p><pre class="line-numbers language-sh"><code class="language-sh">127.0.0.1:6379> SLOWLOG get 51) 1) (integer) 32693       # 慢日志ID   2) (integer) 1593763337  # 执行时间戳   3) (integer) 5299        # 执行耗时(微秒)   4) 1) "LRANGE"           # 具体执行的命令和参数      2) "user_list:2000"      3) "0"      4) "-1"2) 1) (integer) 32692   2) (integer) 1593763337   3) (integer) 5044   4) 1) "GET"      2) "user_info:1000"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你的应用程序执行的 Redis 命令有以下特点，那么有可能会导致操作延迟变大：</p><ol><li>经常使用 O(N) 以上复杂度的命令，例如 SORT、SUNION、ZUNIONSTORE 聚合类命令</li><li>使用 O(N) 复杂度的命令，但 N 的值非常大</li></ol><p>两种对应的情况不同，第一种情况导致变慢的原因在于，Redis 在操作内存数据时，时间复杂度过高，要花费更多的 CPU 资源。第二种情况导致变慢的原因在于，Redis 一次需要返回给客户端的数据过多，更多时间花费在数据协议的组装和网络传输过程中。</p><p>另外还可以从资源使用率层面来分析，如果你的应用程序操作 Redis 的 OPS 不是很大，但 Redis 实例的 <strong>CPU 使用率却很高</strong>，那么很有可能是使用了复杂度过高的命令导致的。</p><p>除此之外Redis 是单线程处理客户端请求的，如果经常使用以上命令，那么当 Redis 处理客户端请求时，一旦前面某个命令发生耗时，就会导致后面的请求发生排队，对于客户端来说，响应延迟也会变长。</p><p><img src="/posts/54676/640-1711873863065-3.webp" alt></p><p>针对这种情况如何解决呢？答案很简单：</p><ol><li>尽量不使用 O(N) 以上复杂度过高的命令，对于数据的聚合操作，放在客户端做</li><li>执行 O(N) 命令，保证 N 尽量的小（推荐 N &lt;= 300），每次获取尽量少的数据，让 Redis 可以及时处理返回</li></ol><h2 id="操作bigkey"><a href="#操作bigkey" class="headerlink" title="操作bigkey"></a>操作bigkey</h2><p>如果你查询慢日志发现，并不是复杂度过高的命令导致的，而都是 SET / DEL 这种简单命令出现在慢日志中，那么你就要怀疑你的实例否写入了 bigkey。</p><p>Redis 在写入数据时，需要为新的数据分配内存，相对应的，当从 Redis 中删除数据时，它会释放对应的内存空间。如果一个 key 写入的 value 非常大，那么 Redis 在<strong>分配内存时就会比较耗时</strong>。同样的，当删除这个 key 时，<strong>释放内存也会比较耗时</strong>，这种类型的 key 我们一般称之为 bigkey。此时，你需要检查你的业务代码，是否存在写入 bigkey 的情况。你需要评估写入一个 key 的数据大小，尽量避免一个 key 存入过大的数据。</p><p>如果已经写入了 bigkey，那有没有什么办法可以扫描出实例中 bigkey 的分布情况呢？Redis 提供了扫描 bigkey 的命令，执行以下命令就可以扫描出，一个实例中 bigkey 的分布情况，输出结果是以类型维度展示的：</p><pre class="line-numbers language-sh"><code class="language-sh">$ redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.01...-------- summary -------Sampled 829675 keys in the keyspace!Total key length in bytes is 10059825 (avg len 12.13)Biggest string found 'key:291880' has 10 bytesBiggest   list found 'mylist:004' has 40 itemsBiggest    set found 'myset:2386' has 38 membersBiggest   hash found 'myhash:3574' has 37 fieldsBiggest   zset found 'myzset:2704' has 42 members36313 strings with 363130 bytes (04.38% of keys, avg size 10.00)787393 lists with 896540 items (94.90% of keys, avg size 1.14)1994 sets with 40052 members (00.24% of keys, avg size 20.09)1990 hashs with 39632 fields (00.24% of keys, avg size 19.92)1985 zsets with 39750 members (00.24% of keys, avg size 20.03)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果我们可以很清晰地看到，每种数据类型所占用的最大内存 / 拥有最多元素的 key 是哪一个，以及每种数据类型在整个实例中的占比和平均大小 / 元素数量。其实使用这个命令的原理，就是 Redis 在内部执行了 SCAN 命令，遍历整个实例中所有的 key，然后针对 key 的类型，分别执行 STRLEN、LLEN、HLEN、SCARD、ZCARD 命令，来获取 String 类型的长度、容器类型（List、Hash、Set、ZSet）的元素个数。</p><p>当执行这个命令时，要注意 2 个问题：</p><ol><li>对线上实例进行 bigkey 扫描时，Redis 的 OPS 会突增，为了降低扫描过程中对 Redis 的影响，最好控制一下扫描的频率，指定 -i 参数即可，它表示扫描过程中每次扫描后休息的时间间隔，单位是秒</li><li>扫描结果中，对于容器类型（List、Hash、Set、ZSet）的 key，只能扫描出元素最多的 key。但一个 key 的元素多，不一定表示占用内存也多，你还需要根据业务情况，进一步评估内存占用情况</li></ol><p>那针对 bigkey 导致延迟的问题，有什么好的解决方案呢？这里有两点可以优化：</p><ol><li>业务应用尽量避免写入 bigkey</li><li>如果你使用的 Redis 是 4.0 以上版本，用 UNLINK 命令替代 DEL，此命令可以把释放 key 内存的操作，放到后台线程中去执行，从而降低对 Redis 的影响</li><li>如果你使用的 Redis 是 6.0 以上版本，可以开启 lazy-free 机制（<code>lazyfree-lazy-user-del = yes</code>），在执行 DEL 命令时，释放内存也会放到后台线程中执行</li></ol><p>但即便可以使用方案 2，也尽可能不要在实例中存入 bigkey。这是因为 bigkey 在很多场景下，依旧会产生性能问题。例如，bigkey 在分片集群模式下，对于数据的迁移也会有性能影响，包括数据过期、数据淘汰、透明大页，都会受到 bigkey 的影响。</p><h2 id="集中过期"><a href="#集中过期" class="headerlink" title="集中过期"></a>集中过期</h2><p>如果你发现，平时在操作 Redis 时，并没有延迟很大的情况发生，但在某个时间点突然出现一波延时，其现象表现为：<strong>变慢的时间点很有规律，例如某个整点，或者每间隔多久就会发生一波延迟。</strong></p><p>如果是出现这种情况需要排查一下，业务代码中是否存在设置大量 key 集中过期的情况。如果有大量的 key 在某个固定时间点集中过期，在这个时间点访问 Redis 时，就有可能导致延时变大。</p><p>为什么集中过期会导致 Redis 延迟变大？因为Redis 的过期数据采用被动过期 + 主动过期两种策略：</p><ol><li>被动过期：只有当访问某个 key 时，才判断这个 key 是否已过期，如果已过期，则从实例中删除</li><li>主动过期：Redis 内部维护了一个定时任务，默认每隔 100 毫秒（1秒10次）就会从全局的过期哈希表中随机取出 20 个 key，然后删除其中过期的 key，如果过期 key 的比例超过了 25%，则继续重复此过程，直到过期 key 的比例下降到 25% 以下，或者这次任务的执行耗时超过了 25 毫秒，才会退出循环</li></ol><p><strong>主动过期 key 的定时任务，是在 Redis 主线程中执行的</strong>。也就是说如果在执行主动过期的过程中，出现了需要大量删除过期 key 的情况，那么此时应用程序在访问 Redis 时，必须要等待这个过期任务执行结束，Redis 才可以服务这个客户端请求。此时就会出现开头提出的情况，应用访问 Redis 延时变大。如果此时需要过期删除的是一个 bigkey，那么这个耗时会更久。而且，<strong>这个操作延迟的命令并不会记录在慢日志中</strong>（因为慢记录只记录真正操作内存的值）。</p><p><img src="/posts/54676/640-1711874518055-6.webp" alt></p><p>一般集中过期使用的是 <code>expireat</code> / <code>pexpireat</code> 命令，你需要在代码中搜索这个关键字。排查代码后，如果确实存在集中过期 key 的逻辑存在，但这种逻辑又是业务所必须的，那此时如何优化，同时又不对 Redis 有性能影响呢？</p><p>一般有两种方案来规避这个问题：</p><ol><li>集中过期 key 增加一个随机过期时间，把集中过期的时间打散，降低 Redis 清理过期 key 的压力</li><li>如果你使用的 Redis 是 4.0 以上版本，可以开启 lazy-free 机制，当删除过期 key 时，把释放内存的操作放到后台线程中执行，避免阻塞主线程</li></ol><p>第一种方案，在设置 key 的过期时间时，增加一个随机时间，伪代码可以这么写：</p><pre class="line-numbers language-sh"><code class="language-sh"># 在过期时间点之后的 5 分钟内随机过期掉redis.expireat(key, expire_time + random(300))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样一来，Redis 在处理过期时，不会因为集中删除过多的 key 导致压力过大，从而避免阻塞主线程。</p><p>第二种方案，Redis 4.0 以上版本，开启 lazy-free 机制：</p><pre class="line-numbers language-sh"><code class="language-sh"># 释放过期 key 的内存，放到后台线程执行lazyfree-lazy-expire yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另外，除了业务层面的优化和修改配置之外，还可以通过运维手段及时发现这种情况。运维层面，你需要把 Redis 的各项运行状态数据监控起来，在 Redis 上执行 INFO 命令就可以拿到这个实例所有的运行状态数据。在这里我们需要重点关注 expired_keys 这一项，它代表整个实例到目前为止，累计删除过期 key 的数量。你需要把这个指标监控起来，<strong>当这个指标在很短时间内出现了突增</strong>，需要及时报警出来，然后与业务应用报慢的时间点进行对比分析，确认时间是否一致，如果一致，则可以确认确实是因为集中过期 key 导致的延迟变大。</p><h2 id="实例内存达到上限"><a href="#实例内存达到上限" class="headerlink" title="实例内存达到上限"></a>实例内存达到上限</h2><p>如果Redis 实例设置了内存上限 maxmemory，那么也有可能导致 Redis 变慢。当我们把 Redis 当做纯缓存使用时，通常会给这个实例设置一个内存上限 maxmemory，然后设置一个数据淘汰策略。而当实例的内存达到了 maxmemory 后，在此之后每次写入新数据，操作延迟变大了。这是为什么？</p><p>原因在于，当 Redis 内存达到 maxmemory 后，每次写入新的数据之前，<strong>Redis 必须先从实例中踢出一部分数据，让整个实例的内存维持在 maxmemory 之下</strong>，然后才能把新数据写进来。这个踢出旧数据的逻辑也是需要消耗时间的，而具体耗时的长短，要取决于你配置的淘汰策略：</p><ul><li><code>allkeys-lru</code>：不管 key 是否设置了过期，淘汰最近最少访问的 key</li><li><code>volatile-lru</code>：只淘汰最近最少访问、并设置了过期时间的 key</li><li><code>allkeys-random</code>：不管 key 是否设置了过期，随机淘汰 key</li><li><code>volatile-random</code>：只随机淘汰设置了过期时间的 key</li><li><code>allkeys-ttl</code>：不管 key 是否设置了过期，淘汰即将过期的 key</li><li><code>noeviction</code>：不淘汰任何 key，实例内存达到 maxmeory 后，再写入新数据直接返回错误</li><li><code>allkeys-lfu</code>：不管 key 是否设置了过期，淘汰访问频率最低的 key（4.0+版本支持）</li><li><code>volatile-lfu</code>：只淘汰访问频率最低、并设置了过期时间 key（4.0+版本支持）</li></ul><p>具体使用哪种策略，我们需要根据具体的业务场景来配置。</p><p>一般最常使用的是 <code>allkeys-lru</code> / <code>volatile-lru</code> 淘汰策略，它们的处理逻辑是，每次从实例中随机取出一批 key（这个数量可配置），然后淘汰一个最少访问的 key，之后把剩下的 key 暂存到一个池子中，继续随机取一批 key，并与之前池子中的 key 比较，再淘汰一个最少访问的 key。以此往复，直到实例内存降到 maxmemory 之下。需要注意的是，Redis 的淘汰数据的逻辑与删除过期 key 的一样，<strong>也是在命令真正执行之前执行的</strong>，也就是说它也会增加我们操作 Redis 的延迟，而且，写 OPS 越高，延迟也会越明显。</p><p><img src="/posts/54676/640-1711874813688-9.webp" alt="图片"></p><p>另外，如果此时你的 Redis 实例中还存储了 bigkey，那么<strong>在淘汰删除 bigkey 释放内存时，也会耗时比较久</strong>。针对这种情况，如何解决呢？</p><ol><li>避免存储 bigkey，降低释放内存的耗时</li><li>淘汰策略改为随机淘汰，随机淘汰比 LRU 要快很多（视业务情况调整）</li><li>拆分实例，把淘汰 key 的压力分摊到多个实例上</li><li>如果使用的是 Redis 4.0 以上版本，开启 layz-free 机制，把淘汰 key 释放内存的操作放到后台线程中执行（配置 lazyfree-lazy-eviction = yes）</li></ol><h2 id="fork耗时严重"><a href="#fork耗时严重" class="headerlink" title="fork耗时严重"></a>fork耗时严重</h2><p>为了保证 Redis 数据的安全性，我们可能会开启后台定时 RDB 和 AOF rewrite 功能。但如果发现<strong>操作 Redis 延迟变大，都发生在 Redis 后台 RDB 和 AOF rewrite 期间</strong>，那就需要排查在这期间有可能导致变慢的情况。</p><p>当 Redis 开启了后台 RDB 和 AOF rewrite 后，在执行时，它们都需要主进程创建出一个子进程进行数据的持久化。主进程创建子进程，会调用操作系统提供的 fork 函数。而 fork 在执行过程中，<strong>主进程需要拷贝自己的内存页表给子进程</strong>，如果这个实例很大，那么这个拷贝的过程也会比较耗时。</p><p>而且这个 fork 过程会消耗大量的 CPU 资源，在完成 fork 之前，整个 Redis 实例会被阻塞住，无法处理任何客户端请求。如果此时你的 CPU 资源本来就很紧张，那么 fork 的耗时会更长，甚至达到秒级，这会严重影响 Redis 的性能。</p><p>那如何确认确实是因为 fork 耗时导致的 Redis 延迟变大呢？可以在 Redis 上执行 INFO 命令，查看 latest_fork_usec 项，单位微秒。</p><pre class="line-numbers language-sh"><code class="language-sh"># 上一次 fork 耗时，单位微秒latest_fork_usec:59477<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个时间就是主进程在 fork 子进程期间，整个实例阻塞无法处理客户端请求的时间。如果发现这个耗时很久，就要警惕起来了，这意味在这期间，你的整个 Redis 实例都处于不可用的状态。</p><p>除了数据持久化会生成 RDB 之外，当主从节点第一次建立数据同步时，主节点也创建子进程生成 RDB，然后发给从节点进行一次全量同步，所以，这个过程也会对 Redis 产生性能影响。</p><p><img src="/posts/54676/640-1711875208587-12.webp" alt></p><p>要想避免这种情况可以采取以下方案进行优化：</p><ol><li>控制 Redis 实例的内存：尽量在 10G 以下，执行 fork 的耗时与实例大小有关，实例越大，耗时越久</li><li>合理配置数据持久化策略：在 slave 节点执行 RDB 备份，推荐在低峰期执行，而对于丢失数据不敏感的业务（例如把 Redis 当做纯缓存使用），可以关闭 AOF 和 AOF rewrite</li><li>Redis 实例不要部署在虚拟机上：fork 的耗时也与系统也有关，虚拟机比物理机耗时更久</li><li>降低主从库全量同步的概率：适当调大 <code>repl-backlog-size</code> 参数，避免主从全量同步</li></ol><h2 id="开启内存大页"><a href="#开启内存大页" class="headerlink" title="开启内存大页"></a>开启内存大页</h2><p>除了上面讲到的子进程 RDB 和 AOF rewrite 期间，fork 耗时导致的延时变大之外，这里还有一个方面也会导致性能问题，这就是操作系统是否开启了<strong>内存大页机制</strong>。Linux 内核从 2.6.38 开始，支持了<strong>内存大页机制</strong>，该机制允许应用程序以 2MB 大小为单位，向操作系统申请内存。</p><p>当 Redis 在执行后台 RDB 和 AOF rewrite 时，采用 fork 子进程的方式来处理。但主进程 fork 子进程后，此时的<strong>主进程依旧是可以接收写请求的</strong>，而进来的写请求，会采用 Copy On Write（写时复制）的方式操作内存数据。也就是说，主进程一旦有数据需要修改，Redis 并不会直接修改现有内存中的数据，而是<strong>先将这块内存数据拷贝出来，再修改这块新内存的数据</strong>，这就是所谓的「写时复制」。</p><p>但是请注意，主进程在拷贝内存数据时，这个阶段就涉及到新内存的申请，如果此时操作系统开启了内存大页，那么在此期间，客户端即便只修改 10B 的数据，<strong>Redis 在申请内存时也会以 2MB 为单位向操作系统申请，申请内存的耗时变长，进而导致每个写请求的延迟增加，影响到 Redis 性能。</strong></p><p>同样地，如果这个写请求操作的是一个 bigkey，那主进程在拷贝这个 bigkey 内存块时，一次申请的内存会更大，时间也会更久。可见，bigkey 在这里又一次影响到了性能。</p><p><img src="/posts/54676/640-1711876210499-15.webp" alt></p><p>如何解决这个问题？只需要关闭内存大页机制就可以了。</p><p>首先，你需要查看 Redis 机器是否开启了内存大页：</p><pre class="line-numbers language-sh"><code class="language-sh">$ cat /sys/kernel/mm/transparent_hugepage/enabled[always] madvise never<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果输出选项是 always，就表示目前开启了内存大页机制，我们需要关掉它：</p><pre class="line-numbers language-sh"><code class="language-sh">$ echo never > /sys/kernel/mm/transparent_hugepage/enabled<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>操作系统提供的内存大页机制，其优势是可以在一定程序上降低应用程序申请内存的次数。但是对于 Redis 这种对性能和延迟极其敏感的数据库来说，我们希望 Redis 在每次申请内存时，耗时尽量短，所以不建议在 Redis 机器上开启这个机制。</p><h2 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h2><p>当 Redis 开启 AOF 后，其工作原理如下：</p><ol><li>Redis 执行写命令后，把这个命令写入到 AOF 文件内存中（write 系统调用）</li><li>Redis 根据配置的 AOF 刷盘策略，把 AOF 内存数据刷到磁盘上（fsync 系统调用）</li></ol><p>为了保证 AOF 文件数据的安全性，Redis 提供了 3 种刷盘机制：</p><ol><li><code>appendfsync always</code>：主线程每次执行写操作后立即刷盘，此方案会占用比较大的磁盘 IO 资源，但数据安全性最高</li><li><code>appendfsync no</code>：主线程每次写操作只写内存就返回，内存数据什么时候刷到磁盘，交由操作系统决定，此方案对性能影响最小，但数据安全性也最低，Redis 宕机时丢失的数据取决于操作系统刷盘时机</li><li><code>appendfsync everysec</code>：主线程每次写操作只写内存就返回，然后由后台线程每隔 1 秒执行一次刷盘操作（触发fsync系统调用），此方案对性能影响相对较小，但当 Redis 宕机时会丢失 1 秒的数据</li></ol><p>如果 AOF 配置为 <code>appendfsync always</code>，那么 Redis 每处理一次写操作，都会把这个命令写入到磁盘中才返回，整个过程都是在主线程执行的，这个过程必然会加重 Redis 写负担。原因也很简单，操作磁盘要比操作内存慢几百倍，采用这个配置会严重拖慢 Redis 的性能，因此我不建议你把 AOF 刷盘方式配置为 always。</p><p> <code>appendfsync no</code>配置项下，Redis 每次写操作只写内存，什么时候把内存中的数据刷到磁盘，交给操作系统决定，此方案对 Redis 的性能影响最小，但当 Redis 宕机时，会丢失一部分数据，为了数据的安全性，一般我们也不采取这种配置。</p><blockquote><p>如果你的 Redis 只用作纯缓存，对于数据丢失不敏感，采用配置 appendfsync no 也是可以的。</p></blockquote><p>看到这里，如果选比较折中的方案 <code>appendfsync everysec</code>就没问题了吧？这个方案优势在于，Redis 主线程写完内存后就返回，具体的刷盘操作是放到后台线程中执行的，后台线程每隔 1 秒把内存中的数据刷到磁盘中。这种方案既兼顾了性能，又尽可能地保证了数据安全，是不是觉得很完美？</p><p><strong>但是，采用这种方案你也要警惕一下，因为这种方案还是存在导致 Redis 延迟变大的情况发生，甚至会阻塞整个 Redis。</strong>这是为什么？我把 AOF 最耗时的刷盘操作，放到后台线程中也会影响到 Redis 主线程？试想这样一种情况：当 Redis 后台线程在执行 AOF 文件刷盘时，如果此时磁盘的 IO 负载很高，那这个后台线程在执行刷盘操作（fsync系统调用）时就会被阻塞住。</p><p>此时的主线程依旧会接收写请求，紧接着，主线程又需要把数据写到文件内存中（write 系统调用），<strong>但此时的后台子线程由于磁盘负载过高，导致 fsync 发生阻塞，迟迟不能返回，那主线程在执行 write 系统调用时，也会被阻塞住</strong>，直到后台线程 fsync 执行完成后，主线程执行 write 才能成功返回。在这个过程中，主线程依旧有阻塞的风险。</p><p><img src="/posts/54676/640-1711881699423-18.webp" alt="图片"></p><p>所以AOF 配置为 appendfsync everysec，也不能掉以轻心，要警惕磁盘压力过大导致的 Redis 有性能问题。那什么情况下会导致磁盘 IO 负载过大？以及如何解决这个问题呢？</p><ol><li>子进程正在执行 AOF rewrite，这个过程会占用大量的磁盘 IO 资源</li><li>有其他应用程序在执行大量的写文件操作，也会占用磁盘 IO 资源</li></ol><p>对于情况1，说白了就是，Redis 的 AOF 后台子线程刷盘操作，撞上了子进程 AOF rewrite！</p><p>这怎么办？难道要关闭 AOF rewrite 才行？幸运的是，Redis 提供了一个配置项，当子进程在 AOF rewrite 期间，可以让后台子线程不执行刷盘（不触发 fsync 系统调用）操作。这相当于在 AOF rewrite 期间，临时把 appendfsync 设置为了 none，配置如下：</p><pre><code># AOF rewrite 期间，AOF 后台子线程不进行刷盘操作# 相当于在这期间，临时把 appendfsync 设置为了 noneno-appendfsync-on-rewrite yes</code></pre><p>开启这个配置项，在 AOF rewrite 期间，如果实例发生宕机，那么此时会丢失更多的数据，性能和数据安全性需要trade-off后进行选择。如果占用磁盘资源的是其他应用程序，那就比较简单了，定位到是哪个应用程序在大量写磁盘，然后把这个应用程序迁移到其他机器上执行就好了，避免对 Redis 产生影响。</p><p>当然，如果对 Redis 的性能和数据安全都有很高的要求，建议从<strong>硬件层面</strong>来优化，更换为 SSD 磁盘，提高磁盘的 IO 能力，保证 AOF 期间有充足的磁盘资源可以使用，加钱解决一切问题。</p><h2 id="绑定CPU"><a href="#绑定CPU" class="headerlink" title="绑定CPU"></a>绑定CPU</h2><p>很多时候在部署服务时，为了提高服务性能，降低应用程序在多个 CPU 核心之间的上下文切换带来的性能损耗，通常采用的方案是进程绑定 CPU 的方式提高性能。</p><p>我们都知道一般现代的服务器会有多个 CPU，而每个 CPU 又包含多个物理核心，每个物理核心又分为多个逻辑核心，每个物理核下的逻辑核共用 L1/L2 Cache。而 Redis Server 除了主线程服务客户端请求之外，还会创建子进程、子线程。</p><p>其中子进程用于数据持久化，而子线程用于执行一些比较耗时操作，例如异步释放 fd、异步 AOF 刷盘、异步 lazy-free 等等。如果你把 Redis 进程只绑定了一个 CPU 逻辑核心上，那么当 Redis 在进行数据持久化时，fork 出的子进程会继承父进程的 CPU 使用偏好。</p><p><strong>而此时的子进程会消耗大量的 CPU 资源进行数据持久化（把实例数据全部扫描出来需要耗费CPU），这就会导致子进程会与主进程发生 CPU 争抢，进而影响到主进程服务客户端请求，访问延迟变大。</strong></p><p>如果确实想要绑定 CPU，可以优化的方案是，不要让 Redis 进程只绑定在一个 CPU 逻辑核上，而是绑定在多个逻辑核心上，而且，绑定的多个逻辑核心最好是同一个物理核心，这样它们还可以共用 L1/L2 Cache。</p><p>当然，即便把 Redis 绑定在多个逻辑核心上，也只能在一定程度上缓解主线程、子进程、后台线程在 CPU 资源上的竞争。因为这些子进程、子线程还是会在这多个逻辑核心上进行切换，存在性能损耗。</p><p>如何再进一步优化？是否可以让主线程、子进程、后台线程，分别绑定在固定的 CPU 核心上，不让它们来回切换，这样一来，他们各自使用的 CPU 资源互不影响。Redis 在 6.0 版本已经推出了这个功能，可以通过以下配置，对主线程、后台线程、后台 RDB 进程、AOF rewrite 进程，绑定固定的 CPU 逻辑核心：</p><pre class="line-numbers language-sh"><code class="language-sh"># Redis Server 和 IO 线程绑定到 CPU核心 0,2,4,6server_cpulist 0-7:2# 后台子线程绑定到 CPU核心 1,3bio_cpulist 1,3# 后台 AOF rewrite 进程绑定到 CPU 核心 8,9,10,11aof_rewrite_cpulist 8-11# 后台 RDB 进程绑定到 CPU 核心 1,10,11# bgsave_cpulist 1,10-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用Swap"><a href="#使用Swap" class="headerlink" title="使用Swap"></a>使用Swap</h2><p>如果发现 Redis 突然变得非常慢，<strong>每次的操作耗时都达到了几百毫秒甚至秒级</strong>，那此时就需要检查 Redis 是否使用到了 Swap，在这种情况下 Redis 基本上已经无法提供高性能的服务了。</p><p>可以通过以下方式来查看 Redis 进程是否使用到了 Swap：</p><pre class="line-numbers language-sh"><code class="language-sh"># 先找到 Redis 的进程 ID$ ps -aux | grep redis-server# 查看 Redis Swap 使用情况$ cat /proc/$pid/smaps | egrep '^(Swap|Size)'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果如下：</p><pre class="line-numbers language-sh"><code class="language-sh">Size:               1256 kBSwap:                  0 kBSize:                  4 kBSwap:                  0 kBSize:                132 kBSwap:                  0 kBSize:              63488 kBSwap:                  0 kBSize:                132 kBSwap:                  0 kBSize:              65404 kBSwap:                  0 kBSize:            1921024 kBSwap:                  0 kB...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个结果会列出 Redis 进程的内存使用情况。每一行 Size 表示 Redis 所用的一块内存大小，Size 下面的 Swap 就表示这块 Size 大小的内存，有多少数据已经被换到磁盘上了，如果这两个值相等，说明这块内存的数据都已经完全被换到磁盘上了。</p><p>如果只是少量数据被换到磁盘上，例如每一块 Swap 占对应 Size 的比例很小，那影响并不是很大。<strong>如果是几百兆甚至上 GB 的内存被换到了磁盘上</strong>，那么你就需要警惕了，这种情况 Redis 的性能肯定会急剧下降。此时的解决方案是：</p><ol><li>增加机器的内存，让 Redis 有足够的内存可以使用</li><li>整理内存空间，释放出足够的内存供 Redis 使用，然后释放 Redis 的 Swap，让 Redis 重新使用内存</li></ol><p>释放 Redis 的 Swap 过程通常要重启实例，为了避免重启实例对业务的影响，一般会先进行主从切换，然后释放旧主节点的 Swap，重启旧主节点实例，待从库数据同步完成后，再进行主从切换即可。</p><h2 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h2><p>Redis 的数据都存储在内存中，当我们的应用程序频繁修改 Redis 中的数据时，就有可能会导致 Redis 产生内存碎片。内存碎片会降低 Redis 的内存使用率，我们可以通过执行 INFO 命令，得到这个实例的内存碎片率：</p><pre class="line-numbers language-sh"><code class="language-sh"># Memoryused_memory:5709194824used_memory_human:5.32Gused_memory_rss:8264855552used_memory_rss_human:7.70G...mem_fragmentation_ratio:1.45<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mem_fragmentation_ratio = used_memory_rss / used_memory。</p><p>其中 used_memory 表示 Redis 存储数据的内存大小，而 used_memory_rss 表示操作系统实际分配给 Redis 进程的大小。</p><p>如果 mem_fragmentation_ratio &gt; 1.5，说明内存碎片率已经超过了 50%，这时我们就需要采取一些措施来降低内存碎片了。</p><p>解决的方案一般如下：</p><ol><li>如果你使用的是 Redis 4.0 以下版本，只能通过重启实例来解决</li><li>如果你使用的是 Redis 4.0 版本，它正好提供了自动碎片整理的功能，可以通过配置开启碎片自动整理</li></ol><p><strong>但是，开启内存碎片整理，它也有可能会导致 Redis 性能下降。</strong></p><p>原因在于，Redis 的碎片整理工作是也在<strong>主线程</strong>中执行的，当其进行碎片整理时，必然会消耗 CPU 资源，产生更多的耗时，从而影响到客户端的请求。所以，当需要开启这个功能时，最好提前测试评估它对 Redis 的影响。Redis 碎片整理的参数配置如下：</p><pre class="line-numbers language-sh"><code class="language-sh"># 开启自动内存碎片整理（总开关）activedefrag yes# 内存使用 100MB 以下，不进行碎片整理active-defrag-ignore-bytes 100mb# 内存碎片率超过 10%，开始碎片整理active-defrag-threshold-lower 10# 内存碎片率超过 100%，尽最大努力碎片整理active-defrag-threshold-upper 100# 内存碎片整理占用 CPU 资源最小百分比active-defrag-cycle-min 1# 内存碎片整理占用 CPU 资源最大百分比active-defrag-cycle-max 25# 碎片整理期间，对于 List/Set/Hash/ZSet 类型元素一次 Scan 的数量active-defrag-max-scan-fields 1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要结合 Redis 机器的负载情况，以及应用程序可接受的延迟范围进行评估，合理调整碎片整理的参数，尽可能降低碎片整理期间对 Redis 的影响。</p><h2 id="其他原因"><a href="#其他原因" class="headerlink" title="其他原因"></a>其他原因</h2><p><strong>1) 频繁短连接</strong></p><p>业务应用，应该使用长连接操作 Redis，避免频繁的短连接。频繁的短连接会导致 Redis 大量时间耗费在连接的建立和释放上，TCP 的三次握手和四次挥手同样也会增加访问延迟。</p><p><strong>2) 运维监控</strong></p><p>要想提前预知 Redis 变慢的情况发生，必不可少的就是做好完善的监控。监控其实就是对采集 Redis 的各项运行时指标，通常的做法是监控程序定时采集 Redis 的 INFO 信息，然后根据 INFO 信息中的状态数据做数据展示和报警。</p><p>这里需要提醒的是在写一些监控脚本，或使用开源的监控组件时，也不能掉以轻心。在写监控脚本访问 Redis 时，尽量采用长连接的方式采集状态信息，避免频繁短连接。同时，你还要注意控制访问 Redis 的频率，避免影响到业务请求。</p><p>在使用一些开源的监控组件时，最好了解一下这些组件的实现原理，以及正确配置这些组件，防止出现监控组件发生 Bug，导致短时大量操作 Redis，影响 Redis 性能的情况发生。</p><p><strong>3）其它程序争抢资源</strong></p><p>最后需要注意的是， Redis 机器最好专项专用，只用来部署 Redis 实例，不要部署其他应用程序，尽量给 Redis 提供一个相对「安静」的环境，避免其它程序占用 CPU、内存、磁盘资源，导致分配给 Redis 的资源不足而受到影响。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 的性能问题，涉及到的知识点非常广，几乎涵盖了 CPU、内存、网络、甚至磁盘的方方面面，同时还需要了解计算机的体系结构，以及操作系统的各种机制。从资源使用角度来看，包含的知识点如下：</p><ul><li>CPU 相关：使用复杂度过高命令、数据的持久化，都与耗费过多的 CPU 资源有关</li><li>内存相关：bigkey 内存的申请和释放、数据过期、数据淘汰、碎片整理、内存大页、内存写时复制都与内存息息相关</li><li>磁盘相关：数据持久化、AOF 刷盘策略，也会受到磁盘的影响</li><li>网络相关：短连接、实例流量过载、网络流量过载，也会降低 Redis 性能</li><li>计算机系统：CPU 结构、内存分配，都属于最基础的计算机系统知识</li><li>操作系统：写时复制、内存大页、Swap、CPU 绑定，都属于操作系统层面的知识</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为什么我的 Redis 突然慢了一波，之后又恢复正常了？&lt;/li&gt;
&lt;li&gt;为什么我的 Redis 稳定运行了很久，突然从某个时
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
