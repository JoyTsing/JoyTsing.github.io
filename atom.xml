<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoyTsing</title>
  
  <subtitle>深海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joytsing.github.io/"/>
  <updated>2024-04-07T12:48:49.217Z</updated>
  <id>https://joytsing.github.io/</id>
  
  <author>
    <name>JoyTsing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Linux网络学习笔记(七)</title>
    <link href="https://joytsing.github.io/posts/48821/"/>
    <id>https://joytsing.github.io/posts/48821/</id>
    <published>2024-04-10T09:04:07.000Z</published>
    <updated>2024-04-07T12:48:49.217Z</updated>
    
    <content type="html"><![CDATA[<p>在应用程序里，我们使用多少内存都是自己能掌握和控制的，但是纵观Linux整台服务器，除了应用程序以外，内核也会申请和管理大量的内存。</p><h3 id="一、相关实际问题"><a href="#一、相关实际问题" class="headerlink" title="一、相关实际问题"></a>一、相关实际问题</h3><ol><li>内核是如何管理内存的</li><li>如何查看内核使用的内存信息</li><li>服务器上一条ESTABLISH状态的空连接需要消耗多少内存</li><li>机器上出现了3万多个TIME_WAIT，内存开销会不会很大</li></ol><h3 id="二、Linux内核如何管理内存"><a href="#二、Linux内核如何管理内存" class="headerlink" title="二、Linux内核如何管理内存"></a>二、Linux内核如何管理内存</h3><p>内核针对自己的应用场景，使用了一种叫做SLAB/SLUB的内存管理机制。这种管理机制通过四个步骤把物理内存条管理起来，供内核申请和分配内核对象。</p><h4 id="1）node划分"><a href="#1）node划分" class="headerlink" title="1）node划分"></a>1）node划分</h4><p>早期的计算机中，内存控制器还没有整合到CPU，所有的内存访问都需要经过北桥芯片组来完成，即内存控制器集成在北桥中。<strong>CPU访存需要通过前端总线连接到北桥芯片，然后北桥芯片连接到内存，这样的架构被称为UMA（一致性内存访问）</strong>。总线模型保证了所有的内存访问都是一致的（即每个处理器共享相同的内存地址空间）。<strong>在UMA架构下，CPU和内存之间的通信全部都要通过前端总线，而提高性能的方式就是不断提高CPU、前端总线和内存的工作频率。</strong></p><p>而随着物理条件的限制，CPU朝着高频率的方向发展遇到了天花板，性能的提升开始供提高主频转向增加CPU数量（多核、多CPU）。<strong>而越来越多的 CPU 对前端总线的争用，使前端总线成为了瓶颈。为了消除 UMA 架构的瓶颈，NUMA（非一致性内存访问）架构诞生了。</strong>在NUMA架构下，<strong>每个CPU会有自己的独立的内存控制器，并且独立连接到一部分内存（直连的这部分内存称为本地内存），组成一个node，不同node之间通过QPI（Quick Path Interconnect）进行通信访问远程内存。</strong>如下图所示：</p><p><img src="/posts/48821/d4611b458796469c8caacfa92107d0b1.png" alt></p><p>在 NUMA 架构下，内存的访问出现了本地和远程的区别：访问远程内存的延时会明显高于访问本地内存。</p><blockquote><p>系统 boot 的时候，硬件会把 NUMA 信息发送给 os，如果系统支持 NUMA ，会发生以下几件事：</p><ul><li>获取 NUMA 配置信息</li><li>将 processors（不是 cores） 分成很多 nodes，一般是一个 processor 一个 node。</li><li>将 processor 附近的 memory 分配给它。</li><li>计算node 间通信的cost（距离）。</li></ul></blockquote><p>Linux 识别到 NUMA 架构后，每个进程、线程都会继承一个 numa policy，定义了可以使用那些CPU（甚至是那些 core），哪些内存可以使用，以及 policy 的强制程度，即是优先还是强制性只允许。<strong>每个 thread 被分配到了一个”优先” 的 node 上面运行</strong>，thread 可以在其他地方运行（如果 policy 允许的话），但是 os 会尝试让他在优先地 node 上面去运行。默认的内存分配方案是：<strong>优先从本地分配内存。如果本地内存不足，优先淘汰本地内存中无用的内存。使内存页尽可能地和调用线程处在同一个 node。</strong></p><blockquote><p>只是优先从本地分配内存，进程同样可以访问到其他内存条。因为在计算机系统中，物理内存地址是由内存管理单元（Memory Management Unit，MMU）管理的，它会把CPU发出的地址请求转换为实际的物理内存地址。即使系统中有多个内存条（也就是说，有多个物理内存块），MMU也会把它们看作是一个连续的地址空间进行管理。</p><p>当系统启动时，BIOS或者UEFI会检测所有的硬件设备，包括内存条。每个内存条的大小和位置信息会被记录在一个叫做内存映射（Memory Map）的数据结构中。这个内存映射会被传递给操作系统。</p><p>在操作系统启动时，它会读取这个内存映射，然后建立起自己的物理内存管理数据结构，如页帧数组。操作系统会把每个物理内存页的地址和状态（比如是否被使用，被哪个进程使用）记录在struct page的一个实例中。页帧数组中的每个元素对应物理内存中的一个页，页帧数组的索引直接映射到物理内存地址。</p><p>在多个内存条的情况下，页帧数组会涵盖所有的内存条。即使内存条在物理上是分离的，但在页帧数组中它们看起来是连续的。当一个物理页面被分配给一个进程时，操作系统会在页表中创建一个页表项，将虚拟地址映射到这个物理页面的地址。</p></blockquote><p>这种默认的分配策略一般情况下可能没有问题，但是对于一些需要分配大量内存的应用上可能会出现性能问题。如使用MySQL时，假如每个node有32G的内存，而MySQL配置了48G 的 innodb buffer pool，那么可能会出现尽管系统还有很多空余的内容，但是很多内存都被 swap 出去了。这就是因为默认的内存分配方案是优先从本地分配，所以当node0内存快被占满时，尽管node1还有很多内存，但是node0里面的内存还是会被swap出去。</p><blockquote><p>以上是硬件层面上的NUMA（hardware view），而作为软件层面的Linux，则对NUMA的概念进行了抽象。即便硬件上是一整块连续内存的UMA，Linux也可将其划分为若干的node（所有node其实是个软件上的概念）。同样，即便硬件上是物理内存不连续的NUMA，Linux也可将其视作UMA（software view）。</p><p>所以，在<a href="https://so.csdn.net/so/search?q=Linux系统&spm=1001.2101.3001.7020">Linux系统</a>中，你可以基于一个UMA的平台测试NUMA上的应用特性。从另一个角度，UMA就是只有一个node的特殊NUMA，所以两者可以统一用NUMA模型表示。</p></blockquote><h4 id="2）zone划分"><a href="#2）zone划分" class="headerlink" title="2）zone划分"></a>2）zone划分</h4><p>NUMA模型中，<strong>物理内存</strong>被划分为几个节点（node），一个node对应一个内存簇bank，即每个内存簇认为是一个节点。</p><p>首先，内存被划分为结点，每个节点关联到系统中的一个处理器。接着各个节点又被划分为内存管理区域，一个管理区域通过struct zone_struct描述，其被定义为zone_t，用以表示内存的某个范围。主要分为以下几种类型的内存管理区域：</p><ol><li>ZONE_DMA：地址段最低的一块内存区域（物理内存起始的16M），供IO设备DMA访问。<ul><li>一些使用 DMA 的外设并没有像 CPU 那样的 32 位地址总线，比如只有 16 位总线，就只能访问 64 KB 的空间，24 位总线就只能访问 16 MB 的空间，如果给 DMA 分配的内存地址超出了这个范围，设备就没法（寻址）访问了。也应该成为ZONE_DMA24</li></ul></li><li>ZONE_DMA32：到了 64 位系统，外设的寻址能力增强，因此又加入了一个 ZONE_DMA32，空间大小为 16MB 到 4GB</li><li>ZONE_NORMAL：可<strong>直接映射</strong>到内核的普通内存域（16M-896M），在X86-64架构下，DMA和DMA32之外的内存全部在NORMAL的zone里管理</li><li>ZONE_HIGHMEM：高端内存，内核不能直接使用（896M-4G），<strong>动态映射</strong>到内核空间3G+896M-4G的位置。即要访问的物理地址空间大于虚拟地址空间，不能直接建立映射的场景。适用于32位CPU系统，64位的CPU系统虚拟地址空间足够大，直接映射即可，所以都是NORMAL。</li></ol><p><img src="/posts/48821/969d18e411f3417abe1318c9b2349f45.png" alt></p><p>每个zone下都包含了许许多多个Page（页面），在Linux下一个页面的大小一般是4KB（处理器架构决定的，操作系统编译的时候固定下来）。</p><p>可以使用zoneinfo命令查看机器上zone的划分，也可以看到每个zone下所管理的页面有多少。</p><h4 id="3）基于伙伴系统管理空闲页面"><a href="#3）基于伙伴系统管理空闲页面" class="headerlink" title="3）基于伙伴系统管理空闲页面"></a>3）基于伙伴系统管理空闲页面</h4><blockquote><p>伙伴系统中的伙伴指的是两个内存块、大小相同、地址连续，同属于一个大块区域</p></blockquote><p>每个zone下面都有很多的页面，Linux使用伙伴系统对这些页面进行高效的管理。在内核中，表示zone的数据结构是struct zone。其下面的一个数组free_area管理了绝大部分可用的空闲页面。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MAX_ORDER 11</span><span class="token keyword">struct</span> zone<span class="token punctuation">{</span>    free_area free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>free_area是一个包含11个元素的数组。每一个元素分别代表不同大小（4KB、8KB、16KB、32KB…）的空闲可分配的连续内存链表。</strong></p><p>即每一个元素都代表一种大小的内存块，数组的索引表示了内存块包含的页框数量。例如，free_area[0]中存放的是单独的空闲页框（4KB），free_area[1]中存放的是包含两个页框的空闲内存块（8KB），等等。这种方式可以方便地查找和分配满足特定大小需求的内存块。</p><p><img src="/posts/48821/a74c3cf0ab4d4c61b2c5db5a79870151.png" alt></p><p>每个free_area元素都有一个或多个链表：</p><ol><li>MIGRATE_UNMOVABLE：表示不可移动的pages，例如内核数据结构的pages。</li><li>MIGRATE_RECLAIMABLE：表示可回收的pages，例如系统中的缓存，当内存紧张时可以回收其内存。</li><li>MIGRATE_MOVABLE：表示可移动的pages，例如用户进程的pages。当需要大块连续的内存空间，或者进行内存碎片整理时，可以移动这类page。</li><li>MIGRATE_PCPTYPES：表示特殊用途的pages，一般用于不可移动和可回收page的临时备份。</li><li>MIGRATE_HIGHATOMIC：表示高优先级的分配请求，这种类型的page只有在内存非常紧张时才会被使用。</li></ol><p>链表中的每一个元素都是一个空闲内存块。这些内存块在物理内存中是连续的，也就是说，它们包含的页框在物理内存中是紧邻的。这样，当内核需要分配一个连续的内存区域时，可以直接从这些链表中查找和分配。但要注意，虽然这些内存块在物理内存中是连续的，但在虚拟内存中可能并不连续。因为虚拟地址到物理地址的映射是通过页表完成的，不同的页框可以被映射到虚拟内存中的任意位置（不一定在相邻的页表项）。</p><blockquote><p>free_area数组里的链表元素存储了一个叫struct page的结构体。struct page是内核用来描述<strong>物理内存页</strong>的主要数据结构。</p><p>每个物理页在内核中都有一个对应的struct page实例。这个结构体包含了许多用于页管理的字段，如用于链接空闲页的链表节点字段等。内核可以通过这个结构体找到对应的物理页。为了映射物理内存和struct page实例，Linux内核使用了一种叫做mem_map的数组。这个数组的每个元素都是一个struct page实例，整个数组的顺序与物理内存页的顺序相同。因此，内核可以通过简单的指针运算在物理地址和对应的struct page实例之间进行转换。</p></blockquote><p>通过cat /proc/pagetypeinfo可以看到当前系统中伙伴系统各个尺寸的可用连续内存块数量。</p><p>内核提供分配器函数alloc_pages到上面的多个链表中寻找可用连续页面。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> page <span class="token operator">*</span> <span class="token function">alloc_pages</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如要申请8KB（连续两个页框的内存），<strong>在基于伙伴系统的内存分配中，有可能需要将大块内存拆分成两个小伙伴。在释放中，可能会将两个小伙伴合并，在此组成更大块的连续内存。</strong>具体的工作步骤：</p><ol><li>先到free_area[1]，即8KB的链表中查询</li><li>如果无可用，则到free_area[2]，即16KB的链表中查询</li><li>如果找到了则将其拆分成两个小伙伴，使用掉其中一个</li><li>将另一个小伙伴放置到8KB的链表中</li></ol><h4 id="4、slab分配器"><a href="#4、slab分配器" class="headerlink" title="4、slab分配器"></a>4、slab分配器</h4><p>到目前介绍的内存分配都是以页面4KB为单位的。而内核代码经常需要在运行时分配和释放小块的内存区域。如果每次都使用普通的页分配器（即每次分配至少一个页的内存）来完成，可能会浪费大量内存。为了更高效地分配小块内存，内核在伙伴系统之上又引入了一个专用的内存分配器slab（或叫slub）</p><p>这个分配器最大的特点就是<strong>一个slab内只分配特定大小、甚至是特定的对象，当一个对象释放内存后，另一个同类对象可以直接使用这块内存</strong>。通过这样的方式极大地降低了碎片发生的概率。</p><p>在SLAB分配器中，<strong>当内核需要频繁创建和销毁某种类型的对象时（比如文件描述符、进程描述符等），它会创建一个kmem_cache，并根据需要的对象大小进行初始化</strong>。<strong>每个kmem_cache都包含一些预分配的内存块（SLABs）</strong>，这些内存块的大小都与需要的对象大小相匹配。当内核代码需要分配一个新的对象时，可以直接从对应的kmem_cache中取出一个预先分配的内存块，而不需要每次都去进行页分配。同样，当一个对象被释放时，它的内存块可以被直接归还到kmem_cache中，以便再次使用。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> kmem_cache <span class="token punctuation">{</span>    <span class="token keyword">struct</span> kmem_cache_node <span class="token operator">*</span><span class="token operator">*</span>node<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> kmem_cache_node <span class="token punctuation">{</span>    <span class="token keyword">struct</span> list_head slabs_partial<span class="token punctuation">;</span>    <span class="token keyword">struct</span> list_head slabs_full<span class="token punctuation">;</span>    <span class="token keyword">struct</span> list_head slabs_free<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>一个kmem_cache可以有多个kmem_cache_node，每个kmem_cache_node代表该kmem_cache在一个特定的NUMA节点上的状态。</strong>NUMA是一种针对多处理器系统的内存架构，其主要思想是将物理内存划分为多个节点，每个处理器可以直接访问所有的内存，但访问不同节点的内存的延迟和带宽可能会有所不同。因此，在NUMA系统中，内存的分配策略可能会影响到程序的性能。为了在NUMA系统中更高效地管理内存，Linux内核引入了kmem_cache_node。在每个kmem_cache中，每个NUMA节点都有一个对应的kmem_cache_node。这个kmem_cache_node包含了该节点上的空闲对象列表，以及其他一些与该节点相关的信息。当从kmem_cache中分配或释放对象时，内核会优先考虑当前CPU对应的NUMA节点，这样可以提高内存访问的性能。</p><p><strong>每个kmem_cache_node中都有满、半满、空三个链表。每个链表节点都对应一个slab，一个slab由一个或多个内页也组成。</strong></p><p><strong>每一个slab内都保存的是同等大小的对象。</strong></p><p>当cache中内存不够时，会调用基于伙伴系统的分配器请求整页连续内存的分配。</p><p><img src="/posts/48821/c5a0449280aa42e593cf86d90c29092d.png" alt></p><p>内核中会有很多个kmem_cache存在，它们是在Linux初始化或者是运行的过程中分配出来的。其中有的是通用的，有的是专用的。</p><p><img src="/posts/48821/d06a875b50c649e5bb57d84ddfb1986d.png" alt></p><p>从图中可以<strong>看到socket_alloc内核对象都存在TCP的专用kmem_cache中</strong>。通过查看/proc/slabinfo可以查看所有的kmem_cahce。</p><p><strong>并不是所有的对象都会使用SLAB分配器进行分配。SLAB分配器是针对频繁分配和释放的小型对象设计的</strong>，比如内核中的各种数据结构（例如，文件描述符、信号量、进程描述符等）。对于这些对象，SLAB分配器可以显著提高分配效率，减少内存碎片，并提高缓存利用率。然而，对于大型对象（比如用户请求的大块内存），或者不常用的对象（即分配和释放不频繁的对象），直接使用页分配器（Page Allocator）或者伙伴系统（Buddy System）进行分配通常更为高效。页分配器可以处理任何大小的内存请求，但对于小型对象，可能会造成内存的浪费。</p><p>此外，用户空间的内存分配（例如，通过malloc()或者new进行的分配）通常不直接使用SLAB分配器。用户空间的内存分配通常由C库（例如，glibc）提供的内存分配器处理，这个分配器使用系统调用（例如，brk()或者mmap()）从内核获取或释放内存。</p><blockquote><p>Linux还提供了一个特别方便的命令slabtop来按照内存从大到小进行排列，可以用来分析slab内存开销。</p><p>此外slab管理器组件提供了若干接口函数方便使用：</p><ol><li>kmem_cache_create：创建一个基于slab的内核对象管理器。</li><li>kmem_cache_alloc：快速为某个对象申请内存。</li><li>kmem_cache_free：将对象占用的内存归还给slab分配器</li></ol></blockquote><h4 id="5）小结"><a href="#5）小结" class="headerlink" title="5）小结"></a>5）小结</h4><p>内核使用内存的方式：</p><ol><li>把所有内存条和CPU换分成node</li><li>把每一个node划分成zone</li><li>每个zone下都用伙伴系统管理空闲页面</li><li>内核提供slab分配器为自己专用</li></ol><p><strong>前三步是基础模块，为应用程序分配内存时的请求调页组件页能够用到，但是第四步就是内核给自己专用的了。</strong></p><h3 id="三、TCP连接相关内核对象"><a href="#三、TCP连接相关内核对象" class="headerlink" title="三、TCP连接相关内核对象"></a>三、TCP连接相关内核对象</h3><p>TCP连接建立的过程中，每申请一个内核对象也都需要到相应的缓存里申请一块内存。</p><h4 id="1）socket函数直接创建"><a href="#1）socket函数直接创建" class="headerlink" title="1）socket函数直接创建"></a>1）socket函数直接创建</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__sock_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分配socket对象</span>    sock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用协议族的创建函数创建sock对象</span>    err <span class="token operator">=</span> pf<span class="token operator">-></span><span class="token function">create</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-sock-inode-cache对象申请"><a href="#1-sock-inode-cache对象申请" class="headerlink" title="1. sock_inode_cache对象申请"></a>1. sock_inode_cache对象申请</h5><p>在sock_alloc函数中，申请了一个struct socket_alloc的内核对象。<strong>socket_alloc内核对象将socket和inode信息关联了起来。</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> socket_alloc <span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket socket<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inode vfs_inode<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在sock_alloc的实现逻辑中，最后就<strong>调用了kmem_cache_alloc从sock_inode_cache中申请了一个struct socket_alloc对象</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token function">sock_alloc_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket_alloc <span class="token operator">*</span>ei<span class="token punctuation">;</span>    <span class="token keyword">struct</span> socket_wq <span class="token operator">*</span>wq<span class="token punctuation">;</span>    ei <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>sock_inode_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ei<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    wq <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>wq<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>sock_inode_cache是专门用来存储struct socket_alloc的slab缓存</strong>，它是在init_inodecache中通过<code>kmem_cache(&quot;sock_inode_cache&quot;, sizeof(struct socket_alloc), ...)</code>初始化的。</p><p>另外还可以看到通过kmalloc申请了一个socket_wq，这是个用来记录在socket上等待事件的等待项。</p><h5 id="2-tcp对象申请"><a href="#2-tcp对象申请" class="headerlink" title="2. tcp对象申请"></a>2. tcp对象申请</h5><p>对于IPv4来说，inet协议族对应的create函数是inet_create，因此__sock_create中对pf-&gt;create的调用会执行到inet_create中去。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">inet_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 这个answer_prot其实就是tcp_prot</span>    answer_prot <span class="token operator">=</span> answer<span class="token operator">-></span>prot<span class="token punctuation">;</span>    sk <span class="token operator">=</span> <span class="token function">sk_alloc</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> PF_INET<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> answer_prot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">sk_alloc</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    sturct sock <span class="token operator">*</span>sk<span class="token punctuation">;</span>    sk <span class="token operator">=</span> <span class="token function">sk_prot_alloc</span><span class="token punctuation">(</span>prot<span class="token punctuation">,</span> priority <span class="token operator">|</span> __GFP_ZERO<span class="token punctuation">,</span> family<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">sk_prot_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> proto <span class="token operator">*</span>prot<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    slab <span class="token operator">=</span> prot<span class="token operator">-></span>slab<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>slab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      sk <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>slab<span class="token punctuation">,</span> priority <span class="token operator">&amp;</span> <span class="token operator">~</span>__GFP_ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个函数中，<strong>将会到TCP这个slab缓存中使用kmem_cache_alloc从slab中申请一个struct sock内核对象出来</strong>。TCP这个slab缓存是在协议栈初始化的时候在inet_init中使用<code>kmem_cache_create(prot-&gt;name, prot-&gt;obj_size, ...)</code>（这里prot是一个tcp_prot）初始化好的一个名为TCP、大小为sizeof(struct tcp_sock)的kmem_cache，并把它记到tcp_prot-&gt;slab的字段下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> proto tcp_prot <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"TCP"</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span>obj_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tcp_sock<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要记住的是，在<strong>TCP slab缓存中实际存放的是struct tcp_sock对象，是struct sock的扩展</strong>，由于tcp_sock、inet_connection_sock、inet_sock、sock是逐层嵌套的关系，所以tcp_sock是可以当作sock来使用的。</p><h5 id="3-dentry和flip对象申请"><a href="#3-dentry和flip对象申请" class="headerlink" title="3. dentry和flip对象申请"></a>3. dentry和flip对象申请</h5><p>回到socket系统调用的入口处，除了sock_create以外，还调用了一个sock_map_fd</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">sock_create</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sock_map_fd</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>0_CLOEXEC <span class="token operator">|</span> ONONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以此为入口将完成struct dentry的和struct file申请。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> dentry <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> dentry <span class="token operator">*</span>d_parent<span class="token punctuation">;</span>    <span class="token keyword">struct</span> qstr d_name<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inode <span class="token operator">*</span>d_inode<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> d_iname<span class="token punctuation">[</span>DNAME_INLINE_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内核初始化的时候创建好了一个dentry slab和flip slab缓存，所有的struct dentry对象和struct file对象都将由它们进行分配。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sock_map_fd</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> file <span class="token operator">*</span>newfile<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 1.申请dentry、file内核对象</span>    newfile <span class="token operator">=</span> <span class="token function">sock_alloc_file</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>newfile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 2.关联到socket及进程</span>      <span class="token function">fd_install</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> newfile<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> fd<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token function">sock_alloc_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dname<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 申请dentry</span>    path<span class="token punctuation">.</span>dentry <span class="token operator">=</span> <span class="token function">d_alloc_pseudo</span><span class="token punctuation">(</span>sock_mnt<span class="token operator">-></span>mnt_sb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 申请flip</span>    file <span class="token operator">=</span> <span class="token function">alloc_file</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">,</span> FMOD_READ <span class="token operator">|</span> FMODE_WRITE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>socket_file_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在sock_alloc_file中完成内核对象的申请，其中会去进行struct dentry和struct file两个内核对象的申请。</strong>dentry对象的申请最终同样是是调用到了kmem_cache_alloc函数（对应的slab缓存dentry在内核初始化时的dcache_init中创建的），而file对象的申请最终是调用了kmem_cache_zalloc函数进行分配（对应的slab缓存flip是在内核初始化时的files_init中创建的）</p><blockquote><p>kmem_cache_alloc()和kmem_cache_zalloc()都是用于从指定的kmem_cache中分配对象的函数。它们的主要区别在于，kmem_cache_zalloc()在分配内存后，会自动将内存区域初始化为0。</p><p>具体来说：</p><ul><li>kmem_cache_alloc()：从指定的kmem_cache分配一个对象的内存空间。返回的内存空间中的内容是不确定的，也就是说，它可能包含任何数据。调用者需要自己对内存进行初始化。</li><li>kmem_cache_zalloc()：从指定的kmem_cache分配一个对象的内存空间，并自动将整个内存区域初始化为0。这意味着调用者可以直接使用返回的内存，无需再进行初始化。</li></ul><p>在一些情况下，使用kmem_cache_zalloc()可能更方便，因为它可以确保内存区域的内容被初始化为0。然而，如果你知道你会立即覆盖整个内存区域的内容，那么使用kmem_cache_alloc()可能会更高效，因为它避免了不必要的内存初始化。</p></blockquote><h5 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h5><p>调用链：</p><ul><li>SYSCALL_DEFINE3<ul><li>sock_create<ul><li>__sock_create<ul><li>sock_alloc =&gt; =&gt; sock_alloc_inode：申请socket_alloc和socket_wq</li><li>inet_create<ul><li>sk_alloc =&gt; sk_prot_alloc：申请tcp_sock</li></ul></li></ul></li></ul></li><li>sock_map_fd<ul><li>sock_alloc_file<ul><li>d_alloc_pseudo =&gt; __d_alloc：申请dentry</li><li>alloc_file =&gt; get_empty_flip：申请file</li></ul></li></ul></li></ul></li></ul><p>socket系统调用完毕之后，在内核中就申请了配套的一组内核对象。这些内核对象并不是鼓励地存在，而是互相保留着和其他内存对象的关联关系。</p><p><img src="/posts/48821/6d424f2828a1426d973ef066379d1b47.png" alt></p><p>所有网络相关的操作，包括数据接收和发送等都以这些数据结构为基础来进行的</p><h4 id="2）服务端socket创建"><a href="#2）服务端socket创建" class="headerlink" title="2）服务端socket创建"></a>2）服务端socket创建</h4><p>除了直接创建socket意外，服务端还可以通过accept函数在接受连接请求时完成相关内核对象的创建。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE</span><span class="token punctuation">(</span>accept4<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr __user <span class="token operator">*</span><span class="token punctuation">,</span> upeerp_sockaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token operator">*</span>newsock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据fd查找到监听的socket</span>    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 申请并初始化新的socket</span>    newsock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    newsock<span class="token operator">-></span>type <span class="token operator">=</span> sock<span class="token operator">-></span>type<span class="token punctuation">;</span>    newsock<span class="token operator">-></span>ops <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 申请新的file对象，并设置到新的socket上</span>    newfile <span class="token operator">=</span> <span class="token function">sock_alloc_file</span><span class="token punctuation">(</span>newsock<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 接受连接</span>    err <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">accept</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> newsock<span class="token punctuation">,</span> sock<span class="token operator">-></span>file<span class="token operator">-></span>f_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将新文件添加到当前进程的打开文件列表</span>    <span class="token function">fd_install</span><span class="token punctuation">(</span>newfd<span class="token punctuation">,</span> newfile<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到socket_alloc、file、dentry对象的分配都是相同的方式，唯一的区别是tcp_sock对象是在第三次握手的时候创建的，所以这里在接收连接的时候直接从全连接队列拿出request_sock的sock成员就可以了，无需再单独申请。</p><h3 id="四、问题解答"><a href="#四、问题解答" class="headerlink" title="四、问题解答"></a>四、问题解答</h3><ol><li>内核是如何管理内存的：内核采用SLAB的方式来管理内存，总共分为四部<ul><li>把所有的内存条和CPU进行分组，组成node</li><li>把每一个node划分成多个zone</li><li>每个zone下都用伙伴系统来管理空闲页面</li><li>提供slab分配器来管理各种内核对象</li><li>前三步时基础模块，为应用程序分配内存时的请求调页组件也能够用到，而第四步是内核专用的。每个slab缓存都是用来存储固定大小，甚至是特定的一种内核对象。这样当一个对象释放内存后，另一个同类对象可以直接使用这块内存，几乎没有任何碎片。极大地提高了分配效率，同时降低了碎片率。</li></ul></li><li>如何查看内核使用的内存信息<ul><li>通过/proc/slabinfo可以看到所有的kmem_cache。</li><li>更方便的是slatop命令，它从大到小按照占用内存进行排列。</li></ul></li><li>服务器上一条ESTABLISH状态的空连接需要消耗多少内存：假设连接上绝大部分时间都是空闲的，也就是假设没有发送缓存区和接收缓存区的开销，那么一个socket大约需要如下几个内核对象<ul><li>struct socket_alloc：大约0.62KB， slab缓存名是sock_inode_cache</li><li>struct top_sock：大约1.94KB，slab缓存名是tcp</li><li>struct dentry：大约0.19KB，slab缓存名是dentry</li><li>struct file：大约为0.25KB，slab缓存名是flip</li><li>加上slab多少会存在一点碎片无法使用，这组内核对象的大小大约是3.3KB左右。所以即使一万条连接也只需要占用33MB的内存</li><li>至于CPU开销，没有数据包的接收和处理是不需要消耗CPU的。长连接上在没有数据传输的情况下，只有极少量的保护包传输，CPU开销可以忽略不计</li></ul></li><li>机器上出现了3万多个TIME_WAIT，内存开销会不会很大<ul><li>从内存的角度来考虑，一条TIME_WAIT状态的连接仅仅是0.4KB左右的内存而已</li><li>从端口的角度来考虑，占用的端口只是针对特定服务器来说是占用了，只要下次连接的服务端不一样（IP或者端口不一样），那么这个端口仍然可以用来发起TCP连接</li><li>只有在连接同一个server的时候端口占用才能算得上是问题。如果想解决这个问题可以考虑使用tcp_max_tw_buckets来限制TIME_WAIT连接总数，或者打开tcp_tw_recycle、tcp_tw_reuse来快速回收端口，或者干脆使用长连接代替频繁的短连接。</li></ul></li></ol><p><strong>拓展阅读</strong>：</p><p><a href="https://zhuanlan.zhihu.com/p/62795773">Linux 内核 101：NUMA架构 - 知乎 (zhihu.com)</a></p><p><a href="https://www.jianshu.com/p/0607c5f62c51">浅解NUMA机制 - 简书 (jianshu.com)</a></p><p><a href="https://www.cnblogs.com/linhaostudy/p/10006723.html">Linux内存描述之内存区域zone–Linux内存管理(三) - yooooooo - 博客园 (cnblogs.com)</a></p><p><a href="https://www.dingmos.com/index.php/archives/23/#cl-2">Linux 内核 | 内存管理——Slab 分配器 - 一丁点儿 (dingmos.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/68465952">Linux中的物理内存管理 [一] - 知乎 (zhihu.com)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在应用程序里，我们使用多少内存都是自己能掌握和控制的，但是纵观Linux整台服务器，除了应用程序以外，内核也会申请和管理大量的内存。&lt;/p&gt;
&lt;h3 id=&quot;一、相关实际问题&quot;&gt;&lt;a href=&quot;#一、相关实际问题&quot; class=&quot;headerlink&quot; title=&quot;一、
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议三次握手和四次挥手</title>
    <link href="https://joytsing.github.io/posts/42952/"/>
    <id>https://joytsing.github.io/posts/42952/</id>
    <published>2024-04-07T12:35:56.000Z</published>
    <updated>2024-04-07T13:49:08.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、三次握手流程"><a href="#一、三次握手流程" class="headerlink" title="一、三次握手流程"></a>一、三次握手流程</h3><p>推荐<a href="https://www.coonote.com/tcpip/tcp-three-handshakes-four-waves.html">阅读这篇文章</a>：</p><ol><li>客户端调用connect系统调用，发出第一次握手<ul><li><strong>找到套接字</strong>：创建内核对象的时候，fd会跟file对象做通过fd_install关联起来，通过进程的fd_table就可以找到对应的file，而file的private指针就指向了socket对象，所以根据fd即可找到套接字</li><li><strong>判断当前套接字的状态</strong>：只有SS_UNCONNECTED状态（刚创建的套接字就是该状态）才会继续，其他状态都会报错<ul><li>注意此处是socket的状态，而不是sock的状态</li><li>会将socket状态更改为SS_CONNECTING</li></ul></li><li><strong>更改sock状态为TCP_SYN_SENT</strong></li><li><strong>绑定端口</strong>：如果当前套接没有bind端口（端口为0则表示没有绑定），则从ip_local_port_range的某一个随机位置开始循环遍历找到合适的端口，如果查询不到则抛出Cannot assign requested address的错误</li><li><strong>申请skb加入发送队列并设置syn数据包</strong>：将SYN标志位置为1，随机生成一个序列号，并设置MSS等字段，随后将数据包发送出去<ul><li>这里直接调用的是tcp_transmit_skb，而正常发送逻辑会从tcp_sendmsg开始，其中会检查当前套接字的状态，如果不是已建立或者CLOSE_WAIT，会等待连接建立</li></ul></li><li><strong>启动重传定时器</strong>：等到一定时间后收不到服务端的反馈的时候来开启重传。首次超时时间是在TCP_TIMEOUT_INIT宏中定义的，该值在Linux3.10版本是1秒， 在一些老版本中是3秒。每次超时时间为2的指数递增（1，2，4，8，16，32）</li></ul></li><li>服务端收到SYN包之后，发出第二次握手<ul><li><strong>找到套接字</strong>：skb通过软中断不断上传到tcp协议栈，根据数据报首部的IP地址和端口号查找对应的socket对象</li><li><strong>判断当前套接字的状态</strong>：这里会进入TCP_LISTEN的处理逻辑</li><li><strong>判断连接是否已经建立</strong>：检查是否有与这个SYN包的四元组相同的连接已经存在<ul><li>如果已经存在ESTABLISHED状态的连接，则丢弃该握手包</li><li>如果已经存在SYN_RCVD状态的连接，则可能是一个重传的SYN包，这个时候会继续一下逻辑</li></ul></li><li><strong>查找半连接队列</strong>：到套接字的半连接队列中查找是否存在对应的半连接对象，因为当前是第一次握手，所以显然队列中还不存在半连接对象</li><li><strong>创建半连接对象加入队列</strong>：会先检查半连接队列和全连接队列是否已满，如果数据包没有被丢弃则创建request_sock对象，将状态设置为TCP_SYN_RCVD<ul><li>如果半连接队列满了且还没有开启syn_cookies那么将直接把握手包丢弃</li><li>如果全连接队列已满且存在young ack则同样把握手包丢弃</li></ul></li><li><strong>构造synack包并发送</strong>：将ACK和SYN标志位都置为1，随机生成一个序列号，并将确认号设置为SYN包的序列号+1，同时设置MSS等字段，最后将数据包发送出去</li><li><strong>半连接对象入队</strong>：将半连接对象request_sock加入半连接队列</li><li><strong>开启重传定时器</strong></li></ul></li><li>客户端收到SYNACK包之后，发出第三次握手<ul><li><strong>找到套接字</strong>：skb通过软中断不断上传到tcp协议栈，根据数据报首部的IP地址和端口号查找对应的socket对象</li><li><strong>判断当前套接字的状态</strong>：这里会进入TCP_SYN_SENT的处理逻辑</li><li><strong>移除重传队列中的SYN包，停止计时器</strong></li><li><strong>更改sock状态为ESTABLISHED</strong></li><li><strong>初始化TCP连接的拥塞控制算法、接收缓存和发送缓存空间等信息</strong></li><li><strong>开启keep alive保活计时器</strong></li><li><strong>唤醒等待队列的进程</strong></li><li><strong>构造ACK包进行发送</strong>：判断是否满足TCP的延迟确认（Delayed ACK）机制，如果满足则和数据包一起发送</li></ul></li><li>服务端收到ACK包之后，完成连接建立<ul><li><strong>找到套接字</strong>：skb通过软中断不断上传到tcp协议栈，根据数据报首部的IP地址和端口号查找对应的socket对象</li><li><strong>判断当前套接字的状态</strong>：这里会进入TCP_LISTEN的处理逻辑（注意不是TCP_SYN_RCVD）</li><li><strong>查找半连接队列</strong>：这次是响应第三次握手，在上一次已经创建了半连接对象放置在队列中，所以这次可以<strong>从队列中拿到半连接对象</strong></li><li><strong>创建sock对象</strong>：判断socket的全连接队列是否满了，没满则根据半连接对象创建子sock<ul><li>会将sock状态设置为ESTABLISHED，并且关联到这个request_sock</li><li>随后将request_sock其从半连接队列移除，加入到全连接队列中</li></ul></li><li><strong>唤醒等待队列的进程</strong>：如果有进程调用accept等待连接的话，则会被唤醒<ul><li>唤醒之后进程从全连接队列中拿到request_sock</li><li>之后就可以根据request_sock中保存的tcp_sock来创建socket对象</li></ul></li></ul></li></ol><h3 id="二、为什么握手是三次"><a href="#二、为什么握手是三次" class="headerlink" title="二、为什么握手是三次"></a>二、为什么握手是三次</h3><p>如果不进行最后一次握手，即服务端返回synack报文之后就完成建立的话，那么在数据包延迟到达的情况下有可能出现问题。</p><ul><li>第一次握手包延迟：假如说客户端发起的SYN数据包因为网络延迟没有到达服务端，那么这时候它就收不到服务端的SYNACK报文，那么此时它就会超时重传SYN数据包。如果这次服务端收到了并回复了SYNACK报文，那么连接就算建立成功了。而在连接建立成功并且通讯完成又释放了之后，第一次因为延迟而没有到达服务端的SYN数据包这时候到达了，这时候服务端会以为是一个新的连接到达，于是再次响应一个SYNACK报文，因为只有两次握手，所以就建立了一条本不应该存在的连接。而如果此时使用的是三次握手，那么客户端收到这条SYNACK报文后则会将其丢弃，不会完成连接的建立。</li><li>第二次握手包延迟：如果服务端收到了客户端的SYN报文，而回传SYNACK包的时候超时了，那么如果此时是两次握手，服务端直接认为连接建立成功，而客户端会以为是自己的SYN报文没有到达服务端而重传SYN数据包，那么服务端会因为已经建立连接（自己认为已经建立过了）所以丢弃重传的SYN包，所以客户端这边永远都连不上。而如果此时使用的是三次握手，那么在SYNACK包超时之后，除了客户端重发SYN包，服务端也会重发SYNACK包。那么客户端收到重发的SYNACK包之后会发出ACK包，而服务端收到重发的SYN包后会再次发出SYNACK包。这时这个新的SYNACK包到达之后会因为序列号对不上而被客户端丢弃，而服务端收到ACK包之后就完成连接的建立。建立完成之后即使延迟的SYNACK包到达了客户端，也会同样被丢弃。</li><li>第三次握手包延迟（当然只可能在三次握手时出现）：客户端发出ACK报文之后是不会期待响应的，所以此时它会直接认为连接建立。而服务端会因为收不到ACK包而重传SYNACK包，那么客户端会再次发送ACK包，如果服务端收到则完成建立。如果重试多次后一直丢失，那么服务端会认为连接建立失败而关闭连接。后续如果客户端正常的发出数据包给服务端，则会收到RST包，从而意识到连接已经被关闭。也就是说没有必要有第四次握手，如果ACK包一直丢失不能建立连接，后续发送数据的时候就可以感知到。</li></ul><p><img src="/posts/42952/7179150385446631985.png" alt></p><h3 id="三、关闭连接的情况"><a href="#三、关闭连接的情况" class="headerlink" title="三、关闭连接的情况"></a>三、关闭连接的情况</h3><p>关闭连接有以下几种可能：</p><ol><li><strong>超时</strong>：如果在设定的超时时间内没有收到期望的ACK包或其他响应，TCP连接会被关闭。这是为了防止网络中的“僵尸连接”消耗系统资源。</li><li><strong>错误或异常</strong>：如果发生了某些错误或异常，例如网络错误、对方突然断线或程序崩溃等，TCP连接也会被关闭。</li><li><strong>主动关闭</strong>：如果应用程序调用了关闭连接的函数（例如close和shutdown），TCP连接也会被关闭。</li><li><strong>RST标志</strong>：如果收到一个带有RST（Reset）标志的TCP包，TCP连接也会被立即关闭。RST包通常在发生错误或异常时被发送，例如，收到了一个不应该收到的包，或者试图打开一个不存在的连接等。</li></ol><p>如果是发生了如网络错误、断线或程序崩溃等错误或异常，那么自己这边的系统可能关闭所有的网络接口，释放所有的网络相关的内存等（取决于操作系统和协议栈的实现），而对端发送的保活数据包将接收不到ACK，重试几次后，就会进行连接的关闭，这个时候是不会进行四次挥手的。</p><p>而如果是发生以下情况，就会发送一个带有RST标志的TCP包。收到带有RST标志的包的一方会立即关闭连接，而不需要执行常规的四次挥手过程。这种情况下，连接的关闭是非正常的，因为它并没有经过正常的关闭过程就被终止了。</p><ol><li><strong>收到了一个错误的序列号的数据包</strong>：在TCP连接中，每个数据包都有一个序列号，用来保证数据包的有序接收。如果收到了一个序列号不正确的数据包（即这个数据包的序列号不在期望的序列号范围内），TCP会发送一个RST数据包来重置连接</li><li><strong>应用程序强制关闭</strong>：应用程序在正常关闭一个TCP连接时，会通过操作系统发送一个FIN（Finish）标志的数据包，这将触发TCP的正常关闭流程，也就是所谓的”四次挥手”。然而，有一种特殊的情况，那就是”强制关闭”或”紧急关闭”。在某些情况下，例如，应用程序崩溃，或者用户想要立即关闭连接，而不等待四次挥手过程完成，操作系统会发送一个RST（Reset）标志的数据包来立即关闭连接。这种情况下，操作系统并不会等待对方的确认，连接会立即关闭。可以使用SO_LINGER选项来设置一个0延迟的linger时间以实现强制关闭</li><li><strong>网络层错误或异常</strong>：在某些网络层的错误或异常情况下，例如，网络接口出错或者IP路由失败，TCP可能会发送一个RST数据包来关闭连接。</li><li><strong>TCP层错误或异常</strong>：在某些TCP层的错误或异常情况下，例如，内存不足，无法创建新的数据包，或者处理到一半的数据包被意外丢失，TCP可能会发送一个RST数据包来关闭连接。</li></ol><p>也就是以上的情况其实都不会进行四次挥手，只有当正常进行连接的关闭才会进行四次挥手的逻辑。当应用程序A决定关闭一个TCP连接时，它会调用 close() 或 shutdown() 函数，这些函数在操作系统内部会发送一个FIN（Finish）标志的TCP数据包给对端B，这就开始了所谓的四次挥手过程。</p><h3 id="四、四次挥手流程"><a href="#四、四次挥手流程" class="headerlink" title="四、四次挥手流程"></a>四、四次挥手流程</h3><ol><li><p>主动方调用close或shutdown，发起第一次挥手</p><ul><li><strong>取消文件描述符和file对象指针的关联</strong>：即后续无法再使用这个文件描述符，shutdown不会关闭fd，所以仍需要调用close来关闭文件描述符<ul><li>lose在fd被多个进程持有时不会立马关闭连接，调用close只会让引用计数-1，需要等到socket的引用计数为0才会发送FIN报文</li><li>而shutdown会直接关闭连接</li></ul></li><li><strong>判断当前套接字状态</strong>：如果是LISTEN则直接设置为close，然后释放对象，结束流程</li><li><strong>释放接收队列</strong>：如果不是LISTEN状态则循环遍历接收队列，释放队列中的skb<ul><li>如果接收队列不为空，即释放了skb，则会发送一个RST来中断连接，然后更改套接字状态并释放相关资源，结束流程</li></ul></li><li><strong>判断是否设置了SO_LINGER</strong>：如果设置了该选项并且linger时间设置为0，那么也发送RST直接中断连接<ul><li>默认是没有设置该选项的，close方法不会阻塞的，在后台进行处理</li><li>如果设置为0，则立即关闭连接，发送缓冲区有未发送的数据则直接丢弃，直接进入CLOSED</li></ul></li><li><strong>发送FIN数据包</strong>：只有没有设置SO_LINGER或者设置了非0的linger才会来到这里<ul><li><strong>更新自身状态为FIN_WAIT_1（状态机中ESTABLISH的下一位）</strong></li><li><strong>遍历发送队列，如果其中有数据包未发送就在最后一个数据包设置FIN标志位，然后将所有数据包发送出去。</strong></li><li>如果设置了SO_LINGER，则进程进入阻塞，等待linger时间，如果超时仍然没有发完则会发送RST报文。</li><li>默认没有设置linger（不会阻塞）则会检测当前socket状态。如果是FIN_WAIT1（一般来说没有阻塞直接返回就是这个状态），就会查看孤儿socket数量是不是太多了，如果是则更改为CLOSE状态并发送RST直接关闭，不是则tcp_close函数到此基本结束</li></ul></li></ul></li><li><p>服务端收到FIN包之后，发起第二次挥手</p><ul><li><strong>找到套接字，检查到套接字状态</strong>：因为当前是ESTABLISHED状态，所以进入tcp_rcv_established，并在最终检测到数据报的FIN标志位为1而进入tcp_fin函数进行处理</li><li><strong>更改套接字状态</strong>：对于ESTABLISHED状态的套接字，会将其更改为CLOSE_WAIT状态</li><li><strong>内存清理</strong>：清空乱序队列中的数据包，并且根据当前的内存压力和套接字的内存使用情况来回收一部分内存</li><li><strong>唤醒阻塞的进程</strong>：通知在recv上等待的进程有数据可读，此时读取的返回结果会是0<ul><li>此时服务端已经知道对端已经关闭连接，然后就可以编写逻辑来决定何时调用close方法</li></ul></li><li><strong>发送ACK包给客户端</strong></li></ul></li><li><p>客户端收到ACK包</p><ul><li><strong>找到套接字，检查到套接字状态</strong>：因为当前的状态是TCP_FIN_WAIT1，所以会进去一个状态处理函数tcp_rcv_state_process（如果不是LISTEN或是ESTABLISHED就会进入这个函数）</li><li><strong>更改套接字状态</strong>：将自身的状态更改为TCP_FIN_WAIT2</li><li><strong>设置定时器</strong>：TMO+2MSL或者基于RTO计算超时<ul><li>超时后会直接变迁到closed状态，然后将套接字的发送端设置为关闭</li></ul></li><li><strong>唤醒阻塞在close上的进程</strong>：针对于设置了SO_LINGER的情况，被唤醒后继续执行close后续逻辑<ul><li>检测linger2是否大于等于0（TCP层面的，用于设定孤儿套接字在FIN_WAIT2状态的生存时间，如果没有配置则默认为tcp_fin_timeout，如果大于则等待一段时间来接收对端的FIN，如果小于0则立即关闭连接，并发送RST报文</li></ul></li></ul></li><li><p>服务端继续处理，发送数据包给客户端</p><ul><li><p>服务端在知道客户端关闭连接后还可以继续发送数据包</p></li><li><p>如果客户端关闭了读通道(close会都关闭)，那么客户端收到数据包后会发送RST数据包之后服务端直接进行关闭</p><p><img src="/posts/42952/aa1363297f2045bfb85055ee100d7a42.png" alt="在这里插入图片描述"></p></li><li><p>如果客户端只是关闭了写通道(shutdown可以只关闭写)，那么数据包会照常接收并返回ACK报文</p><p><img src="/posts/42952/bf95d06b15044605b0308d0dc5710f0b.png" alt="在这里插入图片描述"></p></li></ul></li><li><p>当服务端处理完毕之后，调用close方法，发起第三次挥手</p><ul><li><strong>释放接收队列</strong>：如果有skb释放或者socket设置了SO_LINGER选项且linger时间为0，那么还是发送RST</li><li><strong>更新套接字状态</strong> ：如果不是上面两种情况则继续更新到状态机的下一位，因为当前是CLOSE_WAIT，所以更新成LAST_ACK<ul><li>CLOSE_WAIT会在保活定时器超时后强行关闭连接，用于服务端一直没有主动关闭连接而客户端已经因为超时而关闭的情况。</li></ul></li><li><strong>发送FIN包给客户端</strong></li></ul></li><li><p>客户端收到FIN包之后，发起第四次挥手</p><ul><li><strong>发送ACK数据包</strong>：同样进入tcp_fin函数，发送ack包给服务端然</li><li><strong>更改套接字状态</strong>：为当前状态是TCP_FIN_WAIT2，更改至TIME_WAIT</li><li><strong>内存释放</strong>：time_wait状态时，原socket会被destroy，然后新创建一个inet_timewait_sock，在等待2MSL之后删除。</li></ul></li><li><p>服务端收到客户端的ACK包之后，完成四次挥手：<strong>将LAST_ACK更改为CLOSED，并且释放对象</strong></p></li></ol><p>如果两边同时发送FIN，那么在FIN_WAIT_1时收到对方的FIN，会进入CLOSING，之后收到ACK变成TIME_WAIT</p><h3 id="五、为什么挥手是四次"><a href="#五、为什么挥手是四次" class="headerlink" title="五、为什么挥手是四次"></a>五、为什么挥手是四次</h3><p>不同于握手，SYN和ACK可以同时发送。FIN表示的是自己没有数据要发了，而在客户端结束发送数据的时候，不一定服务端也结束了，所以没办法将FIN包和ACK包结合在一起发送。</p><p>对于可靠连接而言，ACK包是不可以省略的，每一个方向上的数据发送都应该得到对端的确认。并且假如说节省第二次挥手的ACK包，那么因为下一个FIN的时间是不确定的，有可能很久，那么实现的时候得让FIN_WAIT_1等待一个很久的时间。如果它是因为丢包了，那么重试也会需要一个很长的时间，这会导致close的时间非常的久。如果节省最后一个ACK包，也就是说被动方发出FIN之后就关闭，主动方收到FIN之后也直接关闭。那么有可能FIN包丢失了，所以导致被动方关闭了而主动方还在等待。</p><p>而最后需要进入TIME_WAIT状态等待2MSL的原因主要有两个：</p><ol><li>保证老的重复报文在网络中消逝：如果说没有TIME_WAIT两个2MSL，而客户端和服务端又基于原本的端口建立了新的连接，那么旧连接中可能有数据包延迟，没达到最大生存时间，所以还没被丢弃，这个时候到达了新的连接，并且正好在接收窗口中，那么此时会被误以为是正常的数据包，从而导致新的连接数据错乱。序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。所以通过设置2MSL，保证新连接建立的时候，旧连接在网络中残留的数据包都已经死亡了</li><li>如果主动关闭方的ACK丢失，那么被动方会重发FIN包，以允许主动方重发ACK，那么此时如果没有TIMEWAIT，则主动方已经关闭了，无法重发ACK报文，TCP协议栈会返回 RST 报文，RST其实是出现异常的时候才发送的数据包，这对于可靠的TCP协议而言不是一个比较优雅的关闭方式。</li></ol><p>如果出现过多的TIME_WAIT，想要缩短TIME_WAIT的时间，Linux 操作系统提供了两个可以系统参数来快速回收处于 <code>TIME_WAIT</code> 状态的连接（这两个参数都是默认关闭的），分别是<code>net.ipv4.tcp_tw_reuse</code>和<code>net.ipv4.tcp_tw_recycle</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、三次握手流程&quot;&gt;&lt;a href=&quot;#一、三次握手流程&quot; class=&quot;headerlink&quot; title=&quot;一、三次握手流程&quot;&gt;&lt;/a&gt;一、三次握手流程&lt;/h3&gt;&lt;p&gt;推荐&lt;a href=&quot;https://www.coonote.com/tcpip/tcp-t
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(六)</title>
    <link href="https://joytsing.github.io/posts/11832/"/>
    <id>https://joytsing.github.io/posts/11832/</id>
    <published>2024-04-07T09:03:59.000Z</published>
    <updated>2024-04-07T12:33:14.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、相关实际问题"><a href="#一、相关实际问题" class="headerlink" title="一、相关实际问题"></a>一、相关实际问题</h3><ol><li>为什么服务端程序都需要先listen一下</li><li>半连接队列和全连接队列长度如何确定</li><li>“Cannot assign requested address”这个报错是怎么回事</li><li>一个客户端端口可以同时用在两条连接上吗</li><li>服务端半/全连接队列满了会怎么样</li><li>新连接的soket内核对象是什么时候建立的</li><li>建立一条TCP连接需要消耗多长时间</li><li>服务器负载很正常，但是CPU被打到底了时怎么回事</li></ol><h3 id="二、深入理解listen"><a href="#二、深入理解listen" class="headerlink" title="二、深入理解listen"></a>二、深入理解listen</h3><h4 id="1）listen系统调用"><a href="#1）listen系统调用" class="headerlink" title="1）listen系统调用"></a>1）listen系统调用</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE2</span><span class="token punctuation">(</span>listen<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 根据fd查找socket内核对象</span>    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取内核参数net.core.somaxconn</span>      somaxconn <span class="token operator">=</span> <span class="token function">sock_net</span><span class="token punctuation">(</span>sock<span class="token operator">-></span>sk<span class="token punctuation">)</span><span class="token operator">-></span>core<span class="token punctuation">.</span>sysctl_somaxconn<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>backlog <span class="token operator">></span> somaxconn<span class="token punctuation">)</span>        backlog <span class="token operator">=</span> somaxconn<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用协议栈注册的listen函数</span>     err <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">listen</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用户态的<a href="https://so.csdn.net/so/search?q=socket&spm=1001.2101.3001.7020">socket</a>文件描述符只是一个整数而已，内核是没有办法直接使用的，所以首先就是先<strong>根据用户传入的文件描述符来查找对应的socket内核对象</strong>。</p><p>再接着获取了<strong>系统里的net.core.somaxconn内核参数的值，和用户传入的backlog作比较后取一个最小值</strong>传入下一步。</p><p><strong>所以虽然listen允许我们传入backlog（该值和半连接队列、全连接队列都有关系），但是会受到内核参数的限制。</strong></p><p>接着通过<strong>调用sock-&gt;ops-&gt;listen进入协议栈的listen函数</strong>。</p><blockquote><ol><li>文件描述表：<strong>进程级别</strong>。一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，<strong>PCB 内部有一个文件描述符表，记录着当前进程所有可用的文件描述符</strong>，也即当前进程所有打开的文件。</li><li>打开文件表：系统级别。<strong>内核对所有打开文件维护的一个描述表格，将表格中的每一项称为打开文件句柄</strong>。它<strong>存储了一个打开文件的所有相关信息</strong>，例如当前文件的偏移量，访问模式，状态等等。</li><li>inode：系统级别。<strong>文件系统中的每个文件都有自己的i-node信息</strong>，它包含文件类型，访问权限，文件属性等等。<br><img src="/posts/11832/065d37f6d7d44a75b2424affa394ae17.png" alt></li></ol><p><img src="/posts/11832/9b38462ae8ce460cb84a1706ea9e63f5.png" alt></p><p>fdtable对应用户已打开文件表，或者说<a href="https://so.csdn.net/so/search?q=文件描述符&spm=1001.2101.3001.7020">文件描述符</a>表，是进程私有的。它的成员fd是file指针数组的指针，其中数组的索引就是文件描述符，而数组元素就是file指针，或者说已打开文件句柄。一个struct file的实例代表一个打开的文件，当一个用户进程成功打开文件时，会创建次结构体，并包含调用者应用程序的文件访问属性，例如文件数据的偏移量、访问模式和特殊标志等。此对象映射到调用者的文件描述符表，作为调用者应用程序对文件的句柄。</p><p>通常数组的第一个元素（索引为0）是进程的标准输入文件，数组的第二个元素（索引为1）是进程的标准输出文件，数组的第三个元素（索引为2）是进程的标准错误文件。</p><p>查看进程允许打开的最大文件句柄数：<code>ulimit -n</code>；设置进程能打开的最大文件句柄数：<code>ulimit -n xxx</code>。</p><p><img src="/posts/11832/72723c4182ef4e628557ad49db706a3b.png" alt></p><p>以上说法是在linux中的概念，而在windows中句柄的概念对应的是linux中文件描述符的概念，都是一个非负的整数。</p></blockquote><h4 id="2）协议栈listen"><a href="#2）协议栈listen" class="headerlink" title="2）协议栈listen"></a>2）协议栈listen</h4><p>上文提到系统调用最后会通过sock-&gt;ops-&gt;listen进入协议栈的listen函数，对于AF_INET而言，指向的是inet_listen</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_listen</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 还不是listen状态（尚未listen过）</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>old_state <span class="token operator">!=</span> TCP_LISTEN<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 开始监听</span>    err <span class="token operator">=</span> <span class="token function">inet_csk_listen_start</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置全连接队列长度</span>    sk<span class="token operator">-></span>sk_max_ack_backlog <span class="token operator">=</span> backlog<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<strong>全连接队列的长度就是执行listen调用时传入的backlog和系统参数之间较小的那个值</strong>。所以如果再线上遇到了全连接队列溢出的问题，想加大该队列的长度，那么可能需要将它们都设置得更大。</p><p>回过头来看inet_csk_listen_start函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_csk_listen_start</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> nr_table_entries<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> inet_connection_sock <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// icsk->icsk_accept_queue时接收队列</span>    <span class="token comment" spellcheck="true">// 接收队列内核对象的申请和初始化</span>    <span class="token keyword">int</span> rc <span class="token operator">=</span> <span class="token function">reqsk_queue_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>icsk<span class="token operator">-></span>icsk_accept_queue<span class="token punctuation">,</span> nr_table_entries<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数再一开始就<strong>将struct sock对象强制转换成了inet_connection_sock，名叫icsk</strong>。之所以可以强制转换是因为inet_connection_sock是包含sock的。tcp_sock、inet_connection_sock、inet_sock、sock是逐层嵌套的关系，类似面向对象里继承的概念。而对于TCP的socket来说，sock对象实际上是一个tcp_sock。因此TCP的sock对象可以强制类型转换为tcp_sock、inet_connection_sock、inet_sock来使用。即子类转换为父类。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> tcp_sock <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* inet_connection_sock has to be the first member of tcp_sock */</span>    <span class="token keyword">struct</span> inet_connection_sock inet_conn<span class="token punctuation">;</span>    u16 tcp_header_len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Bytes of tcp header to send      */</span>    u16 xmit_size_goal_segs<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Goal for segmenting output packets */</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> inet_connection_sock <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* inet_sock has to be the first member! */</span>    <span class="token keyword">struct</span> inet_sock      icsk_inet<span class="token punctuation">;</span>    <span class="token keyword">struct</span> request_sock_queue icsk_accept_queue<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inet_bind_bucket   <span class="token operator">*</span>icsk_bind_hash<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> inet_sock <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* sk and pinet6 has to be the first two members of inet_sock */</span>    <span class="token keyword">struct</span> sock     sk<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> IS_ENABLED(CONFIG_IPV6)</span>    <span class="token keyword">struct</span> ipv6_pinfo   <span class="token operator">*</span>pinet6<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> socket <span class="token punctuation">{</span>    socket_state        state<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> sock     <span class="token operator">*</span>sk<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> proto_ops  <span class="token operator">*</span>ops<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>也可以由sock强制转换为tcp_sock，因为在套接字创建的时候，就是以struct tcp_sock作为大小进行分配的。也就是内核中的每个sock都是tcp_sock类型，而struct tcp_sock正好是最大的那个结构体，不会出现越界访问的情况。</p></blockquote><p>在接下来的一行reqsk_queue_alloc中实际上包含了两件重要的事情。一是接<strong>收队列数据结构的定义</strong>，二是<strong>接收队列的申请和初始化</strong>。</p><h4 id="3）接收队列定义"><a href="#3）接收队列定义" class="headerlink" title="3）接收队列定义"></a>3）接收队列定义</h4><p>icsk-&gt;icsk_accept_queue定义在inet_connection_sock下，是一个request_sock_queue类型的对象，是内核用来接收客户端请求的主要数据结构。我们平时说的全连接队列、半连接队列全都是在这个数据结构里实现的。</p><p><img src="/posts/11832/729eba138dc942e58206eaeee3a97113.png" alt></p><p>我们来看具体的代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> inet_connection_sock <span class="token punctuation">{</span>    <span class="token keyword">struct</span> inet_sock icsk_inet<span class="token punctuation">;</span>    <span class="token keyword">struct</span> request_sock_queue icsk_accept_queue<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> request_sock_queue <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 全连接队列</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>rskq_accept_head<span class="token punctuation">;</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>rskq_accept_tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 半连接队列</span>    <span class="token keyword">struct</span> listen_sock <span class="token operator">*</span>listen_opt<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> listen_sock <span class="token punctuation">{</span>    u8 max_qlen_log<span class="token punctuation">;</span>    u32 nr_table_entires<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>syn_table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于全连接队列来说，在它上面不需要进行复杂的查找工作，<strong>accept处理的时候只是先进先出地接受就好了</strong>。所以全连接队列通过rskq_accept_head和rskq_accept_tail以<strong>链表的形式来管理</strong>。</p><p>和半连接队列相关联的数据对象是listen_opt，它是listen_sock类型的。<strong>因为服务端需要在第三次握手时快速地查找出来第一次握手时留存的request_sock对象，所以其实是用了一个哈希表来管理</strong>，就是struct request_sock *syn_table[0]。max_qlen_log和nr_table_entries都和半连接队列的长度有关。</p><h4 id="4）接收队列申请和初始化"><a href="#4）接收队列申请和初始化" class="headerlink" title="4）接收队列申请和初始化"></a>4）接收队列申请和初始化</h4><p>了解了全/半连接队列数据结构后，再回到inet_csk_listen_start函数中。它<strong>调用了reqsk_queue_alloc来申请和初始化icsk_accept_queue这个接收队列</strong>。</p><p>在reqsk_queue_alloc这个函数中完成了接收队列request_sock_queue内核对象的创建和初始化。其中包括内存申请、半连接队列长度的计算、全连接队列头的初始化等等。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">reqsk_queue_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> request_sock_queue <span class="token operator">*</span>queue<span class="token punctuation">,</span> unsigend <span class="token keyword">int</span> nr_table_entries<span class="token punctuation">)</span><span class="token punctuation">{</span>    size_t lopt_size <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> listen_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> listen_sock <span class="token operator">*</span>lopt<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算半连接队列的长度</span>    nt_table_entries <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> nr_table_entries<span class="token punctuation">,</span> sysctl_max_syn_backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    nr_table_entries <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 为listen神奇对象申请内存，这里包括了半连接队列</span>    lopt_size <span class="token operator">+</span><span class="token operator">=</span> nr_table_entries <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sturct request_sock <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lopt_size <span class="token operator">></span> PAGE_SIZE<span class="token punctuation">)</span>        lopt <span class="token operator">=</span> <span class="token function">vzalloc</span><span class="token punctuation">(</span>lopt_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    lopt <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span>lopt_size<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 全连接队列头初始化</span>    queue<span class="token operator">-></span>rskq_accept_head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 半连接队列设置</span>    lopt<span class="token operator">-></span>nr_table_entries <span class="token operator">=</span> nr_table_entries<span class="token punctuation">;</span>    queue<span class="token operator">-></span>listen_opt <span class="token operator">=</span> lopt<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开头定义了一个struct listen_sock的指针，这个listen_sock就是我们平时经常说的半连接队列。接下来计算半连接队列的长度，计算出来实际大小后进行内存的申请。最后将全连接队列呕吐设置成了NULL，将半连接队列挂到了接收队列queue上。</p><blockquote><p>半连接队列上每个元素分配的是一个指针大小，实际指向的request_sock的内存还未分配。这其实是一个哈希表，真正的半连接用的request_sock对象是在握手的过程中分配的，计算完哈希值后挂到这个哈希表上。</p></blockquote><h4 id="5）半连接队列长度计算"><a href="#5）半连接队列长度计算" class="headerlink" title="5）半连接队列长度计算"></a>5）半连接队列长度计算</h4><p>reqsk_queue_alloc函数中计算了半连接队列的长度，因为有些复杂所以没有在前面展开，这里深入一下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">reqsk_queue_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> request_sock_queue <span class="token operator">*</span>queue<span class="token punctuation">,</span> unsigend <span class="token keyword">int</span> nr_table_entries<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算半连接队列的长度</span>    nr_table_entries <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> nr_table_entries<span class="token punctuation">,</span> sysctl_max_syn_backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    nr_table_entries <span class="token operator">=</span> <span class="token function">max_t</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> nr_table_entries<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nr_table_entries <span class="token operator">=</span> <span class="token function">roundup_pow_of_two</span><span class="token punctuation">(</span>nr_table_entries <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为了效率，不记录nr_table_entries而是记录2的N次幂等于nr_table_entries</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>kopt<span class="token operator">-></span>max_qlen_log <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> lopt<span class="token operator">-></span>max_qlen_log<span class="token punctuation">)</span> <span class="token operator">&lt;</span> nr_table_entries<span class="token punctuation">;</span> lopt<span class="token operator">-></span>max_qlen_log<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传进来的nr_table_entries在最初是用户传入的backlog和内核参数net.core.somaxconn二者之间的较小值。而在这个reqsk_queue_alloc函数里又将完成三次的对比和计算。</p><ul><li>min_t(u32, nr_table_entries, sysctl_max_syn_backlog)：和sysctl_max_syn_backlog内核对象比较，取较小值</li><li>max_t(u32, nr_table_entries, 8)：用来保证nr_table_entries不能比8小，避免传入太小的值导致无法建立连接</li><li>roundup_pow_of_two(nr_table_entries + 1)：用于上对齐到2的整数次幂</li></ul><p><strong>总的来说半连接队列的长度是min(backlog, somaxconn, tcp_max_syn_backlog)+1再向上取整到2的N次幂，但最小不能小于16。</strong></p><p>最后为了提升比较性能，内核并没有直接记录半连接队列的长度，而是采用了一种晦涩的方法，只记录其N次幂。即如果队列长度为16，则记录max_qlen_log为4，只需要直到它是为了提升性能的即可。</p><h4 id="6）小结"><a href="#6）小结" class="headerlink" title="6）小结"></a>6）小结</h4><p><strong>listen的主要工作其实就是申请和初始化接收队列，包括全连接队列和半连接队列。其中全连接队列是一个链表，而半连接队列由于需要快速地查找，所以使用的是一个哈希表。这两个队列是三次握手中很重要的两个数据结构，有了它们服务端才能正常相应来自客户端的三次握手。所以服务端都需要先调用listen才行。</strong></p><p>同时我们也知道了去内核时如何确定全连接队列和半连接队列的长度。</p><ol><li>全连接队列：min(backlog, net.core.somaxconn)</li><li>半连接队列：max(min(backlog, net.core.somaxconn, tcp_max_syn_backlog) + 1向上取整到2的幂次, 16)</li></ol><h3 id="三、深入理解connect"><a href="#三、深入理解connect" class="headerlink" title="三、深入理解connect"></a>三、深入理解connect</h3><p>客户端再发起连接的时候，创建一个socket，如何瞄准服务端调用connect就可以了，代码可以简单到只有两句。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">connect</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但这两行代码背后隐藏的技术细节却很多。</p><p><img src="/posts/11832/f96eece2281843df8f18c01b97d3d5af.png" alt></p><h4 id="1）connect调用链展开"><a href="#1）connect调用链展开" class="headerlink" title="1）connect调用链展开"></a>1）connect调用链展开</h4><p>当客户机调用connect函数的时候，进入系统调用</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>connect<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr __user <span class="token operator">*</span><span class="token punctuation">,</span> uservaddr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据用户fd查找内核中的socket对象</span>    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 进行connect</span>    err <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">connect</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> addlen<span class="token punctuation">,</span> sock<span class="token operator">-></span>file<span class="token operator">-></span>f_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理还是首先根据用户传入的文件描述符来查询对应的socket内核对象，如何再调用sock-&gt;ops-&gt;connect，对于AF_INET类型的socket而言，指向的是inet_stream_connect。而inet_stream_connect实际会去调用__inet_stream_connect</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__inet_stream_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-></span>sk<span class="token punctuation">;</span>    <span class="token function">witch</span><span class="token punctuation">(</span>sock<span class="token operator">-></span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>            err <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token keyword">case</span> SS_CONNECTED<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">// 此套接口已经和对端的套接口相连接了，即连接已经建立</span>        err <span class="token operator">=</span> <span class="token operator">-</span>EISCONN<span class="token punctuation">;</span>        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token keyword">case</span> SS_CONNECTING<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">// 此套接口正在尝试连接对端的套接口，即连接正在建立中</span>            err <span class="token operator">=</span> <span class="token operator">-</span>EALREADY<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> SS_UNCONNECTED<span class="token punctuation">:</span>        err <span class="token operator">=</span> sk<span class="token operator">-></span>sk_prot<span class="token operator">-></span><span class="token function">connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> uaddr<span class="token punctuation">,</span> addr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>          sock<span class="token operator">-></span>state <span class="token operator">=</span> SS_CONNECTING<span class="token punctuation">;</span>        err <span class="token operator">=</span> <span class="token operator">-</span>EINPROGRESS<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>刚创建完毕的socket的状态就是SS_UNCONNECTED，根据switch判断会去调用sk-&gt;sk_prot-&gt;connect</strong>，对于TCP socket而言，调用的是<strong>tcp_v4_connect</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> addr_len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置socket的状态为TCP_SYN_SENT</span>    <span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_SYN_SENT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 动态选择一个端口</span>    err <span class="token operator">=</span> <span class="token function">inet_hash_connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_death_row<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 函数用来根据sk中的信息，构建一个syn报文，并将它发送出去</span>    err <span class="token operator">=</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里会<strong>把socket的状态设置为TCP_SYN_SENT，再通过inet_hash_connect来动态地选择一个可用的端口</strong>。</p><h4 id="2）选择可用端口"><a href="#2）选择可用端口" class="headerlink" title="2）选择可用端口"></a>2）选择可用端口</h4><p>找到inet_hash_connect的源码，我们来看看到底端口时如何选择出来的。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_hash_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inet_timewait_death_row <span class="token operator">*</span>death_row<span class="token punctuation">,</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">__inet_hash_connect</span><span class="token punctuation">(</span>death_row<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> <span class="token function">inet_sk_port_offset</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> __inet_check_established<span class="token punctuation">,</span> __inet_hash_nolisten<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要关注一下调用__inet_hash_connect的两个参数 ：</p><ul><li>inet_sk_port_offset(sk)：这个函数根据要链接的目的IP和端口等信息生成一个随机数</li><li>__inet_check_established：检查是否和现有ESTABLISH状态的连接冲突的时候用的函数</li></ul><p>接着进入__inet_hash_connect函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__inet_hash_connect</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 是否绑定过端口</span>    <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> snum <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>inet_num<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取本地端口配置</span>    <span class="token function">inet_get_local_port_range</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>low<span class="token punctuation">,</span> <span class="token operator">&amp;</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>        remaing <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>snum<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 遍历查找</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> remaining<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        port <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> offset<span class="token punctuation">)</span> <span class="token operator">%</span> remaining<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保证了port会在范围之间</span>        <span class="token comment" spellcheck="true">// 查看是否是保留端口，是则跳过</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">inet_is_reserverd_local_port</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 查找和遍历已经使用的端口的哈希表链</span>         head <span class="token operator">=</span> <span class="token operator">&amp;</span>hinfo<span class="token operator">-></span>bhash<span class="token punctuation">[</span><span class="token function">inet_bhashfn</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> port<span class="token punctuation">,</span> hinfo<span class="token operator">-></span>bhash_size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">inet_bind_bucket_for_each</span><span class="token punctuation">(</span>tb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>head<span class="token operator">-></span>charin<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果端口已经使用</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">net_eq</span><span class="token punctuation">(</span><span class="token function">ib_net</span><span class="token punctuation">(</span>tb<span class="token punctuation">)</span><span class="token punctuation">,</span> net<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> tb<span class="token operator">-></span>port <span class="token operator">==</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 通过check_established继续检查是否可用</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">check_established</span><span class="token punctuation">(</span>death_row<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tw<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">goto</span> ok<span class="token punctuation">;</span>         <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 未使用的话</span>        tb <span class="token operator">=</span> <span class="token function">inet_bind_bukcet_create</span><span class="token punctuation">(</span>hinfo<span class="token operator">-></span>bind_bucket_cachep<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">goto</span> ok<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个函数中首先判断了inet_sk(sk)-&gt;inet_num，<strong>如果调用过bind，那么这个函数会选择好端口并设置在inet_num上，加入没有调用过bind，那么snum为0。</strong></p><p>接着调用inet_get_local_port_range，这个函数<strong>读取的是net.ipv4.ip_local_port_range这个内核参数，来读取管理员配置的可用的端口范围</strong>。</p><blockquote><p>该参数的默认值是32768-61000，意味着端口与总可用量是61000-32768=28232个。如果觉得这个数字不够用，那么可以通过修改net.ipve4.ip_local_port_range内参参数来重新设置。</p></blockquote><p>接下来进入for循环，其中offset是通过inet_sk_port_offset(sk)计算出来的随机数（是调用__inet_hash_connect时传进来的参数）。<strong>这段循环的作用就是从某个随机数开始，把整个可用端口范围遍历一遍，直到找到可用的端口为止</strong>。具体逻辑如下</p><ol><li>从随机数+low开始<strong>选取一个端口</strong></li><li><strong>判断端口是否是保留端口</strong>，即判断端口是否在net.ipv4.ip_local_reserved_ports中（如果因为某种原因不希望某些端口被内核使用则可以写入这个参数）</li><li><strong>获取已使用端口的哈希表</strong></li><li><strong>遍历哈希表判断端口是否被使用</strong>，如果没有找到则说明可以使用，已使用过则调用check_established（具体逻辑见下部分）</li><li>找到合适的端口：通过inet_bind_bucket_create<strong>申请一个inet_bind_bucket来记录端口已经使用了，并用哈希表的形式管理起来</strong>。</li><li>找不到合适的端口：<strong>返回-EADDRNOTAVAIL</strong>，也就是我们在用户程序上看到的Cannot assign requested address</li></ol><blockquote><p>所以如果遇到这个错误，应该想到去查一下net.ipv4.ip_local_port_range中设置的可用端口的范围是不是太小了。</p></blockquote><h4 id="3）端口被使用过怎么办"><a href="#3）端口被使用过怎么办" class="headerlink" title="3）端口被使用过怎么办"></a>3）端口被使用过怎么办</h4><p>在遍历已使用端口的哈希表时，对于已被使用的端口，会去<strong>调用check_established继续检查是否可用，如果这个函数返回0，则说明端口可以继续使用</strong>。</p><blockquote><p>对于TCP连接而言，维护的是一对四元组，分别由收发双方的端口号和ip地址决定，只要四元组中任意一个元素不同，都算是两条不同的连接。所以只要现有的TCP连接中四元组不与要建立的连接的其他三个元素完全一致，该端口就仍然可以使用。</p></blockquote><p>check_established实际上会去调用__inet_check_established</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__inet_check_established</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inet_timewait_death_row <span class="token operator">*</span>death_row<span class="token punctuation">,</span>                <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> __u16 lport<span class="token punctuation">,</span>                <span class="token keyword">struct</span> inet_timewait_sock <span class="token operator">*</span><span class="token operator">*</span>twp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找哈希桶</span>    ehash_bucket <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">inet_ehash_buket</span><span class="token punctuation">(</span>hinfo<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历看看有没有四元组一样的，一样的话就报错</span>    <span class="token function">sk_nulls_for_each</span><span class="token punctuation">(</span>sk2<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>head<span class="token operator">-></span>chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk2<span class="token operator">-></span>sk_hash <span class="token operator">!=</span> hash<span class="token punctuation">)</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">INET_MATCH</span><span class="token punctuation">(</span>sk2<span class="token punctuation">,</span> net<span class="token punctuation">,</span> acookie<span class="token punctuation">,</span> saddr<span class="token punctuation">,</span> daddr<span class="token punctuation">,</span> ports<span class="token punctuation">,</span> dif<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> not_unique<span class="token punctuation">;</span>    <span class="token punctuation">}</span>unique<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>not_uniqueue<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token operator">-</span>EADDRNOTAVAIL<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数首先找到inet_ehash_bucket（类似bhash，只不过这是所有ESTABLISH状态的socket组成的hash表），然后<strong>遍历整个哈希表，如果哈希值不相同则说明当前四元组不一致，如果哈希值相同则使用INET_MATCH进一步进行比较</strong>。如果匹配就是说明四元组完全一致，所以这个端口不可用，返回-EADDRNOTAVAIL，如果不匹配（四元组有一或以上个元素不一样）那么就返回0，表示该端口仍然可以用于建立新连接。</p><blockquote><p>INET_MATCH中除了将<strong>saddr、</strong>daddr、__ports进行了比较，还比较了一些其他项目，所以TCP连接还有五元组、七元组之类的说法。</p><p>一台客户机的最大建立的连接数并不是65535，只要有足够多的服务端，单机发出百万条连接没有任何问题。</p></blockquote><h4 id="4）发起SYN请求"><a href="#4）发起SYN请求" class="headerlink" title="4）发起SYN请求"></a>4）发起SYN请求</h4><p>找到可用的端口后，回到tcp_v4_connect，接下来会去调用tcp_connect来根据sk中的信息构建一个syn报文发送出去。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 申请并设置skb</span>    buff <span class="token operator">=</span> <span class="token function">alloc_skb_fclone</span><span class="token punctuation">(</span>MAX_TCP_HEADER <span class="token operator">+</span> <span class="token number">15</span><span class="token punctuation">,</span> sk<span class="token operator">-></span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tcp_init_nondata_skb</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> tp<span class="token operator">-></span>write_seq<span class="token operator">++</span><span class="token punctuation">,</span> TCPHDR_SYN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加到发送队列sk_write_queue</span>    <span class="token function">tcp_connect_queue_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 实际发出syn</span>    err <span class="token operator">=</span> tp<span class="token operator">-></span>fastopen_req <span class="token operator">?</span> <span class="token function">tcp_send_syn_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> sk<span class="token operator">-></span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 启动重传定时器</span>    <span class="token function">inet_csk_resetxmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">,</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_rto<span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tcp_connect一口气做了这么几件事：</p><ol><li><strong>申请一个skb，并将其设置为syn包</strong></li><li><strong>添加到发送队列上</strong></li><li><strong>调用tcp_transmit_skb将该包发出</strong>（同之前内核发送网络包的方式，传递给网络层）</li><li><strong>启动一个重传定时器，超时会重发</strong></li></ol><p><strong>该定时器的作用是等到一定时间后收不到服务端的反馈的时候来开启重传</strong>。首次超时时间是在TCP_TIMEOUT_INIT宏中定义的，该值在Linux3.10版本是1秒， 在一些老版本中是3秒。</p><blockquote><p>TCP在实现过程中，发送队列和重传队列都是sk_write_queue，这两个队列是一并处理的。</p></blockquote><h4 id="5）小结"><a href="#5）小结" class="headerlink" title="5）小结"></a>5）小结</h4><p><strong>客户端执行connect函数的时候，把本地socket状态设置成了TCP_SYN_SENT，选了一个可用的端口，接着发出SYN握手请求并启动重传定时器。</strong></p><p>在选择端口时，会随机地从ip_local_port_range指定的范围中选择一个位置开始循环遍历，找到可用端口后发出syn握手包，如果端口查找失败则抛出异常“Cannot assign requested address”。如果当前可用端口很充足，那么循环很快就可以退出。而如果ip_local_port_range中的端口快被用完了，那么这时候内核就大概率要把循环执行很多轮才能找到可用端口，<strong>这会导致connect系统调用的CPU开销上涨</strong>。</p><p><strong>而如果在connect之前使用了bind，将会使得connect系统调用时地端口选择方式无效，转而使用bind时确定的端口</strong>。即如果提前调用bind选了一个端口号，会先尝试使用该端口号，如果传入0也会自动选择一个。但默认情况下一个端口只会被使用一次，所以对于客户端角色的socket，不建议使用bind。</p><h3 id="四、完整TCP连接建立过程"><a href="#四、完整TCP连接建立过程" class="headerlink" title="四、完整TCP连接建立过程"></a>四、完整TCP连接建立过程</h3><p>在一次TCP连接建立（三次握手）的过程中，并不只是简单的状态的流转，还包括端口选择、半连接队列、syncookie、全连接队列、重传计时器等关键操作。</p><p>在三次握手的过程，服务端核心逻辑是创建socket绑定端口，listen监听，最后accept接收客户端的的请求；而客户端的核心逻辑是创建socket，然后调用connect连接服务端。</p><p>socket的创建、服务端的listen、客户端的connect在前面都已经讲解过了，那么这里从客户端connect发出syn包之后开始。客户端通过调用connect来发起连接。<strong>客户端在调用connect的时候，把本地socket状态设置成了TCP_SYN_SENT，选了一个可用的端口，接着发出SYN握手请求并启动重传定时器</strong>。</p><p><img src="/posts/11832/ba1fddf3fe0d459ab307d88650b4d73a.png" alt></p><h4 id="1）服务端响应SYN"><a href="#1）服务端响应SYN" class="headerlink" title="1）服务端响应SYN"></a>1）服务端响应SYN</h4><p>在服务端，所有的TCP包（包括客户端发来的SYN握手请求）都经过网卡、软中断进入tcp_v4_rcv。在该函数中根据网络包skb的TCP头信息中的目的IP信息查找当前处于listen状态的socket，然后继续进入tcp_v4_do_rcv处理握手过程（因为listen状态的socket不会收到的进入预处理队列。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 服务端收到第一步握手SYN或者第三步ACK都会走到这里</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_LISTEN） <span class="token punctuation">{</span>    <span class="token keyword">struct</span> sock <span class="token operator">*</span>nsk <span class="token operator">=</span> <span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nsk<span class="token punctuation">)</span>         <span class="token keyword">goto</span> discard<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nsk <span class="token operator">!=</span> sk<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_child_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> nsk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        rsk <span class="token operator">=</span> nsk<span class="token punctuation">;</span>        <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">,</span> skb<span class="token operator">-></span>len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      rsk <span class="token operator">=</span> sk<span class="token punctuation">;</span>      <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找listen socket的半连接队列</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>req <span class="token operator">=</span> <span class="token function">inet_csk_search_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> iph<span class="token operator">-></span>saddr<span class="token punctuation">,</span> iph<span class="token operator">-></span>daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">tcp_check_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在tcp_v4_do_rcv中判断当前socket是listen状态后，首先会到tcp_v4_hnd_req查看是否处于半连接队列</strong>。如果再半连接队列中没有找到对应的半连接对象，则会返回listen的socket(连接尚未创建)；如果找到了就将该半连接socket返回。服务端第一次响应SYN的时候，半连接队列自然没有对应的半连接对象，所以返回的是原listen的socket，即nsk == sk。</p><p><strong>在tcp_rcv_state_process里根据不同的socket状态进行不同的处理</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span>             <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">swich</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> TCP_LISTEN<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// 判断是否为syn握手包</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>th<span class="token operator">-></span>syn<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>icsk<span class="token operator">-></span>icsk_af_ops<span class="token operator">-></span><span class="token function">conn_request</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中conn_request是一个函数指针，指向tcp_v4_conn_request。<strong>服务端响应SYN的主要逻辑都在整个tcp_v4_conn_request里</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查看半连接队列是否满了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">inet_csk_reqsk_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    want_cookie <span class="token operator">=</span> <span class="token function">tcp_syn_flood_action</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token string">"TCP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>want_cookie<span class="token punctuation">)</span>        <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 在全连接队列满的情况下，如果有young_ack，那么直接丢弃</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inet_csk_reqsk_queue_young</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENOVERFLOWS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 分配request_sock内核对象</span>    req <span class="token operator">=</span> <span class="token function">inet_reqsk_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_request_sock_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造syn+ack包</span>    skb_synack <span class="token operator">=</span> <span class="token function">tcp_make_synack</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> req<span class="token punctuation">,</span> <span class="token function">fastopen_cookie_present</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>valid_foc<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&amp;</span>valid_foc <span class="token punctuation">:</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span>do_fastopen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 发送syn+ack响应</span>    err <span class="token operator">=</span> <span class="token function">ip_build_and_send_pkt</span><span class="token punctuation">(</span>skb_aynack<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> ireq<span class="token operator">-></span>loc_addr<span class="token punctuation">,</span> ireq<span class="token operator">-></span>rmt_addr<span class="token punctuation">,</span> ireq<span class="token operator">-></span>opt<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 添加到半连接队列，并开启计时器</span>    <span class="token function">inet_csk_reqsk_queue_hash_add</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> TCP_TIMEOUT_INIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里首先<strong>判断半连接队列是否满了</strong>，如果满了进入tcp_syn_flood_action去<strong>判断是否开启了tcp_syncookies内核参数</strong>。<strong>如果队列满且未开启tcp_syncookies，那么该握手包将被直接丢弃。</strong></p><blockquote><p>TCP Syn Cookie 是一个防止 SYN Flood 攻击的技术。当服务器接收到大量伪造的 SYN 请求时，可以消耗掉所有的连接资源，导致合法用户无法建立新的连接，这种攻击方式被称为 SYN Flood 攻击。SYN Flood 是一种 DoS（Denial of Service，服务拒绝）攻击。</p><p>这种技术的主要思想是不在服务器上为每个收到的 SYN 请求分配资源，而是通过计算一个 Cookie（实质上是一个哈希值），将这个 Cookie 作为 SYN-ACK 包的序列号发回客户端。当客户端回复 ACK 包时，服务器可以从 ACK 包的确认号中恢复出之前发送的 Cookie，从而验证这个连接请求是有效的。</p><p>这种方式可以有效抵御 SYN Flood 攻击，因为服务器不需要为每个 SYN 请求分配资源，伪造的 SYN 请求不会消耗服务器的资源。但是，SYN Cookie 技术也有一些局限性，例如它不兼容一些 TCP 的高级特性（如窗口缩放），并且在计算 Cookie 时也会消耗一些 CPU 资源</p></blockquote><p>接着<strong>判断全连接队列是否满了</strong>，因为全连接队列满也会导致握手异常，那干脆就在第一次握手的时候也判断了。<strong>如果全队列满了，且young_ack数量大于1的话，那么同样也是直接丢弃</strong>。</p><blockquote><p>young_ack是半连接队列里保存着的一个计时器，记录的是刚有SYN到达，没有被SYN_ACK重传定时器重传过SYN_ACK，同时也没有完成过三次握手的sock数量。</p><p>inet_csk_reqsk_queue_young(sk) &gt; 1这一判断，其实是在检查是否存在”年轻”的连接请求。如果存在这样的请求，而且全连接队列又已经满了，那么就会选择拒绝新的连接请求，以防止服务器过载。</p></blockquote><p>接下来是<strong>构造synack包</strong>，然后通过ip_build_and_send_pkt把它<strong>发送出去</strong>。</p><p>最后<strong>把当前的握手信息添加到半连接队列，并且启动计时器</strong>。计时器的作用是<strong>如果某个时间内还收不到客户端的第三次握手，服务端就会重传synack包</strong>。</p><blockquote><p>此时半连接队列中的request_sock的状态为SYN_RECV。等到服务器收到客户端的ACK报文，也就是三次握手完成后，request_sock 会被”升级”为一个完整的 sock 结构体，状态变为 ESTABLISHED。</p></blockquote><h4 id="2）客户端响应SYNACK"><a href="#2）客户端响应SYNACK" class="headerlink" title="2）客户端响应SYNACK"></a>2）客户端响应SYNACK</h4><p>客户端收到服务端发来的synack包的时候，由于自身状态是TCP_SYN_SENT，所以不会进入ESTABLISHED、LISTEN分支，同样进入tcp_rcv_state_process函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 服务端收到第一个SYN包</span>    <span class="token keyword">case</span> TCP_LISTEN<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 客户端第二次握手处理</span>        <span class="token keyword">case</span> TCP_SYN_SENT<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// 处理synack包</span>        queued <span class="token operator">=</span> <span class="token function">tcp_rcv_synsent_state_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> th<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tcp_rcv_synsent_state_process是客户端响应synack的主要逻辑</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tcp_rcv_synsent_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span>                 <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>tp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">tcp_ack</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> FLAG_SLOWPATH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 连接建立完成</span>    <span class="token function">tcp_finish_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_write_pending <span class="token operator">||</span>    icsk<span class="token operator">-></span>icsk_accept_queue<span class="token punctuation">.</span>rskq_defer_accept <span class="token operator">||</span>    icsk<span class="token operator">-></span>icsk_ack<span class="token punctuation">.</span>pingpong<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 延迟确认......</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">tcp_send_ack</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>tcp_ack(sk, skb, FLAG_SLOWPATH)：这行代码在收到SYN-ACK包后<strong>更新了socket的状态，包括序列号、确认号等</strong>。</p><ul><li><p>tcp_clean_rtx_queue：删除重传队列中已被确认的数据包，停止重传定时器</p><blockquote><p>在TCP协议中，当发送一个数据包时，发送方将这个数据包存储在重传队列中，并启动一个定时器。如果在定时器超时之前收到了这个数据包的确认（ACK），那么发送方就知道这个数据包已经成功地到达接收方，它就会从重传队列中删除这个数据包。否则，当定时器超时时，发送方就会重新发送这个数据包。</p><p>tcp_clean_rtx_queue函数就是处理这个重传队列的函数。它遍历重传队列，查看哪些数据包已经得到了确认，然后从重传队列中删除这些数据包。它还会计算网络的往返时间（RTT），以便于调整TCP的超时时间。</p><p>如果重传队列中的所有数据包都已经被确认，那么停止重传定时器。</p></blockquote></li></ul></li><li><p>tcp_finish_connect(sk, skb)：这行代码完成了TCP连接的建立。它<strong>将socket的状态从SYN_SENT改为ESTABLISHED，初始化TCP连接的拥塞控制算法、接收缓存和发送缓存空间等信息，开启keep alive计时器，然后唤醒等待连接完成的进程</strong>。</p><blockquote><p>Keep-alive计时器就是用于控制发送keep-alive数据包的计时器。通常，当一个TCP连接上没有任何数据包的传输时，我们就启动这个计时器。如果在计时器超时之前有新的数据包在这个连接上发送或接收，那么我们就重置计时器。如果计时器超时，那么我们就发送一个keep-alive数据包，并重新启动计时器等待响应。如果接收到了对这个数据包的响应，那么我们就知道连接仍然存在。如果在一定时间内没有收到响应，那么我们就假定连接已经断开，并将其关闭。</p></blockquote></li><li><p>满足TCP的延迟确认（Delayed ACK）机制：这种情况下，ACK包可能会和后续的数据包一起发送，以减少网络上的包的数量。</p></li><li><p>不满足延迟确认机制：立即调用tcp_send_ack(sk)，<strong>申请和构造ACK包然后发送出去</strong>。这个ACK包是对对方SYN-ACK包的确认，也是TCP三次握手的最后一步。</p></li></ol><p>即<strong>客户端响应来自服务端的synack时清除了connect时设置得重传定时器，把当前socket状态设置为ESTABLISHED，开启保活计时器然后发出第三次握手的ack确认</strong>。</p><h4 id="3）服务端响应ACK"><a href="#3）服务端响应ACK" class="headerlink" title="3）服务端响应ACK"></a>3）服务端响应ACK</h4><p>服务端响应第三次握手的ack时同样会进入tcp_v4_do_rcv。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 服务端收到第一步握手SYN或者第三步ACK都会走到这里</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_LISTEN） <span class="token punctuation">{</span>        <span class="token keyword">struct</span> sock <span class="token operator">*</span>nsk <span class="token operator">=</span> <span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nsk<span class="token punctuation">)</span>             <span class="token keyword">goto</span> discard<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nsk <span class="token operator">!=</span> sk<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_child_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> nsk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rsk <span class="token operator">=</span> nsk<span class="token punctuation">;</span>            <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于此处已经是第三次握手了，半连接队列里会存在第一次握手时留下的半连接信息，所以tcp_v4_hnd_req会在半连接队列里找到半连接request_sock对象后进入tcp_check_req</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找listen socket的半连接队列</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>req <span class="token operator">=</span> <span class="token function">inet_csk_search_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> iph<span class="token operator">-></span>saddr<span class="token punctuation">,</span> iph<span class="token operator">-></span>daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">tcp_check_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_check_req</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建子sock</span>    child <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_af_ops<span class="token operator">-></span><span class="token function">syn_recv_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 清理半连接队列</span>    <span class="token function">inet_csk_reqsk_queue_unlink</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_csk_reqsk_queue_removed</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加全连接队列</span>    <span class="token function">inet_csk_reqsk_queue_add</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数完成了以下工作：</p><ol><li><strong>判断接收队列是不是满了，没满则创建子sock（tcp_sock)</strong></li><li><strong>把request_sock从半连接队列删除</strong></li><li><strong>将request_sock添加到全连接队列链表的尾部，并与新创建的sock关联</strong></li></ol><p>因为是第三次握手所以返回了新的子sock，那么显然nsk!=sk，所以会执行<strong>tcp_child_process来为新的子sock进行一些初始化和处理工作</strong>，如设置TCP标志等，如果处理成功则会返回0。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_child_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>parent<span class="token punctuation">,</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span>child<span class="token punctuation">,</span>        <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> state <span class="token operator">=</span> child<span class="token operator">-></span>sk_state<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sock_owned_by_user</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret <span class="token operator">=</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">,</span> skb<span class="token operator">-></span>len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 进行状态处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> TCP_SYN_RECV <span class="token operator">&amp;&amp;</span> child<span class="token operator">-></span>sk_state <span class="token operator">!=</span> state<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 状态处理结束后socket的状态发生了变化</span>        <span class="token comment" spellcheck="true">// 调用sock_def_readable函数发送可读事件通告给listening socket，告知其可以进行accept系统调用</span>            parent<span class="token operator">-></span><span class="token function">sk_data_ready</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 新的socket被进行系统调用的进程锁定；因为这是新的socket，所以在tcp_v4_rcv加的锁不会起到保护新socket的作用</span>        <span class="token function">__sk_add_backlog</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 加入到后背队列</span>    <span class="token punctuation">}</span>    <span class="token function">bh_unlock_sock</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sock_put</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到其中再一次调用了tcp_rcv_state_process，然后唤醒等待队列上的进程。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 服务端收到第一次握手的SYN包</span>    <span class="token keyword">case</span> TCP_LISTEN<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 客户端第二次握手处理</span>        <span class="token keyword">case</span> TCP_SYN_SENT<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 服务端收到第三次握手的ACK包</span>    <span class="token keyword">case</span> TCP_SYN_RECV<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// 改变状态为连接</span>        <span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_ESTABLISHED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>服务端响应第三次握手ACK所做的工作就是把当前半连接对象删除，创建了新的sock后加入全连接队列，最后将新连接状态设置为ESTABLISHED。</strong></p><h4 id="4）服务端accept"><a href="#4）服务端accept" class="headerlink" title="4）服务端accept"></a>4）服务端accept</h4><p><strong>当服务端调用accept时主要的逻辑就是创建socket对象，然后从全连接队列中取出request_sock，将其中保存的第三次握手时创建的sock取出并与socket关联，随后释放request_sock。</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">inet_csk_accept</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 从全连接都列中获取</span>    <span class="token keyword">struct</span> request_sock_queue <span class="token operator">*</span>queue <span class="token operator">=</span> <span class="token operator">&amp;</span>icsk<span class="token operator">-></span>icsk_accept_queue<span class="token punctuation">;</span>    req <span class="token operator">=</span> <span class="token function">reqsk_queue_remove</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    newsk <span class="token operator">=</span> req<span class="token operator">-></span>sk<span class="token punctuation">;</span>    <span class="token keyword">return</span> newsk<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> request_sock <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 和其它struct request_sock对象形成链表</span>    <span class="token keyword">struct</span> request_sock        <span class="token operator">*</span>dl_next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Must be first member! */</span>    <span class="token comment" spellcheck="true">// SYN段中客户端通告的MSS</span>    u16                mss<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// SYN+ACK段已经重传的次数，初始化为0</span>    u8                retrans<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// SYN+ACK段的超时时间</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>            expires<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指向tcp_request_sock_ops,该函数集用于处理第三次握手的ACK段以及后续accept过程中struct tcp_sock对象的创建</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> request_sock_ops    <span class="token operator">*</span>rsk_ops<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 连接建立前无效，建立后指向创建的tcp_sock结构</span>    <span class="token keyword">struct</span> sock            <span class="token operator">*</span>sk<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>所以，accept的重点工作就是从已经建立好的全连接队列中取出一个返回给用户进程</strong></p><p><img src="/posts/11832/3f1980ac7a6f48858ab0a0eec4dbdb8c.png" alt></p><p>TCP连接建立的操作可以简单划分为两类：</p><ol><li>内核消耗CPU进行接收、发送或者处理，包括系统调用、软中断和上下文切换。它们的耗时基本是几微妙左右。</li><li>网络传输将包从一台机器上发出，经过各式各样的网络互联设备道到达目的及其。网络传输的耗时一般在几毫秒到几百毫秒，远超于本机CPU处理。</li></ol><p>由于网络传输耗时比双端CPU耗时要高1000倍不止，所以在正常的TCP连接建立过程中，一般堪虑网络延时即可。</p><p>一个RTT指的是包从一台服务器到另一台服务器的一个来回的延迟时间。从全局来看，TCP连接建立的网络耗时大约需要三次传输，再加上少许的双方CPU开销，总共大约比1.5倍RTT大一点点。</p><p>不过从客户端的角度来看，只要ACK包发出了，内核就认为连接建立成功，可以开始发送数据了。所以如果在客户端统计TCP连接建立耗时，只需要两次传输耗时——即比1个RTT多一点时间（从服务端视角来看也是同理）。</p><h3 id="五、异常TCP建立情况"><a href="#五、异常TCP建立情况" class="headerlink" title="五、异常TCP建立情况"></a>五、异常TCP建立情况</h3><h4 id="1）connect系统调用耗时失控"><a href="#1）connect系统调用耗时失控" class="headerlink" title="1）connect系统调用耗时失控"></a>1）connect系统调用耗时失控</h4><p>客户端在发起connect系统调用的的时候，主要工作就是端口选择。在选择的过程中有一个大循环，从ip_local_port_range的一个随机位置开始把这个范围遍历一遍，找到可用端口则退出循环。如果端口很充足，那么循环只需要执行少数几次就可以退出。但是如果端口消耗掉很多已经不充足，或者干脆就没有可用的了，那么这个循环就得执行很多遍。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_hash_connect</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">inet_get_local_range</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>low<span class="token punctuation">,</span> <span class="token operator">&amp;</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>    remaining <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> remaining<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 其中offset是一个随机数</span>    port <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> offset<span class="token punctuation">)</span> <span class="token operator">%</span> remaining<span class="token punctuation">;</span>        head <span class="token operator">=</span> <span class="token operator">&amp;</span>hinfo<span class="token operator">-></span>bhash<span class="token punctuation">[</span><span class="token function">inet_bhashfn</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> port<span class="token punctuation">,</span> hinfo<span class="token operator">-></span>bhash_size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加锁</span>    <span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 一大段端口选择逻辑，选择成功就goto ok，选择不成功就goto next_port</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    next_port<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// 解锁</span>           <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<strong>每次循环内部需要等待所以及在哈希表中执行多次的搜索。并且这里的锁是自旋锁，如果资源被占用，进程并不会挂起，而是占用CPU不断地尝试去获得锁</strong>。假设端口范围ip_local_port_range配置的是10000~30000，而且已经用尽了。那么每次当发起连接的时候，都需要把循环执行两万遍才退出。这时会涉及大量的哈希查找以及自旋锁等待开销，系统态CPU将出现大幅度上涨。</p><p>所以当connect系统调用的CPU大幅度上涨时，可以<strong>尝试修改内核常熟ipv4.ip_local_port_range多预留一些端口、改用长连接或者尽快回收TIME_WAIT等方式</strong>。</p><h4 id="2）第一次握手丢包"><a href="#2）第一次握手丢包" class="headerlink" title="2）第一次握手丢包"></a>2）第一次握手丢包</h4><p><strong>服务端在响应来自客户端的第一次握手请求的时候，会判断半连接队列和全连接队列是否溢出。如果发生溢出的，可能会直接将握手包丢弃，而不会反馈给客户端。</strong></p><h5 id="1-半连接队列满"><a href="#1-半连接队列满" class="headerlink" title="1. 半连接队列满"></a>1. 半连接队列满</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 看看半连接队列是否满了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">inet_csk_reqsk_queue_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    want_cookie <span class="token operator">=</span> <span class="token function">tcp_syn_flood_action</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token string">"TCP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>want_cookie<span class="token punctuation">)</span>        <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 看看全连接队列是否满了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>drop<span class="token punctuation">:</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENDROPS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在以上代码中<code>inet_csk_reqsk_is_full</code>如果返回true就表示半连接队列满了，另外<code>tcp_syn_flood_action</code>判断是否打开了内核参数<code>cp_syncookies</code>，如果未打开则返回false。</p><p>也就是说，<strong>如果半连接队列满了，而且没有开启tcp_syncookies，那么来自客户端的握手包将goto drop，即直接丢弃</strong>。</p><p>SYN Flood攻击就是通过耗光服务端上的半连接队列来使得正常的用户连接请求无法被响应。不过在现在的Linux内核里只要打开tcp_syncookies，半连接队列满了仍然可以保证正常握手的进行。</p><h5 id="2-全连接队列满"><a href="#2-全连接队列满" class="headerlink" title="2. 全连接队列满"></a>2. 全连接队列满</h5><p>当半连接队列判断通过以后，紧接着还由全连接队列的相关判断。如果满了服务端还是会丢弃它。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 看看半连接队列是否满了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 在全连接队列满的情况下，如果有young_ack，那么直接丢弃</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inet_csk_reqsk_queue_young</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENOVERFLOWS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sk_aceeptq_is_full</code>判断全连接队列是否满了，<code>inet_csk_reqsk_queue_young</code>判断有没有<code>young_ack</code>（未处理完的半连接请求）。<strong>如果全连接队列满且同时有<code>young_ack</code>，那么内核同样直接丢掉该SYN握手包</strong>。</p><h5 id="3-客户端发起重试"><a href="#3-客户端发起重试" class="headerlink" title="3. 客户端发起重试"></a>3. 客户端发起重试</h5><p>假设服务端发生了全/半连接队列溢出而导致的丢包，那么转换到客户端的视角来看就是SYN包没有任何响应。</p><p>因为客户端在发出握手包的时候，开启了一个重传定时器。如果收不到预期的synack，超时的逻辑就会开始执行。不过重传定时器的时间单位都是以秒来计算的，这意味着如果有握手重传发生，即使第一次重传就能成功，那接口最快响应也是一秒以后的事情了，这对接口耗时影响非常大。以下是connect系统调用关于重传的逻辑。</p><p><img src="/posts/11832/3b6012963a8e4ff49bd91356cc21bab5.png" alt></p><p>来详细看看重传的相关逻辑。客户端在connect系统调用发出SYN握手信号后就开启了重传定时器：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span>sruct sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 实际发出SYN</span>    err <span class="token operator">=</span> tp<span class="token operator">-></span>fastopen_req <span class="token operator">?</span> <span class="token function">tcp_send_syn_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span> <span class="token punctuation">:</span>       <span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> sk<span class="token operator">-></span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 启动重传定时器</span>    <span class="token function">inet_csk_reset_xmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">,</span>        <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_rto<span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其中inet_csk(sk)-&gt;icsk_rto是超时时间，该值初始化的时候被设置为TCP_TIMEOUT_INIT</strong>（1秒，在一些老版本的内核里为3秒）。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_connect_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化为TCP_TIMEOUT_INIT</span>    <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_rto <span class="token operator">=</span> TCP_TIMEOUT_INIT<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果能正常接收到服务端响应的synack，那么客户端的这个定时器会清除</strong>。这段逻辑在tcp_rearm_rto里，具体的调用顺序为tcp_rcv_state_process-&gt;tcp_rcv_synsent_state_process-&gt;tcp_ack-&gt;tcp_clean_rtx_queue-&gt;tcp_rearm_rto;</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_stream_rto</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">inet_csk_clear_xmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果服务端发生了丢包，那么定时器到时候会进入回调函数tcp_write_timer中进行重传（其实不只是握手，连接状态的超时重传也是在这里完成的）</strong>。</p><blockquote><p>其实不只是握手，连接状态的超时重传也是在这里完成的</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tcp_write_timer</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">tcp_write_timer_handler</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">tcp_write_timer_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 取出定时器类型</span>    event <span class="token operator">=</span> icsk<span class="token operator">-></span>icsk_pending<span class="token punctuation">;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">case</span> ICSK_TIME_RETRANS<span class="token punctuation">:</span>           <span class="token comment" spellcheck="true">// 清除定时器</span>        <span class="token comment" spellcheck="true">// icsk_pending用于标记一个 TCP 连接当前有哪些定时器是激活状态，是一个位掩码，每一位都对应一个特定的定时器</span>        icsk<span class="token operator">-></span>icsk_pending <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token function">tcp_retransmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里tcp_transmit_timer是重传的主要函数。在这里<strong>完成重传以及下一次定时器到期的时间设置</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_retransmit_timer</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 超过了重传次数则退出</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_write_timeout</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 重传</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tcp_retransmit_skb（sk<span class="token punctuation">,</span> <span class="token function">tcp_write_queue_head</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 重传失败</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 退出前重新设置下一次的超时时间</span>out_reset_timer<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">// 计算超时时间</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    icsk<span class="token operator">-></span>icsk_rto <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>icsk<span class="token operator">-></span>icsk_rto <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 设置</span>    <span class="token function">inet_csk_reset_xmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">,</span> icsk<span class="token operator">-></span>icsk_rto<span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>tcp_write_timeout用来判断是否重试过多，如果是则退出重试逻辑</strong>。</p><blockquote><p>对于SYN握手包主要的判断依据是net.ipv4_tcp_syn_retries（内核参数，对于一个新建连接，内核要发送多少个SYN连接请求才决定放弃。不应该大于255,默认值是5），但其实并不是简单的对比次数，而是转化成了时间进行对比。所以如果在线上看到了实际重传次数和对应内核参数不一致也不用太奇怪。</p></blockquote><p>接着<strong>调用tcp_retransmit_skb函数重发了发送队列里的头元素</strong>。</p><p>最后再次<strong>设置下一次超时的时间，为前一次时间的两倍</strong>。</p><h5 id="4-实际抓包结果"><a href="#4-实际抓包结果" class="headerlink" title="4. 实际抓包结果"></a>4. 实际抓包结果</h5><p>客户端发出TCP第一次握手之后，在1秒以后进行了第一次握手重试。重试仍然没有响应，那么接下来一次又分别在3秒、7秒、15秒、31秒和63秒等事件共重试了六次（我的tcp_syn_retries设置为6）。</p><p>当服务端第一次握手的时候出现了半/全连接队列溢出导致的丢包，那么接口响应的时间将会很久（只进行一次重试都需要一秒的时间），用户体验会受到很大的影响。并且如果某一个时间段内有多个进程/线程卡在了和Redis或者MySQL的握手连接上，那么可能会导致线程池剩下的线程数量不足以处理服务。</p><h4 id="3）第三次握手丢包"><a href="#3）第三次握手丢包" class="headerlink" title="3）第三次握手丢包"></a>3）第三次握手丢包</h4><p>客户端在收到服务器的synack相应的时候，就认为连接建立成功了，然后会将自己的连接状态设置为ESTABLISHED，发出第三次握手请求。但服务端在第三次握手的时候还有可能有意外发生。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找listen socket的半连接队列</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>req <span class="token operator">=</span> <span class="token function">inet_csk_search_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> iph<span class="token operator">-></span>saddr<span class="token punctuation">,</span> iph<span class="token operator">-></span>daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">tcp_check_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_check_req</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建子socket</span>    child <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_af_ops<span class="token operator">-></span><span class="token function">syn_recv_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 清理半连接队列</span>    <span class="token function">inet_csk_reqsk_queue_unlink</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_csk_reqsk_queue_removed</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加全连接队列</span>    <span class="token function">inet_csk_reqsk_queue_add</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在第三次握手时，首先从半连接队列里拿到半连接对象，之后通过tcp_check_req =&gt; inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock来创建子socket</p><p>这里syn_recv_sock是一个函数指针，在ipv4中指向了tcp_v4_syn_recv_sock。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_syn_recv_sock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断全连接队列是不是满了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">goto</span> exit_overflow<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述代码可以看出，<strong>第三次握手的时候，如果服务器全连接队列满了，来自客户端的ack握手包又被直接丢弃</strong>。</p><p><strong>由于客户端在发起第三次握手之后就认为连接建立了，所以如果第三次握手失败，是由服务端来重发synack（服务端发送synack之后启动了定时器，并将该半连接对象保存在了半连接队列中）</strong>。服务端等到半连接定时器到时后，想客户端重新发起synack，客户端收到后再重新恢复第三次握手。如果这个期间服务端全连接队列一直都是满的，那么服务端重试5次（受内核参数net.ipv4.tcp_synack_retries控制）后就放弃了。</p><p>客户端在发起第三次握手之后往往就开始发送数据，其实这个时候连接还没有真的建立起来。<strong>如果第三次握手失败了，那么它发出去的数据，包括重试都将被服务端无视</strong>，知道连接真正建立成功后才行。</p><h4 id="4）握手异常总结"><a href="#4）握手异常总结" class="headerlink" title="4）握手异常总结"></a>4）握手异常总结</h4><ol><li>端口不足：导致connect系统调用的时候过多地执行自旋锁等待与哈希查找，会引起CPU开销上涨。严重的情况下会耗光CPU，影响用户逻辑的执行。<ol><li>调整ip_local_port_range来尽量加大端口范围</li><li>尽量复用连接，使用长连接来削减频繁的握手处理</li><li>开启tcp_tw_reuse和tcp_tw_recycle</li></ol></li><li>服务端在第一次握手丢包（半连接队列满且tcp_syncookies为0 || 全连接队列满且有未完成的半连接请求）：客户端不断发起syn重试</li><li>服务端在第三次握手丢包（全连接队列满）：服务端不断发起synack重试</li></ol><p>握手重试对服务端影响很大，常见的解决方法如下：</p><ol><li>打开syncookies：防止SYN Flood攻击等</li><li>加大连接队列长度：全连接是min(backlog，net.core.somaxconn)，半连接是min(backlog，somaxconn，tcp_max_syn_backlog) + 1向上取整到2的幂次（且不小于16）</li><li>尽快调用accept</li><li>尽早拒绝：例如MySQL和Redis等服务器的内核参数tcp_abort_on_overflow设置为1，如果队列满了直接reset指令发送给客户端，告诉其不要继续等待。这时候客户端会收到错误“connection reset by peer”</li><li>尽量减少TCP连接的次数</li></ol><h3 id="六、如何查看是否有连接队列溢出发生"><a href="#六、如何查看是否有连接队列溢出发生" class="headerlink" title="六、如何查看是否有连接队列溢出发生"></a>六、如何查看是否有连接队列溢出发生</h3><h4 id="1）全连接队列溢出判断"><a href="#1）全连接队列溢出判断" class="headerlink" title="1）全连接队列溢出判断"></a>1）全连接队列溢出判断</h4><p>全连接队列溢出都会记录到ListenOverflows这个MIB（管理信息库），对应SNMP统计信息中的ListenDrops这一项。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查看半连接队列是否满了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 在全连接队列满的情况下，如果有young_ack，那么直接丢弃</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inet_csk_reqsk_queue_young</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENOVERFLOWS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>drop<span class="token punctuation">:</span><span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENDROPS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_syn_recv_sock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断全连接队列是不是满了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">goto</span> exit_overflow<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>exit_overflow<span class="token punctuation">:</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENOVERFLOWS<span class="token punctuation">)</span><span class="token punctuation">;</span>exit<span class="token punctuation">:</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENDROPS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到服务端在响应第一次握手和第三次握手的时候，在全队列满了时都会调用<code>NET_INC_STATS_BH</code>来增加<code>LINUX_MIB_LISTENOVERFLOWS</code>和<code>LINUX_MIB_LISTENDROPS</code>这两个MIB。</p><p>在proc.c中，这两个MIB会被整合到SNMP统计信息。</p><p>在执行netstat-s的时候，该工具会读取SNMP统计信息并展现出来。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#watch 'netstat -s | grep overflowed'</span>    <span class="token number">198</span> times the listen queue of a socket overflowed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过netstat -s输出中的xx times the listen queue如果查看到数字有变化，则说明一定是服务端上发生了全连接队列溢出了。</p><h4 id="2）半连接队列溢出判断"><a href="#2）半连接队列溢出判断" class="headerlink" title="2）半连接队列溢出判断"></a>2）半连接队列溢出判断</h4><p>半连接队列溢出时更新的是LINUX_MIB_LISTENDROPS这个MIB，然而不只是半连接队列发生溢出的时候会增加该值，全连接队列满了该值也会增加。所以根据netstat -s查看半连接队列是否溢出是不靠谱的。</p><p>对于半连接队列是否溢出这个问题，一般直接看服务器tcp_syncookies是不是1就行了。如果该值是1，那么根本不会发生半连接溢出丢包。而如果不是1，则建议改为1。</p><p>如果因为其他原因不想打开，那么除了netstat -s，也可以同时查看listen端口上的SYN_RECV的数量，如果该数量达到了半连接队列的长度（根据内核参数和自己传递的backlog可以计算出来）则可以确定有半连接队列溢出。</p><h3 id="七、问题解答"><a href="#七、问题解答" class="headerlink" title="七、问题解答"></a>七、问题解答</h3><ol><li>为什么服务端程序都需要先listen一下<ul><li>内核在响应listen调用的时候创建了半连接、全连接两个队列，这两个队列是三次握手中很重要的数据结构，有了它吗才能正常响应客户端的三次握手。所以服务器提供服务前都需要先listen一下才行。</li></ul></li><li>半连接队列和全连接队列长度如何确定<ul><li>半连接队列：max((min(backlog, somaxconn, tcp_max_syn_backlog) + 1)向上取整到2的幂次), 16)</li><li>全连接队列：min(backlog, somaxconn)</li></ul></li><li>“Cannot assign requested address”这个报错是怎么回事<ul><li>一条TCP连接由一个四元组构成，其中目的IP和端口以及自身的IP都是在连接建立前确定了的，只有自身的端口需要动态选择出来。客户端会在connect发起的时候自动选择端口号。具体的选择就是随机地从ip_local_port_range选择一个位置开始循环判断，跳过ip_local_reserver_ports里设置的要避开的端口，然后挨个判断是否可用。如果循环完也没有找到可用端口，就会抛出这个错误。</li></ul></li><li>一个客户端端口可以同时用在两条连接上吗<ul><li>connect调用在选择端口的时候如果端口没有被用上那就是可用的，但是如果被用过也不代表这个端口就不可用。</li><li>如果用过，则会去判断是否有老的连接四元组与当前要建立的这个新连接四元组完全一致，如果不完全一致则该端口仍然可用。</li></ul></li><li>服务端半/全连接队列满了会怎么样<ul><li>服务端响应第一次握手的时候会进行半连接队列和全连接队列是否满的判断<ul><li>如果半连接队列满了且未开启tcp_syncookies，丢弃握手包</li><li>如果全连接队列满了且存在young_acck，丢弃握手包</li></ul></li><li>服务端响应第三次握手的时候会进行全连接队列是否满的判断<ul><li>如果全连接队列满了则丢弃握手包</li></ul></li></ul></li><li>新连接的soket内核对象是什么时候建立的<ul><li>内核其实在第三次握手完毕的时候就把sock对象创建好了。在用户进程调用accept的时候，直接把该对象取出来，再包装一个socket对象就返回了。</li></ul></li><li>建立一条TCP连接需要消耗多长时间<ul><li>一般网络的RTT值根据服务器物理距离的不同大约是在零点几秒、几十毫秒之间。这个时间要比CPU本地的系统调用耗时长得多。所以正常情况下，在客户端或者是服务端看来，都基本上约等于一个RTT。</li><li>如果一旦出现了丢包，无论是那种原因，需要重传定时器来接入的话，耗时就最少要一秒了。</li></ul></li><li>服务器负载很正常，但是CPU被打到底了时怎么回事<ul><li>如果在端口极其不充足的情况下，connect系统调用的内部循环需要全部执行完毕才能判断出来没有端口可用。如果要发出的连接请求特别频繁，connect就会消耗掉大量的CPU。如果要发出的连接请求特别频繁，connect就会消耗掉大量的CPU。当服务器上的进程不多，但是每个进程都在疯狂的消耗CPU，这时候就会出现CPU被消耗光，但是服务器负载却不高的情况。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、相关实际问题&quot;&gt;&lt;a href=&quot;#一、相关实际问题&quot; class=&quot;headerlink&quot; title=&quot;一、相关实际问题&quot;&gt;&lt;/a&gt;一、相关实际问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;为什么服务端程序都需要先listen一下&lt;/li&gt;
&lt;li&gt;半连接队列和全连接队
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(五)</title>
    <link href="https://joytsing.github.io/posts/36379/"/>
    <id>https://joytsing.github.io/posts/36379/</id>
    <published>2024-04-05T09:03:52.000Z</published>
    <updated>2024-04-07T12:51:38.095Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、相关实际问题"><a href="#一、相关实际问题" class="headerlink" title="一、相关实际问题"></a>一、相关实际问题</h3><ol><li>127.0.0.1本机网络IO需要经过网卡吗</li><li>数据包在内核中是什么走向，和外网发送相比流程上有什么差别</li><li>访问本机服务时，使用127.0.0.1能比本机IP（例如192.168.x.x）快吗</li></ol><h3 id="二、跨机网络通信过程"><a href="#二、跨机网络通信过程" class="headerlink" title="二、跨机网络通信过程"></a>二、跨机网络通信过程</h3><p>在开始讲述本机通信过程之前，先回顾前面的跨机网络通信。</p><h4 id="1）跨机数据发送"><a href="#1）跨机数据发送" class="headerlink" title="1）跨机数据发送"></a>1）跨机数据发送</h4><p><img src="/posts/36379/905c9a70079c41958e9b0bf745ed53af.png" alt></p><ol><li>应用层：send/sendto</li><li>系统调用：（send=&gt;）<strong>sendto</strong><ol><li><strong>构造msghdr并赋值</strong>（用户待发送数据的指针、数据长度、发送标志等）</li><li>sock_sendmsg =&gt; __sock_sendmsg_nosec =&gt; <strong>sock-&gt;ops-&gt;sendmsg</strong></li></ol></li><li>协议栈：<strong>inet_sendmsg</strong>（AF_INET协议族对socck-&gt;ops-&gt;sendmsg的实现）<ul><li>传输层<ol><li><strong>sk-&gt;sk_prot-&gt;sendmsg</strong></li><li><strong>tcp_sendmsg</strong>（tcp协议对sk-&gt;sk_prot-&gt;sendmsg的实现）：<strong>数据拷贝到发送队列的skb</strong></li><li><strong>tcp_write_xmit：拥塞控制、滑动窗口、包分段</strong></li><li><strong>tcp_transmit_skb：拷贝skb、封装TCP头、调用网络层发送</strong></li></ol></li><li>网络层<ol><li><strong>ip_queue_xmit：查找socket缓存的路由表，没有则查找路由项并缓存，为skb设置路由表，封装IP头并发送</strong></li><li>ip_local_out =&gt; __ip_local_out =&gt; nf_hook：<strong>netfilter过滤</strong></li><li>skb_dst(skb)-&gt;output(skb)：找到skb路由表的dst条目，调用output方法</li><li>ip_output：<strong>简单的统计，再次执行netfilter过滤</strong>，回调ip_finish_output</li><li>ip_finish_output：<strong>校验数据包的长度，如果大于MTU，就会执行分片</strong></li><li>ip_finish_output2：调用邻居子系统定义的方法</li></ol></li></ul></li><li>邻居子系统<ol><li>rt_nexthop：<strong>获取路由下一跳的IP信息</strong></li><li>__ipv4_neigh_lookup_noref：<strong>根据下一条IP信息在arp缓存中查找邻居项</strong></li><li>__neigh_create：<strong>创建一个邻居项，并加入邻居哈希表</strong></li><li>dst_neigh_output =&gt; neighbour-&gt;output（实际指向neigh_resolve_output）：<ol><li><strong>封装MAC头（可能会先触发arp请求）</strong></li><li>调用dev_queue_xmit发送到下层</li></ol></li></ol></li><li>网络设备子系统<ol><li><strong>dev_queue_xmit：选择发送队列，获得排队规则，存在队列则调用__dev_xmit_skb</strong></li><li>__dev_xmit_skb：根据qdisc状态执行不同逻辑</li><li>q-&gt;enqueue：<strong>入队</strong></li><li><strong>__qdisc_run：开始发送</strong></li><li><strong>qdisc_restart *<em>=&gt; sch_direct_xmit =&gt; *</em>dev_hard_start_xmit</strong>：<strong>从队列取出一个skb并发送</strong></li><li>dev-&gt;netdev_ops-&gt;ndo_start_xmit：调用驱动里的发送回调函数，将数据包传给网卡设备</li></ol></li><li>驱动程序：igb_xmit_frame<ol><li>igb_xmit_frame_ring：<strong>获取发送环形数组队列下一个可用的缓冲区，挂上skb</strong></li><li>igb_tx_map：<strong>获取下一个描述符指针，将skb数据映射到网卡可访问的内存DMA区域</strong></li></ol></li><li>硬件发送<ol><li><strong>发送完毕触发硬中断通知CPU</strong></li><li>igb_msix_ring =&gt; napi_schedule =&gt; __raise_softirq_irqoff：硬中断处理，发起软中断</li><li>net_rx_action =&gt; igb_poll：软中断处理</li><li>igb_clean_tx_irq：<strong>释放skb，清除tx_buffer，清理DMA</strong></li></ol></li></ol><h4 id="2）跨机数据接收"><a href="#2）跨机数据接收" class="headerlink" title="2）跨机数据接收"></a>2）跨机数据接收</h4><ol><li>硬件<ol><li>网卡把帧DMA到内存</li><li>发起硬中断通知CPU</li></ol></li><li>驱动程序<ol><li>igb_msix_ring =&gt; napi_schedule =&gt; __raise_softirq_irqoff：硬中断处理，发起软中断</li><li>net_rx_action =&gt; igb_poll：软中断处理</li><li>igb_clean_rx_irq：<strong>从RingBuffer取出数据包进行初步处理、检查完整性等，并将其封装为sk_buff添加到网络接收队列</strong></li></ol></li><li>网络设备子系统：netif_receive_skb<ol><li>__netif_receive_skb_core：<strong>遍历ptype_all链表处理数据包（tcp_dump抓包点），遍历ptype_base哈希表处理数据包</strong></li><li>deliver_skb：根据上述遍历到的协议，<strong>传递给对应协议处理函数进行进一步的处理</strong>。例如IP数据包（ptype_base中）则将其传递给IP协议处理模块。</li></ol></li><li>网络协议栈处理：pt_prev-&gt;func<ul><li>网络层<ol><li>ip_rcv：<strong>通过Netfilter进行进一步处理</strong>，比如网络地址转换(NAT)、防火墙过滤等操作</li><li>ip_rcv_finish =&gt; ip_local_deliver_finish：使用inet_protos<strong>拿到协议的函数地址，根据包中的协议类型选择分发</strong>。在这里skb包将会进一步被派送到更上层的协议中，UDP或TCP</li></ol></li><li>传输层<ol><li>tcp_v4_rcv：<strong>获取tcp头和ip头，拿到目的ip地址和端口，找到对应的socket</strong></li><li>tcp_v4_do_rcv =&gt; tcp_rcv_established：<strong>将接收到的数据放到socket的接收队列尾部</strong>，并<strong>调用sk_data_ready来唤醒在socket上等待的用户进程</strong></li><li>sock_def_readable =&gt;autoremove_wake_function =&gt; default_wake_function：唤醒进程</li></ol></li></ul></li><li>用户进程<ol><li>系统调用recv =&gt; sock_recvmsg ==&gt; __sock_recvmsg ==&gt; __sock_recvmsg_nosec</li><li>sock-&gt;ops-&gt;recvmsg：在AF_INET中其指向的是inet_recvmsg</li><li>inet_recvmsg =&gt; sk-&gt;sk_prot-&gt;recvmsg：在SOCK_STREAM中它的实现是tcp_recvmsg</li><li>tcp_recvmsg：<strong>遍历接收队列，如果数据量不满足则阻塞进程</strong></li><li>sk_wait_data：<strong>定义了一个等待队列项wait</strong>，在这个新的等待队列项上<strong>注册了回调函数autoremove_wake_function</strong>，并把<strong>当前进程描述符current关联到其.private成员上，让出cpu进入睡眠</strong></li><li>睡眠===</li><li><strong>唤醒后继续遍历队列接收数据</strong></li></ol></li></ol><h4 id="3）跨机网络通信汇总"><a href="#3）跨机网络通信汇总" class="headerlink" title="3）跨机网络通信汇总"></a>3）跨机网络通信汇总</h4><p><img src="/posts/36379/371fb77993524d25960f79688ee38136.png" alt></p><h3 id="三、本机发送过程"><a href="#三、本机发送过程" class="headerlink" title="三、本机发送过程"></a>三、本机发送过程</h3><p>上面主要介绍了跨机时整个网络的发送过程， 而在本机网络IO过程中，会有一些差别。主要的差异有两部分，分别是路由和驱动程序。</p><h4 id="1）网络层路由"><a href="#1）网络层路由" class="headerlink" title="1）网络层路由"></a>1）网络层路由</h4><p><img src="/posts/36379/b6ad411f22094f07ad1c3b4739525ee4.png" alt></p><p>发送数据进入协议栈到达网络层的时候，网络层入口函数是ip_queue_xmit。在网络层里会进行路由选择，路由选择完毕再设置一些IP头，进行一些Netfilter的过滤，数据包分片等操作，然后将包交给邻居子系统。</p><p>对于本机网络IO来说，特殊之处在于<strong>在local路由表中就可以找到路由项，对应的设备都是用loopback网卡，也就是常说的lo设备</strong>。</p><p>我们重新回到之前网络层查找路由项的部分代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ip_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> flowi <span class="token operator">*</span>fl<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 检查socket中是否有缓存的路由表</span>    rt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> rtable<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">__sk_dst_check</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>rt <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 没有缓存则展开查找路由项并缓存到socket中</span>    rt <span class="token operator">=</span> <span class="token function">ip_route_output_ports</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">sk_setup_caps</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-></span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1234567891011</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查找路由项的函数时ip_route_output_ports，它经过层层调用，来到关键的部分——fib_lookup</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">fib_lookup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> flowi4 <span class="token operator">*</span>flp<span class="token punctuation">,</span> <span class="token keyword">struct</span> fib_result <span class="token operator">*</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> fib_table <span class="token operator">*</span>table<span class="token punctuation">;</span>    table <span class="token operator">=</span> <span class="token function">fib_get_table</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> RT_TABLE_LOCAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">fib_table_lookup</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> flp<span class="token punctuation">,</span> res<span class="token punctuation">,</span> FIB_LOOKUP_NOREF<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 查找与给定流（由flp指定）匹配的路由项，并将查找结果存储在res中。FIB_LOOKUP_NOREF是传递给此函数的标志，用于指定查找行为的一些细节。</span>    <span class="token comment" spellcheck="true">// 查找成功返回0</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> <span class="token function">fib_get_table</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> RT_TABLE_MAIN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">fib_table_lookup</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> flp<span class="token punctuation">,</span> res<span class="token punctuation">,</span> FIB_LOOKUP_NOREF<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span>ENETUNREACH<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">12345678910111213</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在fib_lookup中将<strong>会对local和main两个路由表展开查询，并且先查询local后查询main</strong>。我们在Linux上使用ip命令可以查看到这两个路由表，这里只看local路由表（因为本机网络IO查询到整个表就结束了）</p><pre class="line-numbers language-cmd"><code class="language-cmd">#ip route list table locallocal 10.143.x.y dev eth0 proto kernel scope host src 10.143.x.ylocal 127.0.0.1 dev lo proto kernel host src 127.0.0.1123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从上述结果可以看出127.0.0.1的路由在local路由表中就能够找到。</p><blockquote><p>上面路由表中10.143.x.y dev eth0是本机的局域网IP，虽然写的是dev eth0，但是其实内核在初始化local路由表的时候，把local路由表里所有的路由项都设置为了RTN_LOCAL。所以即使本机IP不用环回地址，内核在路由项查找的时候判断类型是RTN_LOCAL，仍然会使用net-&gt;loopback_dev，也就是lo虚拟网卡。</p><p>此处可以使用tcpdump -i eht0 port 8888以及telnet 10.143.x.y 8888进行验证，telnet后tcpdump并不会收到网络请求，因为发给的是lo。</p></blockquote><p>之后fib_lookup的工作完成，返回上一层__ip_route_output_key函数继续执行。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> rtable <span class="token operator">*</span><span class="token function">ip_route_output_key</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> flowi4 <span class="token operator">*</span>fl4<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fib_lookup</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> fl4<span class="token punctuation">,</span> <span class="token operator">&amp;</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>type <span class="token operator">==</span> RTN_LOCAL<span class="token punctuation">)</span> <span class="token punctuation">{</span>      dev_out <span class="token operator">=</span> net<span class="token operator">-></span>loopback_dev<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token number">12345678910</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对于本机的网络请求，设备将全部使用net-&gt;loopback_dev，也就是lo虚拟网卡。接下来的网络层仍然和跨机网络IO一样（所以本机网络IO如果skb大于MTU仍然会进行分片，不过lo虚拟网卡(65535)的MTU(1500)比Ethernet大得多），最终会经过ip_finish_output，进入邻居子系统的入口函数dst_neigh_output</strong>。</p><p>在邻居子系统函数中经过处理后，进入网络设备子系统（入口函数是dev_queue_xmit）</p><h4 id="2）网络设备子系统"><a href="#2）网络设备子系统" class="headerlink" title="2）网络设备子系统"></a>2）网络设备子系统</h4><p>网络设备子系统的入口函数是dev_queue_xmit，其中会<strong>判断是否有队列</strong>。<strong>对于有队列的物理设备，该函数进行了一系列复杂的排队等处理后，才调用dev_hard_start_xmit，从这个函数在进入驱动程序igb_xmit_frame来发送</strong>。在这个过程中还可能触发软中断进行发送。</p><p>但是<strong>对于启动状态的回环设备</strong>（q-&gt;enqueue判断为false）来说就简单多了，它<strong>没有队列的问题，直接进入dev_hard_start_xmit</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dev_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    q <span class="token operator">=</span> <span class="token function">rcu_dereference_bh</span><span class="token punctuation">(</span>txq_qdisc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">-></span>enqueue<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 回环设备这里返回false</span>      rc <span class="token operator">=</span> <span class="token function">__dev_xmit_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 开始回环设备处理</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>dev<span class="token operator">-></span>flags <span class="token operator">&amp;</span> IFF_UP<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">12345678910111213</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在dev_hard_start_xmit函数中还将调用设备驱动的操作函数，对<strong>于回环设备的而言，其“设备驱动”的操作函数ops-&gt;ndo_start_xmit指向的是loopback_xmit</strong>（不同于正常网络设备的igb_xmit_frame）。</p><p><img src="/posts/36379/031af9965aea406c88692f7ca8c55793.png" alt></p><p><img src="/posts/36379/dd2484c6c34746579ffd367efb80eec7.png" alt></p><h4 id="3）驱动程序"><a href="#3）驱动程序" class="headerlink" title="3）驱动程序"></a>3）驱动程序</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> netdev_tx_t <span class="token function">loopback_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> net_device <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 剥离掉和源socket的联系</span>    <span class="token function">skb_orphan</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用netif_rx</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">netif_rx</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span> <span class="token operator">==</span> NET_RX_SUCCESS<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>loopback_xmit中首先调用skb_orphan先把skb上的socket指针去掉了，接着调用netif_tx，在该方法中最终会执行到enqueue_to_backlog。</strong></p><blockquote><p>在本机IO发送的过程中，传输层下面的skb就不需要释放了，直接给接收方传过去就行。不过传输层的skb就节约不了，还是需要频繁地申请和释放。</p></blockquote><p><img src="/posts/36379/2c95c6ac11f046adab03100275efee3e.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">enqueue_to_backlog</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">int</span> cpu<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>qtail<span class="token punctuation">)</span><span class="token punctuation">{</span>    sd <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>softnet_data<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">__skb_queue_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>input_pkt_queue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">__napi_schedule</span><span class="token punctuation">(</span>sd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sd<span class="token operator">-></span>backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">12345678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>enqueue_to_backlog函数用于<strong>把要发送的skb插入softnet_data-&gt;input_pkt_queue队列</strong></p><p>具体步骤如下：</p><ol><li>sd = &amp;per_cpu(softnet_data, cpu)：获取给定 CPU 的softnet_data结构。这个结构保存了这个 CPU 的一些网络处理状态和数据，比如input_pkt_queue。</li><li>__skb_queue_tail(&amp;sd-&gt;input_pkt_queue, skb)：将数据包skb加入到input_pkt_queue队列的尾部。</li><li>__napi_schedule(sd, &amp;sd-&gt;backlog)：调度该函数来触发软中断处理这个队列。</li></ol><p>这里<strong>触发的软中断类型是NET_RX_SOFTIRQ</strong>，只有触发完软中断，发送过程才算完成了。</p><h3 id="四、本机接收过程"><a href="#四、本机接收过程" class="headerlink" title="四、本机接收过程"></a>四、本机接收过程</h3><p>发送过程触发软中断后，会进入软中断处理函数net_rx_action。</p><p><img src="/posts/36379/28e7da137a7845cbaab82ba100861be8.png" alt></p><p><strong>在跨机地网络包地接收过程中，需要经过硬中断，然后才能触发软中断。而在本机地网络IO过程中，由于并不真的过网卡，所以网卡地发送过程、硬中断就都省去了，直接从软中断开始。</strong></p><p>对于igb网卡来说，软中断中轮询调用的poll函数指向的是igb_poll函数。而对于loopback网卡来说，poll函数是process_backlog。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process_backlog</span><span class="token punctuation">(</span><span class="token keyword">struct</span> napi_struct <span class="token operator">*</span>napi<span class="token punctuation">,</span> <span class="token keyword">int</span> quota<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>skb <span class="token operator">=</span> <span class="token function">__skb_dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>process_queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">__netif_receive_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// skb_queue_splice_tail_init()函数用来将链表a(输入队列)的元素链接到链表b(处理队列)上</span>     <span class="token comment" spellcheck="true">// 形成一个新的链表b，并将原来a的头变成了空链表</span>     qlen <span class="token operator">=</span> <span class="token function">skb_queue_len</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>input_pkt_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>qlen<span class="token punctuation">)</span>        <span class="token function">skb_queue_splice_tail_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>input_pkt_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sd<span class="token operator">-></span>process_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1234567891011121314</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数用于反复处理队列中的数据包，直到队列为空或者处理的数据包数量达到了指定的配额（quota）。</p><p>在内层循环中，它使用 __skb_dequeue() 函数<strong>从 process_queue 中取出一个数据包，然后使用 __netif_receive_skb() 函数处理这个数据包</strong>。</p><p>在内层循环结束后，它<strong>检查 input_pkt_queue（输入数据包队列）是否还有剩余的数据包</strong>。如果有，它<strong>使用 skb_queue_splice_tail_init() 函数将 input_pkt_queue 中的数据包移动到 process_queue 中</strong>，然后在下一次内层循环中继续处理这些数据包。</p><p><strong>__netif_receive_skb用于将数据送往协议栈，在此之后的调用过程就和跨机网络的IO又一致了</strong>：__netif_receive_skb =&gt; __netif_receive_skb_core =&gt; deliver_skb，然后再将数据送入ip_rcv中进行后续操作。</p><p><img src="/posts/36379/e492262233c94d3ca37656becc5f263b.png" alt></p><h3 id="五、问题解答"><a href="#五、问题解答" class="headerlink" title="五、问题解答"></a>五、问题解答</h3><ol><li>127.0.0.1本机网络IO需要经过网卡吗<ul><li>不需要经过网卡，即使网卡拔了也可以正常使用本机网络</li></ul></li><li>数据包在内核中是什么走向，和外网发送相比流程上有什么差别<ul><li>节约了驱动上的一些开销。发送数据不需要静茹RingBuffer的驱动队列，直接把skb传给接收协议栈。</li><li>其他组件，包括系统调用、协议栈、设备子系统都经过了，甚至驱动程序也运行了，所以还是有一定的开销的。</li><li>如果想要再本机网络IO上绕开协议栈的开销，可以动用eBPF，用eBPF的sockmap和sk redirect可以达到真正不走协议栈的目的。</li></ul></li><li>访问本机服务时，使用127.0.0.1能比本机IP（例如192.168.x.x）快吗<ul><li>本机IP和127.0.0.1没有差别，都是走的环回设备lo</li><li>这是因为内核在设置IP的时候，把所有的本机IP都初始化到了local路由表里，类型写死了是RTN_LOCAL。所以后面的路由项选择的时候发现类型是RTN_LOCAL就会选择lo设备。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、相关实际问题&quot;&gt;&lt;a href=&quot;#一、相关实际问题&quot; class=&quot;headerlink&quot; title=&quot;一、相关实际问题&quot;&gt;&lt;/a&gt;一、相关实际问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;127.0.0.1本机网络IO需要经过网卡吗&lt;/li&gt;
&lt;li&gt;数据包在内核中是
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的零拷贝技术</title>
    <link href="https://joytsing.github.io/posts/44422/"/>
    <id>https://joytsing.github.io/posts/44422/</id>
    <published>2024-04-02T09:16:35.000Z</published>
    <updated>2024-04-02T08:38:48.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>零拷贝技术是一种<code>IO</code>操作优化技术。可以快速高效地将数据从文件系统移动到网络接口，<strong>而不需要将其从内核空间复制到用户空间。</strong></p><h2 id="一-相关概念"><a href="#一-相关概念" class="headerlink" title="一. 相关概念"></a>一. 相关概念</h2><p>用户进行<code>IO</code>操作，其实也就是应用程序访问系统资源，即通过系统调用 或者中断（外中断、内中断）<strong>从而使得 <code>CPU</code> 从用户态转向内核态。</strong></p><p>系统调用其实就是一些函数，用于对文件和设备进行访问和控制。最常见的有两种：</p><ul><li><code>read</code>：从文件中读取内容。</li><li><code>write</code>：往文件中写入内容。</li></ul><h3 id="1-1-缓冲区"><a href="#1-1-缓冲区" class="headerlink" title="1.1 缓冲区"></a>1.1 缓冲区</h3><p>在复习<code>IO</code>模型相关的知识的时候，就遇到这么两个概念：</p><ul><li><strong>内核缓冲区。</strong></li><li><strong>用户缓冲区。</strong></li></ul><p>这个到底有什么区别呢？我们知道，我们的应用程序从磁盘上读取数据的时候，一般都是分成两步：</p><ol><li><strong>操作系统（内核）从磁盘上读取数据存到内核空间。</strong></li><li><strong>再把数据从内核空间拷贝到用户空间。</strong></li></ol><p>那么这个过程中就会涉及到<strong>两次</strong>数据读操作：</p><ol><li>从<strong>磁盘</strong>上读取。</li><li>从<strong>内存</strong>中读取。</li></ol><p>而<strong>访问磁盘的速度要远远小于访问内存的速度</strong>，那么整个读取数据的操作中耗费时长最长的阶段自然在磁盘读取上。因此出现了内核缓冲区以及对应的用户缓冲区。至于具体流程可以看另外几篇博文。</p><h4 id="1-1-1-内核缓冲区"><a href="#1-1-1-内核缓冲区" class="headerlink" title="1.1.1 内核缓冲区"></a>1.1.1 内核缓冲区</h4><p>内核缓冲区，其实可以从两个方向去理解：</p><ul><li><strong>缓冲</strong>：<code>Buffer</code>。</li><li><strong>缓存</strong>：<code>Cache</code>。</li></ul><p>它的作用如下：</p><ul><li><strong>数据预读（缓存功能）</strong>：当程序发起<code>read</code>系统调用的时候，<strong>内核会读更多磁盘上的数据，以备程序后续使用</strong>。（假设我的<code>read</code>请求可能只需要读<code>100KB</code>的数据，那么此时内核会读<code>200KB</code>，就是这个意思。）</li><li><strong>延时回写（缓冲功能）</strong>：当程序发起 <code>write</code> 系统调用时，<strong>内核并不会直接把数据写入到磁盘文件中，而是写入到缓冲区中。当缓冲区中的数据积累到一定程度，才将数据真正地刷新到磁盘中。</strong></li></ul><h4 id="1-1-2-用户缓冲区"><a href="#1-1-2-用户缓冲区" class="headerlink" title="1.1.2 用户缓冲区"></a>1.1.2 用户缓冲区</h4><p>用户缓冲区的作用和内核缓冲区一样，都是数据的预读以及延时回写。不过两者出现的目的还是不一样：</p><ul><li>内核缓冲区：主要处理的是内核空间和磁盘之间的数据传递，<strong>目的是减少访问磁盘的次数。</strong></li><li>用户缓冲区：主要处理的是用户空间和内核空间之间的数据传递，<strong>目的是减少系统调用的次数。</strong></li></ul><h3 id="1-2-DMA技术"><a href="#1-2-DMA技术" class="headerlink" title="1.2 DMA技术"></a>1.2 DMA技术</h3><p><code>DMA</code>的全称：<code>Direct Memory Access</code>，直接存储器访问。<code>DMA</code>传输<strong>将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。</strong></p><p>为什么要有<code>DMA</code>技术？我们来看下<code>IO</code>操作的前后流程对比：<br><img src="/posts/44422/929e089c44174984a067f1b11008629f.png" alt><br>总结就是：<strong><code>DMA</code>帮助<code>CPU</code>将数据从磁盘拷贝至内核缓冲区中，让<code>CPU</code>解放双手。</strong></p><h3 id="1-3-虚拟内存"><a href="#1-3-虚拟内存" class="headerlink" title="1.3 虚拟内存"></a>1.3 虚拟内存</h3><p>虚拟内存：<strong>即拿出一部分硬盘空间来充当内存使用</strong>，当内存占用完时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。一般虚拟内存都用来替代一部分物理内存的，有这么几个好处：</p><ol><li>多个虚拟内存可以指向同一个物理地址（<strong>多对一</strong>）。</li><li>虚拟内存空间可以远远大于物理内存空间（<strong>空间大</strong>）。</li></ol><h2 id="二-零拷贝"><a href="#二-零拷贝" class="headerlink" title="二. 零拷贝"></a>二. 零拷贝</h2><h3 id="2-1-传统文件传输流程"><a href="#2-1-传统文件传输流程" class="headerlink" title="2.1 传统文件传输流程"></a>2.1 传统文件传输流程</h3><p>我们用一个最基本的文件读取操作来看下流程，无非分为两个步骤：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">read</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> tmp_buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> tmp_buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>将磁盘上的文件读取出来。</li><li>将文件数据通过网络协议发送给客户端。</li></ol><p>流程图如下：</p><p><img src="/posts/44422/1.png" alt></p><p>这里能得到几个信息：</p><ol><li>期间完成了<strong>4次</strong>数据拷贝。</li><li>完成了<strong>4次</strong>的用户态和内核态之间的状态切换，我们简称上下文切换。</li></ol><p><strong>备注：每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。因此相当于2次上下文切换。</strong>问题就是：再这样的传统<code>IO</code>传输模型中，用户为了获取服务器上的某个数据，期间竟然有4次数据的搬运过程，<strong>而过多的数据拷贝会消耗CPU资源，在高并发的情况下更是大大降低了系统的性能。</strong></p><p><strong>如何减少用户态和内核态之间的上下文切换以及内存拷贝的次数”</strong> 成了提高文件传输性能的一个关键点。</p><h3 id="2-2-零拷贝技术原理"><a href="#2-2-零拷贝技术原理" class="headerlink" title="2.2 零拷贝技术原理"></a>2.2 零拷贝技术原理</h3><p>还记得上文提到的虚拟内存的概念吗？零拷贝技术中就用到了虚拟内存可以多对一的一个特性：<strong>将内核空间和用户空间的虚拟地址映射到同一个物理地址，这样在 I/O 操作时就不需要来回复制了。</strong></p><p>零拷贝实现的方式有多种：</p><ul><li><code>mmap + write</code></li><li><code>sendfile</code></li><li><code>sendfile+DMA收集</code></li><li><code>splice</code></li></ul><h4 id="2-2-1-mmap-write"><a href="#2-2-1-mmap-write" class="headerlink" title="2.2.1 mmap+ write"></a>2.2.1 mmap+ write</h4><p><code>mmap()</code>函数也是属于系统函数的一种，在 2.1 节当中，我们知道<code>read()</code>函数<strong>会把内核缓冲区的数据拷贝到用户的缓冲区里。</strong> 而<code>mmap()</code>函数就可以减少这一步开销，因为它会<strong>直接把内核缓冲区里的数据映射到用户空间。</strong>那么这种模式下，文件传输模型图就会有所改变：</p><p><img src="/posts/44422/795ab30d4d2d4ce6a807f2ca4ffc12df.png" alt></p><p><strong>具体过程如下：</strong></p><ul><li>应用进程调用了 mmap() 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li><li>应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li><li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul><p>可以看到：</p><ol><li>虽然说拷贝过程从原来的4次—-&gt;3次。</li><li>但是系统调用依旧是2次。原本：<code>read + write</code>。现在：<code>mmap + write</code>。</li></ol><h4 id="2-2-2-sendfile-amp-amp-sendfile-DMA收集"><a href="#2-2-2-sendfile-amp-amp-sendfile-DMA收集" class="headerlink" title="2.2.2 sendfile&amp;&amp;sendfile+DMA收集"></a>2.2.2 sendfile&amp;&amp;sendfile+DMA收集</h4><p><code>sendfile()</code>是一个专门发送文件的系统调用函数，由于 sendfile 仅仅对应一次系统调用，而传统文件操作则需要使用 read 以及 write 两个系统调用。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span>ssize_t <span class="token function">sendfile</span><span class="token punctuation">(</span><span class="token keyword">int</span> out_fd<span class="token punctuation">,</span> <span class="token keyword">int</span> in_fd<span class="token punctuation">,</span> off_t <span class="token operator">*</span>offset<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>out_fd</code>：目的端的文件描述符。</li><li><code>in_fd</code>：源端文件描述符。</li><li><code>offset</code>：源端数据偏移量。</li><li><code>count</code>：复制数据的长度。</li></ul><p>最终的返回是实际复制数据的长度。该函数的作用主要有两点：</p><ol><li>可以同时替代<code>read(</code>)和<code>write()</code>函数。<strong>即可以减少一次系统调用。</strong></li><li>通过<code>SG-DMA</code>控制器减少数据拷贝的次数。</li></ol><p>这个<code>SG</code>的前缀是什么意思呢？</p><blockquote><p><code>SG：scatter-gather</code>。其原理就是在内核空间 <code>Read Buffer</code> 和 <code>Socket Buffer</code> <strong>不做数据复制，而是将 <code>Read Buffer</code> 的内存地址、偏移量记录到相应的 <code>Socket Buffer</code> 中</strong>，这样就不需要复制。其本质和虚拟内存的解决方法思路一致，就是内存地址的记录。</p></blockquote><p>流程如下：</p><ol><li>通过 <code>DMA</code> 将磁盘上的数据拷贝到内核缓冲区里。</li><li>将缓冲区描述符和数据长度传到 <code>socket</code> 缓冲区，<strong><code>SG-DMA</code>控制器直接将内核缓存中的数据拷贝到网卡的缓冲区里，</strong> 因此不需要将内核缓冲区的数据拷贝到<code>socket</code>缓冲区中。</li></ol><p>如图：</p><p><img src="/posts/44422/cfd077077e0145938fa085f78daad0a5.png" alt></p><p>这就是零拷贝技术。即没有再内存层面去拷贝数据，整个过程中<code>CPU</code>都没有参与数据的拷贝，都是交给<code>DMA</code>来完成。</p><p>相对于传统的文件传输方式，零拷贝的优势：</p><ol><li>减少了2次上下文切换和数据拷贝。</li><li>2次的数据拷贝过程中，无需<code>CPU</code>参与，因此<code>CPU</code>可以在此期间做其他事情。</li></ol><p><strong>注意：零拷贝并不是说数据传输过程中拷贝的次数为0，而是指不存在内存层面的数据拷贝（一共2次）。</strong>因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</p><h4 id="2-2-3-splice方式"><a href="#2-2-3-splice方式" class="headerlink" title="2.2.3 splice方式"></a>2.2.3 splice方式</h4><p>splice系统调用是Linux 在 2.6 版本引入的，其不需要硬件支持，并且不再限定于socket上，实现两个普通文件之间的数据零拷贝。</p><p><code>splice</code> 调用和<code>sendfile</code> 非常相似，用户应用程序必须拥有两个已经打开的文件描述符，一个表示输入设备，一个表示输出设备。与<code>sendfile</code>不同的是，<code>splice</code>允许任意两个文件互相连接，而并不只是文件与<code>socket</code>进行数据传输。对于从一个文件描述符发送数据到<code>socket</code>这种特例来说，一直都是使用<code>sendfile</code>系统调用，而<code>splice</code>一直以来就只是一种机制，它并不仅限于<code>sendfile</code>的功能。也就是说 sendfile 是 splice 的一个子集。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>无论是传统的 I/O 方式，还是引入了零拷贝之后，2 次 <code>DMA copy</code>是都少不了的。因为两次 DMA 都是依赖硬件完成的。所以，所谓的零拷贝，都是为了减少 CPU copy 及减少了上下文的切换。</p><p>下图展示了各种零拷贝技术的对比图：</p><table><thead><tr><th></th><th>CPU拷贝</th><th>DMA拷贝</th><th>系统调用</th><th>上下文切换</th></tr></thead><tbody><tr><td>传统方法</td><td>2</td><td>2</td><td>read/write</td><td>4</td></tr><tr><td>内存映射</td><td>1</td><td>2</td><td>mmap/write</td><td>4</td></tr><tr><td>sendfile</td><td>1</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>scatter/gather copy</td><td>0</td><td>2</td><td>sendfile</td><td>2</td></tr><tr><td>splice</td><td>0</td><td>2</td><td>splice</td><td>0</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;零拷贝技术是一种&lt;code&gt;IO&lt;/code&gt;操作优化技术。可以快速高效地将数据从文件系统移动到网络接口，&lt;strong&gt;而不需要将其从内核
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/categories/Linux/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>当Redis碰上消息队列</title>
    <link href="https://joytsing.github.io/posts/24283/"/>
    <id>https://joytsing.github.io/posts/24283/</id>
    <published>2024-04-02T09:03:55.000Z</published>
    <updated>2024-04-07T12:54:29.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一开始在不熟悉的时候当我听到Redis可以当消息队列来用是很奇怪的，后面了解才知道与专业的队列中间件相比各有优劣。</p><h2 id="List队列"><a href="#List队列" class="headerlink" title="List队列"></a>List队列</h2><p>如果你的业务需求足够简单，想把 Redis 当作队列来使用，肯定最先想到的就是使用 List 这个数据类型。因为 List 底层的实现就是一个「链表」，在头部和尾部操作元素，时间复杂度都是 O(1)，这意味着它非常符合消息队列的模型。如果把 List 当作队列，你可以这么来用。</p><p>生产者使用 LPUSH 发布消息：</p><pre class="line-numbers language-sh"><code class="language-sh">127.0.0.1:6379> LPUSH queue msg1(integer) 1127.0.0.1:6379> LPUSH queue msg2(integer) 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>消费者这一侧，使用 RPOP 拉取消息：</p><pre class="line-numbers language-sh"><code class="language-sh">127.0.0.1:6379> RPOP queue"msg1"127.0.0.1:6379> RPOP queue"msg2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个模型非常简单，也很容易理解。</p><p><img src="/posts/24283/640.webp" alt></p><p>但这里有个小问题，当队列中已经没有消息了，消费者在执行 RPOP 时，会返回 NULL。</p><pre class="line-numbers language-sh"><code class="language-sh">127.0.0.1:6379> RPOP queue(nil)   // 没消息了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而我们在编写消费者逻辑时，一般是一个「死循环」，这个逻辑需要不断地从队列中拉取消息进行处理，伪代码一般会这么写：</p><pre class="line-numbers language-sh"><code class="language-sh">while true:    msg = redis.rpop("queue")    // 没有消息，继续循环    if msg == null:        continue    // 处理消息    handle(msg)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果此时队列为空，那消费者依旧会频繁拉取消息，这会造成「CPU 空转」，不仅浪费 CPU 资源，还会对 Redis 造成压力。Redis 是否存在这样一种机制：如果队列为空，消费者在拉取消息时就「阻塞等待」，一旦有新消息过来，就通知我的消费者立即处理新消息呢？Redis 提供了「阻塞式」拉取消息的命令：BRPOP / BLPOP，这里的 B 指的是阻塞（Block）。</p><p><img src="/posts/24283/640-1711972064075-3.webp" alt></p><p>现在，你可以这样来拉取消息了：</p><pre class="line-numbers language-sh"><code class="language-sh">while true:    // 没消息阻塞等待，0表示不设置超时时间    msg = redis.brpop("queue", 0)    if msg == null:        continue    // 处理消息    handle(msg)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 BRPOP 这种阻塞式方式拉取消息时，还支持传入一个「超时时间」，如果设置为 0，则表示不设置超时，直到有新消息才返回，否则会在指定的超时时间后返回 NULL。这个方案不错，既兼顾了效率，还避免了 CPU 空转问题，一举两得。</p><blockquote><p>注意：如果设置的超时时间太长，这个连接太久没有活跃过，可能会被 Redis Server 判定为无效连接，之后 Redis Server 会强制把这个客户端踢下线。所以，采用这种方案，客户端要有重连机制。</p></blockquote><p>解决了消息处理不及时的问题，你可以再思考一下，这种队列模型，有什么缺点？我们一起来分析一下：</p><ol><li><strong>不支持重复消费</strong>：消费者拉取消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费，即不支持多个消费者消费同一批数据</li><li><strong>消息丢失</strong>：消费者拉取到消息后，如果发生异常宕机，那这条消息就丢失了</li></ol><p>第一个问题是功能上的，使用 List 做消息队列，它仅仅支持最简单的，一组生产者对应一组消费者，不能满足多组生产者和消费者的业务场景。</p><p>第二个问题就比较棘手了，因为从 List 中 POP 一条消息出来后，这条消息就会立即从链表中删除了。也就是说，无论消费者是否处理成功，这条消息都没办法再次消费了。</p><p>这也意味着，如果消费者在处理消息时异常宕机，那这条消息就相当于丢失了。针对这 2 个问题怎么解决呢？我们一个个来看。</p><h2 id="发布-订阅模型：Pub-Sub"><a href="#发布-订阅模型：Pub-Sub" class="headerlink" title="发布/订阅模型：Pub/Sub"></a>发布/订阅模型：Pub/Sub</h2><p>从名字就能看出来，这个模块是 Redis 专门是针对「发布/订阅」这种队列模型设计的。它正好可以解决前面提到的第一个问题：重复消费。即多组生产者、消费者的场景，我们来看它是如何做的：</p><p>Redis 提供了 PUBLISH / SUBSCRIBE 命令，来完成发布、订阅的操作。</p><p><img src="/posts/24283/640-1711972384594-6.webp" alt></p><p>假设你想开启 2 个消费者，同时消费同一批数据，就可以按照以下方式来实现。</p><p>首先，使用 SUBSCRIBE 命令，启动 2 个消费者，并「订阅」同一个队列。</p><pre><code>// 2个消费者 都订阅一个队列127.0.0.1:6379&gt; SUBSCRIBE queueReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;queue&quot;3) (integer) 1</code></pre><p>此时，2 个消费者都会被阻塞住，等待新消息的到来。之后，再启动一个生产者，发布一条消息。</p><pre><code>127.0.0.1:6379&gt; PUBLISH queue msg1(integer) 1</code></pre><p>这时，2 个消费者就会解除阻塞，收到生产者发来的新消息。</p><pre><code>127.0.0.1:6379&gt; SUBSCRIBE queue// 收到新消息1) &quot;message&quot;2) &quot;queue&quot;3) &quot;msg1&quot;</code></pre><p>看到了么，使用 Pub/Sub 这种方案，既支持阻塞式拉取消息，还很好地满足了多组消费者，消费同一批数据的业务需求。除此之外，Pub/Sub 还提供了「匹配订阅」模式，允许消费者根据一定规则，订阅「多个」自己感兴趣的队列。</p><pre><code>// 订阅符合规则的队列127.0.0.1:6379&gt; PSUBSCRIBE queue.*Reading messages... (press Ctrl-C to quit)1) &quot;psubscribe&quot;2) &quot;queue.*&quot;3) (integer) 1</code></pre><p>这里的消费者，订阅了 queue.* 相关的队列消息。之后，生产者分别向 queue.p1 和 queue.p2 发布消息。</p><pre><code>127.0.0.1:6379&gt; PUBLISH queue.p1 msg1(integer) 1127.0.0.1:6379&gt; PUBLISH queue.p2 msg2(integer) 1</code></pre><p>这时再看消费者，它就可以接收到这 2 个生产者的消息了。</p><pre><code>127.0.0.1:6379&gt; PSUBSCRIBE queue.*Reading messages... (press Ctrl-C to quit)...// 来自queue.p1的消息1) &quot;pmessage&quot;2) &quot;queue.*&quot;3) &quot;queue.p1&quot;4) &quot;msg1&quot;// 来自queue.p2的消息1) &quot;pmessage&quot;2) &quot;queue.*&quot;3) &quot;queue.p2&quot;4) &quot;msg2&quot;</code></pre><p><img src="/posts/24283/640-1711972490726-9.webp" alt></p><p>我们可以看到，Pub/Sub 最大的优势就是，支持多组生产者、消费者处理消息。讲完了它的优点，那它有什么缺点呢？Pub/Sub 最大问题是：<strong>丢数据</strong>。如果发生以下场景，就有可能导致数据丢失：</p><ol><li>消费者下线</li><li>Redis 宕机</li><li>消息堆积</li></ol><p>这与 Pub/Sub 的实现方式有很大关系。Pub/Sub 在实现时非常简单，它没有基于任何数据类型，也没有做任何的数据存储，它只是单纯地为生产者、消费者建立「数据转发通道」，把符合规则的数据，从一端转发到另一端，一个完整的发布、订阅消息处理流程是这样的：</p><ol><li>消费者订阅指定队列，Redis 就会记录一个映射关系：队列-&gt;消费者</li><li>生产者向这个队列发布消息，那 Redis 就从映射关系中找出对应的消费者，把消息转发给它</li></ol><p><img src="/posts/24283/640-1711972524653-12.webp" alt></p><p>整个过程中，没有任何的数据存储，一切都是实时转发的。这种设计方案，就导致了上面提到的那些问题。例如，如果一个消费者异常挂掉了，它再重新上线后，只能接收新的消息，在下线期间生产者发布的消息，因为找不到消费者，都会被丢弃掉。</p><p>如果所有消费者都下线了，那生产者发布的消息，因为找不到任何一个消费者，也会全部「丢弃」。所以，当你在使用 Pub/Sub 时，一定要注意：<strong>消费者必须先订阅队列，生产者才能发布消息，否则消息会丢失。</strong></p><p>这也是前面例子让消费者先订阅队列，之后才让生产者发布消息的原因。另外，因为 Pub/Sub 没有基于任何数据类型实现，所以它也不具备「数据持久化」的能力。也就是说，Pub/Sub 的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，Pub/Sub 的数据也会全部丢失。</p><p>最后来看 Pub/Sub 在处理「消息积压」时，为什么也会丢数据？当消费者的速度，跟不上生产者时，就会导致数据积压的情况发生。如果采用 List 当作队列，消息积压时，会导致这个链表很长，最直接的影响就是，Redis 内存会持续增长，直到消费者把所有数据都从链表中取出。但 Pub/Sub 的处理方式却不一样，当消息积压时，有可能会导致<strong>消费失败和消息丢失</strong>！</p><p>回到 Pub/Sub 的实现细节上来说。每个消费者订阅一个队列时，Redis 都会在 Server 上给这个消费者在分配一个「缓冲区」，这个缓冲区其实就是一块内存。生产者发布消息时，Redis 先把消息写到对应消费者的缓冲区中。之后，消费者不断地从缓冲区读取消息，处理消息。</p><p><img src="/posts/24283/640-1711972615643-15.webp" alt></p><p>问题就出在这个缓冲区上。因为这个缓冲区其实是有「上限」的（可配置），如果消费者拉取消息很慢，就会造成生产者发布到缓冲区的消息开始积压，缓冲区内存持续增长。如果超过了缓冲区配置的上限，此时，Redis 就会「强制」把这个消费者踢下线。这时消费者就会消费失败，也会丢失数据。如果看过 Redis 的配置文件，可以看到这个缓冲区的默认配置：<code>client-output-buffer-limit pubsub 32mb 8mb 60</code>。它的参数含义如下：</p><ul><li>32mb：缓冲区一旦超过 32MB，Redis 直接强制把消费者踢下线</li><li>8mb + 60：缓冲区超过 8MB，并且持续 60 秒，Redis 也会把消费者踢下线</li></ul><p>Pub/Sub 的这一点特点，是与 List 作队列差异比较大的。从这里你应该可以看出，<strong>List 其实是属于「拉」模型，而 Pub/Sub 其实属于「推」模型</strong>。List 中的数据可以一直积压在内存中，消费者什么时候来「拉」都可以。但 Pub/Sub 是把消息先「推」到消费者在 Redis Server 上的缓冲区中，然后等消费者再来取。当生产、消费速度不匹配时，就会导致缓冲区的内存开始膨胀，Redis 为了控制缓冲区的上限，所以就有了上面讲到的，强制把消费者踢下线的机制。好了，现在总结一下 Pub/Sub 的优缺点：</p><ol><li>支持发布 / 订阅，支持多组生产者、消费者处理消息</li><li>消费者下线，数据会丢失</li><li>不支持数据持久化，Redis 宕机，数据也会丢失</li><li>消息堆积，缓冲区溢出，消费者会被强制踢下线，数据也会丢失</li></ol><p>有没有发现，除了第一个是优点之外，剩下的都是缺点。所以，很多人看到 Pub/Sub 的特点后，觉得这个功能很「鸡肋」。也正是以上原因，Pub/Sub 在实际的应用场景中用得并不多。</p><blockquote><p>目前只有哨兵集群和 Redis 实例通信时，采用了 Pub/Sub 的方案，因为哨兵正好符合即时通讯的业务场景。</p></blockquote><p>当我们在使用一个消息队列时，希望它的功能如下：</p><ul><li>支持阻塞等待拉取消息</li><li>支持发布 / 订阅模式</li><li>消费失败，可重新消费，消息不丢失</li><li>实例宕机，消息不丢失，数据可持久化</li><li>消息可堆积</li></ul><p>Redis 除了 List 和 Pub/Sub 之外，还有符合这些要求的数据类型吗？在 Redis 5.0 版本， disque 功能移植到了 Redis 中，并给它定义了一个新的数据类型：<strong>Stream</strong>。</p><h2 id="趋于成熟的队列：Stream"><a href="#趋于成熟的队列：Stream" class="headerlink" title="趋于成熟的队列：Stream"></a>趋于成熟的队列：Stream</h2><p>首先，Stream 通过 XADD 和 XREAD 完成最简单的生产、消费模型：</p><ul><li>XADD：发布消息</li><li>XREAD：读取消息</li></ul><p>生产者发布 2 条消息：</p><pre><code>// *表示让Redis自动生成消息ID127.0.0.1:6379&gt; XADD queue * name zhangsan&quot;1618469123380-0&quot;127.0.0.1:6379&gt; XADD queue * name lisi&quot;1618469127777-0&quot;</code></pre><p>使用 XADD 命令发布消息，其中的「*」表示让 Redis 自动生成唯一的消息 ID。这个消息 ID 的格式是「时间戳-自增序号」。</p><p>消费者拉取消息：</p><pre><code>// 从开头读取5条消息，0-0表示从开头读取127.0.0.1:6379&gt; XREAD COUNT 5 STREAMS queue 0-01) 1) &quot;queue&quot;   2) 1) 1) &quot;1618469123380-0&quot;         2) 1) &quot;name&quot;            2) &quot;zhangsan&quot;      2) 1) &quot;1618469127777-0&quot;         2) 1) &quot;name&quot;            2) &quot;lisi&quot;</code></pre><p>如果想继续拉取消息，需要传入上一条消息的 ID：</p><pre><code>127.0.0.1:6379&gt; XREAD COUNT 5 STREAMS queue 1618469127777-0(nil)</code></pre><p>没有消息，Redis 会返回 NULL。</p><p><img src="/posts/24283/640-1711973118284-18.webp" alt></p><p>以上就是 Stream 最简单的生产、消费。</p><blockquote><p>这里不再重点介绍 Stream 命令的各种参数，凡是大写的单词都是「固定」参数，凡是小写的单词，都是可以自己定义的，例如队列名、消息长度等等，</p></blockquote><p>下面我们来看，针对前面提到的消息队列要求，Stream 都是如何解决的？</p><h3 id="1-Stream-是否支持「阻塞式」拉取消息？"><a href="#1-Stream-是否支持「阻塞式」拉取消息？" class="headerlink" title="1) Stream 是否支持「阻塞式」拉取消息？"></a><strong>1) Stream 是否支持「阻塞式」拉取消息？</strong></h3><p>可以，在读取消息时，只需要增加 BLOCK 参数即可。</p><pre><code>// BLOCK 0 表示阻塞等待，不设置超时时间127.0.0.1:6379&gt; XREAD COUNT 5 BLOCK 0 STREAMS queue 1618469127777-0</code></pre><p>这时，消费者就会阻塞等待，直到生产者发布新的消息才会返回。</p><h3 id="2-Stream-是否支持发布-订阅模式？"><a href="#2-Stream-是否支持发布-订阅模式？" class="headerlink" title="2) Stream 是否支持发布 / 订阅模式？"></a><strong>2) Stream 是否支持发布 / 订阅模式？</strong></h3><p>Stream 通过以下命令完成发布订阅：</p><ul><li>XGROUP：创建消费者组</li><li>XREADGROUP：在指定消费组下，开启消费者拉取消息</li></ul><p>下面我们来看具体如何做？首先，生产者依旧发布 2 条消息：</p><pre><code>127.0.0.1:6379&gt; XADD queue * name zhangsan&quot;1618470740565-0&quot;127.0.0.1:6379&gt; XADD queue * name lisi&quot;1618470743793-0&quot;</code></pre><p>之后，我们想要开启 2 组消费者处理同一批数据，就需要创建 2 个消费者组：</p><pre><code>// 创建消费者组1，0-0表示从头拉取消息127.0.0.1:6379&gt; XGROUP CREATE queue group1 0-0OK// 创建消费者组2，0-0表示从头拉取消息127.0.0.1:6379&gt; XGROUP CREATE queue group2 0-0OK</code></pre><p>消费者组创建好之后，我们可以给每个「消费者组」下面挂一个「消费者」，让它们分别处理同一批数据。第一个消费组开始消费：</p><pre><code>// group1的consumer开始消费，&gt;表示拉取最新数据127.0.0.1:6379&gt; XREADGROUP GROUP group1 consumer COUNT 5 STREAMS queue &gt;1) 1) &quot;queue&quot;   2) 1) 1) &quot;1618470740565-0&quot;         2) 1) &quot;name&quot;            2) &quot;zhangsan&quot;      2) 1) &quot;1618470743793-0&quot;         2) 1) &quot;name&quot;            2) &quot;lisi&quot;</code></pre><p>同样地，第二个消费组开始消费：</p><pre><code>// group2的consumer开始消费，&gt;表示拉取最新数据127.0.0.1:6379&gt; XREADGROUP GROUP group2 consumer COUNT 5 STREAMS queue &gt;1) 1) &quot;queue&quot;   2) 1) 1) &quot;1618470740565-0&quot;         2) 1) &quot;name&quot;            2) &quot;zhangsan&quot;      2) 1) &quot;1618470743793-0&quot;         2) 1) &quot;name&quot;            2) &quot;lisi&quot;</code></pre><p>我们可以看到，这 2 组消费者，都可以获取同一批数据进行处理了。这样一来，就达到了多组消费者「订阅」消费的目的。</p><p><img src="/posts/24283/640-1711973188270-21.webp" alt></p><h3 id="3-消息处理时异常，Stream-能否保证消息不丢失，重新消费？"><a href="#3-消息处理时异常，Stream-能否保证消息不丢失，重新消费？" class="headerlink" title="3) 消息处理时异常，Stream 能否保证消息不丢失，重新消费？"></a><strong>3) 消息处理时异常，Stream 能否保证消息不丢失，重新消费？</strong></h3><p>除了上面拉取消息时用到了消息 ID，这里为了保证重新消费，也要用到这个消息 ID。当一组消费者处理完消息后，需要执行 XACK 命令告知 Redis，这时 Redis 就会把这条消息标记为「处理完成」。</p><pre><code>// group1下的 1618472043089-0 消息已处理完成127.0.0.1:6379&gt; XACK queue group1 1618472043089-0</code></pre><p><img src="/posts/24283/640-1711973483264-24.webp" alt></p><p>如果消费者异常宕机，肯定不会发送 XACK，那么 Redis 就会依旧保留这条消息。待这组消费者重新上线后，Redis 就会把之前没有处理成功的数据，重新发给这个消费者。这样一来，即使消费者异常，也不会丢失数据了。</p><pre><code>// 消费者重新上线，0-0表示重新拉取未ACK的消息127.0.0.1:6379&gt; XREADGROUP GROUP group1 consumer1 COUNT 5 STREAMS queue 0-0// 之前没消费成功的数据，依旧可以重新消费1) 1) &quot;queue&quot;   2) 1) 1) &quot;1618472043089-0&quot;         2) 1) &quot;name&quot;            2) &quot;zhangsan&quot;      2) 1) &quot;1618472045158-0&quot;         2) 1) &quot;name&quot;            2) &quot;lisi&quot;</code></pre><h3 id="4-Stream-数据会写入到-RDB-和-AOF-做持久化吗？"><a href="#4-Stream-数据会写入到-RDB-和-AOF-做持久化吗？" class="headerlink" title="4) Stream 数据会写入到 RDB 和 AOF 做持久化吗？"></a><strong>4) Stream 数据会写入到 RDB 和 AOF 做持久化吗？</strong></h3><p>Stream 是新增加的数据类型，它与其它数据类型一样，每个写操作，也都会写入到 RDB 和 AOF 中。我们只需要配置好持久化策略，这样的话，就算 Redis 宕机重启，Stream 中的数据也可以从 RDB 或 AOF 中恢复回来。</p><h3 id="5-消息堆积时，Stream-是怎么处理的？"><a href="#5-消息堆积时，Stream-是怎么处理的？" class="headerlink" title="5) 消息堆积时，Stream 是怎么处理的？"></a><strong>5) 消息堆积时，Stream 是怎么处理的？</strong></h3><p>当消息队列发生消息堆积时，一般只有 2 个解决方案：</p><ol><li>生产者限流：避免消费者处理不及时，导致持续积压</li><li>丢弃消息：中间件丢弃旧消息，只保留固定长度的新消息</li></ol><p>而 Redis 在实现 Stream 时，采用了第 2 个方案。在发布消息时，你可以指定队列的最大长度，防止队列积压导致内存爆炸。</p><pre><code>// 队列长度最大10000127.0.0.1:6379&gt; XADD queue MAXLEN 10000 * name zhangsan&quot;1618473015018-0&quot;</code></pre><p>当队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息。这么来看，Stream 在消息积压时，如果指定了最大长度，还是有可能丢失消息的。</p><blockquote><p>除了以上介绍到的命令，Stream 还支持查看消息长度（XLEN）、查看消费者状态（XINFO）等命令，使用也比较简单，你可以查询官方文档了解一下，这里就不过多介绍了。</p></blockquote><p>Redis 的 Stream 几乎覆盖到了消息队列的各种场景，<strong>既然它的功能这么强大，这是不是意味着，Redis 真的可以作为专业的消息队列中间件来使用呢？</strong>原因在于 Redis 本身的一些问题，如果把其定位成消息队列，还是有些欠缺的。到这里，就不得不把 Redis 与专业的队列中间件做对比了。</p><h2 id="与专业的消息队列对比"><a href="#与专业的消息队列对比" class="headerlink" title="与专业的消息队列对比"></a>与专业的消息队列对比</h2><p>其实，一个专业的消息队列，必须要做到两大块：</p><ol><li>消息不丢</li><li>消息可堆积</li></ol><p>前面我们讨论的重点，很大篇幅围绕的是第一点展开的。这里我们换个角度，从一个消息队列的「使用模型」来分析一下，怎么做，才能保证数据不丢？使用一个消息队列，其实就分为三大块：<strong>生产者、队列中间件、消费者</strong>。</p><p><img src="/posts/24283/640-1711973586474-27.webp" alt="图片"></p><p>消息是否会发生丢失，其重点也就在于以下 3 个环节：</p><ol><li>生产者会不会丢消息？</li><li>消费者会不会丢消息？</li><li>队列中间件会不会丢消息？</li></ol><h3 id="1-生产者会不会丢消息？"><a href="#1-生产者会不会丢消息？" class="headerlink" title="1) 生产者会不会丢消息？"></a><strong>1) 生产者会不会丢消息？</strong></h3><p>当生产者在发布消息时，可能发生以下异常情况：</p><ol><li>消息没发出去：网络故障或其它问题导致发布失败，中间件直接返回失败</li><li>不确定是否发布成功：网络问题导致发布超时，可能数据已发送成功，但读取响应结果超时了</li></ol><p>如果是情况 1，消息根本没发出去，那么重新发一次就好了。</p><p>如果是情况 2，生产者没办法知道消息到底有没有发成功？所以，为了避免消息丢失，它也只能继续重试，直到发布成功为止。</p><blockquote><p>生产者一般会设定一个最大重试次数，超过上限依旧失败，需要记录日志报警处理。</p></blockquote><p>也就是说，生产者为了避免消息丢失，只能采用失败重试的方式来处理。但发现没有？这也意味着消息可能会重复发送。在使用消息队列时，要保证消息不丢，宁可重发，也不能丢弃。</p><p>那消费者这边，就需要多做一些逻辑了。对于敏感业务，当消费者收到重复数据数据时，要设计幂等逻辑，保证业务的正确性。从这个角度来看，生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。所以，无论是 Redis 还是专业的队列中间件，生产者在这一点上都是可以保证消息不丢的。</p><h3 id="2-消费者会不会丢消息？"><a href="#2-消费者会不会丢消息？" class="headerlink" title="2) 消费者会不会丢消息？"></a><strong>2) 消费者会不会丢消息？</strong></h3><p>这种情况就是我们前面提到的，消费者拿到消息后，还没处理完成，就异常宕机了，那消费者还能否重新消费失败的消息？要解决这个问题，消费者在处理完消息后，必须「告知」队列中间件，队列中间件才会把标记已处理，否则仍旧把这些数据发给消费者。</p><p>这种方案需要消费者和中间件互相配合，才能保证消费者这一侧的消息不丢。无论是 Redis 的 Stream，还是专业的队列中间件，例如 RabbitMQ、Kafka，其实都是这么做的。所以，从这个角度来看，Redis 也是合格的。</p><h3 id="3-队列中间件会不会丢消息？"><a href="#3-队列中间件会不会丢消息？" class="headerlink" title="3) 队列中间件会不会丢消息？"></a><strong>3) 队列中间件会不会丢消息？</strong></h3><p>前面 2 个问题都比较好处理，只要客户端和服务端配合好，就能保证生产端、消费端都不丢消息。但是如果队列中间件本身就不可靠呢？毕竟生产者和消费这都依赖它，如果它不可靠，那么生产者和消费者无论怎么做，都无法保证数据不丢。在这个方面，Redis 其实没有达到要求。</p><p>Redis 在以下 2 个场景下，都会导致数据丢失。</p><ol><li>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能</li><li>主从复制也是异步的，主从切换时，也存在丢失数据的可能（从库还未同步完成主库发来的数据，就被提成主库）</li></ol><p>基于以上原因我们可以看到，<strong>Redis 本身的无法保证严格的数据完整性</strong>。所以，如果把 Redis 当做消息队列，在这方面是有可能导致数据丢失的。再来看那些专业的消息队列中间件是如何解决这个问题的？</p><p>像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时，一般是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，以此保证消息的完整性。这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。也正因为如此，RabbitMQ、Kafka在设计时也更复杂。毕竟，它们是专门针对队列场景设计的。但 Redis 的定位则不同，它的定位更多是当作缓存来用，它们两者在这个方面肯定是存在差异的。</p><p><strong>4) 消息积压怎么办？</strong></p><p>因为 Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。所以，Redis 的 Stream 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。</p><p>但 Kafka、RabbitMQ 这类消息队列就不一样了，它们的数据都会存储在磁盘上，磁盘的成本要比内存小得多，当消息积压时，无非就是多占用一些磁盘空间，相比于内存，在面对积压时也会更加「坦然」。</p><p>综上，我们可以看到，把 Redis 当作队列来使用时，始终面临的 2 个问题：</p><ol><li>Redis 本身可能会丢数据</li><li>面对消息积压，Redis 内存资源紧张</li></ol><p>到这里，Redis 是否可以用作队列，这个答案你应该会比较清晰了。如果业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。而且，Redis 相比于 Kafka、RabbitMQ，部署和运维也更加轻量。如果业务场景对于数据丢失非常敏感，写入量非常大，消息积压时会占用很多的机器资源，那么建议使用专业的消息队列中间件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/posts/24283/640-1711973975871-30.webp" alt></p><p><strong>在面对技术选型时，不要不经过思考就觉得哪个方案好，哪个方案不好</strong>。需要根据具体场景具体分析，业务功能角度和技术资源角度，如果本来做的东西就不复杂或者团队都不熟悉专业的消息队列，如果贸然使用这些组件，当发生故障时，排查问题也会变得很困难，甚至会阻碍业务的发展，那还不如选择自己顺手的兵器而不是去用屠龙刀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;一开始在不熟悉的时候当我听到Redis可以当消息队列来用是很奇怪的，后面了解才知道与专业的队列中间件相比各有优劣。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(四)</title>
    <link href="https://joytsing.github.io/posts/34895/"/>
    <id>https://joytsing.github.io/posts/34895/</id>
    <published>2024-04-02T09:00:23.000Z</published>
    <updated>2024-04-07T12:51:59.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核是如何发送网络包的"><a href="#内核是如何发送网络包的" class="headerlink" title="内核是如何发送网络包的"></a>内核是如何发送网络包的</h2><h3 id="1）网络包发送过程总览"><a href="#1）网络包发送过程总览" class="headerlink" title="1）网络包发送过程总览"></a>1）网络包发送过程总览</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bind</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listen</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 接收用户请求</span>    <span class="token function">read</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用户请求处理</span>    <span class="token function">dosomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 给用户返回结果</span>    <span class="token function">send</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中，调用send之后内核是怎样把数据包发送出去的？</p><p><img src="/posts/34895/7889902380838845028.png" alt></p><p>如上图所示，可以看到用户数据被拷贝到内核态，然后经过协议栈处理后进入RingBuffer。随后网卡驱动真正将数据发送了出去。当发送完成的时候，是通过硬中断来通知CPU，然后清理RingBuffer。</p><p>总体的流程图如下：</p><p><img src="/posts/34895/8223474428938309457.png" alt></p><p>虽然数据这时已经发送完毕，但是其实还有一件重要的事情没有做，那就是释放缓存队列等内存。</p><p>那内核是如何知道什么时候才能释放内存的呢，当然是等网络发送完毕之后。网卡在发送完毕的时候，会给 CPU 发送一个硬中断来通知 CPU。更完整的流程看图：</p><p><img src="/posts/34895/6645374755730163142.png" alt></p><h3 id="2）网卡启动准备"><a href="#2）网卡启动准备" class="headerlink" title="2）网卡启动准备"></a>2）网卡启动准备</h3><p>现在的服务器上的网卡一般都是支持多队列的。每一个队列都是由一个RingBuffer表示的，开启了多队列以后的网卡就会对应有多个RingBuffer，如下图所示：</p><p><img src="/posts/34895/5740764547427485556.png" alt></p><p>网卡在启动时最重要的任务之一就是分配和初始化RingBuffer，接下来看看网卡启动时分配传输队列<code>RingBuffer</code>的实际过程。在网卡启动的时候，会调用<code>__igb_open</code>函数，<code>RingBuffer</code>就是在这里分配的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__igb_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net_device <span class="token operator">*</span>netdev<span class="token punctuation">,</span> bool resuming<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> igb_adapter <span class="token operator">*</span>adapter <span class="token operator">=</span> <span class="token function">netdev_priv</span><span class="token punctuation">(</span>netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 分配传输描述符数组</span>    err <span class="token operator">=</span> <span class="token function">igb_setup_all_tx_resources</span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 分配接收描述符数组</span>    err <span class="token operator">=</span> <span class="token function">igb_setup_all_rx_resources</span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 开启全部队列</span>    <span class="token function">netif_tx_start_all_queues</span><span class="token punctuation">(</span>netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的<code>__igb_open</code>函数调用<code>igb_setup_all_tx_resources</code>分配所有的传输<code>RingBuffer</code>，调用<code>igb_setup_all_rx_resources</code>分配所有的接收<code>RingBuffer</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">igb_setup_all_tx_resources</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_adapter <span class="token operator">*</span>adapter<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 有几个队列就构造几个RingBuffer</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adapter<span class="token operator">-></span>num_tx_queues<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        err <span class="token operator">=</span> <span class="token function">igb_setup_tx_resources</span><span class="token punctuation">(</span>adapter<span class="token operator">-></span>tx_ring<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>真正的<code>RingBuffer</code>构造过程是在<code>igb_setup_tx_resources</code>中完成的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span><span class="token keyword">int</span> <span class="token function">igb_setup_tx_resources</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_ring <span class="token operator">*</span>tx_ring<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.申请igb_tx_buffer数组内存</span>    size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_tx_buffer<span class="token punctuation">)</span> <span class="token operator">*</span> tx_ring<span class="token operator">-></span>count<span class="token punctuation">;</span>    tx_ring<span class="token operator">-></span>tx_buffer_info <span class="token operator">=</span> <span class="token function">vzalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 2.申请e1000_adv_tx_desc DMA数组内存</span>    tx_ring<span class="token operator">-></span>size <span class="token operator">=</span> tx_ring<span class="token operator">-></span>count <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">union</span> e1000_adv_tx_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    tx_ring<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-></span>size<span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tx_ring<span class="token operator">-></span>desc <span class="token operator">=</span> <span class="token function">dma_alloc_coherent</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> tx_ring<span class="token operator">-></span>size<span class="token punctuation">,</span>                       <span class="token operator">&amp;</span>tx_ring<span class="token operator">-></span>dma<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 3.初始化队列成员</span>    tx_ring<span class="token operator">-></span>next_to_use <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    tx_ring<span class="token operator">-></span>next_to_clean <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述源码可以看到，一个传输RingBuffer的内部也不仅仅是一个环形队列数组：</p><ul><li><code>igb_tx_buffer</code>数组：这个数组是内核使用的，通过<code>vzalloc</code>申请</li><li><code>e1000_adv_tx_desc</code>数组：这个数组是网卡硬件使用的，通过<code>dma_alloc_coherent</code>分配</li></ul><p>这个时候它们之间还没有啥联系。将来在发送的时候，这两个环形数组中相同位置的指针将都将指向同一个 skb。这样，内核和硬件就能共同访问同样的数据了，内核往 skb 里写数据，网卡硬件负责发送。</p><p><img src="/posts/34895/6701590266695649995.png" alt></p><p>最后调用<code>netif_tx_start_all_queues</code>开启队列。另外，硬中断的处理函数<code>igb_msix_ring</code>其实也是在<code>__igb_open</code>中注册的</p><h3 id="3）数据从用户进程到网卡的详细过程"><a href="#3）数据从用户进程到网卡的详细过程" class="headerlink" title="3）数据从用户进程到网卡的详细过程"></a>3）数据从用户进程到网卡的详细过程</h3><h4 id="1）send系统调用实现"><a href="#1）send系统调用实现" class="headerlink" title="1）send系统调用实现"></a>1）send系统调用实现</h4><p>send系统调用的源码位于net/socket.c中。在这个系统调用里，内部其实真正使用的是sendto系统调用。主要干了两件事情：</p><ol><li>在内核中把真正的socket找出来，在这个对象里记录着各种协议栈的函数地址</li><li>构造一个struct msghdr对象，把用户传入的数据，比如buffer地址、数据长度什么的，都装进去</li></ol><p><img src="/posts/34895/5127322427803208878.png" alt></p><p>有了上面的了解，我们再看起源码就要容易许多了。源码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/socket.c</span><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>send<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> buff<span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> len<span class="token punctuation">,</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">sys_sendto</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> len<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">SYSCALL_DEFINE6</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//1.根据 fd 查找到 socket</span> sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2.构造 msghdr</span> <span class="token keyword">struct</span> msghdr msg<span class="token punctuation">;</span> <span class="token keyword">struct</span> iovec iov<span class="token punctuation">;</span> iov<span class="token punctuation">.</span>iov_base <span class="token operator">=</span> buff<span class="token punctuation">;</span> iov<span class="token punctuation">.</span>iov_len <span class="token operator">=</span> len<span class="token punctuation">;</span> msg<span class="token punctuation">.</span>msg_iovlen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> msg<span class="token punctuation">.</span>msg_iov <span class="token operator">=</span> <span class="token operator">&amp;</span>iov<span class="token punctuation">;</span> msg<span class="token punctuation">.</span>msg_flags <span class="token operator">=</span> flags<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//3.发送数据</span> <span class="token function">sock_sendmsg</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码可以看到，我们在用户态使用的 send 函数和 sendto 函数其实都是 sendto 系统调用实现的。send 只是为了方便，封装出来的一个更易于调用的方式而已。在 sendto 系统调用里，首先根据用户传进来的 socket 句柄号来查找真正的 socket 内核对象。接着把用户请求的 buff、len、flag 等参数都统统打包到一个 struct msghdr 对象中。</p><p>接着调用了 sock_sendmsg =&gt; <strong>sock_sendmsg ==&gt; __sock_sendmsg_nosec。在</strong>sock_sendmsg_nosec 中，调用将会由系统调用进入到协议栈，我们来看它的源码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//file: net/socket.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">__sock_sendmsg_nosec</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">return</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">sendmsg</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2）传输层处理"><a href="#2）传输层处理" class="headerlink" title="2）传输层处理"></a>2）传输层处理</h4><p><strong>传输层拷贝</strong></p><p>在进入协议栈inet_sendmsg以后，内核接着会找到socket上的具体协议发送函数。对于TCP协议来说，那就是tcp_sendmsg（同样也是通过socket内核对象找到的）</p><p>在这个函数中，内核会申请一个内核态的skb内存，将用户待发送的数据拷贝进去。注意，这个时候不一定会真正开始发送，如果没有达到发送条件，很可能这次调用直接就返回了，大概过程如下图所示：</p><p><img src="/posts/34895/6212660484899004570.png" alt></p><p>在进入协议栈inet_sendmsg以后，内核接着会找到sock中具体的协议处理函数，对于TCP协议而言，sk_prot操作函数集实例为tcp_prot，其中.sendmsg的实现为tcp_sendmsg（对于UDP而言中的为udp_sendmsg）。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_sendmsg</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> sk<span class="token operator">-></span>sk_prot<span class="token operator">-></span><span class="token function">sendmsg</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">tcp_sendmsg</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment" spellcheck="true">// 获取用户传递过来的数据和标志</span>iov <span class="token operator">=</span> msg<span class="token operator">-></span>msg_iov<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用户数据地址</span>iovlen <span class="token operator">=</span> msg<span class="token operator">-></span>msg_iovlen<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数据块数为1</span>flags <span class="token operator">=</span> msg<span class="token operator">-></span>msg_flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 各种标志</span>copied <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 已拷贝到发送队列的字节数</span><span class="token comment" spellcheck="true">// 遍历用户层的数据块</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">--</span>iovlen <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 待发送数据块的长度</span>size_t seglen <span class="token operator">=</span> iov<span class="token operator">-></span>len<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 待发送数据块的地址</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>from <span class="token operator">=</span> iov<span class="token operator">-></span>iov_base<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 指向下一个数据块</span>iovlen<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">while</span><span class="token punctuation">(</span>seglen <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> copy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> size_goal<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 单个skb最大的数据长度</span>    skb <span class="token operator">=</span> <span class="token function">tcp_write_queue_tail</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取发送队列最后一个skb</span>    <span class="token comment" spellcheck="true">// 用于返回发送队列第一个数据包，如果不是NULL说明还有未发送的数据</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_send_head</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    copy <span class="token operator">=</span> max <span class="token operator">-</span> skb<span class="token operator">-></span>len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 该skb还可以存放的字节数</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 需要申请新的skb</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>copy <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 发送队列的总大小大于等于发送缓存的上限，或尚发送缓存中未发送的数据量超过了用户的设置值，进入等待</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sk_stream_memory_free</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">goto</span> wait_for_sndbuf<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 申请一个skb</span>    skb <span class="token operator">=</span> <span class="token function">sk_stream_alloc_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token function">select_size</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> sg<span class="token punctuation">)</span><span class="token punctuation">,</span> sk<span class="token operator">-></span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 把skb添加到sock的发送队列尾部</span>    <span class="token function">skb_entail</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>copy <span class="token operator">></span> seglen<span class="token punctuation">)</span>    copy <span class="token operator">=</span> seglen<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// skb的线性数据区中有足够的空间</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">skb_availroom</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    copy <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> copy<span class="token punctuation">,</span> <span class="token function">skb_availroom</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将用户空间的数据拷贝到内核空间，同时计算校验和</span>    err <span class="token operator">=</span> <span class="token function">skb_add_data_nocache</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> from<span class="token punctuation">,</span> copy<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token keyword">goto</span> do_fault<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 线性数据区用完，使用分页区</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数的实现逻辑比较复杂，代码总只显示了skb拷贝的相关部分，总体逻辑如下：</p><ol><li>如果使用了TCP Fast Open，则会在发送SYN包的同时带上数据</li><li>如果连接尚未建好，不处于ESTABLISHED或者CLOSE_WAIT状态则进程进入睡眠，等待三次握手的完成</li><li>获取当前的MSS（最大报文长度）和size_goal（一个理想的TCP数据包大小，受MTU、MSS、TCP窗口大小影响）<ul><li>如果网卡支持GSO（利用网卡分片），size_goal会是MSS的整数倍</li></ul></li><li><strong>遍历用户层的数据块数组</strong><ol><li><strong>获取发送队列的最后一个skb，如果是尚未发送的，且长度未到达size_goal，那么向这个skb继续追加数据</strong></li><li><strong>否则申请一个新的skb来装载数据</strong><ol><li>如果发送队列的总大小大于等于发送缓存的上限，或者发送缓存中尚未发送的数据量超过了用户的设置值：设置发送时发送缓存不够的标志，进入等待</li><li>申请一个skb，其线性区的大小为通过select_size()得到的线性数据区中TCP负荷的大小和最大的协议头长度，申请失败则等待可用内存</li><li>前两步成功则更新skb的TCP控制块字段，把skb加入发送队列队尾，增加发送队列的大小，减少预分配缓存的大小</li></ol></li><li><strong>将数据拷贝至skb中</strong><ol><li><strong>如果skb的线性数据区还有剩余，就复制到线性数据区同时计算校验和</strong></li><li><strong>如果已经用完则使用分页区</strong><ol><li>检查分页区是否有可用空间，没有则申请新的page，申请失败则说明内存不足，之后会设置TCP内存压力标志，减小发送缓冲区的上限，睡眠等待内存</li><li>判断能否往最后一个分页追加数据，不能追加时，检查分页数是否已经达到了上限或网卡是否不支持分散聚合，如果是的话就将skb设置为PSH标志，然后回到4.2中重新申请一个skb来继续填装数据</li><li>从系统层面判断此次分页发送缓存的申请是否合法</li><li>拷贝用户空间的数据到skb的分页中，同时计算校验和。更新skb的长度字段，更新sock的发送队列大小和预分配缓存</li><li>如果把数据追加到最后一个分页了，更新最后一个分页的数据大小。否则初始化新的分页</li></ol></li></ol></li><li>拷贝成功后更新：发送队列的最后一个序号、skb的结束序号、已经拷贝到发送队列的数据量</li><li>发送数据<ol><li>如果所有数据都拷贝好了就退出循环进行发送</li><li>如果skb还可以继续装填数据或者发送的是带外数据那么就继续拷贝数据先不发送</li><li>如果为发送的数据已经超过最大窗口的一半则设置PUSH标志后尽可能地将发送队列中的skb发送出去</li><li>如果当前skb就是发送队列中唯一一个skb，则将这一个skb发送出去</li><li><em>如果上述过程中出现缓存不足，且已经有数据拷贝到发送队列了也直接发送</em></li></ol></li></ol></li></ol><blockquote><p>这里的发送数据只是指调用tcp_push或者tcp_push_one（情况4）或者__tcp_push_pending_frames（情况3）尝试发送，并不一定真的发送到网络（tcp_sendmsg主要任务只是将应用程序的数据封装成网络数据包放到发送队列）。</p><p>数据何时实际被发送到网络，取决于许多因素，包括但不限于：</p><ul><li>TCP的拥塞控制算法：TCP使用了复杂的拥塞控制算法来防止网络过载。如果TCP判断网络可能出现拥塞，它可能会延迟发送数据。</li><li>发送窗口的大小：TCP使用发送窗口和接收窗口来控制数据的发送和接收。如果发送窗口已满（即已发送但未被确认的数据量达到了发送窗口的大小），那么TCP必须等待接收到确认信息后才能发送更多的数据。</li><li>网络设备（如网卡）的状态：如果网络设备繁忙或出现错误，数据可能会被暂时挂起而无法立即发送。</li></ul><p>struct sk_buff（常简称为skb）在Linux网络栈中表示一个网络包。它有两个主要的数据区用来存储数据，分别是线性数据区（linear data area）和分页区（paged data area）。</p><ol><li>线性数据区（linear data area）: 这个区域连续存储数据，并且能够容纳一个完整的网络包的所有协议头，比如MAC头、IP头和TCP/UDP头等。除了协议头部，线性数据区还可以包含一部分或全部的数据负载。每个skb都有一个线性数据区。</li><li>分页区（paged data area）: 一些情况下，为了优化内存使用和提高性能，skb的数据负载部分可以存储在一个或多个内存页中，而非线性数据区。分页区的数据通常只包含数据负载部分，不包含协议头部。如果一个skb的数据全部放入了线性数据区，那么这个skb就没有分页区。</li></ol><p>这种设计的好处是，对于大的数据包，可以将其数据负载部分存储在分页区，避免对大块连续内存的分配，从而提高内存使用效率，减少内存碎片。另外，这种设计也可以更好地支持零拷贝技术。例如，当网络栈接收到一个大数据包时，可以直接将数据包的数据负载部分留在原始的接收缓冲区（即分页区），而无需将其拷贝到线性数据区，从而节省了内存拷贝的开销。</p></blockquote><p><strong>传输层发送</strong></p><p><img src="/posts/34895/6494688155226641158.png" alt></p><p>上面的发送数据步骤，不论是调用__tcp_push_pending_frames还是tcp_push_one，最终都会执行到<strong>tcp_write_xmit</strong>（在网络协议中学到滑动窗口、拥塞控制就是在这个函数中完成的），函数的主要逻辑如下：</p><ol><li>如果要发送多个数据段则先发送一个路径mtu探测</li><li><strong>检测拥塞窗口的大小</strong>，如果窗口已满（通过窗口大小-正在网络上传输的包数目判断）则不发送</li><li><strong>检测当前报文是否完全在发送窗口内</strong>，如果不是则不发送</li><li><strong>判断是否需要延时发送</strong>（取决于拥塞窗口和发送窗口）</li><li><strong>根据需要对数据包进行分段</strong>（取决于拥塞窗口和发送窗口）</li><li><strong>tcp_transmit_skb发送数据包</strong></li><li>如果push_one则结束循环，否则继续遍历队列发送</li><li>结束循环后如果本次有数据发送，则对TCP拥塞窗口进行检查确认</li></ol><p>这里我们只关注发送的主过程，其他部分不过多展开，即来到<strong>tcp_transmit_skb</strong>函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">int</span> clone_it<span class="token punctuation">,</span> gfp_t gfp_mask<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.克隆新的skb出来</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>clone_it<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     skb <span class="token operator">=</span> <span class="token function">skb_clone</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> gfp_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2.封装TCP头</span>    th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    th<span class="token operator">-></span>source <span class="token operator">=</span> inet<span class="token operator">-></span>inet_sport<span class="token punctuation">;</span>    th<span class="token operator">-></span>dest <span class="token operator">=</span> inet<span class="token operator">-></span>inet_dport<span class="token punctuation">;</span>    th<span class="token operator">-></span>window <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    th<span class="token operator">-></span>urg <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 3.调用网络层发送接口</span>    err <span class="token operator">=</span> icsk<span class="token operator">-></span>icsk_af_ops<span class="token operator">-></span><span class="token function">xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inet<span class="token operator">-></span>cort<span class="token punctuation">.</span>fl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一件事就是先<strong>克隆一个新的skb</strong>，因为skb后续在调用网络层，最后到达网卡发送完成的时候，这个skb会被释放掉。而<strong>TCP协议是支持丢失重传的，在收到对方的ACK之前，这个skb不能被删除掉。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是skb的一个拷贝</strong>。等收到ACK再真正删除。</p><p>第二件事是修<strong>改skb的TCP头</strong>，根据实际情况把TCP头设置好。实际上<strong>skb内部包含了网络协议中所有的头，在设置TCP头的时候，只是把指针指向skb合适的位置</strong>。后面设置IP头的时候，再把指针挪动一下即可，避免了频繁的内存申请和拷贝，提高效率。</p><p>tcp_transmit_skb是发送数据位于传输层的最后一步，调用了网络层提供的发送接口icsk-&gt;icsk_Af_ops-&gt;queue_xmit()之后就可以进入网络层进行下一层的操作了。</p><h4 id="3）网络层发送处理"><a href="#3）网络层发送处理" class="headerlink" title="3）网络层发送处理"></a>3）网络层发送处理</h4><p><img src="/posts/34895/7977866705463715655.png" alt></p><p>在tcp_ipv4中，queue_xmit指向的是ip_queue_xmit，具体实现如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ip_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> flowi <span class="token operator">*</span>fl<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 检查socket中是否有缓存的路由表</span>    rt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> rtable<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">__sk_dst_check</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>rt <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 没有缓存则展开查找路由项并缓存到socket中</span>    rt <span class="token operator">=</span> <span class="token function">ip_route_output_ports</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">sk_setup_caps</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-></span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 为skb设置路由表</span>    <span class="token function">skb_dst_set_noref</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-></span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置IP头</span>    iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    ip<span class="token operator">-></span>protocol <span class="token operator">=</span> sk<span class="token operator">-></span>sk_protocol<span class="token punctuation">;</span>    iph<span class="token operator">-></span>ttl <span class="token operator">=</span> <span class="token function">ip_select_ttl</span><span class="token punctuation">(</span>inet<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-></span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    ip<span class="token operator">-></span>frag_off <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token function">ip_copy_addr</span><span class="token punctuation">(</span>iph<span class="token punctuation">,</span> f14<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 发送</span>    <span class="token function">ip_local_out</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数主要做的就是<strong>找到该把这个包发往哪，并构造好IP包头</strong>。它会去查询socket中是否有缓存的路由表，如果有则直接构造包头，如果没有就去查询并缓存到sokect，然后为skb设置路由表，最后封装ip头，发往ip_local_out函数。</p><p>ip_local_out中主要会经过__ip_local_out =&gt; nf_hook 的过程<strong>进行netfilter的过滤</strong>。如果使用iptables配置了一些规则，那么这里将检测到是否命中规则，然后进行相应的操作，如网络地址转换、数据包内容修改、数据包过滤等。如果设置了非常复杂的netfilter规则，则在这个函数会导致进程CPU的开销大增。经过netfilter处理之后，（忽略其他部分）调用dst_output(skb)函数。</p><p>dst_output会去调用skb_dst(skb)-&gt;output(skb)，即<strong>找到skb的路由表</strong>（dst条目），然后<strong>调用路由表的output方法</strong>。这里是个函数指针，指向的是ip_output方法。</p><p>在ip_output方法中首先会进行一些<strong>简单的统计工作</strong>，随后<strong>再次执行netfilter过滤</strong>。过滤通过之后<strong>回调ip_finish_output</strong>。</p><p>在ip_finish_output中，会<strong>校验数据包的长度，如果大于MTU，就会执行分片</strong>。MTU的大小是通过MTU发现机制确定，在以太网中为1500字节。分片会带来两个问题：</p><ol><li>需要进行额外的处理，会有性能开销</li><li>只要一个分片丢失，整个包都要重传</li></ol><p>如果不需要分片则调用ip_finish_output2函数，根据下一跳的IP地址查找邻居项，找不到就创建一个，然后发给下一层——邻居子系统。</p><p>总体过程如下：</p><ol><li>ip_queue_xmit<ol><li>查找并设置路由项</li><li>设置IP头</li></ol></li><li>ip_local_out：netfilter过滤</li><li>ip_output<ol><li>统计工作</li><li>再次netfilter过滤</li></ol></li><li>ip_finish_output<ol><li>大于MTU的话进行分片</li><li>调用ip_finish_output2</li></ol></li></ol><h4 id="4）邻居子系统"><a href="#4）邻居子系统" class="headerlink" title="4）邻居子系统"></a>4）邻居子系统</h4><p><img src="/posts/34895/698520973817362620.png" alt></p><p><strong>邻居子系统是位于网络层和数据链路层中间的一个系统，其作用是为网络层提供一个下层的封装，让网络层不用关心下层的地址信息，让下层来决定发送到哪个MAC地址。</strong></p><blockquote><p>邻居子系统不位于协议栈net/ipv4/目录内，而是位于net/core/neighbour.c，因为无论对于ipv4还是ipv6都需要使用该模块</p></blockquote><p>在邻居子系统中主要<strong>查找或者创建邻居项</strong>，在创建邻居项时有可能会发出实际的arp请求。然后<strong>封装MAC头</strong>，将发生过程再<strong>传递给更下层的网络设备子系统</strong>。</p><p>ip_finish_output2的实现逻辑大致流程如下：</p><ol><li>rt_nexthop：<strong>获取路由下一跳的IP信息</strong></li><li>__ipv4_neigh_lookup_noref：<strong>根据下一条IP信息在arp缓存中查找邻居项</strong></li><li>__neigh_create：<strong>创建一个邻居项，并加入邻居哈希表</strong></li><li>dst_neight_output =&gt; neighbour-&gt;output（实际指向neigh_resolve_output）：<ol><li><strong>封装MAC头（可能会先触发arp请求）</strong></li><li><strong>调用dev_queue_xmit发送到下层</strong></li></ol></li></ol><h4 id="5）网络设备子系统"><a href="#5）网络设备子系统" class="headerlink" title="5）网络设备子系统"></a>5）网络设备子系统</h4><p>邻居子系统通过dev_queue_xmit进入网络设备子系统，dev_queue_xmit的工作逻辑如下</p><ol><li><strong>选择发送队列</strong></li><li><strong>获取排队规则</strong></li><li><strong>存在队列则调用__dev_xmit_skb继续处理</strong></li></ol><p>在前面讲过，网卡是有多个发送队列的，所以首先需要选择一个队列进行发送。队列的选择首先是通过获取用户的XPS配置（为队列绑核），如果没有配置则调用skb_tx_hash去计算出选择的队列。接着会根据与此队列关联的qdisc得到该队列的排队规则。</p><p><img src="/posts/34895/3920606513907107361.png" alt></p><p>最后会根据是否存在队列（如果是发给回环设备或者隧道设备则没有队列）来决定后续数据包流向。对于存在队列的设备会进入__dev_xmit_skb函数。</p><blockquote><p>在Linux网络子系统中，qdisc（Queueing Discipline，队列规则）是一个用于管理网络包排队和发送的核心组件。它决定了网络包在发送队列中的排列顺序，以及何时从队列中取出包进行发送。qdisc还可以应用于网络流量控制，包括流量整形（traffic shaping）、流量调度（traffic scheduling）、流量多工（traffic multiplexing）等。</p><p>Linux提供了许多预定义的qdisc类型，包括：</p><ul><li>pfifo_fast：这是默认的qdisc类型，提供了基本的先入先出（FIFO）队列行为。</li><li>mq：多队列时的默认类型，本身并不进行任何数据包的排队或调度，而是为网络设备的每个发送队列创建和管理一个子 qdisc。</li><li>tbf (Token Bucket Filter)：提供了基本的流量整形功能，可以限制网络流量的速率。</li><li>htb (Hierarchical Token Bucket)：一个更复杂的流量整形qdisc，可以支持多级队列和不同的流量类别。</li><li>sfq (Stochastic Fairness Queueing)：提供了公平队列调度，可以防止某一流量占用过多的带宽。</li></ul><p>每个网络设备（如eth0、eth1等）都有一个关联的qdisc，用于管理这个设备的发送队列。用户可以通过tc（traffic control）工具来配置和管理qdisc。</p><p>对于支持多队列的网卡，Linux内核为发送和接收队列分别分配一个qdisc。每个qdisc独立管理其对应的队列，包括决定队列中的数据包发送顺序，应用流量控制策略等。这样，可以实现每个队列的独立调度和流量控制，提高整体网络性能。</p><p>我们可以说，<strong>对于支持多队列的网卡，内核中的每个发送队列都对应一个硬件的发送队列（也就是 Ring Buffer）</strong>。选择哪个内核发送队列发送数据包，也就决定了数据包将被放入哪个 Ring Buffer。<strong>数据包从 qdisc 的发送队列出队后，会被放入 Ring Buffer，然后由硬件发送到网络线路上。所以，Ring Buffer 在发送路径上位于发送队列之后。</strong></p><p>将struct sock的发送队列和网卡的Ring Buffer之间设置一个由qdisc（队列规则）管理的发送队列，可以提供更灵活的网络流量控制和调度策略，以适应不同的网络环境和需求。</p><p>下面是一些具体的原因：</p><ol><li><strong>流量整形和控制</strong>：qdisc可以实现各种复杂的排队规则，用于控制数据包的发送顺序和时间。这可以用于实现流量整形（比如限制数据的发送速率以避免网络拥塞）和流量调度（比如按照优先级或服务质量（QoS）要求来调度不同的数据包）。</li><li><strong>对抗网络拥塞</strong>：qdisc可以通过管理发送队列，使得在网络拥塞时可以控制数据的发送，而不是简单地将所有数据立即发送出去，这可以避免网络拥塞的加剧。</li><li><strong>公平性</strong>：在多个网络连接共享同一个网络设备的情况下，qdisc可以确保每个连接得到公平的网络带宽，而不会因为某个连接的数据过多而饿死其他的连接。</li><li><strong>性能优化</strong>：qdisc可以根据网络设备的特性（例如，对于支持多队列（Multi-Queue）的网卡）和当前的网络条件来优化数据包的发送，以提高网络的吞吐量和性能。</li></ol></blockquote><p>__dev_xmit_skb分为三种情况：</p><ol><li>qdisc停用：释放数据并返回代码设置为NET_XMIT_DROP</li><li>qdisc允许绕过排队系统&amp;&amp;没有其他包要发送&amp;&amp;qdisc没有运行：绕过排队系统，调用sch_direct_xmit发送数据</li><li>其他情况：正常排队<ol><li>调用q-&gt;enqueue入队</li><li>调用__qdisc_run开始发送</li></ol></li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">__qdisc_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Qdisc <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> quota <span class="token operator">=</span> weight_p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 循环从队列取出一个skb并发送</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">qdisc_restart</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果quota耗尽或其他进程需要CPU则延后处理</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>quota <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> need_resched<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将触发一次NET_TX_SOFTIRQ类型的softirq</span>        <span class="token function">__netif_shcedule</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述代码中可以看到，<strong>while循环不断地从队列中取出skb并进行发送，这个时候其实占用的都是用户进程系统态时间sy，只有当quota用尽或者其他进程需要CPU的时候才触发软中断进行发送</strong>。</p><p>这就是为什么服务器上查看/proc/softirqs，一般NET_RX要比NET_TX大得多的原因。<strong>对于接收来说，都要经过NET_RX软中断，而对于发送来说，只有系统配额用尽才让软中断上</strong>。</p><p>这里我们聚焦于qdisc_restart函数上，这个函数用于从qdisc队列中取包并发给网络驱动</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">qdisc_restart</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Qdisc <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb <span class="token operator">=</span> <span class="token function">dequeue_skb</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>skb<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token function">sch_direct_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> root_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用 dequeue_skb() <strong>从 qdisc 中取出要发送的 skb</strong>。如果队列为空，返回 0， 这将导致上层的 qdisc_restart() 返回 false，继而退出 while 循环。</p><p>如果拿到了skb则<strong>调用sch_direct_xmit继续发送</strong>，该函数会<strong>调用dev_hard_start_xmit，进入驱动程序发包，如果无法发送则重新入队</strong>。</p><p>即整个__qdisc_run的整体逻辑为：while 循环调用 qdisc_restart()，后者取出一个 skb，然后尝试通过 sch_direct_xmit() 来发送；sch_direct_xmit 调用 dev_hard_start_xmit 来向驱动程序进行实际发送。任何无法发送的 skb 都重新入队，将在 NET_TX softirq 中进行发送。</p><h4 id="6）软中断调度"><a href="#6）软中断调度" class="headerlink" title="6）软中断调度"></a>6）软中断调度</h4><p>上一部分中如果发送网络包的时候CPU耗尽了，会调用进入<strong>netif_schedule，该函数会进入</strong>netif_reschedule，<strong>将发送队列设置到softnet_data上，并最终发出一个NET_TX_SOFTIRQ类型的软中断</strong>。软中断是由内核进程运行的，该进程会进入net_tx_action函数，在该函数中能<strong>获得发送队列，并最终也调用到驱动程序的入口函数dev_hard_start_xmit</strong>。</p><p><img src="/posts/34895/8847982115340149470.png" alt></p><p>从触发软中断开始以后发送数据消耗的CPU就都显示在si中，而不会消耗用户进程的系统时间</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">net_tx_action</span><span class="token punctuation">(</span><span class="token keyword">struct</span> softirq_action <span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> softnet_data <span class="token operator">*</span>sd <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">__get_cpu_var</span><span class="token punctuation">(</span>softnet_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果softnet_data设置了发送队列</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sd<span class="token operator">-></span>output_queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 将head指向第一个qdisc</span>       head <span class="token operator">=</span> sd<span class="token operator">-></span>output_queue<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历所有发送队列</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> Qdisc <span class="token operator">*</span>q <span class="token operator">=</span> head<span class="token punctuation">;</span>         head <span class="token operator">=</span> head<span class="token operator">-></span>next_sched<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 处理数据</span>        <span class="token function">qdisc_run</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">qdisc_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Qdisc <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">qdisc_run_begin</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token function">__qdisc_run</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到软中断的处理中，最后和前面一样都是调用了<strong>qdisc_run。也就是说不管是在qdisc_restart中直接处理，还是软中断来处理，最终实际都会来到dev_hard_start_xmit（</strong>qdisc_run =&gt; qdisc_restart =&gt; dev_hard_start_xmit）。</p><h4 id="7）igb网卡驱动发送"><a href="#7）igb网卡驱动发送" class="headerlink" title="7）igb网卡驱动发送"></a>7）igb网卡驱动发送</h4><p>通过前面的介绍可知，<strong>无论对于用户进程的内核态，还是对于软中断上下文，都会调用网络设备子系统的dev_hard_start_xmit函数</strong>，在这个函数中，会<strong>调用驱动里的发送函数igb_xmit_frame</strong>。在驱动函数里，会<strong>将skb挂到RingBuffer上</strong>，驱动调用完毕，<strong>数据包真正从网卡发送出去</strong>。</p><p><img src="/posts/34895/2639590539896627397.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> net_device <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> netdev_queue <span class="token operator">*</span>txq<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取设备的回调函数ops</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> net_device_ops <span class="token operator">*</span> ops <span class="token operator">=</span> dev<span class="token operator">-></span>netdev_ops<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取设备支持的功能列表</span>    features <span class="token operator">=</span> <span class="token function">netif_skb_features</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用驱动的ops里的发送回调函数ndo_start_xmit将数据包传给网卡设备</span>    skb_len <span class="token operator">=</span> skb<span class="token operator">-></span>len<span class="token punctuation">;</span>    rc <span class="token operator">=</span> ops<span class="token operator">-></span><span class="token function">ndo_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里ndo_start_xmit是网卡驱动要实现的函数，igb网卡驱动中的实现是igb_xmit_frame（在网卡驱动程序初始化的时候赋值的）。igb_xmit_frame主要会去调用igb_xmit_frame_ring函数</p><p><img src="/posts/34895/1444488744580676143.png" alt></p><pre class="line-numbers language-c"><code class="language-c">netdev_tx_t <span class="token function">igb_xmit_frame_ring</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> igb_ring <span class="token operator">*</span>tx_ring<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取TX queue中下一个可用缓冲区的信息</span>    first <span class="token operator">=</span> <span class="token operator">&amp;</span>tx_ring<span class="token operator">-></span>tx_buffer_info<span class="token punctuation">[</span>tx_ring<span class="token operator">-></span>next_to_use<span class="token punctuation">]</span><span class="token punctuation">;</span>    first<span class="token operator">-></span>skb <span class="token operator">=</span> skb<span class="token punctuation">;</span>    first<span class="token operator">-></span>bytecount <span class="token operator">=</span> skb<span class="token operator">-></span>len<span class="token punctuation">;</span>    first<span class="token operator">-></span>gso_segs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 准备给设备发送的数据</span>    <span class="token function">igb_tx_map</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> first<span class="token punctuation">,</span> hdr_len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">igb_tx_map</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_ring <span class="token operator">*</span>tx_ring<span class="token punctuation">,</span> <span class="token keyword">struct</span> igb_tx_buffer <span class="token operator">*</span>first<span class="token punctuation">,</span> <span class="token keyword">const</span> u8 hdr_len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取下一个可用的描述符指针</span>    tx_desc <span class="token operator">=</span> <span class="token function">IGB_TX_DESC</span><span class="token punctuation">(</span>tx_ring<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为skb->data构造内存映射，以允许设备通过DMA从RAM中读取数据</span>    dma <span class="token operator">=</span> <span class="token function">dma_map_single</span><span class="token punctuation">(</span>tx_ring<span class="token operator">-></span>dev<span class="token punctuation">,</span> skb<span class="token operator">-></span>data<span class="token punctuation">,</span> size<span class="token punctuation">,</span> DMA_TO_DEVICE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历该数据包的所有分片，为skb的每个分片生成有效映射</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>frag <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">skb_shinfo</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-></span>frags<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> flag<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    tx_desc<span class="token operator">-></span>read<span class="token punctuation">.</span>buffer_addr <span class="token operator">=</span> <span class="token function">cpu_to_le64</span><span class="token punctuation">(</span>dma<span class="token punctuation">)</span><span class="token punctuation">;</span>        tx_desc<span class="token operator">-></span>read<span class="token punctuation">.</span>cmd_type_len <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>      tx_desc<span class="token operator">-></span>read<span class="token punctuation">.</span>olinfo_status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 设置最后一个descriptor</span>    cmd_type <span class="token operator">|</span><span class="token operator">=</span> size <span class="token operator">|</span> IGB_TXD_DCMD<span class="token punctuation">;</span>    tx_desc<span class="token operator">-></span>read<span class="token punctuation">.</span>cmd_type_len <span class="token operator">=</span> <span class="token function">cpu_to_le32</span><span class="token punctuation">(</span>cmd_type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在这里从网卡的发送队列的RingBuffer上取下来一个元素，并将skb挂到元素上。然后使用igb_tx_map函数将skb数据映射到网卡可访问的内存DMA区域。</strong></p><blockquote><p>这里可以理解为&amp;tx_ring-&gt;tx_buffer_info[tx_ring-&gt;next_to_use]拿到了RingBuffer发送队列中指针数组（前文提到的igb_tx_buffer，网卡启动的时候创建的供内核使用的数组）的下一个可用的元素，然后为其填充skb、byte_count等数据。</p><p>填充完成之后，获取描述符数组（前文提到的e1000_adv_tx_desc，网卡启动的时候创建的供网卡使用的数组）的下一个可用元素。</p><p>调用dma_map_single函数创建内存和设备之间的DMA映射，tx_ring-&gt;dev是设备的硬件描述符，即网卡，skb-&gt;data是要映射的地址，size是映射的数据的大小，即数据包的大小，DMA_TO_DEVICE是指映射的方向，这里是数据将从内存传输到设备，返回的调用结果是一个DMA地址，存储在dma变量中，设备可以直接通过这个地址访问到skb的数据。</p><p>最后就是为前面拿到的描述符填充信息，将dma赋值给buffer_addr，网卡使用的时候就是从这里拿到数据包的地址。</p></blockquote><p>当所有需要的描述符都建好，且skb的所有数据都映射到DMA地址后，驱动就会进入到它的最后一步，触发真实的发送。</p><blockquote><p>到目前为止我们可以这么理解：</p><p>应用程序将数据发送到 socket，这些数据会被放入与 sock 中的发送队列。然后，网络协议栈（例如 TCP 或 UDP）将这些数据从 socket 的发送队列中取出，往下层封装，然后将这些数据包放入由 qdisc 管理的设备发送队列中。最后，这些数据包将从设备发送队列出队，放置到RingBuffer的指针数组中，通过dma将数据包的地址映射到可供网卡访问的内存DMA区域，由硬件读取后发送到网络上。</p></blockquote><h3 id="4）RingBuffer内存回收"><a href="#4）RingBuffer内存回收" class="headerlink" title="4）RingBuffer内存回收"></a>4）RingBuffer内存回收</h3><p>当数据发送完以后，其实工作并没有结束，因为内存还没有清理。<strong>当发送完成的时候，网卡设备会触发一个硬中断（硬中断会去触发软中断）来释放内存</strong>。</p><p><img src="/posts/34895/8196118784844985864.png" alt></p><p>这里需要注意的就是，<strong>虽然是数据发送完成通知，但是硬中断触发的软中断是NET_RX_SOFTIRQ</strong>，这也就是为什么软中断统计中RX要高于TX的另一个原因。</p><p>硬中断中会向softnet_data添加poll_list，<strong>软中断中轮询后调用其poll回调函数</strong>，具体实现是igb_poll，其会<strong>在q_vector-&gt;tx.ring存在时去调用igb_clean_tx_irq</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> bool <span class="token function">igb_clean_tx_irq</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_q_vector <span class="token operator">*</span>q_vector<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 释放skb</span>    <span class="token function">dev_kfree_skb_any</span><span class="token punctuation">(</span>tx_buffer<span class="token operator">-></span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 清除tx_buffer数据</span>    tx_buffer<span class="token operator">-></span>skb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将tx_buffer指定的DMA缓冲区的长度设置为0</span>    <span class="token function">dma_unmap_len_set</span><span class="token punctuation">(</span>tx_buffer<span class="token punctuation">,</span> len <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 清除最后的DMA位置，解除映射</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tx_desc <span class="token operator">!=</span> eop_desc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实逻辑无非就是清理了skb（其中data保存的数据包没有释放），解决了DMA映射等，到了这一步传输才算基本完成。</p><p>当然因为传输层需要保证可靠性，所以数据包还没有删除，此时还有前面的拷贝过的skb指向它，它得等到收到对方的ACK之后才会真正删除。</p><p><img src="/posts/34895/8261733188501617381.png" alt></p><h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><ol><li>查看内核发送数据消耗的CPU时应该看sy还是si<ul><li>在网络包发送过程中，用户进程（在内核态）完成了绝大部分的工作，甚至连调用驱动的工作都干了。只有当内核态进程被切走前才会发起软中断。发送过程中百分之九十以上的开销都是在用户进程内核态消耗掉的，只有一少部分情况才会触发软中断，有软中断ksoftirqd内核线程来发送。</li><li>所以在监控网络IO对服务器造成的CPU开销的时候，不能近看si，而是应该把si、sy（内核占用CPU时间比例）都考虑进来。</li></ul></li><li>在服务器上查看/proc/softirqs，为什么NET_RX要比NET_TX大得多<ul><li>对于读来说，都是要经过NET_RX软中断的，都走ksoftirqd内核线程。而对于发送来说，绝大部份工作都是在用户进程内核态处理了，只有系统态配额用尽才会发出NET_TX，让软中断处理。</li><li>当数据发送完以后，通过硬中断的方式来通知驱动发送完毕。但是硬中断无论是有数据接收还是发送完毕，触发的软中断都是NET_RX_SOFTIRQ而不是NET_TX_SOFTIRQ。</li></ul></li><li>发送网络数据的时候都涉及那些内存拷贝操作<ul><li>这里只指内存拷贝</li><li>内核申请完skb之后，将用户传递进来的buffer里的数据拷贝到skb。如果数据量大，这个拷贝操作还是开销不小的。</li><li>从传输层进入网络层时。每个skb都会被克隆出一个新的副本，目的是保存原始的skb，当网络对方没有发挥ACK的时候还可以重新发送，易实现TCP中要求的可靠传输。不过这次只是浅拷贝，只拷贝skb描述符本身，所指向的数据还是复用的。</li><li>第三次拷贝不是必须的，只有当IP层发现skb大于MTU时才需要进行，此时会再申请额外的skb，并将原来的skb拷贝成多个小的skb。</li></ul></li><li>零拷贝到底是怎么回事<ul><li>如果想把本机的一个文件通过网络发送出去，需要先调用read将文件读到内存，之后再调用send将文件发送出去</li><li>假设数据之前没有读去过，那么read系统调用需要两次拷贝才能到用户进程的内存。第一次是从硬盘DMA到Page Cache。第二次是从Page Cache拷贝到内存。send系统调用也同理，先CPU拷贝到socket发送队列，之后网卡进行DMA拷贝。</li><li>如果要发送的数据量较大，那么就需要花费不少的时间在数据拷贝上。而sendfile就是内核提供的一个可用来减少发送文件时拷贝开销的一个技术方案。在sendfile系统调用里，数据不需要拷贝到用户空间，在内核态就能完成发送处理，减少了拷贝的次数。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内核是如何发送网络包的&quot;&gt;&lt;a href=&quot;#内核是如何发送网络包的&quot; class=&quot;headerlink&quot; title=&quot;内核是如何发送网络包的&quot;&gt;&lt;/a&gt;内核是如何发送网络包的&lt;/h2&gt;&lt;h3 id=&quot;1）网络包发送过程总览&quot;&gt;&lt;a href=&quot;#1）网络包发
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Cpp的异常处理额外开销是个啥</title>
    <link href="https://joytsing.github.io/posts/14820/"/>
    <id>https://joytsing.github.io/posts/14820/</id>
    <published>2024-04-01T13:48:57.000Z</published>
    <updated>2024-04-01T14:12:35.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在哪本书（忘了哪本还是哪个讲座）里面看到，打开异常的话会让最终编译出的程序体积扩大三分之一，还会拖慢运行速度，所以C++的异常到底有多慢，以及它为什么这么慢。</p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>要了解异常处理到底做了什么，我们需要深入到汇编语言来看看编译器到底如何生成代码。我们以下面这一段简单的代码为例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noinline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">auto</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，我们使用<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/">Compiler Explorer</a>分析一下它生成的汇编：</p><pre class="line-numbers language-assembly"><code class="language-assembly">foo(int):                                # @foo(int)        push    rbx        mov     ebx, edi        test    edi, edi        js      .LBB0_2        inc     ebx        mov     eax, ebx        pop     rbx        ret.LBB0_2:        mov     edi, 4        call    __cxa_allocate_exception@PLT        mov     dword ptr [rax], ebx        mov     rsi, qword ptr [rip + typeinfo for int@GOTPCREL]        mov     rdi, rax        xor     edx, edx        call    __cxa_throw@PLT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码是使用x86-64 clang 17.0.1生成的，编译选项为<code>-O2 -std=c++20</code>。这段代码非常简单，所以我们很容易可以分析出汇编代码与源代码的对应关系。对于不抛出异常的部分，代码的执行是这样的：</p><pre class="line-numbers language-assembly"><code class="language-assembly">        inc     ebx        mov     eax, ebx        pop     rbx        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这段汇编代码所作的事情就是<code>value += 1</code>，然后返回<code>value</code>。可以看到，在不抛出异常的路径下并没有引入任何影响执行速度的因素。</p><p><code>.LBB0_2</code>段对应了<code>throw value</code>的代码。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>thrown_object <span class="token operator">=</span> <span class="token function">__cxa_allocate_exception</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token comment" spellcheck="true">/* sizeof(int) */</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>thrown_object <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token function">__cxa_throw</span><span class="token punctuation">(</span>thrown_object<span class="token punctuation">,</span> typeinfo_for_int<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以，抛出异常的额外开销也就是这两次函数调用了。我们来看一下<code>__cxa_allocate_exception</code>与<code>__cxa_throw</code>这两个函数具体做了什么。</p><h3 id="cxa-allocate-exception"><a href="#cxa-allocate-exception" class="headerlink" title="__cxa_allocate_exception"></a><code>__cxa_allocate_exception</code></h3><p>以LLVM libcxxabi为例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//  Allocate a __cxa_exception object, and zero-fill it.</span><span class="token comment" spellcheck="true">//  Reserve "thrown_size" bytes on the end for the user's exception</span><span class="token comment" spellcheck="true">//  object. Zero-fill the object. If memory can't be allocated, call</span><span class="token comment" spellcheck="true">//  std::terminate. Return a pointer to the memory to be used for the</span><span class="token comment" spellcheck="true">//  user's exception object.</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">__cxa_allocate_exception</span><span class="token punctuation">(</span>size_t thrown_size<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    size_t actual_size <span class="token operator">=</span> <span class="token function">cxa_exception_size_from_exception_thrown_size</span><span class="token punctuation">(</span>thrown_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Allocate extra space before the __cxa_exception header to ensure the</span>    <span class="token comment" spellcheck="true">// start of the thrown object is sufficiently aligned.</span>    size_t header_offset <span class="token operator">=</span> <span class="token function">get_cxa_exception_offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>raw_buffer <span class="token operator">=</span>        <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">__aligned_malloc_with_fallback</span><span class="token punctuation">(</span>header_offset <span class="token operator">+</span> actual_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> raw_buffer<span class="token punctuation">)</span>        std<span class="token operator">::</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    __cxa_exception <span class="token operator">*</span>exception_header <span class="token operator">=</span>        <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>__cxa_exception <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>raw_buffer <span class="token operator">+</span> header_offset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">::</span><span class="token function">memset</span><span class="token punctuation">(</span>exception_header<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> actual_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">thrown_object_from_cxa_exception</span><span class="token punctuation">(</span>exception_header<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数的注释已经把它所作的事情解释得很清楚了，不过我还是解释一下这段代码所作的事情： </p><ol><li>计算真正需要申请内存的大小（<code>header_offset + actual_size</code>）</li><li>尝试进行<code>aligned_malloc</code></li><li>如果<code>aligned_malloc</code>失败，则<code>std::terminate()</code></li><li>将申请的内存清零（只清零用于存放被抛出对象的部分，header部分不清零）</li></ol><p>所以这段代码约等于进行了一次<code>calloc</code>，其引入的主要开销也就是内存分配了。</p><h3 id="cxa-throw"><a href="#cxa-throw" class="headerlink" title="__cxa_throw"></a><code>__cxa_throw</code></h3><p>还是以LLVM libcxxabi为例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*After constructing the exception object with the throw argument value,the generated code calls the __cxa_throw runtime library routine. Thisroutine never returns.The __cxa_throw routine will do the following:* Obtain the __cxa_exception header from the thrown exception object address,which can be computed as follows: __cxa_exception *header = ((__cxa_exception *) thrown_exception - 1);* Save the current unexpected_handler and terminate_handler in the __cxa_exception header.* Save the tinfo and dest arguments in the __cxa_exception header.* Set the exception_class field in the unwind header. This is a 64-bit valuerepresenting the ASCII string "XXXXC++\0", where "XXXX" is avendor-dependent string. That is, for implementations conforming to thisABI, the low-order 4 bytes of this 64-bit value will be "C++\0".* Increment the uncaught_exception flag.* Call _Unwind_RaiseException in the system unwind library, Its argument is thepointer to the thrown exception, which __cxa_throw itself received as an argument.__Unwind_RaiseException begins the process of stack unwinding, describedin Section 2.5. In special cases, such as an inability to find ahandler, _Unwind_RaiseException may return. In that case, __cxa_throwwill call terminate, assuming that there was no handler for theexception.*/</span><span class="token keyword">void</span><span class="token function">__cxa_throw</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>thrown_object<span class="token punctuation">,</span> std<span class="token operator">::</span>type_info <span class="token operator">*</span>tinfo<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dest<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    __cxa_eh_globals <span class="token operator">*</span>globals <span class="token operator">=</span> <span class="token function">__cxa_get_globals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    __cxa_exception<span class="token operator">*</span> exception_header <span class="token operator">=</span> <span class="token function">cxa_exception_from_thrown_object</span><span class="token punctuation">(</span>thrown_object<span class="token punctuation">)</span><span class="token punctuation">;</span>    exception_header<span class="token operator">-</span><span class="token operator">></span>unexpectedHandler <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">get_unexpected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    exception_header<span class="token operator">-</span><span class="token operator">></span>terminateHandler  <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">get_terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    exception_header<span class="token operator">-</span><span class="token operator">></span>exceptionType <span class="token operator">=</span> tinfo<span class="token punctuation">;</span>    exception_header<span class="token operator">-</span><span class="token operator">></span>exceptionDestructor <span class="token operator">=</span> dest<span class="token punctuation">;</span>    <span class="token function">setOurExceptionClass</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>exception_header<span class="token operator">-</span><span class="token operator">></span>unwindHeader<span class="token punctuation">)</span><span class="token punctuation">;</span>    exception_header<span class="token operator">-</span><span class="token operator">></span>referenceCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// This is a newly allocated exception, no need for thread safety.</span>    globals<span class="token operator">-</span><span class="token operator">></span>uncaughtExceptions <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Not atomically, since globals are thread-local</span>    exception_header<span class="token operator">-</span><span class="token operator">></span>unwindHeader<span class="token punctuation">.</span>exception_cleanup <span class="token operator">=</span> exception_cleanup_func<span class="token punctuation">;</span>    <span class="token function">_Unwind_RaiseException</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>exception_header<span class="token operator">-</span><span class="token operator">></span>unwindHeader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  This only happens when there is no handler, or some unexpected unwinding</span>    <span class="token comment" spellcheck="true">//     error happens.</span>    <span class="token function">failed_throw</span><span class="token punctuation">(</span>exception_header<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与<code>__cxa_allocate_exception</code>相同，<code>__cxa_throw</code>函数的注释也写得很清楚了（PS：LLVM的注释写得真不错）。让我们来看看它干了什么：</p><ol><li>从<code>thrown_object</code>中拿到<code>__cxa_exception</code>。还记得吗，<code>__cxa_allocate_exception</code>申请内存时包含了<code>__cxa_exception</code>的header与被抛出的对象。<code>thrown_object</code>指向被抛出的对象，向前偏移header的大小即可拿到<code>__cxa_exception</code>对象的地址。</li><li>填充<code>__cxa_exception</code>的header；</li><li>调用<code>_Unwind_RaiseException</code>；</li><li>如果<code>_Unwind_RaiseException</code>调用成功，则不返回。否则，异常处理失败，调用<code>std::terminate()</code>。</li></ol><p><code>__cxa_exception</code>的header主要包含了各种处理函数的函数指针，以及异常对象的RTTI信息。填充header的过程基本就是几次赋值，以及一次<code>memcpy</code>（<code>setOurExceptionClass</code>的主要流程）。栈回溯等主要流程由<code>_Unwind_RaiseException</code>开始。</p><h2 id="栈回溯"><a href="#栈回溯" class="headerlink" title="栈回溯"></a>栈回溯</h2><p><code>_Unwind_RaiseException</code>函数是Itanium ABI定义的异常处理函数，它函数是语言无关的，其他语言也可以使用这个函数实现异常处理等功能。Itanium ABI在Base ABI中定义了一系列函数，在抛出异常这里我们只关心<code>_Unwind_RaiseException</code>。</p><p>我们继续展开<code>_Unwind_RaiseException</code>看看它做了什么，它是在<code>libunwind</code>中实现的：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/// Called by __cxa_throw.  Only returns if there is a fatal error.</span>_LIBUNWIND_EXPORT _Unwind_Reason_Code<span class="token function">_Unwind_RaiseException</span><span class="token punctuation">(</span>_Unwind_Exception <span class="token operator">*</span>exception_object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">_LIBUNWIND_TRACE_API</span><span class="token punctuation">(</span><span class="token string">"_Unwind_RaiseException(ex_obj=%p)"</span><span class="token punctuation">,</span>                         <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>exception_object<span class="token punctuation">)</span><span class="token punctuation">;</span>    unw_context_t uc<span class="token punctuation">;</span>    unw_cursor_t cursor<span class="token punctuation">;</span>    <span class="token function">__unw_getcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>uc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Mark that this is a non-forced unwind, so _Unwind_Resume()</span>    <span class="token comment" spellcheck="true">// can do the right thing.</span>    exception_object<span class="token operator">-></span>private_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    exception_object<span class="token operator">-></span>private_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// phase 1: the search phase</span>    _Unwind_Reason_Code phase1 <span class="token operator">=</span> <span class="token function">unwind_phase1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>uc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cursor<span class="token punctuation">,</span> exception_object<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>phase1 <span class="token operator">!=</span> _URC_NO_REASON<span class="token punctuation">)</span>        <span class="token keyword">return</span> phase1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// phase 2: the clean up phase</span>    <span class="token keyword">return</span> <span class="token function">unwind_phase2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>uc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cursor<span class="token punctuation">,</span> exception_object<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如上面的代码所示，栈回溯包含两个阶段：<code>unwind_phase1</code>与<code>unwind_phase2</code>。第一阶段会遍历整个栈以查找Exception Handler，除此之外什么也不会做。如果没有找到Exception Handler，则应当终止程序。不过<code>libunwind</code>本身不会直接调用<code>std::terminate()</code>，而是返回<code>_URC_END_OF_STACK</code>并由调用者决定如何终止程序。在第二阶段才会回溯并清理栈。</p><p>这意味着，如果有异常被抛出，但没有被捕获，那么显然不会进入到第二阶段，也就是不会进行栈回溯，栈上对象的析构函数不会被执行。需要注意的是，对于未捕获异常时的栈回溯行为，C++标准规定这是由具体实现决定的。对于Itanium ABI而言，栈回溯不会被执行，但对于其他ABI而言则未必。</p><p><code>unwind_phase1</code>与<code>unwind_phase2</code>的代码都比较长，这里就不贴代码了，我会简要叙述一下它们的实现过程，感兴趣的话可以在<a href="https://link.zhihu.com/?target=https%3A//github.com/llvm/llvm-project/blob/28c29fbec3057692a7985819d799a9e5d47eb2d1/libunwind/src/UnwindLevel1.c%23L420">GitHub</a>找到它们的实现。</p><h3 id="unwind-phase1"><a href="#unwind-phase1" class="headerlink" title="unwind_phase1"></a><code>unwind_phase1</code></h3><p>在<code>unwind_phase1</code>中，代码会不断循环执行一段代码，来查找Exception Handler，直到找到Exception Handler或者到达栈的底部。这段循环的代码步骤如下：</p><ol><li>使用<code>__unw_step</code>函数，使cursor指向下一个栈帧；</li><li>使用<code>__unw_get_proc_info</code>函数，检查当前栈帧是否有需要执行的代码；</li></ol><ul><li>如果找到了要执行的代码，则检查是否要停在当前栈帧（可能找到了Exception Handler）；<ul><li>如果这段要执行的代码要求停在当前栈帧，则说明找到了Exception Handler，标记当前栈帧并返回；</li><li>否则继续循环。</li></ul></li><li>如果没有找到要执行的代码，则继续循环。</li></ul><p>不难想到，“可能的Exception Handler”就是C++代码中的<code>catch</code>了。在检查<code>catch</code>块是否与当前异常对象所匹配时，会对比RTTI信息等，所以如果回滚过程中找到了很多<code>catch</code>，会对<code>unwind_phase1</code>的性能有较大的影响。</p><h3 id="unwind-phase2"><a href="#unwind-phase2" class="headerlink" title="unwind_phase2"></a><code>unwind_phase2</code></h3><p><code>unwind_phase2</code>与<code>unwind_phase1</code>的代码非常类似，也是在循环中不断执行代码来回溯栈，只不过它所做的事情要稍微多一点：</p><ol><li>使用<code>__unw_step_stage2</code>函数，使cursor指向下一个栈帧；</li><li>使用<code>__unw_get_reg</code>获取当前栈帧的<code>sp</code>寄存器（stack pointer）；</li><li>使用<code>__unw_get_proc_info</code>函数，获取当前栈帧的信息；</li></ol><ul><li>如果当前栈帧有要执行的代码，则告诉它目前正在进行栈回溯；</li><li>如果当前栈帧是第一阶段标记的栈帧，则告诉它这是被标记的栈帧；</li><li>尝试执行这段代码：<ul><li>如果这段代码执行后，通知调用者应当继续回溯（返回<code>_URC_CONTINUE_UNWIND</code>），则继续循环；</li><li>如果这段代码执行后，通知调用者回溯到此为止，则尝试resume控制权（调用<code>__unw_phase2_resume</code>）。</li></ul></li></ul><p>很有趣的一点是，<code>libunwind</code>中的函数在调用具体的异常处理函数时全部是通过函数指针实现的，这一点保证了它能够做到语言无关。具体的栈清理等代码由C++的前端编译器生成，并以函数指针的形式传递给<code>libunwind</code>，这给了编译器前端很大的自由度。</p><h2 id="捕获和处理异常"><a href="#捕获和处理异常" class="headerlink" title="捕获和处理异常"></a>捕获和处理异常</h2><p>我们还是以一段简单的代码为例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">__attribute</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noinline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">auto</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">foo</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">int</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Get error %d\n"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/">Compiler Explorer</a>分析一下它生成的汇编：</p><pre class="line-numbers language-assembly"><code class="language-assembly">bar(int):                                # @bar(int)        push    rax        call    foo(int)        pop     rcx        ret        mov     rdi, rax        call    __cxa_begin_catch@PLT        mov     esi, dword ptr [rax]        lea     rdi, [rip + .L.str]        xor     eax, eax        call    printf@PLT        call    __cxa_end_catch@PLT        mov     eax, -1        pop     rcx        ret.Ltmp19:                                # TypeInfo 1        .long   .L_ZTIi.DW.stub-.Ltmp19.L.str:        .asciz  "Get error %d\n"DW.ref.__gxx_personality_v0:        .quad   __gxx_personality_v0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，在不需要执行<code>catch</code>的情况下，<code>bar</code>函数只有4行汇编：</p><pre class="line-numbers language-assembly"><code class="language-assembly">bar(int):                                # @bar(int)        push    rax        call    foo(int)        pop     rcx        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而<code>catch</code>生成的代码显然被直接塞到了<code>ret</code>指令的后面。<code>catch</code>部分首先调用了<code>__cxa_begin_catch</code>，然后开始执行<code>printf</code>，最后调用<code>__cxa_end_catch</code>函数后回到了正常的代码路径上。除此之外，编译器还生成了一些其他的信息：<code>Ltmp19</code>段存储了RTTI信息，<code>DW.ref.__gxx_personality_v0</code>段存储了一个函数指针<code>__gxx_personality_v0</code>。这些东西又是什么？</p><h3 id="Personality-Routine"><a href="#Personality-Routine" class="headerlink" title="Personality Routine"></a>Personality Routine</h3><p>因为不知道怎么翻译比较好所以就保持原名了。</p><p>正如上文所述，<code>libunwind</code>使用函数指针的回调函数来具体实现栈清理等功能。<code>__gxx_personality_v0</code>即为<code>libc++abi</code>与<code>libsupc++</code>的Personality Routine（是个函数）。<code>libunwind</code>中Personality Routine的声明如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">_Unwind_Reason_Code</span> <span class="token punctuation">(</span><span class="token operator">*</span>__personality_routine<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token keyword">int</span> version<span class="token punctuation">,</span>         _Unwind_Action actions<span class="token punctuation">,</span>         uint64 exceptionClass<span class="token punctuation">,</span>         <span class="token keyword">struct</span> _Unwind_Exception <span class="token operator">*</span>exceptionObject<span class="token punctuation">,</span>         <span class="token keyword">struct</span> _Unwind_Context <span class="token operator">*</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>actions</code>参数用于表示要执行的操作，<code>exceptionObject</code>与<code>context</code>则分别表示异常对象与目前的上下文。<code>__gxx_personality_v0</code>的具体实现可以在<a href="https://link.zhihu.com/?target=https%3A//github.com/llvm/llvm-project/blob/28c29fbec3057692a7985819d799a9e5d47eb2d1/libcxxabi/src/cxa_personality.cpp%23L861-L1000">libcxxabi</a>找到。这部分代码所作的事情基本就是根据<code>action</code>选择执行相应的操作，<del>具体的实现我懒得看了</del>。</p><p>有了Personality Routine之后，还需要将其传递给<code>libunwind</code>，在DWARF中这是通过<code>.eh_frame</code>段实现的。栈帧和Personality Routine都存储在<code>.eh_frame</code>段中，<code>libunwind</code>自己会从<code>.eh_frame</code>段中查找。</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>最后我们来讨论一下<code>__cxa_begin_catch</code>与<code>__cxa_end_catch</code>。<code>__cxa_begin_catch</code>的代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*This routine can catch foreign or native exceptions.  If native, the exceptioncan be a primary or dependent variety.  This routine may remain blissfullyignorant of whether the native exception is primary or dependent.If the exception is native:* Increment's the exception's handler count.* Push the exception on the stack of currently-caught exceptions if it is not  already there (from a rethrow).* Decrements the uncaught_exception count.* Returns the adjusted pointer to the exception object, which is stored in  the __cxa_exception by the personality routine.If the exception is foreign, this means it did not originate from one of throwroutines.  The foreign exception does not necessarily have a __cxa_exceptionheader.  However we can catch it here with a catch (...), or with a callto terminate or unexpected during unwinding.* Do not try to increment the exception's handler count, we don't know where  it is.* Push the exception on the stack of currently-caught exceptions only if the  stack is empty.  The foreign exception has no way to link to the current  top of stack.  If the stack is not empty, call terminate.  Even with an  empty stack, this is hacked in by pushing a pointer to an imaginary  __cxa_exception block in front of the foreign exception.  It would be better  if the __cxa_eh_globals structure had a stack of _Unwind_Exception, but it  doesn't.  It has a stack of __cxa_exception (which has a next* in it).* Do not decrement the uncaught_exception count because we didn't increment it  in __cxa_throw (or one of our rethrow functions).* If we haven't terminated, assume the exception object is just past the  _Unwind_Exception and return a pointer to that.*/</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token function">__cxa_begin_catch</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> unwind_arg<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    _Unwind_Exception<span class="token operator">*</span> unwind_exception <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Unwind_Exception<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>unwind_arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> native_exception <span class="token operator">=</span> <span class="token function">__isOurExceptionClass</span><span class="token punctuation">(</span>unwind_exception<span class="token punctuation">)</span><span class="token punctuation">;</span>    __cxa_eh_globals<span class="token operator">*</span> globals <span class="token operator">=</span> <span class="token function">__cxa_get_globals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// exception_header is a hackish offset from a foreign exception, but it</span>    <span class="token comment" spellcheck="true">//   works as long as we're careful not to try to access any __cxa_exception</span>    <span class="token comment" spellcheck="true">//   parts.</span>    __cxa_exception<span class="token operator">*</span> exception_header <span class="token operator">=</span>            <span class="token function">cxa_exception_from_exception_unwind_exception</span>            <span class="token punctuation">(</span>                <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Unwind_Exception<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>unwind_exception<span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>native_exception<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Increment the handler count, removing the flag about being rethrown</span>        exception_header<span class="token operator">-</span><span class="token operator">></span>handlerCount <span class="token operator">=</span> exception_header<span class="token operator">-</span><span class="token operator">></span>handlerCount <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span>            <span class="token operator">-</span>exception_header<span class="token operator">-</span><span class="token operator">></span>handlerCount <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> exception_header<span class="token operator">-</span><span class="token operator">></span>handlerCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  place the exception on the top of the stack if it's not already</span>        <span class="token comment" spellcheck="true">//    there by a previous rethrow</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>exception_header <span class="token operator">!=</span> globals<span class="token operator">-</span><span class="token operator">></span>caughtExceptions<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            exception_header<span class="token operator">-</span><span class="token operator">></span>nextException <span class="token operator">=</span> globals<span class="token operator">-</span><span class="token operator">></span>caughtExceptions<span class="token punctuation">;</span>            globals<span class="token operator">-</span><span class="token operator">></span>caughtExceptions <span class="token operator">=</span> exception_header<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        globals<span class="token operator">-</span><span class="token operator">></span>uncaughtExceptions <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Not atomically, since globals are thread-local</span>        <span class="token keyword">return</span> exception_header<span class="token operator">-</span><span class="token operator">></span>adjustedPtr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Else this is a foreign exception</span>    <span class="token comment" spellcheck="true">// If the caughtExceptions stack is not empty, terminate</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>globals<span class="token operator">-</span><span class="token operator">></span>caughtExceptions <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        std<span class="token operator">::</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Push the foreign exception on to the stack</span>    globals<span class="token operator">-</span><span class="token operator">></span>caughtExceptions <span class="token operator">=</span> exception_header<span class="token punctuation">;</span>    <span class="token keyword">return</span> unwind_exception <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然这段代码看起来很长，但其并不复杂。这段代码首先对native和foreign异常进行了判断。<code>libcxxabi</code>不处理foreign异常，所以当其捕获到foreigh异常时，直接调用<code>std::terminate()</code>。如果捕获到了native异常，则维护异常对象的引用计数，以及全局异常对象的状态。其中大部分的操作都是对各种计数进行加减操作。</p><p><code>__cxa_end_catch</code>所作的事情与<code>__cxa_begin_catch</code>类似，也是维护异常对象的状态，这里就不再赘述了。感兴趣的话请自行阅读<code>libcxxabi</code>的源码吧。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简要总结一下Itanium ABI抛出和捕获异常的主要流程：</p><p>抛出异常</p><ol><li>申请内存，用于存放<code>__cxa_exception</code>与异常对象；</li><li><code>_Unwind_RaiseException</code>查找Exception Handler。这个过程可能需要频繁比较RTTI信息；</li><li><code>_Unwind_RaiseException</code>回溯并释放栈对象。这个过程可能需要频繁查找<code>.eh_frame</code>段；</li></ol><p>捕获异常</p><ol><li>交还控制权，<code>__cxa_begin_catch</code>维护异常状态；</li><li>执行<code>catch</code>部分的代码；</li><li>执行<code>__cxa_end_catch</code>，维护异常状态，捕获异常结束。</li></ol><p>从中可以大致看出，抛出异常以及栈回溯会占用异常处理的大部分时间。比较耗费性能的部分有：申请和释放堆内存、比较RTTI信息、以及栈回溯。如果和返回错误码进行比较的话，考虑多层传递错误码的情况，函数返回本身也需要依次析构栈上的对象。这样考虑的话，异常的<strong>栈回溯</strong>也没有带来很大的额外时间开销。</p><h3 id="空间开销"><a href="#空间开销" class="headerlink" title="空间开销"></a>空间开销</h3><p>异常带来的额外空间开销主要是<code>.eh_frame</code>，其中RTTI要占很大一部分。对于比较大型的软件而言，异常和RTTI对二进制大小的影响还是很大的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在哪本书（忘了哪本还是哪个讲座）里面看到，打开异常的话会让最终编译出的程序体积扩大三分之一，还会拖慢运行速度，所以C++的异常到底有多慢，以
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中的memory order</title>
    <link href="https://joytsing.github.io/posts/13357/"/>
    <id>https://joytsing.github.io/posts/13357/</id>
    <published>2024-04-01T09:08:07.000Z</published>
    <updated>2024-04-02T09:08:52.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Memory Order不难理解，需要的只是重新建立一种世界观，需要的只是强迫自己接受那些从来没关注过的东西，就像两个铁球同时落地一样。</p><p><img src="/posts/13357/image-20240402164630777.png" alt></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>1）store buffer，这个是用于存储cpu产生的临时值，它是cpu的私有区，其它核是看不到的，换句话讲，它会导致在整个系统中，同一个内存值数据，它会有多个副本的存在，也就是会出现不同的cpu看到的值是不一样的，也就是会导致数据一致性问题。</p><p>2）invalidate queue，这个一般在弱序系统中比较常见，它用于加速类似MESI这种cache一致性协议的共识过程，比如说，cpu0在同步store buffer数据到cache时，它会发送Read Invalidate消息，而cpu1并不是立即处理的，它可以先把Read Invalidate的消息先放在invalidate queue里，然后就立马回应ACK返回了，这样处理的好处就是，对于cpu0来说 ，它能更快处理Read Invalidate的共识过程，但是导致的结果，就是cpu1它因为不是及时处理的，所以对于cpu1来说，它看到的值可能不是最新的，也就是它会导致跟store buffer存在一样的问题，数据一致性问题。</p><p>3）cache，对于cache来说，不同系统结构采取的方式有可能不一样，l1 cache，l2cache，有些系统甚至有l3 cache，l4 cache，甚至有victim cache等等，各cache之间数据处理策略也会有差异，比如有些采用inclusive方式，有些采用exclusive方式，甚至有些采用NINE方式，也就是混合模式，Non-Inclusive-Non-Exclusive方式。虽然cache的实现方式多种多样，但是有一点是通识的，进入cache后，可以认为数据进入了公共可见区，也就是但凡进入cache的数据，都会走一个cache cycle，它会根据不同策略，做处理。但这里要明白的是，虽然数据进入了公共可见区，但读端是不是立即能读取到这个值，还取决于读端的硬件结构，比如上面说的Invalidate queue的存在，所以对于这样的弱序系统来说，对于读端，要想读取公共可见区的同一个值，它都需要使用内存屏障来做同步处理，而不是简单的一个汇编读就可以了。</p><h2 id="什么是-Memory-Order"><a href="#什么是-Memory-Order" class="headerlink" title="什么是 Memory Order"></a>什么是 Memory Order</h2><p>简单来说，就是 CPU 访问内存的顺序。为什么要研究这个顺序呢？因为 CPU 并不是按照我们写的程序的先后顺序来访问内存的，在编译和执行阶段，都会进行一定程度的指令重排，CPU 随便乱序执行，以提升执行效率。</p><h2 id="为什么感知不到-Memory-Order"><a href="#为什么感知不到-Memory-Order" class="headerlink" title="为什么感知不到 Memory Order"></a>为什么感知不到 Memory Order</h2><p>我们在日常不考虑 Memory Order 写代码的时候，想用原子变量就直接 <code>atomic&lt;int&gt;</code> ，然后对这个变量做运算。实际上，C++ 在这里规定，不显式的写 <code>memory_order_xxx</code> ，就已经隐含了最强的 Memory Order。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> b<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread A</span>a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread B</span><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 A 线程，我写了 a 在 b 之前 set，那么读到了 b 的时候，a 的值肯定已经被 set 过了。实际上，在 C++ 的语义上，允许更弱的内存模型，如果这里不用默认的最强 Memory Order，而用相对最弱的 relaxed，Thread B 中的 assert 是有可能 fail 的。</p><p>另外，在单线程内，编译器也遵循 as-if 规则，不会做让程序员感知到影响执行效果的优化。</p><h2 id="C-语义"><a href="#C-语义" class="headerlink" title="C++ 语义"></a>C++ 语义</h2><p>ref：<a href="https://zh.cppreference.com/w/cpp/atomic/memory_order">std::memory_order - cppreference.com</a></p><p>在 C++ 语义上，一共暴露了 4 种 Memory Order：</p><ol><li>relaxed</li><li>release-acquire</li><li>release-consume</li><li>sc (sequential consistency)</li></ol><h3 id="relaxed"><a href="#relaxed" class="headerlink" title="relaxed"></a>relaxed</h3><p>其中，relaxed 最好理解，在 C++ 语义层面，允许任何 reorder。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// x == 0 &amp;&amp; y == 0</span><span class="token comment" spellcheck="true">// Thread 1:</span>r1 <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// A</span>x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>r1<span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// B</span><span class="token comment" spellcheck="true">// Thread 2:</span>r2 <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// C </span>y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// D</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里面，CD 可以 reorder，因此可能的执行顺序是 DABC，这样 r1 和 r2 可以都是 42。</p><h3 id="release-acquire"><a href="#release-acquire" class="headerlink" title="release-acquire"></a>release-acquire</h3><p>假设在 A 线程 release store x 变量，在 B 线程 acquire load x 变量。在 C++ 语义层面，可以确保：</p><ol><li>如果 B 线程的 acquire load x 能看到 x 变量被 release store x 了，那么 B 线程的这个 acquire load x 可以看到 A 线程在 release store x 之前的所有 store。</li><li>B 线程在 acquire load x 之后的所有 load，都可以看到这个 acquire load x。</li></ol><p>总结这两点，得出一个更强的结论：如果 B 线程的 acquire load x 能看到 x 变量被 release store x 了，那么 B 线程在 acquire load x 之后的所有 load ，都可以看到 A 线程 release store x 之前所有的 store。</p><p>同时，还有：</p><ol><li>在 acquire 线程中，任何 acquire load 之后的读写不能拿到 acquire load 之前。</li><li>在 release 线程中，任何 release store 之前的读写不能拿到 release store 之后。</li></ol><h3 id="release-consume"><a href="#release-consume" class="headerlink" title="release-consume"></a>release-consume</h3><p>与 release-acquire 不同的是，<code>release-consume</code> 可以只同步依赖的变量。也就是说，在 consume load x 的时候，保证能看到<code>x.store(k, mo_release)</code>之前所有与 k 有关的变量 store 即可。</p><h3 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h3><p>sc 比 release-acquire 更强，拥有 total order。</p><p>具体强在 2 个例子。</p><p>第一个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// a == 0 &amp;&amp; b == 0</span><span class="token comment" spellcheck="true">// Thread 1</span>x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread 2</span>y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread 3</span><span class="token keyword">int</span> a <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread 4</span><span class="token keyword">int</span> c <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> d <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，如果采取 release-acquire 模式，thread 3 和 thread 4 的视图可能会不一样。在 Thread 3 中，x 可以早于 y load；而在 Thread 4 中，y 可以早于 x load。因此，可能 a == c == 1；而 b == d == 0。两个线程可能两者会维护不一样的视图，没有 total order，只要满足 release-acquire 原则就行了。</p><p>而如果采取 <code>memory_order_seq_cst</code> ，必须全局维护一个视图，不可能存在上述情况。</p><p>第二个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// x == 0 &amp;&amp; y == 0</span><span class="token comment" spellcheck="true">// Thread 1</span>x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> c <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Thread 2</span>y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> d <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回忆一下，release-acquire 只要求：在 acquire 线程中，任何 acquire load 之后的读写不能拿到 acquire load 之前；在 release 线程中，任何 release store 之前的读写不能拿到 release store 之后。但是有一种 reorder 是允许的，就是可以把 store 拿到 load 之后，把 load 拿到 store 之前。如上：Thread 1 和 Thread 2 都可以把 load 拿到 store 之前，得到 c == d == 0。</p><p>而如果采取 <code>memory_order_seq_cst</code> ，同样地，必须全局维护一个视图，不可能存在上述情况。</p><h2 id="Use-Cases"><a href="#Use-Cases" class="headerlink" title="Use Cases"></a>Use Cases</h2><p>对于 relaxed 语义而言，最常见的应用是各种计数器。因为对计数器的 store 和 load，几乎不依赖其他任何变量，就单纯的 emit 一下即可。</p><p>对于 acquire-release 而言，最常见的是在有锁编程：lock 的时候，必须是先获取锁，然后再访问数据； unlock 的时候，必须先写完数据，再释放锁。这就是典型的 acquire-release 语义。</p><p>对于 sc，当依赖多个变量的时候，可能必须要求这些变量有 total order，每个线程持有不同的视图可能会造成非预期的错误。</p><p>例如：</p><ol><li>Thread A 的逻辑是，while 死循环，当 x == true 的时候退出死循环，判断 y 是不是 true，是 true 的话 ++z。</li><li>Thread B 的逻辑是，while 死循环，当 y == true 的时候退出死循环，判断 x 是不是 true，是 true 的话 ++z。</li></ol><p>这里，如果用 acquire-release 语义，并且 x 和 y 是单独的两个线程来 store，就很有可能，在 Thread A 看来 x == true &amp;&amp; y == false。在 Thread B 看来 y == true &amp;&amp; x == false。这样 z 一次都没有 ++。</p><p>因此“当一个变量的访问，依赖其他 &gt;= 2 个变量的判断条件”的时候，这 &gt;= 2 个变量最好都用 sc 保护。</p><h2 id="x86-Memory-Order-语义"><a href="#x86-Memory-Order-语义" class="headerlink" title="x86 Memory Order 语义"></a>x86 Memory Order 语义</h2><p>并不是所有的 ISA 都支持任何程度的 reorder，有些 ISA 的默认 memory order 也可能足够强，例如 x86。</p><p>x86 并不是 relaxed memory model，而是异常的 strong，甚至可以保证 total store order。</p><p>x86 的 memory order 语义如下：</p><ol><li>load-load 和 store-store 都不能 reorder。</li><li>load-store 不能 reorder。</li><li>store-load 可以 reorder。</li><li>thread a 的 store 和 thread b 的 store，在 thread a 和 thread b 中可以看到不同的顺序。</li><li>thread a 的 store 和 thread b 的 store，在 thread c 和 thread d 中必须看到一致的顺序。</li><li>store 的可见性可以传递。</li><li>store 和 load 指令，都不能在 lock 指令前后 reorder。</li></ol><h2 id="C-Memory-Order-语义和-x86-Memory-Order-语义的对应关系"><a href="#C-Memory-Order-语义和-x86-Memory-Order-语义的对应关系" class="headerlink" title="C++ Memory Order 语义和 x86 Memory Order 语义的对应关系"></a>C++ Memory Order 语义和 x86 Memory Order 语义的对应关系</h2><p>当编程语言的语义要求比 ISA 强的时候（编程语言不允许某种 reorder，而 ISA 默认是允许的），ISA 需要对指令进行额外的 barrier 包装以支持编程语言的语义。</p><p>反之，如果 ISA 默认支持的语义足够强，ban 掉的情况比编程语言的语义要求的还多，那么就不需要 ISA 生成额外的指令了。只是编程语言的语义中承认的“哪种情况可以 reorder”，在 ISA 层面上有可能不会发生。</p><h3 id="relaxed-1"><a href="#relaxed-1" class="headerlink" title="relaxed"></a>relaxed</h3><p>对于 relaxed，C++ 规定任何语句都可以 reorder，然而 x86 限制了 load-load、load-store、store-store 都不能 reorder。因此对于 relaxed 而言，指定了 relaxed 的 store 和 load 指令，只剩下了 store-load 可以 reorder。因此上面 C++ 语义中，relaxed 举的例子是不可能发生的。</p><p>当然地，为了实现 relaxed 语义，不需要任何额外指令。</p><h3 id="release-acquire-1"><a href="#release-acquire-1" class="headerlink" title="release-acquire"></a>release-acquire</h3><p>对于 x86 而言，由于不存在 store-store、load-load reorder，因此直接保证了“acquire load 可以看到 release store 之前的所有 store”以及“acquire load 之后的所有 load 都可以看到这个 acquire load” 这两个在 C++ Memory Order 语义上对 acquire-release 的要求，不需要任何额外指令。</p><p>另外，x86 语义是允许 store-load reorder（见 x86 memory order 语义 3）。不过，不用担心 x86 这个允许 reorder 的设定比较宽松，以至于 x86 上需要更多的同步指令来实现 release-acquire 语义——事实上，release-acquire 语义本身也是允许 store-load reorder 的</p><ol><li>acquire 语义是，任何 acquire 之后的读写不能拿到 load 前面，限制了 load-load 和 load-store 不能 reorder。</li><li>release 语义是，任何 release 之前的读写不能拿到 store 后面，限制了 load-store 和 store-store 不能 reorder。</li></ol><p>正好，acqurie-release 语义没限制 x86 语义允许的 store-load reorder。store 可以拿到 load 后面，load 也可以拿到 store 前面。因此，acquire-release 语义，对于 x86 来讲，是天然支持的，不需要额外指令。</p><p>可以认为，每一条 x86 的指令都是保证 release-acquire 语义的。</p><h3 id="release-consume-1"><a href="#release-consume-1" class="headerlink" title="release-consume"></a>release-consume</h3><p>普遍理性而论，正经的编译器和 ISA 都尊重这种数据依赖的先后顺序。唯一不尊重的就是 DEC Alpha。不需要太考虑 release-consume，直接当成 release-acquire 来看待。</p><p>因此，和 acquire-release 语义一样，对于 x86 来讲，不需要额外指令。</p><h3 id="sc-1"><a href="#sc-1" class="headerlink" title="sc"></a>sc</h3><p>最强内存顺序memory_order_seq_cst会补充x86 不满足 存储-加载顺序的缺失。</p><h2 id="x86-Memory-Order-语义和-x86-Memory-Ordering-硬件模型的对应关系"><a href="#x86-Memory-Order-语义和-x86-Memory-Ordering-硬件模型的对应关系" class="headerlink" title="x86 Memory Order 语义和 x86 Memory Ordering 硬件模型的对应关系"></a>x86 Memory Order 语义和 x86 Memory Ordering 硬件模型的对应关系</h2><p>关于上述 x86 Memory Order 语义，有以下的硬件解释：</p><h3 id="load-load、store-store-和-load-store-都不能-reorder"><a href="#load-load、store-store-和-load-store-都不能-reorder" class="headerlink" title="load-load、store-store 和 load-store 都不能 reorder"></a>load-load、store-store 和 load-store 都不能 reorder</h3><p>由于 load 操作是原子的、瞬发的，因此 load-load、load-store 是不能 reorder 的。</p><p>由于 Write Buffer 是 FIFO 的，而且 Write Buffer flush 到 Shared Memory 也是按照 FIFO 有序的，并且 Shared Memory 保证强一致性，任何 flush 都可以被瞬间看到，因此 store-store 是不能 reorder 的。</p><h3 id="store-load-可以-reorder"><a href="#store-load-可以-reorder" class="headerlink" title="store-load 可以 reorder"></a>store-load 可以 reorder</h3><p>体现在硬件上，是由于 store-load 指令可以拆成 3 部分：</p><ol><li>把 x 放到 Write Buffer</li><li>瞬时的 load y</li><li>把 Write Buffer flush 到 Shared Memory</li></ol><p>因此其他线程从最终的表现来看（只有 flush 到 Shared Memory，其他线程才能看到），是先 load 了 y，后 store 了 x。</p><h3 id="thread-a-的-store-和-thread-b-的-store，在-thread-a-和-thread-b-中可以看到不同的顺序"><a href="#thread-a-的-store-和-thread-b-的-store，在-thread-a-和-thread-b-中可以看到不同的顺序" class="headerlink" title="thread a 的 store 和 thread b 的 store，在 thread a 和 thread b 中可以看到不同的顺序"></a>thread a 的 store 和 thread b 的 store，在 thread a 和 thread b 中可以看到不同的顺序</h3><p>体现在硬件上，由于 Write Buffer flush 的时间不确定，因此，Thread a 的 store，目前还在 Thread a 的 Write Buffer 中，没有写到 Shared Memory；同时，Thread b 的 store，目前还在 Thread b 的 Write Buffer 中，没有写到 Shared Memory。</p><p>此时，Thread a 可以看到自己最近的 store，而 Thread b 可以看到自己最近的 store，而互相的 store 是看不到的。</p><h3 id="thread-a-的-store-和-thread-b-的-store，在-thread-c-和-thread-d-中必须看到一致的顺序"><a href="#thread-a-的-store-和-thread-b-的-store，在-thread-c-和-thread-d-中必须看到一致的顺序" class="headerlink" title="thread a 的 store 和 thread b 的 store，在 thread c 和 thread d 中必须看到一致的顺序"></a>thread a 的 store 和 thread b 的 store，在 thread c 和 thread d 中必须看到一致的顺序</h3><p>由于 Thread c 看到了 Thread a 的 store，说明 Thread a 的 store 已经 flush 到了 Shared Memory 中。而 Shared Memory 是强一致的，Thread c 能看到的瞬间，Thread d 必须能看到。并且 Write Buffer 的 flush 操作是有序的，所以 store 如果被其他 Thread 看见了，那么此时这个 store 必然是有 total order 的。</p><h3 id="store-的可见性可以传递"><a href="#store-的可见性可以传递" class="headerlink" title="store 的可见性可以传递"></a>store 的可见性可以传递</h3><p>如果 Thread 2 看到了 Thread 1 的 store，那么 Thread 3 必然也可以看到 Thread 1 的 store，这是 Shared Memory 是强一致的直接结论。</p><h3 id="任何-store-和-load-指令，都不能在-lock-指令前后-reorder"><a href="#任何-store-和-load-指令，都不能在-lock-指令前后-reorder" class="headerlink" title="任何 store 和 load 指令，都不能在 lock 指令前后 reorder"></a>任何 store 和 load 指令，都不能在 lock 指令前后 reorder</h3><p>由于 LOCK 指令上一个全局的 Memory 锁，因此没有人可以读写任何 Memory，之后的读写都是 ban 掉的。而 LOCK 的同时，当前 Thread 的 Write Buffer 全部 flush 到 Shared Memory，因此 LOCK 释放的时候，可以保证当前 Thread 任何 store 命令都执行完了，而 load 命令是瞬发的，本来就会在任何指令之前执行完。</p><p>基本上可以认为，把上图中的 Write Buffer 拿掉（或者说，每次 store 都写穿 Write Buffer，直接到内存里），那么上面的硬件模型，就是天然满足 sc 的，所有指令都有 sc 语义保证，根本不需要 Lock 这个东西。</p><p>同样的，也可以说，x86 模型就是 sc 的模型加上了一个 FIFO Write Buffer，以及为了支持 sc 语义，能够让 store 原子地写穿 FIFO Write Buffer 的一个 Lock。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>推荐阅读这个回答：<a href="https://www.zhihu.com/question/24301047/answer/3408781900">如何理解 C++11 的六种 memory order？</a>，同时，除了无锁并发外很少使用这个，<strong>不是必要掌握!</strong>，从 <a href="https://blog.hidva.com/2017/10/18/go-c-atomic/">The Go Memory Model</a> 可以看到, golang 是非常不鼓励使用基于原子操作来实现同步的:</p><blockquote><p><em>Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.</em><br><em>To serialize access, protect the data with channel operations or other synchronization primitives such as those in the sync and sync/atomic packages.</em><br><em>If you must read the rest of this document to understand the behavior of your program, you are being too clever.</em><br><em>Don’t be clever.</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Memory Order不难理解，需要的只是重新建立一种世界观，需要的只是强迫自己接受那些从来没关注过的东西，就像两个铁球同时落地一样。&lt;/
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浅析Cpp中的SFINAE</title>
    <link href="https://joytsing.github.io/posts/51621/"/>
    <id>https://joytsing.github.io/posts/51621/</id>
    <published>2024-04-01T09:05:48.000Z</published>
    <updated>2024-04-01T13:30:43.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SFINAE（Substitution Failure Is Not An Error，替换失败并非错误）一听就非常高级，什么是“替换”？这里的替换，实际上指的正是模板实例化；也就是说，当模板实例化失败时，编译器并不认为这是一个错误。这个概念晦涩难懂，因为它牵扯到编译器对模板的处理，而且很多时候不知道怎么去用（唉，语言学家），下面通过一个例子先学习下。</p><h2 id="进化之路"><a href="#进化之路" class="headerlink" title="进化之路"></a>进化之路</h2><h3 id="cpp-11"><a href="#cpp-11" class="headerlink" title="cpp 11"></a><strong>cpp 11</strong></h3><p>在正式编写代码前要介绍一个重要的库 <code>#include &lt;type_traits&gt;</code>。</p><p>该库是模板编程中最重要核心的库之一，若缺少本库就不会有如此丰富强大的泛型编程的实现。</p><p><strong>std:: enable_if&lt;&gt;</strong></p><p>此模板可以说是 SFINA 的灵魂一般的存在。</p><p>我们的目的是让模板参数符合某一种约束条件，而 enable_if 可以根据约束条件进行特定展开。根据这一特点，可以对模板的展开进行限制。具体的：</p><ul><li>如果满足约束条件，在 enable_if 中会存在等同于 T 的公开成员 <code>typedef type</code></li><li>如果不满足条件，则没有此 <code>typedef type</code></li></ul><p>std:: enable_if 可能的实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">></span><span class="token keyword">struct</span> enable_if <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> enable_if<span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>std:: is_xxx&lt;&gt;</strong></p><p>这是在 type_traits 中的一系列模板，这类模板可以对模板参数进行特定条件判断符合与否。</p><ul><li>若符合确定条件，则提供等于 <code>true</code> 的成员常量 <code>value</code></li><li>若不成功，则提供等于 <code>false</code> 的成员常量 <code>value</code></li></ul><blockquote><p>而对于本示例，我们可以使用<code>std::is_integral&lt;T&gt;</code>，本模板可以判断T是否为整数类型。<br>如果是整数类型，则要求展开失败，否则展开成功。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">namespace</span> my <span class="token punctuation">{</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 引入第二个模板参数     * 根据第二个模板参数展开失败与否     * 决定是否最终使用该模板     */</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Iter<span class="token punctuation">,</span>         <span class="token keyword">typename</span> SFINA <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span><span class="token operator">!</span>std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span>Iter<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span>    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当<code>my::vector&lt;Type&gt; vec0(5, val);</code>进行模板匹配时候，首先会找到<code>vector(Iter begin, Iter end)</code>并尝试展开，但该模板的第二个参数约束<code>Iter</code>不是整形类型时，才能展开成功。因此再重新寻找其他的匹配函数。</p><h3 id="cpp-14-cpp-17"><a href="#cpp-14-cpp-17" class="headerlink" title="cpp 14 ~ cpp 17"></a><strong>cpp 14 ~ cpp 17</strong></h3><p>对于每次写<code>std::is_integral&lt;T&gt;::value</code>和<code>std::enable_if&lt;B&gt;::type</code>都比较麻烦。因此 cpp 14 建议可以通过另一个简单的符号表示该内容。也就是<code>type trait variable templates</code>的概念。直到 cpp 17 才在正式标准中进行了全面的完善。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// cpp14</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token operator">></span><span class="token keyword">using</span> enable_if_t <span class="token operator">=</span> <span class="token keyword">typename</span> enable_if<span class="token operator">&lt;</span>B<span class="token punctuation">,</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// cpp17</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> is_integral_v <span class="token operator">=</span> is_integral<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此我们可以得到以下的简洁版本。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">namespace</span> my <span class="token punctuation">{</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 相对于cpp11更加简洁的写法     * 同时第二个模板参数没有具体使用到，可以省略成一个匿名形式     */</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Iter<span class="token punctuation">,</span>         <span class="token keyword">typename</span> <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span><span class="token operator">!</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>Iter<span class="token operator">>></span><span class="token operator">></span>    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cpp-20"><a href="#cpp-20" class="headerlink" title="cpp 20"></a><strong>cpp 20</strong></h3><p>c++ 是一门不断发展的现代语言，在 cpp 20 中提出了概念和约束到标准中。</p><p><strong>requires</strong></p><p><code>requires</code> 是一个关键字。可以直接在模板函数中进行使用。</p><p>requires是在template和函数体之间编写，提升可代码可阅读性。</p><p>注意一点，requires 子句需要是一个初等表达式 或者 带括号的表达式。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;concepts></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">namespace</span> my <span class="token punctuation">{</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用 requires 关键字</span>    <span class="token comment" spellcheck="true">// 直接写出约束条件</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Iter<span class="token operator">></span>    <span class="token function">requires</span> <span class="token punctuation">(</span><span class="token operator">!</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>Iter<span class="token operator">></span><span class="token punctuation">)</span>    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>concept</strong></p><p><code>concept</code> 是一个关键字。可以通过该关键字定义一个基于模板参数的约束条件。再将该约束条件运用到具体的模板函数中。</p><p>这样可以使约束条件和具体的模板函数进行分离，大大化简编码的复杂度。同时这个约束条件可以进行复用，再次减少了代码的冗余度。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;concepts></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">namespace</span> my <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 定义一个约束条件</span><span class="token comment" spellcheck="true">// 约束为不能是整形数值</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span>concept IterType <span class="token operator">=</span> <span class="token operator">!</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>Type<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 直接写定义的约束条件</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span>IterType Iter<span class="token operator">></span>    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>requires 表达式</strong></p><p><code>requires 表达式</code> 是将上述的<code>concept</code>和<code>requires</code>结合使用。</p><p>requires 表达式的编写形式与函数编写非常相似，将约束条件挨个写在requires后的大括号域内。</p><p>这种展现形式简洁明了，容易扩充。能同时兼具单独使用<code>concept</code>和<code>requires</code>的优点。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;concepts></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">namespace</span> my <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// requires 表达式</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span>concept IterType <span class="token operator">=</span> requires <span class="token punctuation">{</span>     std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>Type<span class="token operator">></span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用 requires 表达式</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span>IterType Iter<span class="token operator">></span>    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>假如设计一个加法接口，可以对两个基础类型数据、两个支持加法的自定义类型数据、两个相同容器里的数据、两个相同类型的数组里的数据进行加操作，应当怎么做？这个加法接口有两个输入，返回相加后的结果，对于数组或者容器类型的数据返回的是逐个相加的结果。</p><p>根据这个要求，我们首先可以写出以下的函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>T <span class="token function">add</span><span class="token punctuation">(</span> T a<span class="token punctuation">,</span> T b <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样写会带来一个问题：当形参a和b不是相同的类型的时候，会造成匹配不上的结果</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时编译器会报错：</p><pre class="line-numbers language-cpp"><code class="language-cpp">main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">13</span><span class="token operator">:</span><span class="token number">21</span><span class="token operator">:</span> error<span class="token operator">:</span> no matching function <span class="token keyword">for</span> call to ‘<span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span><span class="token punctuation">)</span>’  <span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token operator">^</span>main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">4</span><span class="token operator">:</span><span class="token number">3</span><span class="token operator">:</span> note<span class="token operator">:</span> candidate<span class="token operator">:</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> T <span class="token function">add</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> T<span class="token punctuation">)</span> T <span class="token function">add</span><span class="token punctuation">(</span> T a<span class="token punctuation">,</span> T b <span class="token punctuation">)</span>   <span class="token operator">^</span><span class="token operator">~</span><span class="token operator">~</span>main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">4</span><span class="token operator">:</span><span class="token number">3</span><span class="token operator">:</span> note<span class="token operator">:</span>   <span class="token keyword">template</span> argument deduction<span class="token operator">/</span>substitution failed<span class="token operator">:</span>main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">13</span><span class="token operator">:</span><span class="token number">21</span><span class="token operator">:</span> note<span class="token operator">:</span>   deduced conflicting types <span class="token keyword">for</span> parameter ‘T’ <span class="token punctuation">(</span>‘<span class="token keyword">int</span>’ <span class="token operator">and</span> ‘<span class="token keyword">float</span>’<span class="token punctuation">)</span>  <span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到我们在调用add方法的时候，我们的模板函数钟的T只有一种类型，没办法推导出两种类型，编译失败。</p><p>我们接着对这个函数进行改进，让它能够支持两种类型的输入，我们想着既然一个模板参数对应一个类型，那么我们再加一个模板参数不就可以对应两个不同类型的参数了吗，答案是可以的，正当我们兴奋的想写下这个函数的时候，问题来了，返回类型怎么写？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>返回类型？<span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当两个不同类型的值相加的时候，怎么确定函数的返回类型呢，我们知道一般我们写一个float的数和int类型的数相加得到的一定是一个float数，但是在模板中输入有成千上万种可能，我们没办法写出一个具体的类型来指代。这种事情最好还是让编译器来自己决定，那就是<strong>尾置返回类型：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">decltype</span><span class="token punctuation">(</span> a <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的auto只是一个占位符，并不是指实际的类型，真正的类型是靠<code>decltype</code>来推导出来的，<code>decltype</code>是c++11之后引入的关键词，作用是在编译期推导出括号里的表达式、变量或者类型本身的类型。这里它会自动推导出表达式( a + b )的类型，并取代前面的auto作为返回值类型。</p><p>在c++14之后，这个函数可以取消尾置返回类型，auto也具备了自动推导返回值类型的能力：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里一切都很好，我们这个模板函数可以支持两种不同类的输入，并且能够自动推导返回类型了，但是这还不够，因为对于容器类型的数据来说，我们还没办法对其进行支持，因此我们要写一个可以支持两个容器类型数据加法的重载函数模板：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// #接口实现2</span><span class="token punctuation">{</span>    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，会选择接口实现2而不是接口实现1</span><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> c1 <span class="token punctuation">)</span> std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>val<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok; 输出 2 4 6 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，这里的Container1和Container2是模板模板参数。T1和T2是模板模板参数中的具体参数。接口实现2可以看成是对接口实现1的重载，在调用时，如果输入是两个容器类型的数据，编译器会认为接口实现2匹配的更好，从而实例化接口实现2的函数模板。</p><p>但是这样同时会带来新的问题，当我们想对两个由自定义的模板类定义的对象操作add接口的时候，会出现棘手的现象。</p><h2 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h2><p>首先，只考虑有接口实现1的情况下，我们自己定义了一个模板类，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token function">B</span><span class="token punctuation">(</span> <span class="token keyword">const</span> T b_ <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">b</span><span class="token punctuation">(</span> b_ <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> B rhs <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 加法运算符重载1</span>        <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">B</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>        <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> B<span class="token operator">&lt;</span>U<span class="token operator">></span> rhs <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 加法运算符重载2 </span>        <span class="token punctuation">{</span>                <span class="token keyword">return</span> B<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意这里让编译器去决定加法之后的模板参数类型是什么</span>        <span class="token punctuation">}</span>        T b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们重载了加法运算符，让它得以支持加法操作，同时我们还实现了一个加法运算符的模板函数重载，让这个类型的变量能对不同的T类型实现加法操作，譬如:</p><pre class="line-numbers language-cpp"><code class="language-cpp">B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">;</span>a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，a1和a2是相同类型的数据,调用加法运算符重载1</span>B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> a3<span class="token punctuation">;</span>a1 <span class="token operator">+</span> a3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，a1和a3不是相同类型的数据，调用加法运算符重载2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在一个只考虑有接口实现1的版本中，我们调用add方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1<span class="token punctuation">;</span>   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1<span class="token punctuation">;</span>   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, a1和b1虽然是不同的类型，但是因为重载了运算符，可以做加法</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在一个既有接口实现1又有接口实现2的版本中，我们调用add方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// #接口实现2</span><span class="token punctuation">{</span>    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现2上</span>   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>   <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error，编译器同样会匹配到接口实现2，但是B类型中没有begin,end等函数，报错</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们本来想让接口实现1只为基础类型或者支持加法的自定义类型服务，而让接口实现2为容器类型服务的。现在好了，在为自定义模板类型的变量调用接口的时候，也会匹配到接口实现2上去，与我们的预期大大不同。</p><p>这个问题的根本原因在于我们的接口实现2的形参在与实参进行匹配的时候，因为我们的自定义类型是模板类，与模板模板参数匹配的更好，这样编译器会优先决策匹配的更好的模板函数实现，而这整个过程就是有c++<strong>重载决议机制</strong>实现的。</p><p>那我们有没有办法去人为的控制这种重载呢，让最终的调用能够选择正确的匹配函数呢？答案是可以的，这就是我们要利用SFINAE机制来做的事情了，而这正是本文接下来要说的重点。</p><p>在讲SFINAE之前，我们要大致了解一下我们实现的这个add接口从定义到实例化再到最终调用编译器做了哪些事情，这有助于后面理解SFINAE机制。</p><h2 id="实例化过程"><a href="#实例化过程" class="headerlink" title="实例化过程"></a>实例化过程</h2><ol><li>两阶段命名查找(<strong>Two-Phase Name Lookup</strong>)</li></ol><p>在c++中，将各种变量、函数、模板等命名分为受限型命名(qualified name)，非受限型命名(unqualified name)，依赖型命名(dependent name)，非依赖型命名(non-dependent)几种。所谓受限型命名，指的是在作用域符(::)或者成员访问运算符(-&gt;和.)之后的名称（即属于类成员或者命名空间内的变量或者函数）。非受限型命名则是除了受限型名之外的名称。依赖型命名是指以某种方式依赖于模板参数的名称。相同的，非依赖型命名就是不属于依赖性名称的名称。</p><p>我们这里的add接口在调用的时候既没有用作用域符，也没有用成员访问运算符，因此是一个非受限型名称，同时add接口又依赖模板参数，因此也属于依赖性名称，因此可以称之为unqulified dependent name。对于这类名称，编译器在首次看到的时候会先对其进行一次查找，这时候由于模板还没有实例化，这个时候找到的只是这个add函数的“蓝图”，即我们所写的函数模板，这个阶段只能对其做基础的模板解析和语法检查，等模板经历了实参推导和替换之后，才会生成实际的函数，这时候还需要在进行一次查找以找到实例化后的函数，这个过程就是<strong>两阶段命名查找</strong>。</p><p>第一阶段的命名查找一般使用普通查找规则(Ordinary Lookup rule)，第二阶段会使用著名的<code>实参依赖</code>(Aurgument Dependent Lookup, ADL)查找规则来进行查找，具体的原理不是本文的重点，这里不再深入，有兴趣的朋友可以自己去了解。通过命名查找机制找到的实例化之后的函数会放入<strong>重载集</strong>中(Overload Set)，随后会以候选者的角色送入重载决议中进行裁决。</p><ol start="2"><li>两阶段编译检查(Two-Phase Translation)</li></ol><p>两阶段编译检查是配合两阶段命名查找的一种机制，同样以add接口为例，在第一次查找这个函数模板的时候，会对其进行解析，同时检查它的语法合法性，这时候不管类型是不是支持加法操作，编译器都不会报错，因为编译器此时还不知道模板的参数具体是什么。</p><p>在第二阶段命名查找之后，编译器已经能够找到了add模板实例化之后函数，经过重载决议之后，编译器会从这些实例化函数中选取一个最合适的重载函数作为最终要执行的函数，这时候会进行第二阶段的编译器检查，这时候检查就会更加严格，会检查函数内部的表达式是否能够成立，例如上面的例子中：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现2上</span>   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>   <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error，编译器同样会匹配到接口实现2，但是B类型中没有begin,end等函数，报错</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中的auto c2 = add( a2, b2 ); 就是在这个第二段编译检查阶段才报错的。</p><ol start="3"><li>模板实参推导(Template Argument Deduction, TAD)</li></ol><p>为啥需要模板实参推导这个机制呢？最主要的原因是我们想要在使用add这个模板函数的时候要像使用普通函数一样简单，虽然可以通过显示的指定模板的参数来调用，但是这种方法显得非常的繁琐。我们先举一个简单的例子来直观感受一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span> T t <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// f&lt;int>(1); 模板参数T被推导为int</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// f&lt;double>(1.1); 模板参数T被推导为double</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// error: T cannot be duduced</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上模板实参推导涉及到许许多多的内容，会遇到诸如类型退化、左值引用传参、右值引用传参、万能引用、完美转发、可变参数等诸多情况，模板实参推导的规则非常复杂，其原理也不在本文中详细说明。</p><ol start="4"><li>模板实参替换(Template Argument Substitution, TAS)</li></ol><p>在用推导出的实参替换模板参数之后，再使用推导出来的类型替换模板参数，从而完成实例化一个函数模板的过程。</p><p>这里就要讲到本文的重点了：<strong>参数替换过程中，并不总是能够替换成功</strong>的，举个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span> T a <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 重载1</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span> T<span class="token operator">::</span>value_type a <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 重载2</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">test</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 重载2替换失败，选择重载1</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里编译器会通过命名查找机制找到重载1和重载2两种函数模板，然后模板参数T都可以被推导为int类型，但是由于int类型中没有value_type这个类型，会造成参数替换失败，此时编译器并不会立即报错，只是将其从重载集中移除，后面的重载决议也就不会再选择它，这个机制就是SFINAE。</p><p>我们利用这种机制可以<strong>实现对模板参数类型的限制</strong>，也可以通过强行<strong>禁用某些模板</strong>来实现人为的重载选择。</p><ol start="5"><li>重载决议</li></ol><p>重载决议的核心就是在重载集中找到唯一的一个与调用情况最优匹配的实现函数，如果重载决议找不到最匹配的函数，则编译器会报” no matching function for call to xxx”的错误。</p><h2 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h2><p>我们的思路是想利用SFINAE机制来让下面这个调用：</p><pre class="line-numbers language-cpp"><code class="language-cpp">B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span><span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>排除掉接口实现2，方法是强行让编译器对这个调用在和接口实现2的函数模板进行模板实参替换的时候失败，这样重载决议中就会忽略掉这个模板实现，从而让它选择接口实现1。具体的实现需要借助标准模板库里提供的两个工具：<code>std::enable_if</code>以及<code>std::voit_t;</code></p><p>enable_if的一个可能的实现是这样的（参考cppreference）:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">></span><span class="token keyword">struct</span> enable_if <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> enable_if<span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">using</span> type <span class="token operator">=</span> T<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token operator">></span><span class="token keyword">using</span> enable_if_t <span class="token operator">=</span> <span class="token keyword">typename</span> enable_if<span class="token operator">&lt;</span>B<span class="token punctuation">,</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// c++14：别名而已，可以少写一个type</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个元函数是一个类型萃取(Type Trait)，在模板的第一个参数B为true的时候，它的type成员会返回一个类型：如果没有第二个模板参数，返回类型是默认的void，否则，返回的是其第二个参数的类型。如果参数B为false的时候，其成员类型是未定义的，根据SFINAE机制，编译期会忽略包含该std::enable_if_t&lt;&gt;表达式的模板。说人话：</p><p>意思就是我们可以设立一个条件，当条件满足的时候，就让编译器生成这个函数实例，否则忽略它。非常方便！<strong>我们只要在我们的add接口实现2上去用这个工具判断输入的模板实参是不是容器类型就行了，如果是容器类型，那么就实例化这个函数模板，如果不是，则忽略它。</strong></p><p>那么问题就变成了怎么去判断输入类型是不是容器类型。我们可以简单的认为一个类中如果有迭代器，并且具有begin()或者end()这样的成员方法，那么这就是一个容器类型（当然并不严谨，因为stack和queue中并没有迭代器，这里只是作为一个例子，并不考虑这种情况，严谨点的也可以单独将stack和queue拎出来做特化处理即可，问题都不大）。</p><p>我们可以利用成员探测技术（Detecting Members）来让编译器在自己去探测一个类型是否具有迭代器成员和begin()成员。我们可以写出下面这种元函数代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 判断类型否是一个容器类型的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_container_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 普通版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 偏特化版本</span><span class="token keyword">struct</span> is_container_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">:</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::void_t也是一种利用SFINAE机制实现的元函数，它的一种可能的实现如下所示（参考cppreference）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token keyword">using</span> void_t <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它就是一个别名模板（alias template），是void类型的一个别名，但是它的模板参数是一个可变参数，这同时也是一个可变参数模板（variable template）。这个元函数的意思是它可以接收任意个类型作为模板参数，编译器会在实参替换阶段检查看你输入的每个类型能否被替换成功，如果替换失败，编译器会忽略这个模板。</p><p>回到我们这个判断类型否是一个容器类型的元函数里，如果模板参数T1和T2中含有iterator类型，并且有begin()函数，那么std::void_t中的模板参数可以被替换成功，从而void_t类型就成了void的别名，进一步的编译器会选择is_container_type这个模板类的偏特化版本。注意这里偏特化的版本继承了std::true_type这个类（这是个语法糖），这个类里面有个编译期布尔常量value，其值为true。</p><p>如果模板参数T1和T2中没有iterator类型或者没有begin()函数，那么std::void_t中模板参数会替换失败，但是由于SFINAE，编译器不会报错，此时编译器会选择is_container_type这个模板类的普通版本，这个普通版本继承了std::false_type这个类，这里类里面的编译期布尔常量value的值为false。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_container_type<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">>></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, 打印1</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_container_type<span class="token operator">&lt;</span>B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">>></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印0</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_container_type<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以把这个判断类型的元函数与std::enable_if_t结合在一起来对类型做一些限制，从而可以帮助编译器排除一些模板，选择正确的模板。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 判断类型否是一个容器类型的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_container_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 普通版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 偏特化版本</span><span class="token keyword">struct</span> is_container_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">:</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_container_type<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">>></span><span class="token operator">::</span>value<span class="token punctuation">,</span> Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// #接口实现2</span><span class="token punctuation">{</span>    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现2上</span>   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>   <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，由于B类型不是容器类型，编译器会匹配到接口实现1上</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题解决！现在我们可以让B<T>这种自定义的模板类的数据在调用add接口的时候不再匹配到接口实现1上去了。这就是SFINAE机制的强大威力。</T></p><p>但是对于接口的提供者来说，这还远远不够，因为你永远不知道用户在调用这个接口的时候会传进去个什么玩意，我们必须对输入的类型做一些限制：a. 比如我们这里的接口实现1中，我们不能允许两个不支持加法操作的类型数据传进来，b. 同样在接口实现2中，我们不能允许两个异型容器进行加法操作。</p><p>针对条件a，我们仿照仿照上面的方法可以写出判断两个类型是否支持加法的元函数，针对b，我们可以写出判断两个容器类型是否是同型容器的元函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 判断两个类型是否支持加法的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_add_supported_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 如果支持加法，is_add_supported_type继承的value = 1</span><span class="token keyword">struct</span> is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">::</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断两个容器是否是相同类型容器的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token operator">></span><span class="token keyword">struct</span> is_same_container_type<span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> value <span class="token operator">=</span> std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 测试</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_add_supported_type<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印1</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">>></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, 打印0，两个容器不支持直接加</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_same_container_type<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, 打印1</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_same_container_type<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token punctuation">,</span> std<span class="token operator">::</span>list<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ok, 打印0, vector和list不是同型容器</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里的判断两个容器是否是同型容器的元函数中用到了std::is_same_v，这个元函数属于预测型萃取，可以用来判断两个类型是否相同，其源码为：（参考cppreference）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span><span class="token keyword">struct</span> is_same <span class="token operator">:</span> std<span class="token operator">::</span>false_type <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token operator">:</span> std<span class="token operator">::</span>true_type <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span> <span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> is_same_v <span class="token operator">=</span> is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// c++ 17</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们利用上面所写的两个元函数来改进我们的接口：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 判断两个类型是否支持加法的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_add_supported_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 如果支持加法，is_add_supported_type继承的value = 1</span><span class="token keyword">struct</span> is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">::</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 判断类型否是一个容器类型的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_container_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 普通版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 偏特化版本</span><span class="token keyword">struct</span> is_container_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">:</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断两个容器是否是相同类型容器的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token operator">></span><span class="token keyword">struct</span> is_same_container_type<span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> value <span class="token operator">=</span> std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_container_type<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">>></span><span class="token operator">::</span>value <span class="token operator">&amp;&amp;</span> is_same_container_type<span class="token operator">&lt;</span>Container1<span class="token punctuation">,</span> Container2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// #接口实现2</span><span class="token punctuation">{</span>    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> a0 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token keyword">float</span> b0 <span class="token operator">=</span> <span class="token number">20.2</span><span class="token punctuation">;</span>   <span class="token keyword">auto</span> c0 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0<span class="token punctuation">,</span> b0 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, a0 和 b0是可加的</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现2上</span>   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>   <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现1上</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写到这里发现这个接口已经像那么回事了，但是还是存在问题，因为我们针对容器类型的函数模板中，使用了emplace_back这个函数，不幸的是并不是所有的容器类型里面都支持这个函数，比如std::set，std::map里面只有insert方法。我们需要根据容器类型里有没有emplace_back函数来区分处理。这时候，可以先写一个判断类型中是否有emplace_back方法的元函数，然后利用<strong>编译期if</strong>来分别做处理：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 判断类型中是否有emplace_back成员的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> has_emplace_back_method <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> has_emplace_back_method<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token operator">:</span> std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// # 改进后的接口实现2</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_container_type<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">>></span><span class="token operator">::</span>value <span class="token operator">&amp;&amp;</span> is_same_container_type<span class="token operator">&lt;</span>Container1<span class="token punctuation">,</span> Container2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// </span><span class="token punctuation">{</span>    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 编译期if，由于我们事先已经约束了Container1和Container2是同型容器，因此只要判断一个就行</span>        <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 测试</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> b2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 也可以支持了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译期if是在c++17标准之后引入的东西，与std::enable_if其实非常类似，其原理也是利用了SFINAE机制，在某些时候甚至可以和std::enable_if互换着用。比如这里如果不用编译期if表达式的话，我们可以再写一个针对具有insert方法的容器类型的重载函数模板，通过std::enable_if来控制编译器选择哪个模板来实例化。</p><p>编译期if的好处是可以根据条件来启用或禁止某些特定语句，而不用像std::enable_if一样重新写一个模板，此外它的可读性更好一些。</p><p>当我们觉得这个函数接口已经写完了的时候，又发现了重大的问题，我们这个接口虽然对容器类型的数据很好的支持了，但是对数组却不支持，好家伙，这是万万不能行的。不过问题其实不大，我们只要对数组类型的数据整一个特化的版本就好了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N1<span class="token punctuation">,</span> <span class="token keyword">int</span> N2<span class="token operator">></span><span class="token keyword">struct</span> min_val <span class="token comment" spellcheck="true">// 元函数：求两个数中的最小值</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> value <span class="token operator">=</span> N1 <span class="token operator">&lt;</span> N2 <span class="token operator">?</span> N1 <span class="token operator">:</span> N2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 元函数：求两个数中的最大值</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">max_val</span><span class="token punctuation">(</span> <span class="token keyword">int</span> N1<span class="token punctuation">,</span> <span class="token keyword">int</span> N2 <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 常量表达式,C++14</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> N1 <span class="token operator">></span> N2 <span class="token operator">?</span> N1 <span class="token operator">:</span> N2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 针对数组类型的模板特化</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">int</span> N1<span class="token punctuation">,</span>         <span class="token keyword">typename</span> T2<span class="token punctuation">,</span> <span class="token keyword">int</span> N2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span><span class="token function">add</span><span class="token punctuation">(</span> <span class="token function">T1</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">T2</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span>N2<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注意这里要用static修饰要返回用结果变量，不然你返回一个临时变量的指针，运行时会出错</span>    <span class="token keyword">static</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span><span class="token function">max_val</span><span class="token punctuation">(</span> N1<span class="token punctuation">,</span> N2 <span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> min_val<span class="token operator">&lt;</span>N1<span class="token punctuation">,</span> N2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N1<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 处理剩余的元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N2<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回数组退化后的指针(注意c++是不允许返回数组类型的)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>min_val和max_val是典型的值元编程技巧，可以用来在编译期间进行值计算。其中常量表达式可读性更好一些。</p><p>到这里，我们的add接口才算是写完了，现在将完整的代码贴在下面供大家参考：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> MY_ADD_H</span><span class="token macro property">#<span class="token directive keyword">define</span> MY_ADD_H</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token comment" spellcheck="true">// 判断两个类型是否支持加法的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_add_supported_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 如果支持加法，is_add_supported_type继承的value = 1</span><span class="token keyword">struct</span> is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">::</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 判断类型否是一个容器类型的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> is_container_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 普通版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 偏特化版本</span><span class="token keyword">struct</span> is_container_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">:</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断两个容器是否是相同类型容器的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token operator">></span><span class="token keyword">struct</span> is_same_container_type<span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> value <span class="token operator">=</span> std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断类型中是否有emplace_back成员的元函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span><span class="token keyword">struct</span> has_emplace_back_method <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> has_emplace_back_method<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token operator">:</span> std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// # 改进后的接口实现2</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_container_type<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">>></span><span class="token operator">::</span>value <span class="token operator">&amp;&amp;</span> is_same_container_type<span class="token operator">&lt;</span>Container1<span class="token punctuation">,</span> Container2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// </span><span class="token punctuation">{</span>    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 编译期if，由于我们事先已经约束了Container1和Container2是同型容器，因此只要判断一个就行</span>        <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N1<span class="token punctuation">,</span> <span class="token keyword">int</span> N2<span class="token operator">></span><span class="token keyword">struct</span> min_val <span class="token comment" spellcheck="true">// 元函数：求两个数中的最小值</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> value <span class="token operator">=</span> N1 <span class="token operator">&lt;</span> N2 <span class="token operator">?</span> N1 <span class="token operator">:</span> N2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 元函数：求两个数中的最大值</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">max_val</span><span class="token punctuation">(</span> <span class="token keyword">int</span> N1<span class="token punctuation">,</span> <span class="token keyword">int</span> N2 <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 常量表达式,C++14</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> N1 <span class="token operator">></span> N2 <span class="token operator">?</span> N1 <span class="token operator">:</span> N2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 针对数组类型的模板特化版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">int</span> N1<span class="token punctuation">,</span>         <span class="token keyword">typename</span> T2<span class="token punctuation">,</span> <span class="token keyword">int</span> N2<span class="token operator">></span>std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span><span class="token function">add</span><span class="token punctuation">(</span> <span class="token function">T1</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">T2</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span>N2<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span><span class="token function">max_val</span><span class="token punctuation">(</span> N1<span class="token punctuation">,</span> N2 <span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> min_val<span class="token operator">&lt;</span>N1<span class="token punctuation">,</span> N2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N1<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 处理剩余的元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N2<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回数组退化后的指针</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"my_add.h"</span></span><span class="token keyword">struct</span> A<span class="token punctuation">{</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">A</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a_ <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span> a_ <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    A <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> A<span class="token operator">&amp;</span> rhs <span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">A</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>a <span class="token operator">+</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> B<span class="token punctuation">{</span>        <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token function">B</span><span class="token punctuation">(</span> <span class="token keyword">const</span> T b_ <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">b</span><span class="token punctuation">(</span> b_ <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> B rhs <span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token comment" spellcheck="true">// 加法运算符重载1</span>        <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">B</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>        <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> B<span class="token operator">&lt;</span>U<span class="token operator">></span> rhs <span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token comment" spellcheck="true">// 加法运算符重载2 </span>        <span class="token punctuation">{</span>                <span class="token keyword">return</span> B<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意这里让编译器去决定加法之后的模板参数类型是什么</span>        <span class="token punctuation">}</span>        T b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a0 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">float</span> b0 <span class="token operator">=</span> <span class="token number">2.1</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c0 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0<span class="token punctuation">,</span> b0 <span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>c0<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印3.1</span>    A <span class="token function">a1</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b1</span><span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>c1<span class="token punctuation">.</span>a<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印30</span>    B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a2</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> <span class="token function">b2</span><span class="token punctuation">(</span> <span class="token number">22.2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>c2<span class="token punctuation">.</span>b<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印30.2</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a0_vec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b0_vec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c0_vec <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0_vec<span class="token punctuation">,</span> b0_vec <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印2, 4, 6, 4</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> c0_vec <span class="token punctuation">)</span> std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>val<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a0_set <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b0_set <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c0_set <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0_set<span class="token punctuation">,</span> b0_set <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印2, 4, 6, 4</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> c0_set <span class="token punctuation">)</span> std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>val<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">a1_vec</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">b1_vec</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c1_vec <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1_vec<span class="token punctuation">,</span> b1_vec <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>    <span class="token keyword">int</span> a0_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> b0_array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c0_array <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0_array<span class="token punctuation">,</span> b0_array <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印2, 4, 6, 4</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>c0_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>     A a1_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    A b1_array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> c1_array <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1_array<span class="token punctuation">,</span> b1_array <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上就是我们为了实现一个范型的add接口所做的全部工作，当然了可以发现template那写的一坨阅读性非常差，所以在C++20版本中添加了新的特性: concept和require，赞美20。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;SFINAE（Substitution Failure Is Not An Error，替换失败并非错误）一听就非常高级，什么是“替换”？这
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(三)</title>
    <link href="https://joytsing.github.io/posts/7859/"/>
    <id>https://joytsing.github.io/posts/7859/</id>
    <published>2024-04-01T09:03:35.000Z</published>
    <updated>2024-04-07T12:55:51.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>说实话，这章我没太看懂，可能还是需要反复多次阅读。</p><h2 id="内核和用户进程协作之epoll"><a href="#内核和用户进程协作之epoll" class="headerlink" title="内核和用户进程协作之epoll"></a>内核和用户进程协作之epoll</h2><p>IO多路复用机制可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。这里的复用指的是对进程的复用，在Linux上多路复用方案有select、poll、epoll。它们三个中的epoll的性能表现是最优秀的，能支持的并发量也最大，epoll的简单示例如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">listen</span><span class="token punctuation">(</span>lfd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cfd1 <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cfd2 <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    efd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>efd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> cfd1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>efd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> cfd2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">epoll_wait</span><span class="token punctuation">(</span>efd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中和epoll相关的函数是如下三个：</p><ul><li><code>epoll_create</code>：创建一个epoll对象</li><li><code>epoll_ctl</code>：向epoll对象添加要管理的连接</li><li><code>epoll_wait</code>：等待其管理的连接上的IO事件</li></ul><h3 id="1）epoll内核对象的创建"><a href="#1）epoll内核对象的创建" class="headerlink" title="1）epoll内核对象的创建"></a>1）epoll内核对象的创建</h3><p>在用户进程调用<code>epoll_create</code>时，内核会创建一个<code>struct eventpoll</code>内核对象，并把它关联到当前进程的已打开文件列表中，如下图所示：</p><p><img src="/posts/7859/d729732bab9941f7a1cfbc568da0ae79.png" alt></p><p>对于<code>struct eventpoll</code>对象，更详细的结构如下图所示：</p><p><img src="/posts/7859/4ee694ad35ed48768bd42f30c1e12cb3.png" alt></p><p><code>poll_create</code>源码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>epoll_create1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> error<span class="token punctuation">,</span> fd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 创建一个eventpoll对象</span>    error <span class="token operator">=</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>struct eventpoll</code>的定义如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">struct</span> eventpoll <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// sys_epollo_wait用到的等待队列</span>    wait_queue_head_t wq<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 接收就绪的描述符都会放到这里</span>    <span class="token keyword">struct</span> list_head rdllist<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每个epollo对象中都有一棵红黑树</span>    <span class="token keyword">struct</span> rb_root rbr<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>eventpoll</code>这个结构体的几个成员的含义如下：</p><ul><li><code>wq</code>：等待队列链表。软中断数据就绪的时候会通过wq来找到阻塞在epoll对象上的用户进程</li><li><code>rbr</code>：一棵红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll内部使用了一棵红黑树。通过这棵树来管理用户进程添加进来的所有socket连接</li><li><code>rdllist</code>：就绪的描述符的链表。当有连接就绪的时候，内核会把就绪的连接放到rdllist链表里。这样应用进程只需要判断链表就能找出就绪连接，而不用去遍历整棵树</li></ul><p><code>eventpoll</code>初始化工作在<code>ep_alloc</code>中完成：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> eventpoll <span class="token operator">*</span><span class="token operator">*</span>pep<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 申请eventpoll内存</span>    ep <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ep<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 初始化等待队列头</span>    <span class="token function">init_waitqueue_head</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_waitqueue_head</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>poll_wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化就绪队列</span>    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>rdllist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化红黑树指针</span>    ep<span class="token operator">-></span>rbr <span class="token operator">=</span> RB_ROOT<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）为epoll添加socket"><a href="#2）为epoll添加socket" class="headerlink" title="2）为epoll添加socket"></a>2）为epoll添加socket</h3><p><strong>理解这一步是理解整个epoll的关键</strong>。为了简单起见，这里只考虑使用EPOLL_CTL_ADD添加socket，先忽略删除和更新。假设现在和客户端的多个连接的socket都创建好了，也创建好了epoll内核对象。在使用epoll_ctl注册每一个socket的时候，内核会做如下三件事情：</p><ol><li>分配一个红黑树节点对象<code>epitem</code></li><li>将等待事件添加到<code>socket</code>的等待队列中，其回调函数是<code>ep_poll_callback</code></li><li>将<code>epitem</code>插入epoll对象的红黑树</li></ol><p>通过<code>epoll_ctl</code>添加两个<code>socket</code>以后，这些内核数据结构最终在进程中的关系大致如下图所示：</p><p><img src="/posts/7859/acb2653d9cef4aa39b77adf579812f64.png" alt></p><p>来看看socket是如何添加到epoll对象里的，找到<code>epoll_ctl</code>的源码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>epoll_ctl<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span>        <span class="token keyword">struct</span> epoll_event __user <span class="token operator">*</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token operator">*</span>tfile<span class="token punctuation">;</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 根据epfd找到eventpoll内核对象</span>    file <span class="token operator">=</span> <span class="token function">fget</span><span class="token punctuation">(</span>epfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 根据socket句柄号,找到其file内核对象</span>    tfile <span class="token operator">=</span> <span class="token function">fget</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    ep <span class="token operator">=</span> file<span class="token operator">-></span>private_data<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>op<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> EPOLL_CTL_ADD<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>epi<span class="token punctuation">)</span> <span class="token punctuation">{</span>            epds<span class="token punctuation">.</span>events <span class="token operator">|</span><span class="token operator">=</span> POLLERR <span class="token operator">|</span> POLLHUP<span class="token punctuation">;</span>            error <span class="token operator">=</span> <span class="token function">ep_insert</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> <span class="token operator">&amp;</span>epds<span class="token punctuation">,</span> tfile<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span>            error <span class="token operator">=</span> <span class="token operator">-</span>EEXIST<span class="token punctuation">;</span>        <span class="token function">clear_tfile_check_list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>epoll_ctl</code>中首先根据传入fd找到<code>eventpoll</code>、<code>socket</code>相关的内核对象。对于<code>EPOLL_CTL_ADD</code>操作来说，会执行到<code>ep_insert</code>函数。所有的注册都是在这个函数中完成的:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event <span class="token operator">*</span>event<span class="token punctuation">,</span>             <span class="token keyword">struct</span> file <span class="token operator">*</span>tfile<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> epitem <span class="token operator">*</span>epi<span class="token punctuation">;</span>    <span class="token keyword">struct</span> ep_pqueue epq<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 1.分配并初始化epitem</span>    <span class="token comment" spellcheck="true">// 分配一个epi对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>epi <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>epi_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 对分配的epi对象进行初始化</span>    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-></span>pwqlist<span class="token punctuation">)</span><span class="token punctuation">;</span>    epi<span class="token operator">-></span>ep <span class="token operator">=</span> ep<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// epi->ffd中存了句柄号和struct file对象地址</span>    <span class="token function">ep_set_ffd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-></span>ffd<span class="token punctuation">,</span> tfile<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 2.设置socket等待队列</span>    <span class="token comment" spellcheck="true">// 定义并初始化ep_pqueue对象</span>    epq<span class="token punctuation">.</span>epi <span class="token operator">=</span> epi<span class="token punctuation">;</span>    <span class="token function">init_poll_funcptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epq<span class="token punctuation">.</span>pt<span class="token punctuation">,</span> ep_ptable_queue_proc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用ep_ptable_queue_proc注册回调函数</span>    <span class="token comment" spellcheck="true">// 实际注入的函数为ep_poll_callback</span>    revents <span class="token operator">=</span> <span class="token function">ep_item_poll</span><span class="token punctuation">(</span>epi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>epq<span class="token punctuation">.</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 3.将epi插入eventpoll对象的红黑树中</span>    <span class="token function">ep_rbtree_insert</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> epi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分配并初始化epitem</strong></p><p>对于每一个socket，调用epoll_ctl的时候，都会为之分配一个epitem。该结构的主要数据结构如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">struct</span> epitem <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 红黑树节点</span>    <span class="token keyword">struct</span> rb_node rbn<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// socket文件描述信息</span>    <span class="token keyword">struct</span> epoll_filefd ffd<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 等待队列</span>    <span class="token keyword">struct</span> list_head pwqlist<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 所归属的eventpoll对象</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对<code>epitem</code>进行一些初始化，首先在<code>epi-&gt;ep = ep;</code>这行代码中将其ep指针指向<code>eventpoll</code>对象。另外用要添加的socket的file、fd来填充<code>epi-&gt;ffd</code>。<code>epitem</code>初始化后的关联关系如下图所示：</p><p><img src="/posts/7859/e853a1e1e9434c3dacc8fad82620a8bb.png" alt></p><p>其中使用到的ep_set_ffd函数如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">ep_set_ffd</span><span class="token punctuation">(</span><span class="token keyword">struct</span> epoll_filefd <span class="token operator">*</span>ffd<span class="token punctuation">,</span>                  <span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>    ffd<span class="token operator">-></span>file <span class="token operator">=</span> file<span class="token punctuation">;</span>    ffd<span class="token operator">-></span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>设置socket等待队列</strong></p><p>在创建<code>epitem</code>并初始化之后，<code>ep_insert</code>中第二件事情就是设置socket对象上的等待任务队列，并把函数<code>fs/eventpoll.c</code>文件下的<code>ep_poll_callback</code>设置为数据就绪时候的回调函数，如下图所示：</p><p><img src="/posts/7859/21c97a7247f140ce8953faa75e349dd3.png" alt></p><p>先来看<code>ep_item_poll</code>：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">ep_item_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> epitem <span class="token operator">*</span>epi<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>pt<span class="token punctuation">)</span><span class="token punctuation">{</span>    pt<span class="token operator">-></span>_key <span class="token operator">=</span> epi<span class="token operator">-></span>event<span class="token punctuation">.</span>events<span class="token punctuation">;</span>    <span class="token keyword">return</span> epi<span class="token operator">-></span>ffd<span class="token punctuation">.</span>file<span class="token operator">-></span>f_op<span class="token operator">-></span><span class="token function">poll</span><span class="token punctuation">(</span>epi<span class="token operator">-></span>ffd<span class="token punctuation">.</span>file<span class="token punctuation">,</span> pt<span class="token punctuation">)</span> <span class="token operator">&amp;</span> epi<span class="token operator">-></span>event<span class="token punctuation">.</span>events<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里调用了socket下的<code>file-&gt;f_op-&gt;poll</code>，这个函数实际上是<code>sock_poll</code>：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/socket.c</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">sock_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>wait<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    sock <span class="token operator">=</span> file<span class="token operator">-></span>private_data<span class="token punctuation">;</span>    <span class="token keyword">return</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">poll</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sock-&gt;ops-&gt;poll</code>指向的是<code>tcp_poll</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp.c</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">tcp_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>wait<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-></span>sk<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">sock_poll_wait</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token function">sk_sleep</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在sock_poll_wait的第二个参数传参前，先调用了sk_sleep函数。<strong>在这个函数里它获取了sock对象下的等待队列列表头wait_queue_head_t，稍后等待队列项就插到这里</strong>。这里稍微注意下，是socket的等待队列，不是epoll对象的。下面来看sk_sleep源码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/net/sock.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> wait_queue_head_t <span class="token operator">*</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket_wq<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token function">rcu_dereference_raw</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_wq<span class="token punctuation">)</span><span class="token operator">-></span>wait<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着真正进入<code>sock_poll_wait</code>:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/net/sock.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">sock_poll_wait</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>filp<span class="token punctuation">,</span>        wait_queue_head_t <span class="token operator">*</span>wait_address<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">poll_wait</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> wait_address<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// include/linux/poll.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">poll_wait</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span> filp<span class="token punctuation">,</span> wait_queue_head_t <span class="token operator">*</span> wait_address<span class="token punctuation">,</span> poll_table <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>_qproc <span class="token operator">&amp;&amp;</span> wait_address<span class="token punctuation">)</span>        p<span class="token operator">-></span><span class="token function">_qproc</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> wait_address<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的<code>qproc</code>是个函数指针，它在前面的<code>init_poll_funcptr</code>调用时设置成了<code>ep_ptable_queue_proc</code>函数，<code>ep_ptable_queue_proc</code>源码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ep_ptable_queue_proc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> wait_queue_head_t <span class="token operator">*</span>whead<span class="token punctuation">,</span>                 poll_table <span class="token operator">*</span>pt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> epitem <span class="token operator">*</span>epi <span class="token operator">=</span> <span class="token function">ep_item_from_epqueue</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> eppoll_entry <span class="token operator">*</span>pwq<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>epi<span class="token operator">-></span>nwait <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pwq <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>pwq_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化回调方法</span>        <span class="token function">init_waitqueue_func_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pwq<span class="token operator">-></span>wait<span class="token punctuation">,</span> ep_poll_callback<span class="token punctuation">)</span><span class="token punctuation">;</span>        pwq<span class="token operator">-></span>whead <span class="token operator">=</span> whead<span class="token punctuation">;</span>        pwq<span class="token operator">-></span>base <span class="token operator">=</span> epi<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将ep_poll_callback放入socket等待队列whead(注意不是epollo等待队列)</span>        <span class="token function">add_wait_queue</span><span class="token punctuation">(</span>whead<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pwq<span class="token operator">-></span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pwq<span class="token operator">-></span>llink<span class="token punctuation">,</span> <span class="token operator">&amp;</span>epi<span class="token operator">-></span>pwqlist<span class="token punctuation">)</span><span class="token punctuation">;</span>        epi<span class="token operator">-></span>nwait<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        epi<span class="token operator">-></span>nwait <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在ep_ptable_queue_proc函数中，新建了一个等待队列项，并注册其回调函数为ep_poll_callback函数，然后再将这个等待项添加到socket的等待队列中</strong>。</p><p>在前面介绍阻塞式的系统调用recvfrom时，由于需要在数据就绪的时候唤醒用户进程，所以等待对象项的private会设置成当前用户进程描述符current。而这里的socket是交给epoll来管理的，不需要在一个socket就绪的时候就唤醒进程，所以这里的q-&gt;private没有什么用就设置成了NULL</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/linux/wait.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">init_waitqueue_func_entry</span><span class="token punctuation">(</span>wait_queue_t <span class="token operator">*</span>q<span class="token punctuation">,</span>                    wait_queue_func_t func<span class="token punctuation">)</span><span class="token punctuation">{</span>    q<span class="token operator">-></span>flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>private <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>func <span class="token operator">=</span> func<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，等待队列项中仅将回调函数q-&gt;func设置为<code>ep_poll_callback</code>。后面讲到“数据来了”时，软中断将数据收到socket的接收队列后，会通过注册的这个<code>ep_poll_callback</code>函数来回调，进而通知epoll对象</p><p><strong>插入红黑树</strong></p><p>分配完epitem对象后，紧接着把它插入红黑树。一个插入了一些socket描述符的epoll里的红黑树示意图如下图所示：</p><p><img src="/posts/7859/e3ef503e34e049939a418227510c40f2.png" alt></p><p>这里使用红黑树是为了让epoll在查找效率、插入效率、内存开销等多个方法比较均衡。</p><h3 id="3）epoll-wait之等待接收"><a href="#3）epoll-wait之等待接收" class="headerlink" title="3）epoll_wait之等待接收"></a>3）epoll_wait之等待接收</h3><p><code>epoll_wait</code>做的事情不复杂，当它被调用时，它观察<code>eventpoll-&gt;rdllist</code>链表里有没有数据。有数据就返回，没有数据就创建一个等待队列项，将其添加到<code>eventpoll</code>的等待队列上，然后把自己阻塞掉:</p><p><img src="/posts/7859/cc452e808acd4f80bbd1c9be43a08b56.png" alt></p><p>其源代码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>epoll_wait<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event __user <span class="token operator">*</span><span class="token punctuation">,</span> events<span class="token punctuation">,</span>        <span class="token keyword">int</span><span class="token punctuation">,</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    error <span class="token operator">=</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> events<span class="token punctuation">,</span> maxevents<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event __user <span class="token operator">*</span>events<span class="token punctuation">,</span>           <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    wait_queue_t wait<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>fetch_events<span class="token punctuation">:</span>    <span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1.判断就绪队列上有没有事件就绪</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ep_events_available</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 2.定义等待事件关联当前进程</span>        <span class="token function">init_waitqueue_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wait<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.把新waitqueue添加到epoll->wq链表</span>        <span class="token function">__add_wait_queue_exclusive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>wq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 4.让出CPU,主动进入睡眠状态</span>            <span class="token function">set_current_state</span><span class="token punctuation">(</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ep_events_available</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span> <span class="token operator">||</span> timed_out<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> <span class="token operator">-</span>EINTR<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">schedule_hrtimeout_range</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> slack<span class="token punctuation">,</span> HRTIMER_MODE_ABS<span class="token punctuation">)</span><span class="token punctuation">)</span>                timed_out <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">__remove_wait_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>wq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">set_current_state</span><span class="token punctuation">(</span>TASK_RUNNING<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>判断就绪队列上有没有事件就绪</strong></p><p>首先调用ep_events_available来判断就绪链表中是否有可处理的事件</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">ep_events_available</span><span class="token punctuation">(</span><span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>rdllist<span class="token punctuation">)</span> <span class="token operator">||</span> ep<span class="token operator">-></span>ovflist <span class="token operator">!=</span> EP_UNACTIVE_PTR<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>定义等待事件关联当前进程</strong></p><p>假设确实没有就绪的连接，那接着会进入init_waitqueue_entry中定义等待任务，并把current（当前进程）添加到waitqueue上</p><blockquote><p>当没有IO事件的时候，epollo也会阻塞调当前进程，因为没有事情可做了占着CPU也没什么意义。epoll本身是阻塞的，但一般会把socket设置成非阻塞</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/linux/wait.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">init_waitqueue_entry</span><span class="token punctuation">(</span>wait_queue_t <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">struct</span> task_struct <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    q<span class="token operator">-></span>flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>private <span class="token operator">=</span> p<span class="token punctuation">;</span>    q<span class="token operator">-></span>func <span class="token operator">=</span> default_wake_function<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里的回调函数名称是default_wake_function。后面讲到“数据来了”时将会调用该函数</p><p><strong>添加到等待队列</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/linux/wait.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__add_wait_queue_exclusive</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span>                          wait_queue_t <span class="token operator">*</span>wait<span class="token punctuation">)</span><span class="token punctuation">{</span>    wait<span class="token operator">-></span>flags <span class="token operator">|</span><span class="token operator">=</span> WQ_FLAG_EXCLUSIVE<span class="token punctuation">;</span>    <span class="token function">__add_wait_queue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里把定义的等待事件添加到了epoll对象的等待队列中</p><p><strong>让出CPU主动进入睡眠状态</strong></p><p>通过set_current_state把当前进程设置为可打断。调用schedule_hrtimeout_range让出CPU，主动进入睡眠状态</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/hrtimer.c</span><span class="token keyword">int</span> __sched <span class="token function">schedule_hrtimeout_range</span><span class="token punctuation">(</span>ktime_t <span class="token operator">*</span>expires<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> delta<span class="token punctuation">,</span>                     <span class="token keyword">const</span> <span class="token keyword">enum</span> hrtimer_mode mode<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">schedule_hrtimeout_range_clock</span><span class="token punctuation">(</span>expires<span class="token punctuation">,</span> delta<span class="token punctuation">,</span> mode<span class="token punctuation">,</span>                          CLOCK_MONOTONIC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> __sched<span class="token function">schedule_hrtimeout_range_clock</span><span class="token punctuation">(</span>ktime_t <span class="token operator">*</span>expires<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> delta<span class="token punctuation">,</span>                   <span class="token keyword">const</span> <span class="token keyword">enum</span> hrtimer_mode mode<span class="token punctuation">,</span> <span class="token keyword">int</span> clock<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在schedule中选择下一个进程调度</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> __sched <span class="token function">__schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    next <span class="token operator">=</span> <span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">context_switch</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4）数据来了"><a href="#4）数据来了" class="headerlink" title="4）数据来了"></a>4）数据来了</h3><p>在前面<code>epoll_ctl</code>执行的时候，内核为每一个socket都添加了一个等待队列项。在<code>epoll_wait</code>运行完的时候，又在<code>event poll</code>对象上添加了等待队列元素</p><p><img src="/posts/7859/d8159be603374ed28e8871b2107cd864.png" alt></p><ul><li>socket-&gt;sock-&gt;sk_data_ready设置的就绪处理函数是sock_def_readable</li><li>在socket的等待队列中，其回调函数是<code>ep_poll_callback</code>，private指向的是空指针null</li><li>在eventpoll的等待队列项中，其回调函数是<code>default_wake_function</code>，private指向的是等待该事件的用户进程</li></ul><p><strong>将数据接收到任务队列</strong></p><p>从TCP协议栈的处理入口函数tcp_v4_rcv开始：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_ipv4.c</span><span class="token keyword">int</span> <span class="token function">tcp_v4_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 获取TCP头</span>    th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取IP头</span>    iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 根据数据包头中的IP、端口信息查找到对应的socket</span>    sk <span class="token operator">=</span> <span class="token function">__inet_lookup_skb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_hashinfo<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> th<span class="token operator">-></span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// socket未被用户锁定</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sock_owned_by_user</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tcp_prequeue</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span>                ret <span class="token operator">=</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在tcp_v4_rcv中首先根据收到的网络包的header里的source和dest信息在本机上查找对应的socket。找到以后，直接接入接收的主体函数<code>tcp_v4_do_rcv</code>:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_ipv4.c</span><span class="token keyword">int</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 执行连接状态下的数据处理  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tcp_rcv_established</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">,</span> skb<span class="token operator">-></span>len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rsk <span class="token operator">=</span> sk<span class="token punctuation">;</span>            <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 其他非ESTABLISH状态的数据包处理</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设处理的是ESTABLISH状态下的包，这样就又进入tcp_rcv_established函数中进行处理了</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_input.c</span><span class="token keyword">int</span> <span class="token function">tcp_rcv_established</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span>            <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token comment" spellcheck="true">// 将数据接收到队列中</span>                eaten <span class="token operator">=</span> <span class="token function">tcp_queue_rcv</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> tcp_header_len<span class="token punctuation">,</span>                              <span class="token operator">&amp;</span>fragstolen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true">// 数据准备好,唤醒socket上阻塞掉的进程  </span>            sk<span class="token operator">-></span><span class="token function">sk_data_ready</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>tcp_rcv_established</code>中通过调用<code>tcp_queue_rcv</code>函数完成了将接收数据放到socket的接收队列上，如下图所示：</p><p><img src="/posts/7859/be296fe2204c4232ab641f4bfc0b3a46.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_input.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> __must_check <span class="token function">tcp_queue_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">int</span> hdrlen<span class="token punctuation">,</span>          bool <span class="token operator">*</span>fragstolen<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 把接收到的数据放到socket的接收队列的尾部 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>eaten<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">__skb_queue_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-></span>sk_receive_queue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">skb_set_owner_r</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> eaten<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查找就绪回调函数</strong></p><p>调用<code>tcp_queue_rcv</code>完成接收之后，接着再调用<code>sk_data_ready</code>来唤醒在socket上等待的用户进程。在“socket的直接创建”中讲到的<code>sock_init_data</code>函数，已经把<code>sk_data_ready</code>设置成了<code>sock_def_readable</code>函数了。它是默认的数据就绪处理函数。</p><p>当socket上数据就绪时，内核将以<code>sock_def_readable</code>这个函数为入口，找到<code>epoll_ctl</code>添加socket时在其上设置的回调函数<code>ep_poll_callback</code>，如下图所示：</p><p><img src="/posts/7859/5d80e29b7219487986e1ba01f822843c.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/sock.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sock_def_readable</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket_wq <span class="token operator">*</span>wq<span class="token punctuation">;</span>    <span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wq <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_wq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断等待队列不为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wq_has_sleeper</span><span class="token punctuation">(</span>wq<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 执行等待队列项上的回调函数</span>        <span class="token function">wake_up_interruptible_sync_poll</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wq<span class="token operator">-></span>wait<span class="token punctuation">,</span> POLLIN <span class="token operator">|</span> POLLPRI <span class="token operator">|</span>                        POLLRDNORM <span class="token operator">|</span> POLLRDBAND<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sk_wake_async</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> SOCK_WAKE_WAITD<span class="token punctuation">,</span> POLL_IN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">rcu_read_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点看<code>wake_up_interruptible_sync_poll</code>，看一下内核是怎么找到等待队列项里注册的回调函数的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/linux/wait.h</span><span class="token macro property">#<span class="token directive keyword">define</span> wake_up_interruptible_sync_poll(x, m)                \    __wake_up_sync_key((x), TASK_INTERRUPTIBLE, 1, (void *) (m))</span><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">void</span> <span class="token function">__wake_up_sync_key</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span>            <span class="token keyword">int</span> nr_exclusive<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>    <span class="token keyword">int</span> wake_flags <span class="token operator">=</span> WF_SYNC<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>nr_exclusive<span class="token punctuation">)</span><span class="token punctuation">)</span>        wake_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__wake_up_common</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> nr_exclusive<span class="token punctuation">,</span> wake_flags<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着进入<code>__wake_up_common</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__wake_up_common</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span>            <span class="token keyword">int</span> nr_exclusive<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    wait_queue_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token function">list_for_each_entry_safe</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token operator">-></span>task_list<span class="token punctuation">,</span> task_list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> flags <span class="token operator">=</span> curr<span class="token operator">-></span>flags<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> wake_flags<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> WQ_FLAG_EXCLUSIVE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token operator">--</span>nr_exclusive<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>__wake_up_common</code>中，选出等待队列里注册的某个元素<code>curr</code>，回调其<code>curr-&gt;func</code>。之前调用<code>ep_insert</code>的时候，把这个func设置成<code>ep_poll_callback</code>了</p><p><strong>执行socket就绪回调函数</strong></p><p>找到了socket等待队列项里注册的函数<code>ep_poll_callback</code>，接着软中断就会调用它</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll_callback</span><span class="token punctuation">(</span>wait_queue_t <span class="token operator">*</span>wait<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> sync<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 获取wait对应的epitem</span>    <span class="token keyword">struct</span> epitem <span class="token operator">*</span>epi <span class="token operator">=</span> <span class="token function">ep_item_from_wait</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取epitem对应的eventpoll结构体</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep <span class="token operator">=</span> epi<span class="token operator">-></span>ep<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ep_is_linked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-></span>rdllink<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.将当前epitem添加到eventpoll的就绪队列中</span>        <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-></span>rdllink<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ep<span class="token operator">-></span>rdllist<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ep_pm_stay_awake_rcu</span><span class="token punctuation">(</span>epi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2.查看eventpoll的等待队列上是否有等待</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">waitqueue_active</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>wq<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">wake_up_locked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>ep_poll_callback</code>中根据等待任务队列上额外的base指针可以找到epitem，进而也可以找到<code>eventpoll</code>对象</p><p>它做的第一件事就是<strong>把自己的epitem添加到epoll的就绪队列中</strong>。接着它又会查看eventpoll对象上的的等待队列里是否有等待项（epoll_wait执行的时候会设置）。如果没有等待项，软中断的事情就做完了。如果有等待项，那就找到等待项里设置的回调函数，如下图所示：</p><p><img src="/posts/7859/4628c0dcfefd440caf263025cc6884f2.png" alt></p><p>依次调用<code>wake_up_locked() =&gt; __wake_up_locked() =&gt; __wake_up_common</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__wake_up_common</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span>            <span class="token keyword">int</span> nr_exclusive<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    wait_queue_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token function">list_for_each_entry_safe</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token operator">-></span>task_list<span class="token punctuation">,</span> task_list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> flags <span class="token operator">=</span> curr<span class="token operator">-></span>flags<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> wake_flags<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> WQ_FLAG_EXCLUSIVE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token operator">--</span>nr_exclusive<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>__wake_up_common</code>离，调用<code>curr-&gt;func</code>。这里的func是在<code>epoll_wait</code>时传入的<code>default_wake_function</code>函数</p><p><strong>执行epoll就绪通知</strong></p><p>在<code>default_wake_function</code>中找到等待队列项里的进程描述符，然后唤醒它，如下图所示：</p><p><img src="/posts/7859/0b82cf2b217c40d9a7fe80dba85acf32.png" alt="img"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">int</span> <span class="token function">default_wake_function</span><span class="token punctuation">(</span>wait_queue_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span>              <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">try_to_wake_up</span><span class="token punctuation">(</span>curr<span class="token operator">-></span>private<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> wake_flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等待队列项curr-&gt;private指针是在对象上等待而被阻塞掉的进程。将epoll_wait进程推入可运行队列，等待内核重新调度进程。当这个进程重新运行后，从epoll_wait阻塞时暂停的代码处继续执行。把rdlist中就绪的事件返回给用户进程</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// fs/eventpoll.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event __user <span class="token operator">*</span>events<span class="token punctuation">,</span>           <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">__remove_wait_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>wq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">set_current_state</span><span class="token punctuation">(</span>TASK_RUNNING<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>check_events<span class="token punctuation">:</span>    eavail <span class="token operator">=</span> <span class="token function">ep_events_available</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 给用户进程返回就绪事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res <span class="token operator">&amp;&amp;</span> eavail <span class="token operator">&amp;&amp;</span>        <span class="token operator">!</span><span class="token punctuation">(</span>res <span class="token operator">=</span> <span class="token function">ep_send_events</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> events<span class="token punctuation">,</span> maxevents<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timed_out<span class="token punctuation">)</span>        <span class="token keyword">goto</span> fetch_events<span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从用户角度来看，epoll_wait只是多等了一会儿而已，但执行流程还是顺序的。</p><h3 id="5）小结"><a href="#5）小结" class="headerlink" title="5）小结"></a>5）小结</h3><p>epoll的整个工作流程总结如下图所示：</p><p><img src="/posts/7859/e15f9f2df8b645fe996a7e5ffaec561b.png" alt></p><p>其中软中断回调时的回调函数调用关系整理如下：</p><pre><code>sock_def_readable: sock对象初始化时设置的    =&gt; ep_poll_callback: 调用epll_ctl时添加到socket上的        =&gt; default_wake_function: 调用epoll_wait时设置到epoll上的</code></pre><p>总结一下，epoll相关的函数里内核运行环境分两部分：</p><ul><li>用户进程内核态。调用<code>epoll_wait</code>等函数时会将进程写入内核态来执行。这部分代码负责查看接收队列，以及负责把当前进程阻塞掉，让出CPU</li><li>硬、软中断上下文。在这些组件中，将包从网卡接收过来进行处理，然后放到socket的接收队列。对于epoll来说，再找到socket关联的epitem，并把它添加到epoll对象的就绪链表中。这个时候再捎带检查一下epoll上是否有被阻塞的进程，如果有唤醒它</li></ul><p><strong>在实践中，只要活儿足够多，epoll_wait根本不会让进程阻塞</strong>。用户进程会一直干活儿，一直干活儿，直到<code>epoll_wait</code>里实在没活儿可干的时候才主动让出CPU。这就是epoll高效的核心原因所在。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1）阻塞到底是怎么一回事？</strong></p><p>阻塞其实说的是<strong>进程因为等待某个事件而主动让出CPU挂起的操作</strong>。在网络IO中，当进程等待socket上的数据时，如果数据还没有到来，那就把当前进程状态从TASK_RUNNING修改为TASK_INTERRUPTIBLE，然后主动让出CPU。由调度器来调度下一个就绪状态的进程来执行</p><p>所以，在分析某个技术方案是不是阻塞的时候，关键要看进程有没有放弃CPU。如果放弃了，那就是阻塞。如果没放弃，那就是非阻塞。事实上，recvfrom也可以设置成非阻塞。在这种情况下，如果socket上没有数据到达，调用直接返回空，而不是挂起等待</p><p><strong>2）同步阻塞IO都需要哪些开销？</strong></p><p>同步阻塞IO的开销主要有以下这些：</p><ul><li>进程通过recv系统调用接收一个socket上的数据时，如果数据没有到达，进程就被从CPU上拿下来，然后再换上另一个进程。这导致一次进程上下文切换的开销</li><li>当连接上的数据就绪的时候，睡眠的进程又会被唤醒，又是一次进程切换的开销</li><li>一个进程同时只能等待一条连接，如果有很多并发，则需要很多进程。每个进程都将占用大于几MB的内存</li></ul><p><strong>3）多路复用epoll为什么就能提高网络性能？</strong></p><p>epoll高性能最根本的原因是<strong>极大程度地减少了无用的进程上下文切换，让进程更专注地处理网络请求</strong></p><p>在内核的硬、软中断上下文中，包从网卡接收过来进行处理，然后放到socket的接收队列。再找到socket关联的epitem，并把它添加到epoll对象的就绪链表中</p><p>在用户进程中，通过调用epoll_wait来查看就绪链表中是否有事件到达，如果有，直接走进行处理。处理完毕再次调用epoll_wait。在高并发的实践中，主要活儿足够多，epoll_wait根本不会让进程阻塞。用户进程会一直干活儿，一直干活儿，直到epoll_wait里实在没活儿可干的时候才主动让出CPU。这就是epoll高效的核心原因所在</p><p>至于红黑树，仅仅是提高了epoll查找、添加、删除socket时的效率而已，不算epoll在高并发场景高性能的根本原因</p><p><strong>4）epoll也是阻塞的？</strong></p><p>例如，一个epoll对象下添加了一万个客户端连接的socket。假设所有这些socket上都还没有数据到达，这个时候进程调用epoll_wait发现没有任何事情可干。这种情况下用户进程就会被阻塞掉，而这种情况是完全正常的，没有工作需要处理，那还占着CPU是没有道理的</p><p>阻塞不会导致低性能，过多过频繁的阻塞才会。epoll的阻塞和它的高性能并不冲突</p><p><strong>5）为什么Redis的网络性能很突出？</strong></p><p>Redis在网络IO性能上表现非常突出，单进程的服务器在极限情况下可以达到10万的QPS</p><p>Redis的事件循环可以简化到用如下伪代码来表示</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    job <span class="token operator">=</span> <span class="token function">epollo_wait</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">do_job</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Redis的主要业务逻辑就是在本机内存上的数据结构的读写，几乎没有网络IO和磁盘IP，单个请求处理起来很快。所以它把主服务器程序干脆就做成了单进程的，这样省去了多进程之间协作的负担，也很大程序减少了进程切换。进程主要的工作过程就是调用epoll_wait等待事件，有了事件以后处理，处理完之后再调用epoll_wait。一直工作，一直工作，直到实在没有请求需要处理，或者进程时间片到的时候才让出CPU。工作效率发挥到了极致</p><p><strong>推荐阅读：</strong></p><p>Linux五种I/O模型：<a href="https://wiyi.org/linux-io-model.html">带你彻底理解Linux五种I/O模型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;说实话，这章我没太看懂，可能还是需要反复多次阅读。&lt;/p&gt;
&lt;h2 id=&quot;内核和用户进程协作之epoll&quot;&gt;&lt;a href=&quot;#内核和用户
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(二)</title>
    <link href="https://joytsing.github.io/posts/36369/"/>
    <id>https://joytsing.github.io/posts/36369/</id>
    <published>2024-04-01T08:14:07.000Z</published>
    <updated>2024-04-01T16:03:56.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="socket的创建"><a href="#socket的创建" class="headerlink" title="socket的创建"></a>socket的创建</h2><p>socket函数调用执行完之后，用户层面看到返回的是一个整数型的句柄，但其实内核在内部创建了一系列socket相关的内核对象。它们互相之间的关系如下图所示：</p><p><img src="/posts/36369/4138aa4c844b498a8441d75227fac969.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/socket.c</span><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    retval <span class="token operator">=</span> <span class="token function">sock_create</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sock_create是创建socket的主要位置，其中sock_create又调用了<code>__sock_create</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/socket.c</span><span class="token keyword">int</span> <span class="token function">__sock_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span>             <span class="token keyword">struct</span> socket <span class="token operator">*</span><span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> err<span class="token punctuation">;</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> net_proto_family <span class="token operator">*</span>pf<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 分配socket对象</span>    sock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 获得每个协议族的操作表  </span>    pf <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>net_families<span class="token punctuation">[</span>family<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 调用指定协议族的创建函数,对于AF_INET对应的是inet_create</span>    err <span class="token operator">=</span> pf<span class="token operator">-></span><span class="token function">create</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>__sock_create</code>里，首先调用<code>sock_alloc</code>来分配一个<code>struct socket</code>内核对象，接着获取协议族的操作函数表，并调用其<code>create</code>方法。对于<code>AF_INET</code>协议族来说，执行到的是<code>inet_create</code>方法</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/af_inet.c</span><span class="token keyword">static</span> <span class="token keyword">struct</span> inet_protosw inetsw_array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token punctuation">{</span>        <span class="token punctuation">.</span>type <span class="token operator">=</span>       SOCK_STREAM<span class="token punctuation">,</span>        <span class="token punctuation">.</span>protocol <span class="token operator">=</span>   IPPROTO_TCP<span class="token punctuation">,</span>        <span class="token punctuation">.</span>prot <span class="token operator">=</span>       <span class="token operator">&amp;</span>tcp_prot<span class="token punctuation">,</span>        <span class="token punctuation">.</span>ops <span class="token operator">=</span>        <span class="token operator">&amp;</span>inet_stream_ops<span class="token punctuation">,</span>        <span class="token punctuation">.</span>no_check <span class="token operator">=</span>   <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span>flags <span class="token operator">=</span>      INET_PROTOSW_PERMANENT <span class="token operator">|</span>                  INET_PROTOSW_ICSK<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">inet_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span>               <span class="token keyword">int</span> kern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inet_protosw <span class="token operator">*</span>answer<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inet_sock <span class="token operator">*</span>inet<span class="token punctuation">;</span>    <span class="token keyword">struct</span> proto <span class="token operator">*</span>answer_prot<span class="token punctuation">;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">list_for_each_entry_rcu</span><span class="token punctuation">(</span>answer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inetsw<span class="token punctuation">[</span>sock<span class="token operator">-></span>type<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>protocol <span class="token operator">==</span> answer<span class="token operator">-></span>protocol<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>protocol <span class="token operator">!=</span> IPPROTO_IP<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>IPPROTO_IP <span class="token operator">==</span> protocol<span class="token punctuation">)</span> <span class="token punctuation">{</span>                protocol <span class="token operator">=</span> answer<span class="token operator">-></span>protocol<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>IPPROTO_IP <span class="token operator">==</span> answer<span class="token operator">-></span>protocol<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        err <span class="token operator">=</span> <span class="token operator">-</span>EPROTONOSUPPORT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 将inet_stream_ops赋到socket->ops上</span>    sock<span class="token operator">-></span>ops <span class="token operator">=</span> answer<span class="token operator">-></span>ops<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取tcp_prot</span>    answer_prot <span class="token operator">=</span> answer<span class="token operator">-></span>prot<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 分配sock对象,并把tcp_prot赋到sock->sk_prot上</span>    sk <span class="token operator">=</span> <span class="token function">sk_alloc</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> PF_INET<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> answer_prot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 对sock对象进行初始化</span>    <span class="token function">sock_init_data</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>inet_create</code>中，根据类型<code>SOCK_STREAM</code>查找到对于TCP定义的操作方法实现集合<code>inet_stream_ops</code>和<code>tcp_prot</code>，并把它们分别设置到socket-&gt;ops和sock-&gt;sk_prot上，如下图所示：</p><p><img src="/posts/36369/64d39a9bc891437eb300b02a93b9b160.png" alt></p><p>再往下看到了<code>sock_init_data</code>。在这个方法中将socket中的<code>sk_data_ready</code>函数指针进行了初始化，设置为默认<code>sock_def_readable</code>，如下图所示：</p><p><img src="/posts/36369/f78159063cb74376a6bf3deffd74ae0b.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/sock.c</span><span class="token keyword">void</span> <span class="token function">sock_init_data</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    sk<span class="token operator">-></span>sk_data_ready    <span class="token operator">=</span>    sock_def_readable<span class="token punctuation">;</span>    sk<span class="token operator">-></span>sk_write_space    <span class="token operator">=</span>    sock_def_write_space<span class="token punctuation">;</span>    sk<span class="token operator">-></span>sk_error_report    <span class="token operator">=</span>    sock_def_error_report<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>当软中断上收到数据包时通过调用sk_data_ready函数指针（实际被设置成了sock_def_readable()）来唤醒在socket上等待的进程</strong>。后面讲到“软中断模块”时可以看到这一过程。</p><p>至此，一个tcp对象，确切的说是AF_INET协议族下SOCKET_STREAM对象就算创建完成了。<strong>这里花费了一次socket系统调用的开销</strong></p><h2 id="内核和用户进程协作之阻塞方式"><a href="#内核和用户进程协作之阻塞方式" class="headerlink" title="内核和用户进程协作之阻塞方式"></a>内核和用户进程协作之阻塞方式</h2><p>在同步阻塞IO模型中，先是用户进程发起创建socket的指令，然后切换到内核态完成了内核对象的初始化。接下来，Linux在数据包的接收上，是硬中断和ksoftirqd线程在进行处理。当ksoftirqd线程处理完以后，再通知相关的用户进程。从用户进程创建socket，到一个网络包抵达网卡被用户进程接收，同步阻塞IO总体上的流程如下图所示：</p><p><img src="/posts/36369/f5a1fc855ce94cd4b42ee99db2335854.png" alt></p><h3 id="1）等待接收消息"><a href="#1）等待接收消息" class="headerlink" title="1）等待接收消息"></a>1）等待接收消息</h3><p>clib库recv函数会执行recvform系统调用。进入系统调用后，用户进程就进入了内核态，执行一系列的内核协议层函数，然后到socket对象的接收队列中查看是否有数据，没有的话就把是自己添加到socket对应的等待队列里。最后让出CPU，操作系统会选择下一个就绪状态的进程来执行。整个流程如下图所示：</p><p><img src="/posts/36369/a32a158245774f2f9ac1a0b7c61f2b6f.png" alt></p><p>接下来根据源码来看更具体的细节。其中<strong>要关注的重点是recvfrom最后是怎么把自己的进程阻塞掉的</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/socket.c</span><span class="token function">SYSCALL_DEFINE6</span><span class="token punctuation">(</span>recvfrom<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> ubuf<span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> size<span class="token punctuation">,</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr __user <span class="token operator">*</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span>        <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> addr_len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 根据用户传入的fd找到socket对象</span>    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    err <span class="token operator">=</span> <span class="token function">sock_recvmsg</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来的调用顺序为：<code>sock_recvmsg</code> =&gt; <code>__sock_recvmsg</code> =&gt; <code>__sock_recvmsg_nosec</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/socket.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">__sock_recvmsg_nosec</span><span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span>                       <span class="token keyword">struct</span> msghdr <span class="token operator">*</span>msg<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">recvmsg</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用socket对象ops里的<code>recvmsg</code>，<code>recvmsg</code>指向的是<code>inet_recvmsg</code>方法:</p><p><img src="/posts/36369/f06e527b9a0b40a789fcad59bccb51d7.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/af_inet.c</span><span class="token keyword">int</span> <span class="token function">inet_recvmsg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> msghdr <span class="token operator">*</span>msg<span class="token punctuation">,</span>         size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    err <span class="token operator">=</span> sk<span class="token operator">-></span>sk_prot<span class="token operator">-></span><span class="token function">recvmsg</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> MSG_DONTWAIT<span class="token punctuation">,</span>                   flags <span class="token operator">&amp;</span> <span class="token operator">~</span>MSG_DONTWAIT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里又遇到一个函数指针，这次调用的是<code>socket</code>对象里<code>sk_prot</code>下的recvmsg方法，<code>recvmsg</code>方法对应的是<code>tcp_recvmsg</code>方法:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp.c</span><span class="token keyword">int</span> <span class="token function">tcp_recvmsg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> msghdr <span class="token operator">*</span>msg<span class="token punctuation">,</span>        size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> nonblock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>addr_len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> copied <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 遍历接收队列接收数据</span>        <span class="token function">skb_queue_walk</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-></span>sk_receive_queue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>copied <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">release_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">lock_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// 没有收到足够数据,启用sk_wait_data阻塞当前进程</span>            <span class="token function">sk_wait_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>skb_queue_walk</code>在访问sock对象下的接收队列，如下图所示：</p><p><img src="/posts/36369/df07ff2eed16473ab4f570e85d5e0b3b.png" alt></p><p>如果没有收到数据，或者收到的不够多，则调用<code>sk_wait_data</code>把当前进程阻塞掉</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/sock.c</span><span class="token keyword">int</span> <span class="token function">sk_wait_data</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>timeo<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> rc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前进程(current)关联到所定义的等待队列项上</span>    <span class="token function">DEFINE_WAIT</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 调用sk_sleep获取sock对象下的wait</span>    <span class="token comment" spellcheck="true">// 并准备挂起,将当前进程设置为可打断(INTERRUPTIBLE)</span>    <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span> TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_bit</span><span class="token punctuation">(</span>SOCK_ASYNC_WAITDATA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sk<span class="token operator">-></span>sk_socket<span class="token operator">-></span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 通过调用schedule_timeout让出CPU,然后进行睡眠</span>    rc <span class="token operator">=</span> <span class="token function">sk_wait_event</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> timeo<span class="token punctuation">,</span> <span class="token operator">!</span><span class="token function">skb_queue_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-></span>sk_receive_queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面再来详细看看<code>sk_wait_data</code>是怎样把当前进程给阻塞掉的，如下图所示：</p><p><img src="/posts/36369/0b984f9cc2ff43aa9d2d66ba1645dafb.png" alt></p><p>首先在<code>DEFINE_WAIT</code>宏下，定义了一个等待队列项wait。在这个新的等待队列项上，注册了回调函数<code>autoremove_wake_function</code>，并把当前进程描述符<code>current</code>关联到其<code>.private</code>成员上：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/linux/wait.h</span><span class="token macro property">#<span class="token directive keyword">define</span> DEFINE_WAIT_FUNC(name, function)                \    wait_queue_t name = {                        \        .private    = current,                \        .func        = function,                \        .task_list    = LIST_HEAD_INIT((name).task_list),    \    }</span><span class="token macro property">#<span class="token directive keyword">define</span> DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>紧接着在<code>sk_wait_data</code>中调用<code>sk_sleep</code>获取socket对象下的等待队列列表头<code>wait_queue_head_t</code>，<code>sk_sleep</code>源码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/net/sock.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> wait_queue_head_t <span class="token operator">*</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token function">offsetof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket_wq<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token function">rcu_dereference_raw</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_wq<span class="token punctuation">)</span><span class="token operator">-></span>wait<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着调用<code>prepare_to_wait</code>来把新定义的等待队列项wait插入sock对象的等待队列</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/wait.c</span><span class="token keyword">void</span> <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span> wait_queue_t <span class="token operator">*</span>wait<span class="token punctuation">,</span> <span class="token keyword">int</span> state<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>    wait<span class="token operator">-></span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>WQ_FLAG_EXCLUSIVE<span class="token punctuation">;</span>    <span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wait<span class="token operator">-></span>task_list<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">__add_wait_queue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_current_state</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这样后面当内核收完数据产生就绪事件的时候，就可以查找socket等待队列上的等待项，进而可以找到回调函数和在等待该socket就绪事件的进程了</strong>。最后调用<code>sk_wait_event</code>让出CPU，进程将进入睡眠状态，<strong>这会产生一次进程上下文切换的开销，这个开销是昂贵的，大约需要消耗几个微妙的CPU时间</strong></p><h3 id="2）软中断模块"><a href="#2）软中断模块" class="headerlink" title="2）软中断模块"></a>2）软中断模块</h3><p>前文讲到了网络包到网卡后是怎么被网卡接收，最后再交由软中断处理的，这里直接从TCP协议的接收函数tcp_v4_rcv看起，总体接收流程如下图所示：</p><p><img src="/posts/36369/f304dc56834a411ea0dfdc7c04629678.png" alt></p><p>软中断（也就是Linux里的<code>ksoftirqd</code>线程）里收到数据以后，发现是TCP包就会执行tcp_v4_rcv函数。接着往下，如果是ESTABLISH状态下的数据包，则最后会把数据拆出来放到对应socket的接收队列中，然后调用<code>sk_data_ready</code>来唤醒用户进程</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_ipv4.c</span><span class="token keyword">int</span> <span class="token function">tcp_v4_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 获取tcp header</span>    th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取ip header</span>    iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 根据数据包header中的IP、端口信息查找到对应的socket</span>    sk <span class="token operator">=</span> <span class="token function">__inet_lookup_skb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_hashinfo<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> th<span class="token operator">-></span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// socket未被用户锁定</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sock_owned_by_user</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tcp_prequeue</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span>                ret <span class="token operator">=</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>tcp_v4_rcv</code>中，首先根据收到的网络包的header里的source和dest信息在本机上查询对应的socket。找到以后，调用<code>tcp_v4_do_rcv</code>函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_ipv4.c</span><span class="token keyword">int</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 执行连接状态下的数据处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tcp_rcv_established</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">,</span> skb<span class="token operator">-></span>len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rsk <span class="token operator">=</span> sk<span class="token punctuation">;</span>            <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 其他非ESTABLISH状态的数据包处理</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设处理的是ESTABLISH状态下的包，这样就进入<code>tcp_rcv_established</code>函数进行处理</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_input.c</span><span class="token keyword">int</span> <span class="token function">tcp_rcv_established</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span>            <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token comment" spellcheck="true">// 接收数据放到队列中</span>                eaten <span class="token operator">=</span> <span class="token function">tcp_queue_rcv</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> tcp_header_len<span class="token punctuation">,</span>                              <span class="token operator">&amp;</span>fragstolen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true">// 数据准备好,唤醒socket上阻塞掉的进程</span>            sk<span class="token operator">-></span><span class="token function">sk_data_ready</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>tcp_rcv_established</code>中通过调用<code>tcp_queue_rcv</code>函数，完成了将接收到的数据放到socket的接收队列上，如下图所示：</p><p><img src="/posts/36369/7d9dbe546d864cb2bd23ec6d2b032f09.png" alt></p><p>函数<code>tcp_queue_rcv</code>的源码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/tcp_input.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> __must_check <span class="token function">tcp_queue_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">int</span> hdrlen<span class="token punctuation">,</span>          bool <span class="token operator">*</span>fragstolen<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 把接收到的数据放到socket的接收队列的尾部  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>eaten<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">__skb_queue_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-></span>sk_receive_queue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">skb_set_owner_r</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> eaten<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>调用<code>tcp_queue_rcv</code>接收完成之后，接着调用<code>sk_data_ready</code>来唤醒在<code>socket</code>上等待的用户进程</strong>。这又是一个函数指针。在前面”socket的直接创建“的部分，讲到在创建socket的流程里执行到的<code>sock_init_data</code>函数已经把<code>sk_data_ready</code>指针设置成了<code>sock_def_readable</code>函数了。它是默认的数据就绪处理函数:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/sock.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sock_def_readable</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket_wq <span class="token operator">*</span>wq<span class="token punctuation">;</span>    <span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wq <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_wq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 有进程在此socket的等待队列</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wq_has_sleeper</span><span class="token punctuation">(</span>wq<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 唤醒等待队列上的进程</span>        <span class="token function">wake_up_interruptible_sync_poll</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wq<span class="token operator">-></span>wait<span class="token punctuation">,</span> POLLIN <span class="token operator">|</span> POLLPRI <span class="token operator">|</span>                        POLLRDNORM <span class="token operator">|</span> POLLRDBAND<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sk_wake_async</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> SOCK_WAKE_WAITD<span class="token punctuation">,</span> POLL_IN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">rcu_read_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>sock_def_readable</code>中再一次访问到了<code>sock-&gt;sk_wq</code>下的wait。在前面”等待接收消息“的部分调用<code>recvform</code>时，在执行过程的最后，通过<code>DEFINE_WAIT(wait)</code>将当前进程关联的等待队列添加到<code>sock-&gt;sk_wq</code>下的wait里了。那接下来就是调用<code>wake_up_interruptible_sync_poll</code>来唤醒在socket上因为等待数据而被阻塞掉的进程了，如下图所示：</p><p><img src="/posts/36369/72989810ecd540b9aa8e7bffb88661c9.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/linux/wait.h</span><span class="token macro property">#<span class="token directive keyword">define</span> wake_up_interruptible_sync_poll(x, m)                \    __wake_up_sync_key((x), TASK_INTERRUPTIBLE, 1, (void *) (m))</span><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">void</span> <span class="token function">__wake_up_sync_key</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span>            <span class="token keyword">int</span> nr_exclusive<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>    <span class="token keyword">int</span> wake_flags <span class="token operator">=</span> WF_SYNC<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>nr_exclusive<span class="token punctuation">)</span><span class="token punctuation">)</span>        wake_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__wake_up_common</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> nr_exclusive<span class="token punctuation">,</span> wake_flags<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>__wake_up_common</code>实现唤醒。该函数调用的参数<code>nr_exclusive</code>传入的是1，这里指的是<strong>即使有多个进程都阻塞在同一个socket上，也只会唤醒一个进程。其作用是为了避免惊群，而不是把所有的进程都唤醒</strong>:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__wake_up_common</span><span class="token punctuation">(</span>wait_queue_head_t <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span>            <span class="token keyword">int</span> nr_exclusive<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    wait_queue_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token function">list_for_each_entry_safe</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token operator">-></span>task_list<span class="token punctuation">,</span> task_list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> flags <span class="token operator">=</span> curr<span class="token operator">-></span>flags<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> wake_flags<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> WQ_FLAG_EXCLUSIVE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token operator">--</span>nr_exclusive<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>__wake_up_common</code>中找出一个等待队列项curr，然后调用其<code>curr-&gt;func</code>。在前面”等待接收消息“的部分recv函数执行的时候，使用DEFINE_WAIT()定义等待队列项时，内核把<code>curr-&gt;func</code>设置成了<code>autoremove_wake_function</code>:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/wait.c</span><span class="token keyword">int</span> <span class="token function">autoremove_wake_function</span><span class="token punctuation">(</span>wait_queue_t <span class="token operator">*</span>wait<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> sync<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">default_wake_function</span><span class="token punctuation">(</span>wait<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> sync<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>        <span class="token function">list_del_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wait<span class="token operator">-></span>task_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>autoremove_wake_function</code>中，调用了<code>default_wake_function</code>:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/sched/core.c</span><span class="token keyword">int</span> <span class="token function">default_wake_function</span><span class="token punctuation">(</span>wait_queue_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span>              <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">try_to_wake_up</span><span class="token punctuation">(</span>curr<span class="token operator">-></span>private<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> wake_flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用<code>try_to_wake_up</code>时传入的<code>task_struct</code>是<code>curr-&gt;private</code>，这个就是因为等待而被阻塞的进程项。当这个函数执行完的时候，<strong>在socket上等待而被阻塞的进程就被推入可运行队列里了，这又将产生一次进程上下文切换的开销</strong></p><h3 id="3）同步阻塞总结"><a href="#3）同步阻塞总结" class="headerlink" title="3）同步阻塞总结"></a>3）同步阻塞总结</h3><p>同步阻塞方式接收网络包的整个过程分为两部分：</p><ul><li>第一部分是我们自己的代码所在的进程，我们调用的socket()函数会进入内核态创建必要内核对象。recv()函数在进入内核态以后负责查看接收队列，以及在没有数据可处理的时候把当前进程阻塞掉，让出CPU</li><li>第二部分是硬中断、软中断（系统线程ksoftirqd）。在这些组件中，将包处理完后会放到socket的接收队列中。然后根据socket内核对象找到其等待队列中正在因为等待而被阻塞掉的进程，把它唤醒</li></ul><p>同步阻塞总体流程如下图所示：</p><p><img src="/posts/36369/44d7544c1ccf4c3b8e6b829bff932d82.png" alt></p><p>每次一个进程专门为了等一个socket上的数据就被从CPU上拿下来，然后换上另一个进程，如下图所示。等到数据准备好，睡眠的进程又被唤醒，总共产生两次进程上下文切换开销：</p><p><img src="/posts/36369/5d306322d4674b01b1cfe470e9964113.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;socket的创建&quot;&gt;&lt;a href=&quot;#socket的创建&quot; class=&quot;headerlink&quot; title=&quot;socket的创建&quot;&gt;&lt;/a&gt;socket的创建&lt;/h2&gt;&lt;p&gt;socket函数调用执行完之后，用户层面看到返回的是一个整数型的句柄，但其实内核在内
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Redis为什么变慢了</title>
    <link href="https://joytsing.github.io/posts/54676/"/>
    <id>https://joytsing.github.io/posts/54676/</id>
    <published>2024-03-31T07:43:11.000Z</published>
    <updated>2024-03-31T11:03:38.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>为什么我的 Redis 突然慢了一波，之后又恢复正常了？</li><li>为什么我的 Redis 稳定运行了很久，突然从某个时间点开始变慢了？</li></ul><p>之前在笔记中也说了，Redis重要的是怎么用和优化以及怎么排查问题，而不是那点基础知识，首先声明一下，这个笔记是对极客时间里蒋德钧的Redis核心技术与实战的拙劣模仿，如何有新的认知了解的话欢迎讨论。</p><h2 id="先问是不是，再问为什么"><a href="#先问是不是，再问为什么" class="headerlink" title="先问是不是，再问为什么"></a>先问是不是，再问为什么</h2><p> 首先可能会很奇怪，Redis 是否真的变慢了我不是从请求和服务上早就知道了吗，还用问是不是？这个逻辑首先有个前提，导致服务速度下降以及业务服务 API 响应延迟变长不一定是Redis的锅，可能是其他模块的问题，比较高效的做法是，在服务内部集成<strong>链路追踪</strong>，也就是在服务访问外部依赖的出入口，记录下每次请求外部依赖的响应延时。</p><p><img src="/posts/54676/640.webp" alt></p><p>如果确实是了，先排查业务服务到 Redis 这条链路，变慢的原因可能也有 2 个：</p><ol><li>业务服务器到 Redis 服务器之间的网络存在问题，例如网络线路质量不佳，网络数据包在传输时存在延迟、丢包等情况</li><li>Redis 本身存在问题，需要进一步排查是什么原因导致 Redis 变慢</li></ol><p>如果是第一个就是网络的问题，那么所有该服务器上的服务都会变慢发生网络延迟的问题，这种情况下不属于咱们讨论的问题。如果确实是Redis本身出现问题了，这时候要开始排查，首先先做一下对照实验，对 Redis 进行基准性能测试，了解 Redis 在生产环境服务器上的基准性能。具体只需要下面这样就可以测试出这个实例 60 秒内的最大响应延迟：</p><pre class="line-numbers language-sh"><code class="language-sh">$ redis-cli -h 127.0.0.1 -p 6379 --intrinsic-latency 60Max latency so far: 1 microseconds.Max latency so far: 15 microseconds.Max latency so far: 17 microseconds.Max latency so far: 18 microseconds.Max latency so far: 31 microseconds.Max latency so far: 32 microseconds.Max latency so far: 59 microseconds.Max latency so far: 72 microseconds.1428669267 total runs (avg latency: 0.0420 microseconds / 42.00 nanoseconds per run).Worst run took 1429x longer than the average latency.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果可以看到，这 60 秒内的最大响应延迟为 72 微秒（0.072毫秒）。还可以使用以下命令，查看一段时间内 Redis 的最小、最大、平均访问延迟：</p><pre class="line-numbers language-sh"><code class="language-sh">$ redis-cli -h 127.0.0.1 -p 6379 --latency-history -i 1min: 0, max: 1, avg: 0.13 (100 samples) -- 1.01 seconds rangemin: 0, max: 1, avg: 0.12 (99 samples) -- 1.01 seconds rangemin: 0, max: 1, avg: 0.13 (99 samples) -- 1.01 seconds rangemin: 0, max: 1, avg: 0.10 (99 samples) -- 1.01 seconds rangemin: 0, max: 1, avg: 0.13 (98 samples) -- 1.00 seconds rangemin: 0, max: 1, avg: 0.08 (99 samples) -- 1.01 seconds range...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了对照组后就可以知道是否是真的变慢了，所以具体来说流程如下：</p><ol><li>在相同配置的服务器上，测试一个正常 Redis 实例的基准性能</li><li>找到你认为可能变慢的 Redis 实例，测试这个实例的基准性能</li><li>如果你观察到，这个实例的运行延迟是正常 Redis 基准性能的 2 倍以上(多少看个人经验和服务内容)，即可认为这个 Redis 实例确实变慢了</li></ol><p>如果确认是 Redis 变慢了，那如何排查是哪里发生了问题呢？</p><h2 id="使用了复杂度高的命令"><a href="#使用了复杂度高的命令" class="headerlink" title="使用了复杂度高的命令"></a>使用了复杂度高的命令</h2><p>第一步，需要去查看一下 Redis 的慢日志（slowlog）。Redis 提供了慢日志命令的统计功能，它记录了有哪些命令在执行时耗时比较久。查看 Redis 慢日志之前需要设置慢日志的阈值。例如，设置慢日志的阈值为 5 毫秒，并且保留最近 500 条慢日志记录：</p><pre class="line-numbers language-sh"><code class="language-sh"># 命令执行耗时超过 5 毫秒，记录慢日志CONFIG SET slowlog-log-slower-than 5000# 只保留最近 500 条慢日志CONFIG SET slowlog-max-len 500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>设置完成之后，所有执行的命令如果操作耗时超过了 5 毫秒，都会被 Redis 记录下来。此时，你可以执行以下命令，就可以查询到最近记录的慢日志：</p><pre class="line-numbers language-sh"><code class="language-sh">127.0.0.1:6379> SLOWLOG get 51) 1) (integer) 32693       # 慢日志ID   2) (integer) 1593763337  # 执行时间戳   3) (integer) 5299        # 执行耗时(微秒)   4) 1) "LRANGE"           # 具体执行的命令和参数      2) "user_list:2000"      3) "0"      4) "-1"2) 1) (integer) 32692   2) (integer) 1593763337   3) (integer) 5044   4) 1) "GET"      2) "user_info:1000"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你的应用程序执行的 Redis 命令有以下特点，那么有可能会导致操作延迟变大：</p><ol><li>经常使用 O(N) 以上复杂度的命令，例如 SORT、SUNION、ZUNIONSTORE 聚合类命令</li><li>使用 O(N) 复杂度的命令，但 N 的值非常大</li></ol><p>两种对应的情况不同，第一种情况导致变慢的原因在于，Redis 在操作内存数据时，时间复杂度过高，要花费更多的 CPU 资源。第二种情况导致变慢的原因在于，Redis 一次需要返回给客户端的数据过多，更多时间花费在数据协议的组装和网络传输过程中。</p><p>另外还可以从资源使用率层面来分析，如果你的应用程序操作 Redis 的 OPS 不是很大，但 Redis 实例的 <strong>CPU 使用率却很高</strong>，那么很有可能是使用了复杂度过高的命令导致的。</p><p>除此之外Redis 是单线程处理客户端请求的，如果经常使用以上命令，那么当 Redis 处理客户端请求时，一旦前面某个命令发生耗时，就会导致后面的请求发生排队，对于客户端来说，响应延迟也会变长。</p><p><img src="/posts/54676/640-1711873863065-3.webp" alt></p><p>针对这种情况如何解决呢？答案很简单：</p><ol><li>尽量不使用 O(N) 以上复杂度过高的命令，对于数据的聚合操作，放在客户端做</li><li>执行 O(N) 命令，保证 N 尽量的小（推荐 N &lt;= 300），每次获取尽量少的数据，让 Redis 可以及时处理返回</li></ol><h2 id="操作bigkey"><a href="#操作bigkey" class="headerlink" title="操作bigkey"></a>操作bigkey</h2><p>如果你查询慢日志发现，并不是复杂度过高的命令导致的，而都是 SET / DEL 这种简单命令出现在慢日志中，那么你就要怀疑你的实例否写入了 bigkey。</p><p>Redis 在写入数据时，需要为新的数据分配内存，相对应的，当从 Redis 中删除数据时，它会释放对应的内存空间。如果一个 key 写入的 value 非常大，那么 Redis 在<strong>分配内存时就会比较耗时</strong>。同样的，当删除这个 key 时，<strong>释放内存也会比较耗时</strong>，这种类型的 key 我们一般称之为 bigkey。此时，你需要检查你的业务代码，是否存在写入 bigkey 的情况。你需要评估写入一个 key 的数据大小，尽量避免一个 key 存入过大的数据。</p><p>如果已经写入了 bigkey，那有没有什么办法可以扫描出实例中 bigkey 的分布情况呢？Redis 提供了扫描 bigkey 的命令，执行以下命令就可以扫描出，一个实例中 bigkey 的分布情况，输出结果是以类型维度展示的：</p><pre class="line-numbers language-sh"><code class="language-sh">$ redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.01...-------- summary -------Sampled 829675 keys in the keyspace!Total key length in bytes is 10059825 (avg len 12.13)Biggest string found 'key:291880' has 10 bytesBiggest   list found 'mylist:004' has 40 itemsBiggest    set found 'myset:2386' has 38 membersBiggest   hash found 'myhash:3574' has 37 fieldsBiggest   zset found 'myzset:2704' has 42 members36313 strings with 363130 bytes (04.38% of keys, avg size 10.00)787393 lists with 896540 items (94.90% of keys, avg size 1.14)1994 sets with 40052 members (00.24% of keys, avg size 20.09)1990 hashs with 39632 fields (00.24% of keys, avg size 19.92)1985 zsets with 39750 members (00.24% of keys, avg size 20.03)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果我们可以很清晰地看到，每种数据类型所占用的最大内存 / 拥有最多元素的 key 是哪一个，以及每种数据类型在整个实例中的占比和平均大小 / 元素数量。其实使用这个命令的原理，就是 Redis 在内部执行了 SCAN 命令，遍历整个实例中所有的 key，然后针对 key 的类型，分别执行 STRLEN、LLEN、HLEN、SCARD、ZCARD 命令，来获取 String 类型的长度、容器类型（List、Hash、Set、ZSet）的元素个数。</p><p>当执行这个命令时，要注意 2 个问题：</p><ol><li>对线上实例进行 bigkey 扫描时，Redis 的 OPS 会突增，为了降低扫描过程中对 Redis 的影响，最好控制一下扫描的频率，指定 -i 参数即可，它表示扫描过程中每次扫描后休息的时间间隔，单位是秒</li><li>扫描结果中，对于容器类型（List、Hash、Set、ZSet）的 key，只能扫描出元素最多的 key。但一个 key 的元素多，不一定表示占用内存也多，你还需要根据业务情况，进一步评估内存占用情况</li></ol><p>那针对 bigkey 导致延迟的问题，有什么好的解决方案呢？这里有两点可以优化：</p><ol><li>业务应用尽量避免写入 bigkey</li><li>如果你使用的 Redis 是 4.0 以上版本，用 UNLINK 命令替代 DEL，此命令可以把释放 key 内存的操作，放到后台线程中去执行，从而降低对 Redis 的影响</li><li>如果你使用的 Redis 是 6.0 以上版本，可以开启 lazy-free 机制（<code>lazyfree-lazy-user-del = yes</code>），在执行 DEL 命令时，释放内存也会放到后台线程中执行</li></ol><p>但即便可以使用方案 2，也尽可能不要在实例中存入 bigkey。这是因为 bigkey 在很多场景下，依旧会产生性能问题。例如，bigkey 在分片集群模式下，对于数据的迁移也会有性能影响，包括数据过期、数据淘汰、透明大页，都会受到 bigkey 的影响。</p><h2 id="集中过期"><a href="#集中过期" class="headerlink" title="集中过期"></a>集中过期</h2><p>如果你发现，平时在操作 Redis 时，并没有延迟很大的情况发生，但在某个时间点突然出现一波延时，其现象表现为：<strong>变慢的时间点很有规律，例如某个整点，或者每间隔多久就会发生一波延迟。</strong></p><p>如果是出现这种情况需要排查一下，业务代码中是否存在设置大量 key 集中过期的情况。如果有大量的 key 在某个固定时间点集中过期，在这个时间点访问 Redis 时，就有可能导致延时变大。</p><p>为什么集中过期会导致 Redis 延迟变大？因为Redis 的过期数据采用被动过期 + 主动过期两种策略：</p><ol><li>被动过期：只有当访问某个 key 时，才判断这个 key 是否已过期，如果已过期，则从实例中删除</li><li>主动过期：Redis 内部维护了一个定时任务，默认每隔 100 毫秒（1秒10次）就会从全局的过期哈希表中随机取出 20 个 key，然后删除其中过期的 key，如果过期 key 的比例超过了 25%，则继续重复此过程，直到过期 key 的比例下降到 25% 以下，或者这次任务的执行耗时超过了 25 毫秒，才会退出循环</li></ol><p><strong>主动过期 key 的定时任务，是在 Redis 主线程中执行的</strong>。也就是说如果在执行主动过期的过程中，出现了需要大量删除过期 key 的情况，那么此时应用程序在访问 Redis 时，必须要等待这个过期任务执行结束，Redis 才可以服务这个客户端请求。此时就会出现开头提出的情况，应用访问 Redis 延时变大。如果此时需要过期删除的是一个 bigkey，那么这个耗时会更久。而且，<strong>这个操作延迟的命令并不会记录在慢日志中</strong>（因为慢记录只记录真正操作内存的值）。</p><p><img src="/posts/54676/640-1711874518055-6.webp" alt></p><p>一般集中过期使用的是 <code>expireat</code> / <code>pexpireat</code> 命令，你需要在代码中搜索这个关键字。排查代码后，如果确实存在集中过期 key 的逻辑存在，但这种逻辑又是业务所必须的，那此时如何优化，同时又不对 Redis 有性能影响呢？</p><p>一般有两种方案来规避这个问题：</p><ol><li>集中过期 key 增加一个随机过期时间，把集中过期的时间打散，降低 Redis 清理过期 key 的压力</li><li>如果你使用的 Redis 是 4.0 以上版本，可以开启 lazy-free 机制，当删除过期 key 时，把释放内存的操作放到后台线程中执行，避免阻塞主线程</li></ol><p>第一种方案，在设置 key 的过期时间时，增加一个随机时间，伪代码可以这么写：</p><pre class="line-numbers language-sh"><code class="language-sh"># 在过期时间点之后的 5 分钟内随机过期掉redis.expireat(key, expire_time + random(300))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样一来，Redis 在处理过期时，不会因为集中删除过多的 key 导致压力过大，从而避免阻塞主线程。</p><p>第二种方案，Redis 4.0 以上版本，开启 lazy-free 机制：</p><pre class="line-numbers language-sh"><code class="language-sh"># 释放过期 key 的内存，放到后台线程执行lazyfree-lazy-expire yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另外，除了业务层面的优化和修改配置之外，还可以通过运维手段及时发现这种情况。运维层面，你需要把 Redis 的各项运行状态数据监控起来，在 Redis 上执行 INFO 命令就可以拿到这个实例所有的运行状态数据。在这里我们需要重点关注 expired_keys 这一项，它代表整个实例到目前为止，累计删除过期 key 的数量。你需要把这个指标监控起来，<strong>当这个指标在很短时间内出现了突增</strong>，需要及时报警出来，然后与业务应用报慢的时间点进行对比分析，确认时间是否一致，如果一致，则可以确认确实是因为集中过期 key 导致的延迟变大。</p><h2 id="实例内存达到上限"><a href="#实例内存达到上限" class="headerlink" title="实例内存达到上限"></a>实例内存达到上限</h2><p>如果Redis 实例设置了内存上限 maxmemory，那么也有可能导致 Redis 变慢。当我们把 Redis 当做纯缓存使用时，通常会给这个实例设置一个内存上限 maxmemory，然后设置一个数据淘汰策略。而当实例的内存达到了 maxmemory 后，在此之后每次写入新数据，操作延迟变大了。这是为什么？</p><p>原因在于，当 Redis 内存达到 maxmemory 后，每次写入新的数据之前，<strong>Redis 必须先从实例中踢出一部分数据，让整个实例的内存维持在 maxmemory 之下</strong>，然后才能把新数据写进来。这个踢出旧数据的逻辑也是需要消耗时间的，而具体耗时的长短，要取决于你配置的淘汰策略：</p><ul><li><code>allkeys-lru</code>：不管 key 是否设置了过期，淘汰最近最少访问的 key</li><li><code>volatile-lru</code>：只淘汰最近最少访问、并设置了过期时间的 key</li><li><code>allkeys-random</code>：不管 key 是否设置了过期，随机淘汰 key</li><li><code>volatile-random</code>：只随机淘汰设置了过期时间的 key</li><li><code>allkeys-ttl</code>：不管 key 是否设置了过期，淘汰即将过期的 key</li><li><code>noeviction</code>：不淘汰任何 key，实例内存达到 maxmeory 后，再写入新数据直接返回错误</li><li><code>allkeys-lfu</code>：不管 key 是否设置了过期，淘汰访问频率最低的 key（4.0+版本支持）</li><li><code>volatile-lfu</code>：只淘汰访问频率最低、并设置了过期时间 key（4.0+版本支持）</li></ul><p>具体使用哪种策略，我们需要根据具体的业务场景来配置。</p><p>一般最常使用的是 <code>allkeys-lru</code> / <code>volatile-lru</code> 淘汰策略，它们的处理逻辑是，每次从实例中随机取出一批 key（这个数量可配置），然后淘汰一个最少访问的 key，之后把剩下的 key 暂存到一个池子中，继续随机取一批 key，并与之前池子中的 key 比较，再淘汰一个最少访问的 key。以此往复，直到实例内存降到 maxmemory 之下。需要注意的是，Redis 的淘汰数据的逻辑与删除过期 key 的一样，<strong>也是在命令真正执行之前执行的</strong>，也就是说它也会增加我们操作 Redis 的延迟，而且，写 OPS 越高，延迟也会越明显。</p><p><img src="/posts/54676/640-1711874813688-9.webp" alt="图片"></p><p>另外，如果此时你的 Redis 实例中还存储了 bigkey，那么<strong>在淘汰删除 bigkey 释放内存时，也会耗时比较久</strong>。针对这种情况，如何解决呢？</p><ol><li>避免存储 bigkey，降低释放内存的耗时</li><li>淘汰策略改为随机淘汰，随机淘汰比 LRU 要快很多（视业务情况调整）</li><li>拆分实例，把淘汰 key 的压力分摊到多个实例上</li><li>如果使用的是 Redis 4.0 以上版本，开启 layz-free 机制，把淘汰 key 释放内存的操作放到后台线程中执行（配置 lazyfree-lazy-eviction = yes）</li></ol><h2 id="fork耗时严重"><a href="#fork耗时严重" class="headerlink" title="fork耗时严重"></a>fork耗时严重</h2><p>为了保证 Redis 数据的安全性，我们可能会开启后台定时 RDB 和 AOF rewrite 功能。但如果发现<strong>操作 Redis 延迟变大，都发生在 Redis 后台 RDB 和 AOF rewrite 期间</strong>，那就需要排查在这期间有可能导致变慢的情况。</p><p>当 Redis 开启了后台 RDB 和 AOF rewrite 后，在执行时，它们都需要主进程创建出一个子进程进行数据的持久化。主进程创建子进程，会调用操作系统提供的 fork 函数。而 fork 在执行过程中，<strong>主进程需要拷贝自己的内存页表给子进程</strong>，如果这个实例很大，那么这个拷贝的过程也会比较耗时。</p><p>而且这个 fork 过程会消耗大量的 CPU 资源，在完成 fork 之前，整个 Redis 实例会被阻塞住，无法处理任何客户端请求。如果此时你的 CPU 资源本来就很紧张，那么 fork 的耗时会更长，甚至达到秒级，这会严重影响 Redis 的性能。</p><p>那如何确认确实是因为 fork 耗时导致的 Redis 延迟变大呢？可以在 Redis 上执行 INFO 命令，查看 latest_fork_usec 项，单位微秒。</p><pre class="line-numbers language-sh"><code class="language-sh"># 上一次 fork 耗时，单位微秒latest_fork_usec:59477<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个时间就是主进程在 fork 子进程期间，整个实例阻塞无法处理客户端请求的时间。如果发现这个耗时很久，就要警惕起来了，这意味在这期间，你的整个 Redis 实例都处于不可用的状态。</p><p>除了数据持久化会生成 RDB 之外，当主从节点第一次建立数据同步时，主节点也创建子进程生成 RDB，然后发给从节点进行一次全量同步，所以，这个过程也会对 Redis 产生性能影响。</p><p><img src="/posts/54676/640-1711875208587-12.webp" alt></p><p>要想避免这种情况可以采取以下方案进行优化：</p><ol><li>控制 Redis 实例的内存：尽量在 10G 以下，执行 fork 的耗时与实例大小有关，实例越大，耗时越久</li><li>合理配置数据持久化策略：在 slave 节点执行 RDB 备份，推荐在低峰期执行，而对于丢失数据不敏感的业务（例如把 Redis 当做纯缓存使用），可以关闭 AOF 和 AOF rewrite</li><li>Redis 实例不要部署在虚拟机上：fork 的耗时也与系统也有关，虚拟机比物理机耗时更久</li><li>降低主从库全量同步的概率：适当调大 <code>repl-backlog-size</code> 参数，避免主从全量同步</li></ol><h2 id="开启内存大页"><a href="#开启内存大页" class="headerlink" title="开启内存大页"></a>开启内存大页</h2><p>除了上面讲到的子进程 RDB 和 AOF rewrite 期间，fork 耗时导致的延时变大之外，这里还有一个方面也会导致性能问题，这就是操作系统是否开启了<strong>内存大页机制</strong>。Linux 内核从 2.6.38 开始，支持了<strong>内存大页机制</strong>，该机制允许应用程序以 2MB 大小为单位，向操作系统申请内存。</p><p>当 Redis 在执行后台 RDB 和 AOF rewrite 时，采用 fork 子进程的方式来处理。但主进程 fork 子进程后，此时的<strong>主进程依旧是可以接收写请求的</strong>，而进来的写请求，会采用 Copy On Write（写时复制）的方式操作内存数据。也就是说，主进程一旦有数据需要修改，Redis 并不会直接修改现有内存中的数据，而是<strong>先将这块内存数据拷贝出来，再修改这块新内存的数据</strong>，这就是所谓的「写时复制」。</p><p>但是请注意，主进程在拷贝内存数据时，这个阶段就涉及到新内存的申请，如果此时操作系统开启了内存大页，那么在此期间，客户端即便只修改 10B 的数据，<strong>Redis 在申请内存时也会以 2MB 为单位向操作系统申请，申请内存的耗时变长，进而导致每个写请求的延迟增加，影响到 Redis 性能。</strong></p><p>同样地，如果这个写请求操作的是一个 bigkey，那主进程在拷贝这个 bigkey 内存块时，一次申请的内存会更大，时间也会更久。可见，bigkey 在这里又一次影响到了性能。</p><p><img src="/posts/54676/640-1711876210499-15.webp" alt></p><p>如何解决这个问题？只需要关闭内存大页机制就可以了。</p><p>首先，你需要查看 Redis 机器是否开启了内存大页：</p><pre class="line-numbers language-sh"><code class="language-sh">$ cat /sys/kernel/mm/transparent_hugepage/enabled[always] madvise never<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果输出选项是 always，就表示目前开启了内存大页机制，我们需要关掉它：</p><pre class="line-numbers language-sh"><code class="language-sh">$ echo never > /sys/kernel/mm/transparent_hugepage/enabled<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>操作系统提供的内存大页机制，其优势是可以在一定程序上降低应用程序申请内存的次数。但是对于 Redis 这种对性能和延迟极其敏感的数据库来说，我们希望 Redis 在每次申请内存时，耗时尽量短，所以不建议在 Redis 机器上开启这个机制。</p><h2 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h2><p>当 Redis 开启 AOF 后，其工作原理如下：</p><ol><li>Redis 执行写命令后，把这个命令写入到 AOF 文件内存中（write 系统调用）</li><li>Redis 根据配置的 AOF 刷盘策略，把 AOF 内存数据刷到磁盘上（fsync 系统调用）</li></ol><p>为了保证 AOF 文件数据的安全性，Redis 提供了 3 种刷盘机制：</p><ol><li><code>appendfsync always</code>：主线程每次执行写操作后立即刷盘，此方案会占用比较大的磁盘 IO 资源，但数据安全性最高</li><li><code>appendfsync no</code>：主线程每次写操作只写内存就返回，内存数据什么时候刷到磁盘，交由操作系统决定，此方案对性能影响最小，但数据安全性也最低，Redis 宕机时丢失的数据取决于操作系统刷盘时机</li><li><code>appendfsync everysec</code>：主线程每次写操作只写内存就返回，然后由后台线程每隔 1 秒执行一次刷盘操作（触发fsync系统调用），此方案对性能影响相对较小，但当 Redis 宕机时会丢失 1 秒的数据</li></ol><p>如果 AOF 配置为 <code>appendfsync always</code>，那么 Redis 每处理一次写操作，都会把这个命令写入到磁盘中才返回，整个过程都是在主线程执行的，这个过程必然会加重 Redis 写负担。原因也很简单，操作磁盘要比操作内存慢几百倍，采用这个配置会严重拖慢 Redis 的性能，因此我不建议你把 AOF 刷盘方式配置为 always。</p><p> <code>appendfsync no</code>配置项下，Redis 每次写操作只写内存，什么时候把内存中的数据刷到磁盘，交给操作系统决定，此方案对 Redis 的性能影响最小，但当 Redis 宕机时，会丢失一部分数据，为了数据的安全性，一般我们也不采取这种配置。</p><blockquote><p>如果你的 Redis 只用作纯缓存，对于数据丢失不敏感，采用配置 appendfsync no 也是可以的。</p></blockquote><p>看到这里，如果选比较折中的方案 <code>appendfsync everysec</code>就没问题了吧？这个方案优势在于，Redis 主线程写完内存后就返回，具体的刷盘操作是放到后台线程中执行的，后台线程每隔 1 秒把内存中的数据刷到磁盘中。这种方案既兼顾了性能，又尽可能地保证了数据安全，是不是觉得很完美？</p><p><strong>但是，采用这种方案你也要警惕一下，因为这种方案还是存在导致 Redis 延迟变大的情况发生，甚至会阻塞整个 Redis。</strong>这是为什么？我把 AOF 最耗时的刷盘操作，放到后台线程中也会影响到 Redis 主线程？试想这样一种情况：当 Redis 后台线程在执行 AOF 文件刷盘时，如果此时磁盘的 IO 负载很高，那这个后台线程在执行刷盘操作（fsync系统调用）时就会被阻塞住。</p><p>此时的主线程依旧会接收写请求，紧接着，主线程又需要把数据写到文件内存中（write 系统调用），<strong>但此时的后台子线程由于磁盘负载过高，导致 fsync 发生阻塞，迟迟不能返回，那主线程在执行 write 系统调用时，也会被阻塞住</strong>，直到后台线程 fsync 执行完成后，主线程执行 write 才能成功返回。在这个过程中，主线程依旧有阻塞的风险。</p><p><img src="/posts/54676/640-1711881699423-18.webp" alt="图片"></p><p>所以AOF 配置为 appendfsync everysec，也不能掉以轻心，要警惕磁盘压力过大导致的 Redis 有性能问题。那什么情况下会导致磁盘 IO 负载过大？以及如何解决这个问题呢？</p><ol><li>子进程正在执行 AOF rewrite，这个过程会占用大量的磁盘 IO 资源</li><li>有其他应用程序在执行大量的写文件操作，也会占用磁盘 IO 资源</li></ol><p>对于情况1，说白了就是，Redis 的 AOF 后台子线程刷盘操作，撞上了子进程 AOF rewrite！</p><p>这怎么办？难道要关闭 AOF rewrite 才行？幸运的是，Redis 提供了一个配置项，当子进程在 AOF rewrite 期间，可以让后台子线程不执行刷盘（不触发 fsync 系统调用）操作。这相当于在 AOF rewrite 期间，临时把 appendfsync 设置为了 none，配置如下：</p><pre><code># AOF rewrite 期间，AOF 后台子线程不进行刷盘操作# 相当于在这期间，临时把 appendfsync 设置为了 noneno-appendfsync-on-rewrite yes</code></pre><p>开启这个配置项，在 AOF rewrite 期间，如果实例发生宕机，那么此时会丢失更多的数据，性能和数据安全性需要trade-off后进行选择。如果占用磁盘资源的是其他应用程序，那就比较简单了，定位到是哪个应用程序在大量写磁盘，然后把这个应用程序迁移到其他机器上执行就好了，避免对 Redis 产生影响。</p><p>当然，如果对 Redis 的性能和数据安全都有很高的要求，建议从<strong>硬件层面</strong>来优化，更换为 SSD 磁盘，提高磁盘的 IO 能力，保证 AOF 期间有充足的磁盘资源可以使用，加钱解决一切问题。</p><h2 id="绑定CPU"><a href="#绑定CPU" class="headerlink" title="绑定CPU"></a>绑定CPU</h2><p>很多时候在部署服务时，为了提高服务性能，降低应用程序在多个 CPU 核心之间的上下文切换带来的性能损耗，通常采用的方案是进程绑定 CPU 的方式提高性能。</p><p>我们都知道一般现代的服务器会有多个 CPU，而每个 CPU 又包含多个物理核心，每个物理核心又分为多个逻辑核心，每个物理核下的逻辑核共用 L1/L2 Cache。而 Redis Server 除了主线程服务客户端请求之外，还会创建子进程、子线程。</p><p>其中子进程用于数据持久化，而子线程用于执行一些比较耗时操作，例如异步释放 fd、异步 AOF 刷盘、异步 lazy-free 等等。如果你把 Redis 进程只绑定了一个 CPU 逻辑核心上，那么当 Redis 在进行数据持久化时，fork 出的子进程会继承父进程的 CPU 使用偏好。</p><p><strong>而此时的子进程会消耗大量的 CPU 资源进行数据持久化（把实例数据全部扫描出来需要耗费CPU），这就会导致子进程会与主进程发生 CPU 争抢，进而影响到主进程服务客户端请求，访问延迟变大。</strong></p><p>如果确实想要绑定 CPU，可以优化的方案是，不要让 Redis 进程只绑定在一个 CPU 逻辑核上，而是绑定在多个逻辑核心上，而且，绑定的多个逻辑核心最好是同一个物理核心，这样它们还可以共用 L1/L2 Cache。</p><p>当然，即便把 Redis 绑定在多个逻辑核心上，也只能在一定程度上缓解主线程、子进程、后台线程在 CPU 资源上的竞争。因为这些子进程、子线程还是会在这多个逻辑核心上进行切换，存在性能损耗。</p><p>如何再进一步优化？是否可以让主线程、子进程、后台线程，分别绑定在固定的 CPU 核心上，不让它们来回切换，这样一来，他们各自使用的 CPU 资源互不影响。Redis 在 6.0 版本已经推出了这个功能，可以通过以下配置，对主线程、后台线程、后台 RDB 进程、AOF rewrite 进程，绑定固定的 CPU 逻辑核心：</p><pre class="line-numbers language-sh"><code class="language-sh"># Redis Server 和 IO 线程绑定到 CPU核心 0,2,4,6server_cpulist 0-7:2# 后台子线程绑定到 CPU核心 1,3bio_cpulist 1,3# 后台 AOF rewrite 进程绑定到 CPU 核心 8,9,10,11aof_rewrite_cpulist 8-11# 后台 RDB 进程绑定到 CPU 核心 1,10,11# bgsave_cpulist 1,10-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用Swap"><a href="#使用Swap" class="headerlink" title="使用Swap"></a>使用Swap</h2><p>如果发现 Redis 突然变得非常慢，<strong>每次的操作耗时都达到了几百毫秒甚至秒级</strong>，那此时就需要检查 Redis 是否使用到了 Swap，在这种情况下 Redis 基本上已经无法提供高性能的服务了。</p><p>可以通过以下方式来查看 Redis 进程是否使用到了 Swap：</p><pre class="line-numbers language-sh"><code class="language-sh"># 先找到 Redis 的进程 ID$ ps -aux | grep redis-server# 查看 Redis Swap 使用情况$ cat /proc/$pid/smaps | egrep '^(Swap|Size)'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果如下：</p><pre class="line-numbers language-sh"><code class="language-sh">Size:               1256 kBSwap:                  0 kBSize:                  4 kBSwap:                  0 kBSize:                132 kBSwap:                  0 kBSize:              63488 kBSwap:                  0 kBSize:                132 kBSwap:                  0 kBSize:              65404 kBSwap:                  0 kBSize:            1921024 kBSwap:                  0 kB...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个结果会列出 Redis 进程的内存使用情况。每一行 Size 表示 Redis 所用的一块内存大小，Size 下面的 Swap 就表示这块 Size 大小的内存，有多少数据已经被换到磁盘上了，如果这两个值相等，说明这块内存的数据都已经完全被换到磁盘上了。</p><p>如果只是少量数据被换到磁盘上，例如每一块 Swap 占对应 Size 的比例很小，那影响并不是很大。<strong>如果是几百兆甚至上 GB 的内存被换到了磁盘上</strong>，那么你就需要警惕了，这种情况 Redis 的性能肯定会急剧下降。此时的解决方案是：</p><ol><li>增加机器的内存，让 Redis 有足够的内存可以使用</li><li>整理内存空间，释放出足够的内存供 Redis 使用，然后释放 Redis 的 Swap，让 Redis 重新使用内存</li></ol><p>释放 Redis 的 Swap 过程通常要重启实例，为了避免重启实例对业务的影响，一般会先进行主从切换，然后释放旧主节点的 Swap，重启旧主节点实例，待从库数据同步完成后，再进行主从切换即可。</p><h2 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h2><p>Redis 的数据都存储在内存中，当我们的应用程序频繁修改 Redis 中的数据时，就有可能会导致 Redis 产生内存碎片。内存碎片会降低 Redis 的内存使用率，我们可以通过执行 INFO 命令，得到这个实例的内存碎片率：</p><pre class="line-numbers language-sh"><code class="language-sh"># Memoryused_memory:5709194824used_memory_human:5.32Gused_memory_rss:8264855552used_memory_rss_human:7.70G...mem_fragmentation_ratio:1.45<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mem_fragmentation_ratio = used_memory_rss / used_memory。</p><p>其中 used_memory 表示 Redis 存储数据的内存大小，而 used_memory_rss 表示操作系统实际分配给 Redis 进程的大小。</p><p>如果 mem_fragmentation_ratio &gt; 1.5，说明内存碎片率已经超过了 50%，这时我们就需要采取一些措施来降低内存碎片了。</p><p>解决的方案一般如下：</p><ol><li>如果你使用的是 Redis 4.0 以下版本，只能通过重启实例来解决</li><li>如果你使用的是 Redis 4.0 版本，它正好提供了自动碎片整理的功能，可以通过配置开启碎片自动整理</li></ol><p><strong>但是，开启内存碎片整理，它也有可能会导致 Redis 性能下降。</strong></p><p>原因在于，Redis 的碎片整理工作是也在<strong>主线程</strong>中执行的，当其进行碎片整理时，必然会消耗 CPU 资源，产生更多的耗时，从而影响到客户端的请求。所以，当需要开启这个功能时，最好提前测试评估它对 Redis 的影响。Redis 碎片整理的参数配置如下：</p><pre class="line-numbers language-sh"><code class="language-sh"># 开启自动内存碎片整理（总开关）activedefrag yes# 内存使用 100MB 以下，不进行碎片整理active-defrag-ignore-bytes 100mb# 内存碎片率超过 10%，开始碎片整理active-defrag-threshold-lower 10# 内存碎片率超过 100%，尽最大努力碎片整理active-defrag-threshold-upper 100# 内存碎片整理占用 CPU 资源最小百分比active-defrag-cycle-min 1# 内存碎片整理占用 CPU 资源最大百分比active-defrag-cycle-max 25# 碎片整理期间，对于 List/Set/Hash/ZSet 类型元素一次 Scan 的数量active-defrag-max-scan-fields 1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要结合 Redis 机器的负载情况，以及应用程序可接受的延迟范围进行评估，合理调整碎片整理的参数，尽可能降低碎片整理期间对 Redis 的影响。</p><h2 id="其他原因"><a href="#其他原因" class="headerlink" title="其他原因"></a>其他原因</h2><p><strong>1) 频繁短连接</strong></p><p>业务应用，应该使用长连接操作 Redis，避免频繁的短连接。频繁的短连接会导致 Redis 大量时间耗费在连接的建立和释放上，TCP 的三次握手和四次挥手同样也会增加访问延迟。</p><p><strong>2) 运维监控</strong></p><p>要想提前预知 Redis 变慢的情况发生，必不可少的就是做好完善的监控。监控其实就是对采集 Redis 的各项运行时指标，通常的做法是监控程序定时采集 Redis 的 INFO 信息，然后根据 INFO 信息中的状态数据做数据展示和报警。</p><p>这里需要提醒的是在写一些监控脚本，或使用开源的监控组件时，也不能掉以轻心。在写监控脚本访问 Redis 时，尽量采用长连接的方式采集状态信息，避免频繁短连接。同时，你还要注意控制访问 Redis 的频率，避免影响到业务请求。</p><p>在使用一些开源的监控组件时，最好了解一下这些组件的实现原理，以及正确配置这些组件，防止出现监控组件发生 Bug，导致短时大量操作 Redis，影响 Redis 性能的情况发生。</p><p><strong>3）其它程序争抢资源</strong></p><p>最后需要注意的是， Redis 机器最好专项专用，只用来部署 Redis 实例，不要部署其他应用程序，尽量给 Redis 提供一个相对「安静」的环境，避免其它程序占用 CPU、内存、磁盘资源，导致分配给 Redis 的资源不足而受到影响。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 的性能问题，涉及到的知识点非常广，几乎涵盖了 CPU、内存、网络、甚至磁盘的方方面面，同时还需要了解计算机的体系结构，以及操作系统的各种机制。从资源使用角度来看，包含的知识点如下：</p><ul><li>CPU 相关：使用复杂度过高命令、数据的持久化，都与耗费过多的 CPU 资源有关</li><li>内存相关：bigkey 内存的申请和释放、数据过期、数据淘汰、碎片整理、内存大页、内存写时复制都与内存息息相关</li><li>磁盘相关：数据持久化、AOF 刷盘策略，也会受到磁盘的影响</li><li>网络相关：短连接、实例流量过载、网络流量过载，也会降低 Redis 性能</li><li>计算机系统：CPU 结构、内存分配，都属于最基础的计算机系统知识</li><li>操作系统：写时复制、内存大页、Swap、CPU 绑定，都属于操作系统层面的知识</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为什么我的 Redis 突然慢了一波，之后又恢复正常了？&lt;/li&gt;
&lt;li&gt;为什么我的 Redis 稳定运行了很久，突然从某个时
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>网站需要备案，新域名先暂停使用</title>
    <link href="https://joytsing.github.io/posts/44555/"/>
    <id>https://joytsing.github.io/posts/44555/</id>
    <published>2024-03-30T08:01:29.000Z</published>
    <updated>2024-03-31T07:42:43.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="还是老的域名登录"><a href="#还是老的域名登录" class="headerlink" title="还是老的域名登录"></a>还是老的域名登录</h2><p>等备案完成了,就会加上CDN加快访问。这段时间还是老域名访问。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;还是老的域名登录&quot;&gt;&lt;a href=&quot;#还是老的域名登录&quot; class=&quot;headerlink&quot; title=&quot;还是老的域名登录&quot;&gt;&lt;/a&gt;还是老的域名登录&lt;/h2&gt;&lt;p&gt;等备案完成了,就会加上CDN加快访问。这段时间还是老域名访问。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="站点相关" scheme="https://JoyTsing.github.io/tags/%E7%AB%99%E7%82%B9%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Kubernetes(一)</title>
    <link href="https://joytsing.github.io/posts/41940/"/>
    <id>https://joytsing.github.io/posts/41940/</id>
    <published>2024-03-29T10:47:13.000Z</published>
    <updated>2024-03-29T15:28:32.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>云原生，启动！</p><h3 id="云原生体系"><a href="#云原生体系" class="headerlink" title="云原生体系"></a>云原生体系</h3><ol><li>容器化（Containerization）</li></ol><p>目前最流行的容器化技术是Docker，你可以将任意大小的应用程序和依赖项，甚至在模拟器上运行的一些程序，都进行容器化。随着时间的推移，你还可以对应用程序进行分割，并将未来的功能编写为微服务。</p><ol start="2"><li>持续集成&amp;发布（CI/CD）</li></ol><p>创建CI/CD环境，从而使源代码上的任意修改，都能够自动通过容器进行编译、测试，并被部署到预生产甚至生产环境中。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/138122028">Argo:云原生的工作流引擎 - 知乎 (zhihu.com)</a></p></blockquote><ol start="3"><li>编排&amp;应用定义（Orchestration&amp;Application Definition）</li></ol><p>Kubernetes是目前市场上应用编排领域被最广泛应用的工具，Helm Charts可以用来帮助应用开发和发布者用于升级Kubernetes上运行的应用。</p><blockquote><p><a href="https://link.zhihu.com/?target=https%3A//www.kubernetes.org.cn/k8s">Kubernetes（k8s）中文文档 Kubernetes概述_Kubernetes中文社区</a><br><a href="https://link.zhihu.com/?target=https%3A//helm.sh/zh/docs/">Helm | Docs</a></p></blockquote><ol start="4"><li>监控&amp;分析（Observability&amp;Analysis）</li></ol><p>在这一步中，用户需要为平台选择监控、日志以及跟踪的相关工具，例如将Prometheus用于监控、Fluentd用于日志、Jaeger用于整个应用调用链的跟踪。</p><blockquote><p><a href="https://link.zhihu.com/?target=https%3A//www.redhat.com/zh/topics/microservices/what-is-jaeger">通俗易懂：什么是 Jaeger 软件？优势及作用一览 (redhat.com)</a><br><a href="https://link.zhihu.com/?target=https%3A//www.prometheus.wang/">Introduction · Prometheus中文技术文档</a><br><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/u010038733/article/details/83185003">Fluentd简介_LiangIter的博客-CSDN博客_fluentd</a></p></blockquote><ol start="5"><li>服务代理、发现、网格化（Service Proxy、Discovery、Mesh）</li></ol><p>CoreDNS、Envoy和LInkerd可以分别用于服务发现和服务治理，提供服务的健康检查、请求路由、和负载均衡等功能。</p><blockquote><p><a href="https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1554609">史上最全的高性能代理服务器 Envoy 中文实战教程 ！(强烈建议收藏) - 云+社区 - 腾讯云 (tencent.com)</a><br><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/144d683bbf26">CoreDNS 简单介绍 - 简书 (jianshu.com)</a><br><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/095b1e2ad1c7">Linkerd 初探 - 简书 (jianshu.com)</a></p></blockquote><ol start="6"><li>网络策略&amp;安全（Networking，Policy，Security）</li></ol><p>Calico、Flannel以及Weave Net等软件用于提供更灵活的网络功能。</p><blockquote><p><a href="https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1482739">calico网络原理、组网方式和使用 - 云+社区 - 腾讯云 (tencent.com)</a><br><a href="https://link.zhihu.com/?target=https%3A//www.open-open.com/news/view/1aa473a">一篇文章带你了解Flannel - Flannel - 操作系统 - 深度开源 (open-open.com)</a><br><a href="https://link.zhihu.com/?target=https%3A//www.sdnlab.com/16002.html">Weave系列之Weave Net安装与探索 | SDNLAB | 专注网络创新技术</a></p></blockquote><ol start="7"><li>分布式数据库&amp;存储（Distributed Database&amp;Storage）</li></ol><p>分布式数据库可以提供更好的弹性和伸缩性能，但同时需要专业的容器存储予以支持。</p><blockquote><p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/bbwangj/article/details/82584988">ETCD 简介 + 使用_菲宇的博客-CSDN博客_etcd</a></p></blockquote><ol start="8"><li>流&amp;消息传递（Streaming&amp;Messaging）</li></ol><p>当应用需要比JSON-REST这个模式更高的性能时，可以考虑使用gRPC或者NATS。gRPC是一个通用的RPC（远程调用）框架（类似各种框架中的RPC调用），NATS是一个发布/订阅和负载均衡的<a href="https://www.zhihu.com/search?q=消息队列系统&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"article"%2c"sourceid"%3a68881339}">消息队列系统</a>。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/48530602">高性能消息中间件——NATS - 知乎 (zhihu.com)</a><br><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/9c947d98e192">gRPC详解 - 简书 (jianshu.com)</a></p></blockquote><ol start="9"><li>容器注册&amp;运行（Container Registry&amp;Runtime）</li></ol><p>Harbor是目前最受欢迎的容器镜像库，同时，你也可以选择使用不同的容器运行环境用于运行<a href="https://www.zhihu.com/search?q=容器程序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"article"%2c"sourceid"%3a68881339}">容器程序</a>。</p><blockquote><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/wxwgk/p/13287336.html">harbor搭建及使用 - 浪淘沙&amp; - 博客园 (cnblogs.com)</a></p></blockquote><ol start="10"><li>软件发布</li></ol><p>最后可以借助Notary等软件用于软件的安全发布。</p><blockquote><p><a href="https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/news/298256">Notary项目 - 云+社区 - 腾讯云 (tencent.com)</a></p></blockquote><h2 id="Docker的本质"><a href="#Docker的本质" class="headerlink" title="Docker的本质"></a>Docker的本质</h2><h3 id="和虚拟机的不同"><a href="#和虚拟机的不同" class="headerlink" title="和虚拟机的不同"></a>和虚拟机的不同</h3><p>首先我们思考一个问题：<strong>容器与进程有何不同？</strong></p><ul><li><strong><code>进程</code></strong>：<strong>就是程序运行起来后的计算机执行环境的总和</strong>。</li></ul><blockquote><p>即：计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。</p></blockquote><ul><li><strong><code>容器</code></strong>：<strong>核心就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”</strong>。</li></ul><blockquote><p>对于 Docker 等大多数 Linux 容器来说，<strong>Cgroups</strong> 技术是用来制造约束的主要手段，而 <strong>Namespace</strong> 技术则是用来修改进程视图的主要方法。</p></blockquote><p><img src="/posts/41940/1.png" alt></p><p>上图是一个常见的将Docker和虚拟机进行比较的图，但其实不应该把 Docker Engine 或者任何容器管理工具放在跟 Hypervisor 相同的位置，因为它们并不像 Hypervisor 那样模拟出完整硬件，Docker Engine只是对Linux底层操作系统技术进行封装，<strong>将一个进程进行一些资源隔离</strong>。Docker Engine扮演的更多是旁路式辅助和管理工作。<strong>那么问题来了，他是怎么做到的？</strong></p><h3 id="Linux-Namespace"><a href="#Linux-Namespace" class="headerlink" title="Linux Namespace"></a>Linux Namespace</h3><p>进程，说白了就是运行起来的程序，它是参与当前的计算机里的数据和状态的总和。既然我们要虚拟化出一个隔离世界，那第一点就是要修改进程的视图，让他看不见别的运行的进程，比如我们进入到一个容器内执行ps -ef，我们可以发现这个容器内部的1号进程就是我们在docker中最开始执行的/bin/sh，这意味着Docker完全看不见宿主机中的世界，自己被隔离了。</p><p>实现这个设计非常简单，这只是一个障眼法，我们只需做到新创建的容器（本质进程），在这个进程空间中它是1，而在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，这个就是Linux操作系统提供的<strong>PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*CLONE_NEWPID ： 新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1CLONE_NEWIPC ： 在新的IPC命名空间中创建进程CLONE_NEWNET ： 在新的网络命名空间中创建进程CLONE_NEWNS  ： 在新的mount命名空间中创建进程CLONE_NEWUTS ： 新的UTS命名空间中创建进程CLONE_NEWUSER： 新的用户命名空间中创建进程*/</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">clone</span><span class="token punctuation">(</span>main_function<span class="token punctuation">,</span> stack_size<span class="token punctuation">,</span> CLONE_NEWPID <span class="token operator">|</span> SIGCHLD<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/41940/v2-068b1fb817730b1d4854e4221f6f3ae9_r.jpg" alt></p><p>如果熟悉 Linux可能会联想到 linux 中的 chroot 命令，该命令允许将当前目录修改成根目录（即根目录 / 的挂载点切换了），相当于文件系统被隔离了，Namespace 也具有相似的功能，但更加强大。</p><p>以一个具体的例子来解释 Namespace 的作用，假设你有一台性能非常好的计算机，你向用户出售自己的计算机的资源，每个用户买到一个 ssh 实例，为了避免不同客户之间相互干扰，你可能会对不同用户进行权限限制，让用户只能访问自己 ssh 实例下的资源。</p><p>但有些操作需要 root 权限，而我们不能将 root 权限提供给用户，此时就可以使用 Namespae 了，通过 User Namespace 对 UID 进行隔离，具体而言，UID 为 x 的用户在该 Namespace 中具有 root 权限，但在真实物理机中，他依旧是 UID 为 x 的用户，这就解决了用户间隔离的问题。</p><p>此外还可以通过 PID Namespace 对 PID 进行隔离，从该 Namespace 中的用户角度看，Namespace 中就像一台新的 Linux，有自己的 init 进程（初始进程，PID 为 1），其他进程的 PID 在 init 进程 PID 上递增，也就是上文提到的。<strong>Docker 利用 Linux Namespace 功能实现多个 Docker 容器相互隔离，具有独立环境的功能</strong>，Go 语言对 Namespce API 进行了相应的封装，当然，不要觉得就这？这个技术听起来容易，但是要真正考虑到安全易用还有许多细节，比如权限、路由表、iptables规则配置等等问题。</p><h3 id="Linux-Cgroups"><a href="#Linux-Cgroups" class="headerlink" title="Linux Cgroups"></a>Linux Cgroups</h3><p>以上namespace只是让容器只看到自己内部的情况，但其实它作为宿主机上普通的进程和其他进程一样，也需要平等的竞争计算机资源如CPU，内存，带宽等，因此容器资源会随时被其他进程所抢占，甚至吃光，这些情况显然不是一个“沙盒”应该表现出来的合理行为，因此，<strong>Linux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。</strong></p><p>Cgroups使用非常简单，它是一组文件系统目录，如下图所示，只需要在里面写入配额即可，例如cfs_period 和 cfs_quota，它是用来限制进程在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 每 100 ms 的时间里，被该控制组限制的进程只能使用 50 ms 的 CPU 时间</span><span class="token comment" spellcheck="true">// 即最多使用50%的CPU带宽</span><span class="token comment" spellcheck="true">// 从下面的top可以明显看出</span>echo <span class="token number">50000</span> <span class="token operator">></span> <span class="token operator">/</span>sys<span class="token operator">/</span>fs<span class="token operator">/</span>cgroup<span class="token operator">/</span>cpu<span class="token operator">/</span>container<span class="token operator">/</span>cpu<span class="token punctuation">.</span>cfs_quota_usecho <span class="token number">100000</span> <span class="token operator">></span> <span class="token operator">/</span>sys<span class="token operator">/</span>fs<span class="token operator">/</span>cgroup<span class="token operator">/</span>cpu<span class="token operator">/</span>container<span class="token operator">/</span>cpu<span class="token punctuation">.</span>cfs_period_us <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/41940/image-20240329190735594.png" alt></p><p>Cgroups 由 3 个组件构成，分别是 cgroup（控制组）、subsystem（子系统）以及 hierarchy（层级树），3 者相互协同作用，Cgroups 会将系统进程分组（cgroup）然后通过 hierachy 构建成独立的树，树的节点就是 cgroup（进程组），每颗树都可以与一个或多个 subsystem 关联，subsystem 会对树中对应的组进行操作。</p><ul><li>cgroup 是对进程分组管理的一种机制，一个 cgroup 通常包含一组（多个）进程，Cgroups 中的资源控制都以 cgroup 为单位实现。</li><li>subsystem 是一组（多个）资源控制的模块，每个 subsystem 会管理到某个 cgroup 上，对该 cgroup 中的进程做出相应的限制和控制。</li><li>hierarchy 会将一组（多个）cgroup 构建成一个树状结构，Cgropus 可以利用该结构实现继承等功能</li></ul><p>有个几个规则需要注意：</p><ol><li>一个 subsystem 只能附加到一个 hierarchy，而一个 hierarchy 可以附加多个 subsystem </li><li>一个进程可以作为多个 cgroup 的成员，但这些 cgroup 只能在不同的 hierarchy 中 </li><li>一个进程 fork 出子进程，此时子进程与父进程默认是在同一个 cgroup 中，可以根据需要移动到其他 cgroup</li></ol><h3 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h3><p>namespace的隔离中有一个<strong>Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效，</strong>否则我们执行ls，仍然看到的是宿主机的目录。不难想到，我们可以在容器进程启动之前重新挂载它的整个根目录“/”，而由于 Mount Namespace 的存在，这个挂载对宿主机不可见，这是专属于容器自己的文件系统，这样容器进程就可以在里面随便折腾了。这是如何做到的呢，其实非常简单，核心就是chroot：</p><pre class="line-numbers language-c"><code class="language-c">mkdir <span class="token operator">-</span>p $HOME<span class="token operator">/</span>testmkdir <span class="token operator">-</span>p $HOME<span class="token operator">/</span>test<span class="token operator">/</span><span class="token punctuation">{</span>bin<span class="token punctuation">,</span>lib64<span class="token punctuation">,</span>lib<span class="token punctuation">}</span>cp <span class="token operator">-</span>v <span class="token operator">/</span>bin<span class="token operator">/</span><span class="token punctuation">{</span>bash<span class="token punctuation">,</span>ls<span class="token punctuation">}</span> $HOME<span class="token operator">/</span>test<span class="token operator">/</span>binT<span class="token operator">=</span>$HOME<span class="token operator">/</span>testlist<span class="token operator">=</span><span class="token string">"$(ldd /bin/ls | egrep -o '/lib.*\.[0-9]')"</span><span class="token keyword">for</span> i in $list<span class="token punctuation">;</span> <span class="token keyword">do</span> cp <span class="token operator">-</span>v <span class="token string">"$i"</span> <span class="token string">"${T}${i}"</span><span class="token punctuation">;</span> done<span class="token comment" spellcheck="true">//告诉操作系统，我们将使用 $HOME/test 目录作为 /bin/bash 进程的根目录</span><span class="token comment" spellcheck="true">//这样docker启动时的根目录就是我们之前宿主机上新建的$HOME/test，它不知道这个宿主机的目录，他对于自己的根目录深信不疑</span>chroot $HOME<span class="token operator">/</span>test <span class="token operator">/</span>bin<span class="token operator">/</span>bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，为了能够让容器的这个根目录看起来更“真实”，我们一般会在这个容器的根目录下挂载一个完整操作系统的文件系统，比如 Cent7的 ISO。这样，在容器启动之后，我们在容器里通过执行 “ls /“ 查看根目录下的内容，就是Cent7的所有目录和文件。但话又说回来，rootfs 只包括了操作系统的“躯壳”，并没有包括操作系统的“灵魂”，因为所有的容器都共享同一个宿主机系统的内核。</p><p>rootfs（根文件系统），这个为docker提供隔离后执行环境的文件系统，又名<strong>容器镜像</strong>。Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs，这里核心技术实现是OverlayFS和copy-on-wirte。</p><p>OverlayFS联合挂载顾名思义，就是将多个不同目录影射到一个基础目录中，比如：</p><p><img src="/posts/41940/image-20240329190953629.png" alt></p><p><img src="/posts/41940/image-20240329191003982.png" alt></p><p>那么docker容器中，可在下图看到三个层结构，即：lowerdir、uperdir、merged，其中 lowerdir 是只读的 image layer，其实就是 rootfs，对比我们上述演示的目录 A 和 B，我们知道 image layer 可以分很多层，所以对应的 lowerdir 是可以有多个目录，后续这些目录会联合挂载在merged中。</p><p>而 upperdir 则是在 lowerdir 之上的一层，这层是读写层，在启动一个容器时候会进行创建，所有的对容器数据更改都发生在这里层，对比示例中的 C。最后 merged 目录是容器的挂载点，也就是给用户暴露的统一视角，对比示例中的/tmp/test。下</p><p>图还有一个层没有画出来，就是init层，用于保存专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。需要这样一层的原因是，这些文件本来属于只读的 Ubuntu 镜像的一部分，但是用户往往需要在启动容器时写入一些指定的值比如 hostname，所以就需要在可读写层对它们进行修改。可是，这些修改往往只对当前的容器有效，我们并不希望执行 docker commit 时，把这些信息连同可读写层一起提交掉。所以，就单独搞出一个init层，用户commit只不提交这层的。</p><p><img src="/posts/41940/u=2834064747,4220999756&fm=253&app=138&f=PNG.png" alt></p><p>为什么要有这个upperdir呢，这就是“分层镜像”设计的巧妙之处，比如容器的读过程，如果文件在容器层（upperdir），直接读取文件；如果文件不在容器层（upperdir），则从镜像层（lowerdir）读取；比如容器的写过程，首次写入通过copy_up行为将文件从 lowdir 拷贝到 upperdir，后续写操作只对副本进行操作；比如容器的删除过程，即在upperdir中创建 同名的whiteout 文件，它是空白的，这样镜像层虽然存在，用户已经无法继续访问了。</p><p>所以最上面这个可读写层的作用，就是<strong>专门用来存放你修改基础rootfs 后产生的增量</strong>，无论是增、删、改，都发生在这里。而当我们使用完了这个被修改过的容器之后，还可以<strong>使用 docker commit 和 push 指令，保存这个被修改过的可读写层，并上传到 Docker Hub 上，供其他人使用；而与此同时，原先的只读层里的内容则不会有任何变化</strong>。这就是增量 rootfs 的好处。否则没有这层读写层，大家直接修改了基础rootfs话，新旧两个 rootfs 之间就没有任何关系了，这样做的结果就是极度的碎片化。</p><p><img src="/posts/41940/8a7b5cfabaab2d877a1d4566961edd5f.png" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>综上，docker容器本质就是蒙了双眼的进程，这就意味着这些因为虚拟化而带来的性能损耗都是不存在的；而另一方面，使用 Namespace 作为隔离手段的容器并不需要单独的 Guest OS，这就使得容器额外的资源占用几乎可以忽略不计，这也就是docker的最大优势：敏捷和高性能。</p><p>不过弊端也十分明显，就是隔离的不彻底，既然是特殊的进程，就意味着多个容器还是共享一个宿主机的操作系统内核，你不可能在linux宿主机跑windows容器，或高于宿主机版本的linux容器。其次有一些linux内核资源是没办法隔离的，比如时间，如果有些容器内部操作改变了时间那么整个宿主机上其他容器也会改变，这显然是不符合用户的预期的，这带来的后果就是容器给应用暴露出来的攻击面非常大，安全性比虚拟机低很多。</p><p>一个正在运行的 Linux 容器，其实可以被“一分为二”地看待：一组联合挂载在 /var/lib/docker/aufs/mnt 上的 rootfs，这一部分我们称为“容器镜像”（Container Image），是容器的静态视图；一个由 Namespace+Cgroups 构成的隔离环境，这一部分我们称为“容器运行时”（Container Runtime），是容器的动态视图。</p><h2 id="exec的实现原理"><a href="#exec的实现原理" class="headerlink" title="exec的实现原理"></a>exec的实现原理</h2><p>实际上，Linux Namespace 创建的隔离空间虽然看不见摸不着，但一个进程的 Namespace 信息在宿主机上是确确实实存在的，并且是以一个文件的方式存在。</p><p>比如，通过如下指令，你可以看到当前正在运行的 Docker 容器的所有namespace了：</p><p><img src="/posts/41940/image-20240329191456199.png" alt></p><p>而exec其实就是调用了linux的系统调用setns()进入到某个进程已有的某个namespace中，比如：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/proc/14532/ns/net"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setns</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"setns"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span> <span class="token operator">*</span>sh <span class="token operator">=</span> <span class="token string">"/bin/bash"</span><span class="token punctuation">;</span>    <span class="token function">execvp</span><span class="token punctuation">(</span>sh <span class="token punctuation">,</span> <span class="token operator">&amp;</span>sh<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"execvp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//加入到了容器进程的Network Namespace中了，/bin/bash 进程的网络设备视图，也被修改了。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;云原生，启动！&lt;/p&gt;
&lt;h3 id=&quot;云原生体系&quot;&gt;&lt;a href=&quot;#云原生体系&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://JoyTsing.github.io/categories/Kubernetes/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Docker" scheme="https://JoyTsing.github.io/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://JoyTsing.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>进程/线程与CPU核绑定</title>
    <link href="https://joytsing.github.io/posts/60864/"/>
    <id>https://joytsing.github.io/posts/60864/</id>
    <published>2024-03-29T08:36:15.000Z</published>
    <updated>2024-03-29T09:19:29.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>看Redis的时候提到了这一点，对尾延迟进行优化的话往往需要对CPU下功夫，因为往往是Redis 实例运行时的CPU 的 context switch 次数比较多导致的。而服务器上往往是CPU多核的环境，一个线程先在一个 CPU 核上运行，之后又切换到另一个 CPU 核上运行，这时就会发生 context switch。本质上是对任务调度进行调优。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="cpu亲和性-affinity"><a href="#cpu亲和性-affinity" class="headerlink" title="cpu亲和性(affinity)"></a>cpu亲和性(affinity)</h3><p>CPU的亲和性， 就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器，也称为CPU关联性；再简单的点的描述就将指定的进程或线程绑定到相应的cpu上；在多核运行的机器上，每个CPU本身自己会有缓存，缓存着进程使用的信息，而进程可能会被OS调度到其他CPU上，如此，CPU cache命中率就低了，当绑定CPU后，程序就会一直在指定的cpu跑，不会由操作系统调度到其他CPU上，性能有一定的提高。</p><h3 id="软亲和性-affinity"><a href="#软亲和性-affinity" class="headerlink" title="软亲和性(affinity)"></a>软亲和性(affinity)</h3><p>就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器，Linux 内核进程调度器天生就具有被称为 软 CPU 亲和性(affinity) 的特性，这意味着进程通常不会在处理器之间频繁迁移。这种状态正是我们希望的，因为进程迁移的频率小就意味着产生的负载小。</p><h3 id="硬亲和性-affinity"><a href="#硬亲和性-affinity" class="headerlink" title="硬亲和性(affinity)"></a>硬亲和性(affinity)</h3><p>简单来说就是利用linux内核提供给用户的API，强行将进程或者线程绑定到某一个指定的cpu核运行。</p><ul><li><strong><em>提高CPU缓存命中率</em></strong></li></ul><p><code>CPU</code>各核之间是不共享缓存的，如果进程频繁地在多个<code>CPU</code>核之间切换，则会使旧<code>CPU</code>核的<code>cache</code>失效，失去了利用<code>CPU</code>缓存的优势。如果进程只在某个<code>CPU</code>上执行，可以避免进程在一个<code>CPU</code>上停止执行，然后在不同的<code>CPU</code>上重新执行时发生的缓存无效而引起的性能成本。</p><ul><li><strong><em>适合对时间敏感的应用</em></strong></li></ul><p>在实时性要求高应用中，我们可以把重要的系统进程绑定到指定的<code>CPU</code>上，把应用进程绑定到其余的<code>CPU</code>上。这种做法确保对时间敏感的应用程序可以得到运行，同时可以允许其他应用程序使用其余的计算资源。</p><h2 id="如何绑定"><a href="#如何绑定" class="headerlink" title="如何绑定"></a>如何绑定</h2><p>通过<code>taskset：(-p:pid; -c:cpu list)</code>能够将进程绑定在指定的核上：</p><pre class="line-numbers language-sh"><code class="language-sh">taskset -c 0 ./redis-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在多CPU也就是NUMA架构下，可以为了提升 Redis 的网络性能，把操作系统的网络中断处理程序和 CPU 核绑定(其实如果看过之前的文章你会发现软中断已经绑定了，谁调用绑谁)。这个做法可以避免网络中断处理程序在不同核上来回调度执行，的确能有效提升 Redis 的网络处理性能。</p><p>不过，需要注意的是在 CPU 的 NUMA 架构下，对 CPU 核的编号规则，并不是先把一个 CPU Socket 中的所有逻辑核编完，再对下一个 CPU Socket 中的逻辑核编码，而是先给每个 CPU Socket 中每个物理核的第一个逻辑核依次编号，再给每个 CPU Socket 中的物理核的第二个逻辑核依次编号。</p><p>假设有 2 个 CPU Socket，每个 Socket 上有 6 个物理核，每个物理核又有 2 个逻辑核，总共 24 个逻辑核。我们可以执行 lscpu 命令，查看到这些核的编号：</p><pre class="line-numbers language-sh"><code class="language-sh">lscpuArchitecture: x86_64...NUMA node0 CPU(s): 0-5,12-17NUMA node1 CPU(s): 6-11,18-23...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在绑定多个核的时候不要绑定错了，接下来回到正题，当我们把 Redis 实例绑到一个 CPU 逻辑核上时，就会导致子进程、后台线程和 Redis 主线程竞争 CPU 资源，一旦子进程或后台线程占用 CPU 时，主线程就会被阻塞，导致 Redis 请求延迟增加，当然不止Redis，别的程序同样也通用。</p><p>目前有两个解决方案：</p><h3 id="方案一：一个实例对应绑一个物理核"><a href="#方案一：一个实例对应绑一个物理核" class="headerlink" title="方案一：一个实例对应绑一个物理核"></a>方案一：一个实例对应绑一个物理核</h3><p>在给 Redis 实例绑核时，我们不要把一个实例和一个逻辑核绑定，而要和一个物理核绑定，也就是说，把一个物理核的 2 个逻辑核都用上。如果我们的CPU架构还是和之前一样的话，那么可以这样绑定在一个物理CPU上：</p><pre class="line-numbers language-c"><code class="language-c">taskset <span class="token operator">-</span>c <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">12</span> <span class="token punctuation">.</span><span class="token operator">/</span>redis<span class="token operator">-</span>server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>和只绑一个逻辑核相比，把 Redis 实例和物理核绑定，可以让主线程、子进程、后台线程共享使用 2 个逻辑核，可以在一定程度上缓解 CPU 资源竞争。但是，因为只用了 2 个逻辑核，它们相互之间的 CPU 竞争仍然还会存在。</p><h3 id="方案二：通过系统调用绑定"><a href="#方案二：通过系统调用绑定" class="headerlink" title="方案二：通过系统调用绑定"></a>方案二：通过系统调用绑定</h3><p>在<code>Linux</code>中，用结构体<code>cpu_set_t</code>来表示<code>CPU Affinity</code>掩码，同时定义了一系列的宏来用于操作进程的可调度<code>CPU</code>集合：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> _GNU_SOURCE </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sched.h></span></span><span class="token keyword">void</span> <span class="token function">CPU_ZERO</span><span class="token punctuation">(</span>cpu_set_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">CPU_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> cpu<span class="token punctuation">,</span> cpu_set_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">CPU_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> cpu<span class="token punctuation">,</span> cpu_set_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">CPU_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> cpu<span class="token punctuation">,</span> cpu_set_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">CPU_COUNT</span><span class="token punctuation">(</span>cpu_set_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的作用如下：</p><pre><code>CPU_ZERO()：清除集合的内容，让其不包含任何CPU。CPU_SET()：添加cpu到集合中。CPU_CLR()：从集合中移除cpuCPU_ISSET() ：测试cpu是否在集合中。CPU_COUNT()：返回集合中包含的CPU数量。</code></pre><p>在<code>Linux</code>中，可以使用以下两个函数设置和获取进程的<code>CPU Affinity</code>属性：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> _GNU_SOURCE </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sched.h></span></span><span class="token keyword">int</span> <span class="token function">sched_setaffinity</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> size_t cpusetsize<span class="token punctuation">,</span><span class="token keyword">const</span> cpu_set_t <span class="token operator">*</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sched_getaffinity</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> size_t cpusetsize<span class="token punctuation">,</span>cpu_set_t <span class="token operator">*</span>mask<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另外可以通过下面的函数获知当前进程运行在哪个<code>CPU</code>上：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sched_getcpu</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果调用成功，该函数返回一个非负的<code>CPU</code>编号值。</p><p>那么，怎么在编程时把这三个函数结合起来实现绑核呢？很简单，我们分四步走就行。</p><ul><li>第一步：创建一个 cpu_set_t 结构的位图变量；</li><li>第二步：使用 CPU_ZERO 函数，把 cpu_set_t 结构的位图所有的位都设置为 0；</li><li>第三步：根据要绑定的逻辑核编号，使用 CPU_SET 函数，把 cpu_set_t 结构的位图相应位设置为 1；</li><li>第四步：使用 sched_setaffinity 函数，把程序绑定在 cpu_set_t 结构位图中为 1 的逻辑核上。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//线程函数</span><span class="token keyword">void</span> <span class="token function">worker</span><span class="token punctuation">(</span><span class="token keyword">int</span> bind_cpu<span class="token punctuation">)</span><span class="token punctuation">{</span>    cpu_set_t cpuset<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建位图变量</span>    <span class="token function">CPU_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cpu_set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//位图变量所有位设置0</span>    <span class="token function">CPU_SET</span><span class="token punctuation">(</span>bind_cpu<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cpuset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//根据输入的bind_cpu编号，把位图对应为设置为1</span>    <span class="token function">sched_setaffinity</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cpuset<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cpuset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把程序绑定在cpu_set_t结构位图中为1的逻辑核</span>    <span class="token comment" spellcheck="true">//实际线程函数工作</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pthread_t pthread1    <span class="token comment" spellcheck="true">//把创建的pthread1绑在编号为3的逻辑核上</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pthread1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>worker<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和给线程绑核类似，当我们使用 fork 创建子进程时，也可以把刚刚说的四步操作实现在 fork 后的子进程代码中，示例代码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//用fork创建一个子进程</span>   pid_t p <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" fork error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//子进程代码部分</span>   <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>      cpu_set_t cpuset<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建位图变量</span>      <span class="token function">CPU_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cpu_set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//位图变量所有位设置0</span>      <span class="token function">CPU_SET</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cpuset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把位图的第3位设置为1</span>      <span class="token function">sched_setaffinity</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cpuset<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cpuset<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//把程序绑定在3号逻辑核</span>      <span class="token comment" spellcheck="true">//实际子进程工作</span>      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 Redis 来说，生成 RDB 和 AOF 日志重写的子进程分别是下面两个文件的函数中实现的。</p><ul><li>rdb.c 文件：rdbSaveBackground 函数；</li><li>aof.c 文件：rewriteAppendOnlyFileBackground 函数。</li></ul><p>这两个函数中都调用了 fork 创建子进程，所以，我们可以在子进程代码部分加上绑核的四步操作。使用源码优化方案，我们既可以实现 Redis 实例绑核，避免切换核带来的性能影响，还可以让子进程、后台线程和主线程不在同一个核上运行，避免了它们之间的 CPU 资源竞争。相比使用 taskset 绑核来说，这个方案可以进一步降低绑核的风险。</p><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>对于一个多CPU的服务器，可以尽量将应用分散在多个CPU上，这样可以更好地提高L3 Cache的命中率、内存利用率、避免使用到Swap：</p><p>1、由于CPU Socket1和2分别有自己的L3 Cache，如果把所有实例都绑定在同一个CPU Socket上，相当于这些实例共用这一个L3 Cache，另一个CPU Socket的L3 Cache浪费了。这些实例共用一个L3 Cache，会导致Cache中的数据频繁被替换，访问命中率下降，之后只能从内存中读取数据，这会增加访问的延迟。而8个实例分别绑定CPU Socket，可以充分使用2个L3 Cache，提高L3 Cache的命中率，减少从内存读取数据的开销，从而降低延迟。</p><p> 2、如果这些实例都绑定在一个CPU Socket，由于采用NUMA架构的原因，所有实例会优先使用这一个节点的内存，当这个节点内存不足时，再经过总线去申请另一个CPU Socket下的内存，此时也会增加延迟。而8个实例分别使用2个CPU Socket，各自在访问内存时都是就近访问，延迟最低。 </p><p>3、如果这些实例都绑定在一个CPU Socket，还有一个比较大的风险是：用到Swap的概率将会大大提高。如果这个CPU Socket对应的内存不够了，也可能不会去另一个节点申请内存（操作系统可以配置内存回收策略和Swap使用倾向：本节点回收内存/其他节点申请内存/内存数据换到Swap的倾向程度），而操作系统可能会把这个节点的一部分内存数据换到Swap上从而释放出内存给进程使用（如果没开启Swap可会导致直接OOM）。因为Redis要求性能非常高，如果从Swap中读取数据，此时Redis的性能就会急剧下降，延迟变大。所以8个实例分别绑定CPU Socket，既可以充分使用2个节点的内存，提高内存使用率，而且触发使用Swap的风险也会降低。</p><p>在NUMA架构下，也经常发生某一个节点内存不够，但其他节点内存充足的情况下，依旧使用到了Swap，进而导致软件性能急剧下降的例子。所以在运维层面，我们也需要关注NUMA架构下的内存使用情况（多个内存节点使用可能不均衡），并合理配置系统参数（内存回收策略/Swap使用倾向），尽量去避免使用到Swap。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>虽然绑核技术可以提高程序性能，但也需要注意以下几点：</p><ol><li>不要过度绑定：过度绑定可能会出现线程之间的竞争和CPU利用率低下的情况。</li><li>绑定前需要评估：在进行核心绑定之前，需要对程序进行评估，以确定性能瓶颈位置和绑定的核心数。</li><li>不要跨核心访问内存：如果一个进程已经绑定到一个核心上，那么该进程所使用的内存也只应该在该核心专用的内存上进行操作。如果在不同核心之间频繁地进行内存操作，则会影响程序的性能。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;看Redis的时候提到了这一点，对尾延迟进行优化的话往往需要对CPU下功夫，因为往往是Redis 实例运行时的CPU 的 context s
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/categories/Linux/"/>
    
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(一)</title>
    <link href="https://joytsing.github.io/posts/20149/"/>
    <id>https://joytsing.github.io/posts/20149/</id>
    <published>2024-03-28T10:40:22.000Z</published>
    <updated>2024-04-01T08:13:52.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近买了本技术书&lt;&lt;深入理解Linux网络-修炼底层内功，掌握高性能原理&gt;&gt;<del>一听就非常硬核啊，感兴趣了</del>。买来放了很久才翻开，发现里面的排版真的非常舒服，没有像别的技术书籍一样通篇贴代码，排版稀烂，并且这本书还是彩印的，大部分地方都画了图帮助理解，同时代码量都尽量控制在一页内并且大部分不跨页，真的爱了。除了这些，内容质量也非常过硬，推荐所有想要深入学习网络的人都买来看看。</p><p>这本书分成了几个问题，将一些你见过思考过但是没深入了解过的问题拆分成一个个章节和一个个问题，来诱导你思考，直到最后理解，作者非常的有水平，当然书的难度也很大。另外直接拍书上的图用不太美观，也不方便，所以图是从网上<del>偷的</del>，实际上在书上是彩色的。</p><h2 id="1）Linux网络收包"><a href="#1）Linux网络收包" class="headerlink" title="1）Linux网络收包"></a>1）Linux网络收包</h2><p>在TCP/IP网络分层模型里，整个协议栈被分为了物理层、链路层、网络层、传输层和应用层。Liunx内核以及网卡驱动主要实现链路层、网络层和传输层这三层上的功能，内核为更上面的应用层提供socket接口来支持用户进程访问。以Linux的视角看到的TCP/IP网络分层模型如下图所示：</p><p><img src="/posts/20149/6930c0dee18f4063a68d14c40448f2af.png" alt></p><p><strong>内核和网络设备驱动是通过中断的方式来处理的。</strong>当设备上有数据到达时，会给CPU的相关引脚触发一个电压变化，以通知CPU来处理数据。对于网络模块来说，由于处理过程比较复杂和耗时，如果在中断函数中完成所有的处理，将会导致中断处理函数（优先级过高）过度占用CPU，使得CPU无法响应其他设备。</p><p>因此<strong>Linux中断处理函数是分上半部和下半部的</strong>。上半部只进行最简单的工作，快速处理然后释放CPU，接着CPU就可以允许其他中断进来。将剩下的绝大部分的工作都放到下半部，可以慢慢、从容处理。<strong>2.4以后的Linux内核版本采用的下半部实现方式是软中断，由ksoftirqd内核线程全权处理</strong>。硬中断是通过给CPU物理引脚施加电压变化实现的，而软中断是通过给内存中的一个变量赋予二进制值以标记有软中断发生，注意，这个软中断是贯穿后面所有的连接线。</p><p>一个完整的逻辑流程如下图：</p><p><img src="/posts/20149/2e4c6310db6c4c6fa130bda906b9eaef.png" alt></p><p>当网卡收到数据以后，以<strong>DMA</strong>的方式把网卡收到的帧写到内存里，再向CPU发起硬一个中断<strong>通知</strong>CPU有数据到达。当CPU收到中断请求后，会去调用网络设备驱动注册的<strong>中断处理函数</strong>。网卡的中断处理函数并不做过多工作，发出软中断请求，然后尽快释放CPU资源。ksoftirqd内核线程检测到有软中断请求到达，调用poll开始轮询收包，收到后交由各级协议栈处理。对于TCP包来说，会被放到用户socket的接收队列中。</p><h2 id="2）Linux，启动！"><a href="#2）Linux，启动！" class="headerlink" title="2）Linux，启动！"></a>2）Linux，启动！</h2><p>接下来让我们看看为了接受这个信息，Linux都需要做哪些准备？原书在这里会贴内核代码，在这里我只贴我认为重要的代码，过于细节的部分不会贴上来<del>其实是我不会</del>,不重要的部分就留着到书里面自己看了。</p><h3 id="1-创建ksoftirqd线程"><a href="#1-创建ksoftirqd线程" class="headerlink" title="1.创建ksoftirqd线程"></a>1.创建ksoftirqd线程</h3><p>Linux软中断由<code>ksoftirqd</code>内核线程处理，该线程数等于CPU核数，系统初始化的时候会执行到<code>spawn_ksoftirqd</code>（位于kernel/softirq.c）来创建出<code>ksoftirqd</code>线程，执行过程如下图所示：</p><p><img src="/posts/20149/39aa54f6144447bf88098afad78e1f98.png" alt></p><p>当<code>ksoftirqd</code>被创建出来以后，它就会进入自己的线程循环函数<code>ksoftirqd_should_run</code>和<code>run_ksoftirqd</code>。接下来判断有没有软中断需要处理，软中断不仅有网络软中断，还有其他类型，这里只需要关注下面两个类型：</p><pre class="line-numbers language-c"><code class="language-c">    NET_TX_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 网络传输发送软中断</span>    NET_RX_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 网络传输接收软中断</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-网络子系统初始化"><a href="#2-网络子系统初始化" class="headerlink" title="2 网络子系统初始化"></a>2 网络子系统初始化</h3><p>在网络子系统的初始化过程中，会为每个CPU初始化<code>softnet_data</code>，也会为<code>NET_TX_SOFTIRQ</code>和<code>NET_RX_SOFTIRQ</code>注册处理函数，执行过程如下图所示：</p><p><img src="/posts/20149/74c005cf8140453986f80d14b1ed1567.png" alt></p><p>Linux内核通过调用<code>subsys_initcall</code>来初始化各个子系统，网络子系统的初始化会执行<code>net_dev_init</code>函数:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/dev.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">net_dev_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">for_each_possible_cpu</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> softnet_data <span class="token operator">*</span>sd <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>softnet_data<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>sd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>sd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">skb_queue_head_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>input_pkt_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">skb_queue_head_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>process_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>        sd<span class="token operator">-></span>completion_queue <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>poll_list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">open_softirq</span><span class="token punctuation">(</span>NET_TX_SOFTIRQ<span class="token punctuation">,</span> net_tx_action<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">open_softirq</span><span class="token punctuation">(</span>NET_RX_SOFTIRQ<span class="token punctuation">,</span> net_rx_action<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token function">subsys_initcall</span><span class="token punctuation">(</span>net_dev_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个函数里，会为每个CPU都申请一个<code>softnet_data</code>数据结构，这个数据结构里的<code>poll_list</code>用于等待驱动程序将其poll函数注册进来，后面讲到“网卡驱动初始化”时可以看到这一过程。另外，<code>open_softirq</code>为每一种软中断都注册一个处理函数。<code>NET_TX_SOFTIRQ</code>的处理函数为<code>net_tx_action``，NET_RX_SOFTIRQ</code>的处理函数为<code>net_rx_action</code>。继续跟踪<code>open_softirq</code>后发现这个注册的方式是记录在<code>softirq_vec</code>变量里的。后面讲到<code>ksoftirqd</code>内核线程处理软中断”时，也会使用这个变量来找到每一种软中断对应的处理函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/softirq.c</span><span class="token keyword">void</span> <span class="token function">open_softirq</span><span class="token punctuation">(</span><span class="token keyword">int</span> nr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>action<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> softirq_action <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    softirq_vec<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">.</span>action <span class="token operator">=</span> action<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-协议栈注册"><a href="#3-协议栈注册" class="headerlink" title="3 协议栈注册"></a>3 协议栈注册</h3><p>内核实现了网络层的IP协议，也实现了传输层的TCP协议和UDP协议。这些协议对应的实现函数分为是<code>ip_rcv()</code>、<code>tcp_v4_rcv()</code>和<code>udp_rcv()</code>。Linux内核中的<code>fs_initcall</code>和<code>subsys_initcall</code>类似，也是初始化模块的入口。<code>fs_initcall</code>调用<code>inet_init</code>后开始网络协议栈注册，通过<code>inet_init</code>，将这些函数注册到<code>inet_protos</code>和<code>ptype_base</code>数据结构中，如下图所示：</p><p><img src="/posts/20149/17a3d67ed737474480dae2a2b960203b.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/af_inet.c</span><span class="token keyword">static</span> <span class="token keyword">struct</span> packet_type ip_packet_type __read_mostly <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token function">cpu_to_be16</span><span class="token punctuation">(</span>ETH_P_IP<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>func <span class="token operator">=</span> ip_rcv<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> net_protocol udp_protocol <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>handler <span class="token operator">=</span>    udp_rcv<span class="token punctuation">,</span>    <span class="token punctuation">.</span>err_handler <span class="token operator">=</span>    udp_err<span class="token punctuation">,</span>    <span class="token punctuation">.</span>no_policy <span class="token operator">=</span>    <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>netns_ok <span class="token operator">=</span>    <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> net_protocol tcp_protocol <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>early_demux    <span class="token operator">=</span>    tcp_v4_early_demux<span class="token punctuation">,</span>    <span class="token punctuation">.</span>handler    <span class="token operator">=</span>    tcp_v4_rcv<span class="token punctuation">,</span>    <span class="token punctuation">.</span>err_handler    <span class="token operator">=</span>    tcp_v4_err<span class="token punctuation">,</span>    <span class="token punctuation">.</span>no_policy    <span class="token operator">=</span>    <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>netns_ok    <span class="token operator">=</span>    <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>udp_protocol</code>结构体中的handler是<code>udp_rcv</code>，<code>tcp_protocol</code>结构体中的handler是<code>tcp_v4_rcv</code>，它们通过<code>inet_add_protocol</code>函数被初始化进来，并通过<code>inet_add_protocol</code>函数将TCP和UDP对应的处理函数都注册到<code>inet_protos</code>数组中：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/protocol.c</span><span class="token keyword">int</span> <span class="token function">inet_add_protocol</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> net_protocol <span class="token operator">*</span>prot<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> protocol<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prot<span class="token operator">-></span>netns_ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pr_err</span><span class="token punctuation">(</span><span class="token string">"Protocol %u is not namespace aware, cannot register.\n"</span><span class="token punctuation">,</span>            protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token function">cmpxchg</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> net_protocol <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>inet_protos<span class="token punctuation">[</span>protocol<span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span> prot<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并且通过<code>dev_add_pack(&amp;ip_packet_type)</code>函数，其中<code>ip_packet_type</code>结构体中的type是协议栈名，被注册到<code>ptype_base</code>哈希表中:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/dev.c</span><span class="token keyword">void</span> <span class="token function">dev_add_pack</span><span class="token punctuation">(</span><span class="token keyword">struct</span> packet_type <span class="token operator">*</span>pt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> list_head <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">ptype_head</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> list_head <span class="token operator">*</span><span class="token function">ptype_head</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> packet_type <span class="token operator">*</span>pt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pt<span class="token operator">-></span>type <span class="token operator">==</span> <span class="token function">htons</span><span class="token punctuation">(</span>ETH_P_ALL<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>ptype_all<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>ptype_base<span class="token punctuation">[</span><span class="token function">ntohs</span><span class="token punctuation">(</span>pt<span class="token operator">-></span>type<span class="token punctuation">)</span> <span class="token operator">&amp;</span> PTYPE_HASH_MASK<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的来说，<code>inet_protos</code>记录着UDP、TCP的处理函数地址，<code>ptype_base</code>存储着<code>ip_rcv()</code>函数的处理地址。”<code>ksoftirqd</code>内核线程处理软中断”中会通过<code>ptype_base</code>找到<code>ip_rcv</code>函数地址，进而将IP包正确地发送到<code>ip_rcv()</code>中执行。在<code>ip_rcv</code>中将会通过<code>inet_protos</code>找到TCP或者UDP的处理函数，再把包转发给<code>udp_rcv()</code>或<code>tcp_v4_rcv()</code>函数。</p><h3 id="4-网卡驱动初始化"><a href="#4-网卡驱动初始化" class="headerlink" title="4 网卡驱动初始化"></a>4 网卡驱动初始化</h3><p>每一个驱动程序（不仅仅包括网卡驱动程序）会使用<code>module_init</code>向内核注册一个初始化函数，当驱动程序被加载时，内核会调用这个函数。书中使用的是Intel的网卡，那么igb网卡驱动程序的代码位于<code>drivers/net/ethernet/intel/igb/igb_main.c</code>中，这里因为每家驱动厂商的驱动写的都不一样，大体上了解这个逻辑就行，不必死磕代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span><span class="token keyword">static</span> <span class="token keyword">struct</span> pci_driver igb_driver <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>name     <span class="token operator">=</span> igb_driver_name<span class="token punctuation">,</span>    <span class="token punctuation">.</span>id_table <span class="token operator">=</span> igb_pci_tbl<span class="token punctuation">,</span>    <span class="token punctuation">.</span>probe    <span class="token operator">=</span> igb_probe<span class="token punctuation">,</span>    <span class="token punctuation">.</span>remove   <span class="token operator">=</span> igb_remove<span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">igb_init_module</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    ret <span class="token operator">=</span> <span class="token function">pci_register_driver</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>igb_driver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>驱动的<code>pci_register_driver</code>调用完成后，Linux内核就知道了该驱动的相关信息，比如igb网卡驱动的<code>igb_driver_name</code>和<code>igb_probe</code>函数地址等等。当网卡设备被识别以后，内核会调用其驱动的probe方法（<code>igb_driver</code>的<code>probe</code>方法是<code>igb_probe</code>）。驱动的<code>probe</code>方法执行的目的就是让设备处于ready状态。对于igb网卡，函数<code>igb_probe</code>主要执行的操作如下图所示：</p><p><img src="/posts/20149/44232165709b40578016c7ad7af0b863.png" alt></p><h3 id="5-启动网卡"><a href="#5-启动网卡" class="headerlink" title="5 启动网卡"></a>5 启动网卡</h3><p>当上面的初始化都完成以后，就可以启动网卡了。在前面“网卡驱动初始化”的部分，驱动向内核注册了<code>struct net_device_ops</code>变量，它包含着网卡启动、发包、设置MAC地址等<code>回调函数的函数指针</code>。当启动一个网卡时，<code>net_device_ops</code>变量中定义的<code>ndo_open</code>方法会被调用。对于igb网卡来说，该函数指针指向的是<code>igb_open</code>方法，它主要执行的操作如下图所示：</p><p><img src="/posts/20149/360ed1adab5241b0a25fa4f9c6ce40f6.png" alt></p><p><code>__igb_open</code>方法中主要将<em>传输描述符数组</em>和<em>接收描述符数组</em>以及<em>中断处理函数</em>初始化，并在<code>igb_setup_all_tx_resources</code>中分配<strong>RingBuffer</strong>，建立内存和Rx队列的映射关系。</p><p><img src="/posts/20149/5740764547427485556.png" alt></p><p>关键点来了，每一个队列是如何创建出来的，前面的代码可以了解即可，但这里你需要理解：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span><span class="token keyword">int</span> <span class="token function">igb_setup_rx_resources</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_ring <span class="token operator">*</span>rx_ring<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 1.申请igb_rx_buffer数组内存</span>    size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_rx_buffer<span class="token punctuation">)</span> <span class="token operator">*</span> rx_ring<span class="token operator">-></span>count<span class="token punctuation">;</span>    rx_ring<span class="token operator">-></span>rx_buffer_info <span class="token operator">=</span> <span class="token function">vzalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rx_ring<span class="token operator">-></span>rx_buffer_info<span class="token punctuation">)</span>        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.申请e1000_adv_rx_desc DMA数组内存</span>    rx_ring<span class="token operator">-></span>size <span class="token operator">=</span> rx_ring<span class="token operator">-></span>count <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">union</span> e1000_adv_rx_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    rx_ring<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span>rx_ring<span class="token operator">-></span>size<span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    rx_ring<span class="token operator">-></span>desc <span class="token operator">=</span> <span class="token function">dma_alloc_coherent</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> rx_ring<span class="token operator">-></span>size<span class="token punctuation">,</span>                       <span class="token operator">&amp;</span>rx_ring<span class="token operator">-></span>dma<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rx_ring<span class="token operator">-></span>desc<span class="token punctuation">)</span>        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.初始化队列成员</span>    rx_ring<span class="token operator">-></span>next_to_alloc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    rx_ring<span class="token operator">-></span>next_to_clean <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    rx_ring<span class="token operator">-></span>next_to_use <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上从代码也能看出来，一个<code>RingBuffer</code>的内部不是仅有一个环形队列数组，而是有两个:</p><ul><li>igb_rx_buffer数组：<strong>给内核使用</strong>，通过vzalloc申请的</li><li>e1000_adv_rx_desc数组：<strong>给网卡硬件使用的</strong>，通过dma_alloc_coherent分配</li></ul><p><img src="/posts/20149/6701590266695649995.png" alt></p><p>再接着看中断函数是如何注册的，注册过程见igb_request_irq：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">igb_request_irq</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_adapter <span class="token operator">*</span>adapter<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>adapter<span class="token operator">-</span><span class="token operator">></span>msix_entries<span class="token punctuation">)</span> <span class="token punctuation">{</span>        err <span class="token operator">=</span> <span class="token function">igb_request_msix</span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>err<span class="token punctuation">)</span>            <span class="token keyword">goto</span> request_done<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">igb_request_msix</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_adapter <span class="token operator">*</span>adapter<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adapter<span class="token operator">-</span><span class="token operator">></span>num_q_vectors<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        err <span class="token operator">=</span> <span class="token function">request_irq</span><span class="token punctuation">(</span>adapter<span class="token operator">-</span><span class="token operator">></span>msix_entries<span class="token punctuation">[</span>vector<span class="token punctuation">]</span><span class="token punctuation">.</span>vector<span class="token punctuation">,</span>                  igb_msix_ring<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> q_vector<span class="token operator">-</span><span class="token operator">></span>name<span class="token punctuation">,</span>                  q_vector<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数调用顺序为<code>__igb_open =&gt; igb_request_irq =&gt; igb_request_msix</code>。在<code>igb_request_msix</code>中，对于多队列的网卡，为每一个队列都注册了中断，其对应的中断处理函数是<code>igb_msix_ring</code>。还可以看到，在<code>msix</code>方式下，每个RX队列都有独立的<code>MSI-X</code>中断，从网卡硬件中断的层面就可以设置让收到的包被不同的CPU处理。</p><h2 id="3）接收网络数据"><a href="#3）接收网络数据" class="headerlink" title="3）接收网络数据"></a>3）接收网络数据</h2><h3 id="1-硬中断处理"><a href="#1-硬中断处理" class="headerlink" title="1 硬中断处理"></a>1 硬中断处理</h3><p>首先，当数据帧从网线到达网卡上的时候，第一站是网卡的接收队列。网卡在分配给自己的RingBuffer中寻找可用的内存位置，找到后DMA引擎会把数据DMA到网卡之前关联的内存里，到这个时候CPU都是无感的。当DMA操作完成以后，网卡会向CPU发起一个硬中断，通知CPU有数据到达。硬中断的处理过程如下图所示</p><p><img src="/posts/20149/ff24417f9fb44215a45bcb676c8287df.png" alt></p><p>在前面”启动网卡“的部分，讲到了网卡的硬中断注册的处理函数是<code>igb_msix_ring</code>，进入其中会发现调用链为<code>igb_msix_ring =&gt; napi_schedule =&gt; __napi_schedule =&gt; ____napi_schedule</code></p><p>而在最后<code>____napi_schedule中</code>：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/dev.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">____napi_schedule</span><span class="token punctuation">(</span><span class="token keyword">struct</span> softnet_data <span class="token operator">*</span>sd<span class="token punctuation">,</span>                     <span class="token keyword">struct</span> napi_struct <span class="token operator">*</span>napi<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>napi<span class="token operator">-></span>poll_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sd<span class="token operator">-></span>poll_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__raise_softirq_irqoff</span><span class="token punctuation">(</span>NET_RX_SOFTIRQ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>list_add_tail</code>修改了每个CPU变量<code>softnet_data</code>里的<code>poll_list</code>，将驱动<code>napi_struct</code>传过来的<code>poll_list</code>添加了进来。<code>softnet_data</code>里的<code>poll_list</code>是一个双向列表，其中的设备都带有输入帧等着被处理。紧接着<code>__raise_softirq_irqoff</code>触发了一个软中断NET_RX_SOFTIRQ，这个所谓的触发过程只是对一个变量进行了一次或运算（对软中断有点感觉了没有,mask魅力时刻）。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/softirq.c</span><span class="token keyword">void</span> <span class="token function">__raise_softirq_irqoff</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">trace_softirq_raise</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">or_softirq_pending</span><span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> nr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// include/linux/interrupt.h</span><span class="token macro property">#<span class="token directive keyword">define</span> or_softirq_pending(x)  (local_softirq_pending() |= (x))</span><span class="token comment" spellcheck="true">// include/linux/irq_cpustat.h</span><span class="token macro property">#<span class="token directive keyword">define</span> local_softirq_pending() \    __IRQ_STAT(smp_processor_id(), __softirq_pending)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过以上代码可以看到，硬中断处理过程真的非常短（因为只需要负责通知，后面的软中断就可以交给操作系统去调度了，解决独占的问题），只是记录了一个寄存器，修改了一下CPU的poll_list，然后发出一个软中断。</p><h3 id="2-ksoftirqd内核线程处理软中断"><a href="#2-ksoftirqd内核线程处理软中断" class="headerlink" title="2 ksoftirqd内核线程处理软中断"></a>2 ksoftirqd内核线程处理软中断</h3><p>网络包的接收处理过程主要都在<code>ksoftirqd</code>内核线程中完成，软中断都是在这里处理的，流程如下图所示：</p><p><img src="/posts/20149/3c73b2241f264c90b998537ca2bf9ecc.png" alt></p><p><code>ksoftirqd</code>中两个线程函数<code>ksoftirqd_should_run</code>和<code>run_ksoftirqd</code>。其中<code>ksoftirqd_should_run</code>函数的代码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/softirq.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ksoftirqd_should_run</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> cpu<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// include/linux/irq_cpustat.h</span><span class="token macro property">#<span class="token directive keyword">define</span> local_softirq_pending() \    __IRQ_STAT(smp_processor_id(), __softirq_pending)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数和硬中断中调用了同一个函数<code>local_softirq_pending</code>。使用方式不同在于，在硬中断处理中是为了写入标记，这里只是读取。如果硬中断中设置了NET_RX_SOFTIRQ，这里就能读取到。接下来由内核线程处理函数run_ksoftirqd进行处理：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/softirq.c</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">run_ksoftirqd</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> cpu<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">__do_softirq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>__do_softirq</code>中，判断根据当前CPU的软中断类型，调用其注册的action方法：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// kernel/softirq.c</span>asmlinkage <span class="token keyword">void</span> <span class="token function">__do_softirq</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">unsigned</span> <span class="token keyword">int</span> vec_nr <span class="token operator">=</span> h <span class="token operator">-</span> softirq_vec<span class="token punctuation">;</span>            <span class="token keyword">int</span> prev_count <span class="token operator">=</span> <span class="token function">preempt_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token function">trace_softirq_entry</span><span class="token punctuation">(</span>vec_nr<span class="token punctuation">)</span><span class="token punctuation">;</span>            h<span class="token operator">-></span><span class="token function">action</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">trace_softirq_exit</span><span class="token punctuation">(</span>vec_nr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">}</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        h<span class="token operator">++</span><span class="token punctuation">;</span>        pending <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>硬中断中的设置软中断标记，和ksoftirqd中的判断是否有软中断到达，都是基于smp_processor_id()的。这意味着<strong>只要硬中断在哪个CPU上被响应，那么软中断也是在这个CPU上处理的</strong>。注意，非常重要，<strong>只要硬中断在哪个CPU上被响应，那么软中断也是在这个CPU上处理的</strong>。</p><p>至于具体的<code>net_rx_action</code>是怎么工作的，这个函数中除了定时控制保证网络包的接收不霸占CPU不放，核心逻辑是获取当前CPU变量<code>softnet_data</code>，对其<code>poll_list</code>进行遍历，然后执行到网卡驱动注册的<code>poll</code>函数。对于igb网卡来说，就是igb驱动里的<code>igb_poll</code>函数。在读取操作中，<code>igb_poll</code>的重点工作是对<code>igb_clean_rx_irq</code>的调用,也就是去<code>RingBuffer</code>取数据。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// drivers/net/ethernet/intel/igb/igb_main.c</span><span class="token keyword">static</span> bool <span class="token function">igb_clean_rx_irq</span><span class="token punctuation">(</span><span class="token keyword">struct</span> igb_q_vector <span class="token operator">*</span>q_vector<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> budget<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">/* retrieve a buffer from the ring */</span>        skb <span class="token operator">=</span> <span class="token function">igb_fetch_rx_buffer</span><span class="token punctuation">(</span>rx_ring<span class="token punctuation">,</span> rx_desc<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* exit if we failed to retrieve a buffer */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>skb<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        cleaned_count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* fetch next buffer in frame if non-eop */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">igb_is_non_eop</span><span class="token punctuation">(</span>rx_ring<span class="token punctuation">,</span> rx_desc<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* verify the packet layout is correct */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">igb_cleanup_headers</span><span class="token punctuation">(</span>rx_ring<span class="token punctuation">,</span> rx_desc<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            skb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">/* populate checksum, timestamp, VLAN, and protocol */</span>        <span class="token function">igb_process_skb_fields</span><span class="token punctuation">(</span>rx_ring<span class="token punctuation">,</span> rx_desc<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">napi_gro_receive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q_vector<span class="token operator">-></span>napi<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>total_packets <span class="token operator">&lt;</span> budget<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>igb_fetch_rx_buffer</code>和<code>igb_is_non_eop</code>的作用就是把数据帧从<code>RingBuffer</code>取下来。<code>skb</code>被从<code>RingBuffer</code>取下来以后，会通过<code>igb_alloc_rx_buffers</code>申请新的<code>skb</code>再重新挂上去。为什么需要两个函数呢？因为有可能数据帧要占用多个<code>RingBuffer</code>，所以是在一个循环里获取的，直到帧尾部。获取的一个数据帧用一个<code>sk_buff</code>来表示。收取完数据后，对其进行一些校验，然后开始设置skb变量的timestamp、VLAN id、protocol等字段。接下来进入<code>napi_gro_receive</code>函数，也就是网卡中，把相关的小包合并成一个大包，目的是减少传给网络栈的包数，有助于减少对CPU的使用量。</p><h3 id="3-网络协议栈处理"><a href="#3-网络协议栈处理" class="headerlink" title="3 网络协议栈处理"></a>3 网络协议栈处理</h3><p><code>netif_receive_skb</code>函数会根据包的协议进程处理，假如是UDP包，将包依次送到ip_rcv、udp_rcv等协议处理函数中进行处理，如下图所示：</p><p><img src="/posts/20149/01fb2f840e0c492db2308a5db42c184a.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/dev.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__netif_receive_skb_core</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> bool pfmemalloc<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// pcap逻辑,这里会将数据送入抓包点 tcpdump就是从这个入口获取包的</span>    <span class="token function">list_for_each_entry_rcu</span><span class="token punctuation">(</span>ptype<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptype_all<span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ptype<span class="token operator">-></span>dev <span class="token operator">||</span> ptype<span class="token operator">-></span>dev <span class="token operator">==</span> skb<span class="token operator">-></span>dev<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pt_prev<span class="token punctuation">)</span>                ret <span class="token operator">=</span> <span class="token function">deliver_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> pt_prev<span class="token punctuation">,</span> orig_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>            pt_prev <span class="token operator">=</span> ptype<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">list_for_each_entry_rcu</span><span class="token punctuation">(</span>ptype<span class="token punctuation">,</span>            <span class="token operator">&amp;</span>ptype_base<span class="token punctuation">[</span><span class="token function">ntohs</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">&amp;</span> PTYPE_HASH_MASK<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptype<span class="token operator">-></span>type <span class="token operator">==</span> type <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>ptype<span class="token operator">-></span>dev <span class="token operator">==</span> null_or_dev <span class="token operator">||</span> ptype<span class="token operator">-></span>dev <span class="token operator">==</span> skb<span class="token operator">-></span>dev <span class="token operator">||</span>             ptype<span class="token operator">-></span>dev <span class="token operator">==</span> orig_dev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pt_prev<span class="token punctuation">)</span>                ret <span class="token operator">=</span> <span class="token function">deliver_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> pt_prev<span class="token punctuation">,</span> orig_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>            pt_prev <span class="token operator">=</span> ptype<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>__netif_receive_skb_core</code>函数中取出protocol，它会从数据包中取出协议信息，然后遍历注册在这个协议上的回调函数列表。<code>ptype_base</code>是一个哈希表，在前面“协议栈注册”的部分提到过。<code>ip_rcv</code>函数地址就是存在其中。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/core/dev.c</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">deliver_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span>                  <span class="token keyword">struct</span> packet_type <span class="token operator">*</span>pt_prev<span class="token punctuation">,</span>                  <span class="token keyword">struct</span> net_device <span class="token operator">*</span>orig_dev<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> pt_prev<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> skb<span class="token operator">-></span>dev<span class="token punctuation">,</span> pt_prev<span class="token punctuation">,</span> orig_dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>pt_prev-&gt;func</code>这一行就调用到了协议层注册的处理函数。对于IP包来说，就会进入<code>ip_rcv</code>（如果是ARP包，会进入<code>arp_rcv</code>）</p><h3 id="4-IP层处理"><a href="#4-IP层处理" class="headerlink" title="4 IP层处理"></a>4 IP层处理</h3><p>再来看看Linux在IP层都做了什么，包又是怎样进一步被送到UDP或TCP处理函数中的。下面是IP层接收网络包的主入口<code>ip_rcv</code>:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/ip_input.c</span><span class="token keyword">int</span> <span class="token function">ip_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> net_device <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> packet_type <span class="token operator">*</span>pt<span class="token punctuation">,</span> <span class="token keyword">struct</span> net_device <span class="token operator">*</span>orig_dev<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token function">NF_HOOK</span><span class="token punctuation">(</span>NFPROTO_IPV4<span class="token punctuation">,</span> NF_INET_PRE_ROUTING<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>               ip_rcv_finish<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的NF_HOOK是一个钩子函数，就是<code>iptables netfilter</code>过滤。当执行完注册的钩子后就会执行到最后一个参数指向的函数<code>ip_rcv_finish</code>：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// net/ipv4/ip_input.c</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ip_rcv_finish</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">skb_dst</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token function">ip_route_input_noref</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> iph<span class="token operator">-></span>daddr<span class="token punctuation">,</span> iph<span class="token operator">-></span>saddr<span class="token punctuation">,</span>                           iph<span class="token operator">-></span>tos<span class="token punctuation">,</span> skb<span class="token operator">-></span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token function">dst_input</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后<code>ip_route_input_noref</code>不停的回调(省略部分，不然太摧残心智了)，最后会发现回到<code>ip_rcv_finish</code>中调用的<code>dst_input</code>函数:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// include/net/dst.h</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">dst_input</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">skb_dst</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">input</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如协议栈注册部分所讲，<code>inet_protos</code>中保存着<code>tcp_v4_rcv</code>和<code>udp_rcv</code>的函数地址。这里将会根据包中的协议类型选择转发，在这里skb包将会进一步被派送到更上层的协议中（UDP和TCP）。</p><h2 id="4）小结"><a href="#4）小结" class="headerlink" title="4）小结"></a>4）小结</h2><p>是不是发现回调函数多了非常摧残人的心智（为什么说事件驱动编程难以编写），回到正文：首先在开始收包之前，Linux要做许多的准备工作：</p><ul><li>创建ksoftirqd线程，为它设置好它自己的线程函数，后面由它来处理软中断</li><li>协议栈注册，Linux要实现需要协议，比如ARP、ICMP、IP、UDP和TCP，每一个协议都会将自己的处理函数注册一下，方便包来了迅速找到对应的处理函数</li><li>网卡驱动初始化，每个驱动都有一个初始化函数，内核会让驱动也初始化一下。在这个初始化过程中，把自己的DMA准备好，把NAPI的poll函数地址告诉内核</li><li>启动网卡，分配RX、TX队列，注册中断对应的处理函数</li></ul><p>以上是内核准备收包之前的重要工作，当上面这些都准备好之后，就可以打开硬中断，等待数据包的到来了</p><p>当数据到来以后，第一个迎接它的是网卡：</p><ul><li>网卡将数据帧DMA到内存的<code>RingBuffer</code>中，然后向CPU发起中断通知</li><li>CPU响应中断请求，调用网卡启动时注册的中断处理函数</li><li>中断处理函数几乎没干什么，只发起了软中断请求</li><li>内核线程<code>ksoftirqd</code>发现有软中断请求到来，先关闭硬中断</li><li><code>ksoftirqd</code>线程开始调用驱动的poll函数收包</li><li>poll函数将收到的包送到协议栈注册的<code>ip_rcv</code>函数中</li><li>如果是UDP包，<code>ip_rcv</code>函数将包送到<code>udp_rcv</code>函数中（对于TCP包是送到tcp_rcv_v4）</li></ul><h2 id="5）开篇提问总结"><a href="#5）开篇提问总结" class="headerlink" title="5）开篇提问总结"></a>5）开篇提问总结</h2><p><strong>1）RingBuffer到底是什么，RingBuffer为什么会丢包？</strong></p><p>RingBuffer这个数据结构包括igb_rx_buffer环形队列数组、e1000_adv_rx_desc环形队列数组及众多的skb，如下图所示：</p><p><img src="/posts/20149/6701590266695649995.png" alt></p><p>网卡在收到数据的时候以DMA的方式将包写到RingBuffer中。软中断收包的时候来这里把skb取走，并申请新的skb重新挂上去。RingBuffer中指针数组是预先分配好的，而skb虽然也会预先分配好，但是在后面收包过程中会不断动态地分配申请。如果内核处理得不及时导致RingBuffer满了，那后面新来的数据包就会被丢弃。</p><p><strong>2）网络相关的硬中断、软中断都是什么？</strong></p><p>在网卡将数据放到RingBuffer中后，接着就发起硬中断，通知CPU进行处理。不过硬中断的上下文里做的工作很少，将传过来的poll_list添加到了Per-CPU变量softnet_data的poll_list里（softnet_data的poll_list是一个双向列表，其中的设备都带有输入帧等着被处理），接着触发软中断NET_RX_SOFTIRQ</p><p>在软中断中对softnet_data的设备列表poll_list进行遍历，执行完卡驱动提供的poll来收取网络包。处理完后会送到协议栈的ip_rcv、udp_rcv、tcp_rcv_v4等函数中</p><p><strong>3）Linux里的ksoftirqd内核线程是干什么的？</strong></p><p>一台两核的虚拟机上有两个ksoftirqd内核线程。机器上有几个核，内核就会创建几个ksoftirqd线程出来。内核线程ksoftirqd包含了所有的软中断处理函数，也包括这里提到的NET_RX_SOFTIRQ。在<code>__do_softirq</code>中根据软中断的类型，执行不同的处理函数。对于软中断NET_RX_SOFTIRQ来说是net_rx_action函数</p><p><strong>4）为什么网卡开启多队列能提升网络性能？</strong></p><p>每个队列都会有独立的、不同的中断号，而中断号亲和的CPU不同，不同的队列在将数据收到自己的RingBuffer后，可以分别向不同的CPU发起硬中断通知。而在硬中断的处理中，调用<code>__raise_softirq_irqoff</code>发起软中断的时候，是基于当前CPU核心smp_processor_id的（<code>__raise_softirq_irqoff =&gt; or_softirq_pending =&gt; local_softirq_pending</code>），<strong>哪个核响应的硬中断，那么该硬中断发起的软中断任务就必然由这个核来处理</strong>，所以在工作实践中，如果网络包的接收频率高而导致个别核si偏高，那么通过加大网卡队列数，并设置每个队列中断号上的smp_affinity，将各个队列的硬中断打散到不同的CPU上就行了。这样硬中断后面的软中断CPU开销也将由多个核来分担。</p><p><strong>5）网络接收过程中的CPU开销如何查看？</strong></p><p>在网络的接收过程中，主要工作集中在硬中断和软中断上，二者的消耗都可以通过top命令来查看：</p><pre class="line-numbers language-shell"><code class="language-shell"># toptop - 08:10:30 up  1:04,  1 user,  load average: 0.07, 0.11, 0.09Tasks: 186 total,   2 running, 184 sleeping,   0 stopped,   0 zombie%Cpu(s):  1.4 us,  2.4 sy,  0.0 ni, 96.0 id,  0.0 wa,  0.0 hi,  0.2 si,  0.0 stMiB Mem :   7933.7 total,   6385.5 free,    576.6 used,    971.6 buff/cacheMiB Swap:   2680.0 total,   2680.0 free,      0.0 used.   7105.4 avail Mem 123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中hi是CPU处理硬中断的开销，si是处理软中断的开销，都是以百分比的形式来展示的。</p><p>如果发现某个核的si过高，那么很有可能你的业务上当前数据包的接收已经非常频繁了，需要通过上面说的多队列网卡配置让其他核参与进来，分担这个核接收包的内核工作量。</p><p>书里面只是介绍了怎么接受数据，如果想要了解怎么发送数据的可以看这篇<a href="https://www.coonote.com/tcpip/linux-network-packet-sending-process.html">深入理解Linux 网络包发送过程</a>，以及了解为什么：</p><blockquote><p>在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？</p><p>答：因为虽然是发送数据，但是硬中断最终触发的软中断却是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ。</p></blockquote><p><strong>如果还想继续深入，推荐阅读（不要过分沉溺其中）：</strong></p><p><a href="http://arthurchiao.art/blog/linux-irq-softirq-zh/">Linux 中断（IRQ/softirq）基础：原理及内核实现（2022）</a></p><p><a href="http://arthurchiao.art/blog/linux-net-stack-implementation-rx-zh/">Linux 网络栈接收数据（RX）：原理及内核实现（2022）</a></p><p><a href="https://xusenqi.site/2018/11/23/网卡多队列总结/">网卡多队列总结（转）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;最近买了本技术书&amp;lt;&amp;lt;深入理解Linux网络-修炼底层内功，掌握高性能原理&amp;gt;&amp;gt;&lt;del&gt;一听就非常硬核啊，感兴趣了&lt;/
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络中的I/O模式:select/poll/epoll</title>
    <link href="https://joytsing.github.io/posts/50203/"/>
    <id>https://joytsing.github.io/posts/50203/</id>
    <published>2024-03-23T09:34:36.000Z</published>
    <updated>2024-03-28T13:25:57.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>”Everything is File“，在Linux <strong>·</strong> 古事迹中是这么记载的。在了解多路复用select、poll、epoll实现之前，先复习一下基础的概念。</p><h2 id="一、什么是多路复用："><a href="#一、什么是多路复用：" class="headerlink" title="一、什么是多路复用："></a>一、什么是多路复用：</h2><p>知乎上有这么一个问题，<a href="https://www.zhihu.com/question/59975081/answer/1932776593">IO多路复用到底是不是异步的？</a>。首先先明确一下这个概念：</p><ul><li>多路: 指的是多个socket网络连接;</li><li>复用: 指的是复用一个线程、使用一个线程来检查多个文件描述符（Socket）的就绪状态</li><li>多路复用主要有三种技术：select，poll，epoll。</li></ul><h2 id="二、五种IO模型："><a href="#二、五种IO模型：" class="headerlink" title="二、五种IO模型："></a>二、五种IO模型：</h2><pre class="line-numbers language-text"><code class="language-text">[1]blockingIO - 阻塞IO[2]nonblockingIO - 非阻塞IO[3]signaldrivenIO - 信号驱动IO[4]asynchronousIO - 异步IO[5]IOmultiplexing - IO多路复用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="阻塞式I-O模型："><a href="#阻塞式I-O模型：" class="headerlink" title="阻塞式I/O模型："></a><strong>阻塞式I/O模型：</strong></h3><p><img src="/posts/50203/2020-02-09-15812482347815-blocking-io-model.png" alt></p><p>进程/线程在从调用recv开始到它返回的整段时间内是被阻塞的，recv成功返回后，应用进程/线程开始处理数据报。主要特点是进程阻塞挂起不消耗CPU资源，能及时响应每个操作；实现难度低，适用并发量小的网络应用开发，不适用并发量大的应用，因为一个请求IO会阻塞进程，所以每请求分配一个处理进程（线程）去响应，系统开销大。</p><h3 id="非阻塞式I-O模型："><a href="#非阻塞式I-O模型：" class="headerlink" title="非阻塞式I/O模型："></a><strong>非阻塞式I/O模型：</strong></h3><p><img src="/posts/50203/2020-02-09-15812482347824-non-blocking-io-model.png" alt></p><p>进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。</p><ul><li>进程轮询（重复）调用，消耗CPU的资源；</li><li>实现难度低、开发应用相对阻塞IO模式较难；</li><li>适用并发量较小、且不需要及时响应的网络应用开发；</li></ul><h3 id="信号驱动IO："><a href="#信号驱动IO：" class="headerlink" title="信号驱动IO："></a>信号驱动IO<strong>：</strong></h3><p><img src="/posts/50203/image-20240323190653949.png" alt></p><p>当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。</p><p>特点：回调机制，实现、开发应用难度大；</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p><img src="/posts/50203/image-20240323190757505.png" alt></p><p>当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。</p><p>特点：</p><ul><li>不阻塞，数据一步到位；Proactor模式；</li><li>需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；</li><li>实现、开发应用难度大；</li><li>非常适合高性能高并发应用；</li></ul><h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a><strong>IO复用模型</strong></h3><p><img src="/posts/50203/image-20240323191129383.png" alt></p><p>IO多路复用会将多个Socket注册到一个选择器(Selector)。相当于可以使用一个线程来管理多个Socket连接。在最初的阻塞型IO，每来一个新的连接都需要分配一个线程来处理。</p><p>IO多路复用有三种模式：select、poll、epoll。当用户调用select/poll/epoll，会阻塞当前进程，内核会不断的轮询注册到选择器(Selector)上的Socket，当任何一个Socket的数据准备好了，就会结束阻塞。这个时候用户进程再调用read操作，将数据从内核空间拷贝到用户空间。<strong>IO多路复用</strong>，第一阶段会阻塞在Selector上，第二阶段拷贝数据也会阻塞。</p><p>回顾一下：大多数文件系统的默认IO操作都是缓存IO。在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存（page cache）。也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓存区拷贝到应用程序的地址空间中。这种做法的缺点就是，<strong>需要在应用程序地址空间和内核进行多次拷贝，这些拷贝动作所带来的CPU以及内存开销是非常大的</strong>。</p><p>至于为什么不能直接让磁盘控制器把数据送到应用程序的地址空间中呢？<strong>最简单的一个原因就是应用程序不能直接操作底层硬件。</strong>总的来说，IO分两阶段：</p><p>1)数据准备阶段</p><p>2)内核空间复制回用户进程缓冲区阶段。如下图：</p><p><img src="/posts/50203/u=1195948225,2395373012&fm=253&app=138&f=PNG.png" alt></p><h2 id="三、I-O-多路复用之select、poll、epoll详解"><a href="#三、I-O-多路复用之select、poll、epoll详解" class="headerlink" title="三、I/O 多路复用之select、poll、epoll详解"></a>三、I/O 多路复用之select、poll、epoll详解</h2><h3 id="一些看法"><a href="#一些看法" class="headerlink" title="一些看法"></a>一些看法</h3><p>都什么年代了还在用上个世纪的C-style API，boost/asio，启动！iouring，启动！</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>目前支持I/O多路复用的系统调用有<code>select，pselect，poll，epoll。</code>与多进程和多线程技术相比，<code>I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程</code>，也不必维护这些进程/线程，从而大大减小了系统的开销。</p><p>I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">select</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> timeval <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从上述的select函数声明可以看出，fd_set本质是一个数组，为了方便我们操作该数组，操作系统提供了以下函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 将文件描述符fd从set集合中删除 </span><span class="token keyword">void</span> <span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 判断文件描述符fd是否在set集合中 </span><span class="token keyword">int</span>  <span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将文件描述符fd添加到set集合中 </span><span class="token keyword">void</span> <span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将set集合中, 所有文件描述符对应的标志位设置为0</span><span class="token keyword">void</span> <span class="token function">FD_ZERO</span><span class="token punctuation">(</span>fd_set <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>select</strong> 函数监视的文件描述符分3类，分别是<code>writefds</code>、<code>readfds</code>、和<code>exceptfds</code>，当用户process调用<strong>select</strong>的时候，select会将需要监控的<code>readfds</code>集合拷贝到内核空间（假设监控的仅仅是socket可读），然后遍历自己监控的<code>skb(SocketBuffer)</code>，挨个调用<code>skb</code>的<code>poll</code>逻辑以便检查该socket是否有可读事件，遍历完所有的<code>skb</code>后，如果没有任何一个socket可读，那么select会调用<code>schedule_timeout</code>进入<code>schedule</code>循环，使得process进入睡眠。</p><p>如果在timeout时间内某个socket上有数据可读了，或者等待timeout了，则调用select的process会被唤醒，接下来select就是遍历监控的集合，挨个收集可读事件并返回给用户了，相应的伪码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// nfds:监控的文件描述符集里最大文件描述符加1</span><span class="token comment" spellcheck="true">// readfds：监控有读数据到达文件描述符集合，传入传出参数</span><span class="token comment" spellcheck="true">// writefds：监控写数据到达文件描述符集合，传入传出参数</span><span class="token comment" spellcheck="true">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数</span><span class="token comment" spellcheck="true">// timeout：定时阻塞监控时间，3种情况</span><span class="token comment" spellcheck="true">//  1.NULL，永远等下去</span><span class="token comment" spellcheck="true">//  2.设置timeval，等待固定时间</span><span class="token comment" spellcheck="true">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span><span class="token comment" spellcheck="true">/* * select服务端伪码* 首先一个线程不断接受客户端连接，并把socket文件描述符放到一个list里。*/</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fcntl</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>  fdlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** select函数还是返回刚刚提交的list，应用程序依然list所有的fd，只不过操作系统会将准备就绪的文件描述符做上标识，* 用户层将不会再有无意义的系统调用开销。*/</span><span class="token keyword">struct</span> timeval timeout<span class="token punctuation">;</span><span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 用于记录最大的fd，在轮询中时刻更新即可</span><span class="token comment" spellcheck="true">// 初始化比特位</span><span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>read_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 阻塞获取 每次需要把fd从用户态拷贝到内核态</span>    nfds <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>max <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>write_fd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次需要遍历所有fd，判断有无读写事件发生</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max <span class="token operator">&amp;&amp;</span> nfds<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 只读已就绪的文件描述符，不用过多遍历</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> listenfd<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这里处理accept事件</span>            <span class="token function">FD_SET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将客户端socket加入到集合中</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这里处理read事件</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>看见C-style风格的代码我是真的会谢</p></blockquote><p><strong>select存在三个问题：</strong></p><p>[1] 每次调用select，都需要把被监控的fds集合从用户态空间拷贝到内核态空间，高并发场景下这样的拷贝会使得消耗的资源是很大的。<br>[2] 能监听端口的数量有限，单个进程所能打开的最大连接数由FD_SETSIZE宏定义，监听上限就等于fds_bits位数组中所有元素的二进制位总数，其大小是32个整数的大小<br>[3] 被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a><strong>poll</strong></h3><p>poll的实现和select非常相似，只是描述fd集合的方式不同。poll只是使用pollfd结构而不是select的fd_set结构，去掉了 select 只能监听 1024 个文件描述符的限制。但poll和select同样存在一个性能缺点就是包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** poll服务端实现伪码：*/</span><span class="token keyword">struct</span> pollfd fds<span class="token punctuation">[</span>POLL_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nfds<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token operator">=</span>server_sockfd<span class="token punctuation">;</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">=</span>POLLIN<span class="token operator">|</span>POLLPRI<span class="token punctuation">;</span>nfds<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">{</span>    res<span class="token operator">=</span><span class="token function">poll</span><span class="token punctuation">(</span>fds<span class="token punctuation">,</span>nfds<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span><span class="token punctuation">(</span>POLLIN<span class="token operator">|</span>POLLPRI<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//执行accept并加入fds中，nfds++</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>res<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//循环之后的fds</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span><span class="token punctuation">(</span>POLLIN<span class="token operator">|</span>POLLERR <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//读操作或处理异常等</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>res<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><strong>epoll</strong></h3><p>相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。如前面我们所说，在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。所以 epoll 主要就是针对这三点进行了改进：</p><ol><li>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</li><li>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</li><li>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</li></ol><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p><p>epoll的接口非常简单，一共就三个函数：</p><ul><li>epoll_create：创建一个epoll句柄</li><li>epoll_ctl：向 epoll 对象中添加/修改/删除要管理的连接</li><li>epoll_wait：等待其管理的连接上的 IO 事件的文件描述符，否者失败，返回-1。</li></ul><p>epoll_create的源码实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>epoll_create1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建一个 eventpoll 对象</span>    error <span class="token operator">=</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//struct eventpoll 的定义</span><span class="token comment" spellcheck="true">// file：fs/eventpoll.c</span><span class="token keyword">struct</span> eventpoll <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//sys_epoll_wait用到的等待队列</span>    wait_queue_head_t wq<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//接收就绪的描述符都会放到这里</span>    <span class="token keyword">struct</span> list_head rdllist<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//每个epoll对象中都有一颗红黑树</span>    <span class="token keyword">struct</span> rb_root rbr<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> eventpoll <span class="token operator">*</span><span class="token operator">*</span>pep<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> eventpoll <span class="token operator">*</span>ep<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//申请 epollevent 内存</span>    ep <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ep<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化等待队列头</span>    <span class="token function">init_waitqueue_head</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-</span><span class="token operator">></span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化就绪列表</span>    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-</span><span class="token operator">></span>rdllist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化红黑树指针</span>    ep<span class="token operator">-</span><span class="token operator">></span>rbr <span class="token operator">=</span> RB_ROOT<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中eventpoll 这个结构体中的几个成员的含义如下：</p><ul><li><strong>wq：</strong> 等待队列链表。软中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程。</li><li><strong>rbr：</strong> 红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用的就是红黑树。通过红黑树来管理用户主进程accept添加进来的所有 socket 连接。</li><li><strong>rdllist：</strong> 就绪的描述符链表。当有连接就绪的时候，内核会把就绪的连接放到 rdllist 链表里。这样应用进程只需要判断链表就能找出就绪进程，而不用去遍历红黑树的所有节点了。</li></ul><p><strong>epoll_ctl 函数</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能：</strong>epoll 的事件注册函数，它不同于 select() 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</li><li><strong>参数epfd:</strong> epoll 专用的文件描述符，epoll_create()的返回值</li><li><strong>参数op:</strong> 表示动作，用三个宏来表示：</li></ul><ol><li>EPOLL_CTL_ADD：注册新的 fd 到 epfd 中；</li><li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</li><li>EPOLL_CTL_DEL：从 epfd 中删除一个 fd；</li></ol><ul><li><strong>参数fd:</strong> 需要监听的文件描述符</li><li><strong>参数event:</strong> 告诉内核要监听什么事件，struct epoll_event 结构如:</li><li><strong>events</strong>可以是以下几个宏的集合：</li><li>EPOLLIN ：表示对应的文件描述符可以读（包括对端 SOCKET 正常关闭）；</li><li>EPOLLOUT：表示对应的文件描述符可以写；</li><li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li><li>EPOLLERR：表示对应的文件描述符发生错误；</li><li>EPOLLHUP：表示对应的文件描述符被挂断；</li><li>EPOLLET ：将 EPOLL 设为边缘触发(Edge Trigger)模式，这是相对于水平触发(Level Trigger)来说的。</li><li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 EPOLL 队列里</li><li><strong>返回值：</strong>0表示成功，-1表示失败。</li></ul><p><strong>epoll_wait函数</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> epoll_event <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能：</strong>等待事件的产生，收集在 epoll 监控的事件中已经发送的事件，类似于 select() 调用。</li><li><strong>参数epfd:</strong> epoll 专用的文件描述符，epoll_create()的返回值</li><li><strong>参数events:</strong> 分配好的 epoll_event 结构体数组，epoll 将会把发生的事件赋值到events 数组中（events 不可以是空指针，内核只负责把数据复制到这个 events 数组中，不会去帮助我们在用户态中分配内存）。</li><li><strong>参数maxevents:</strong> maxevents 告之内核这个 events 有多少个 。</li><li><strong>参数timeout:</strong> 超时时间，单位为毫秒，为 -1 时，函数为阻塞。</li><li><strong>返回值：</strong></li></ul><ol><li>如果成功，表示返回需要处理的事件数目</li><li>如果返回0，表示已超时</li><li>如果返回-1，表示失败</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cassert></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAX_EVENT_NUMBER <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//最大事件数</span><span class="token comment" spellcheck="true">// 设置句柄非阻塞</span><span class="token keyword">int</span> <span class="token function">setnonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> old_option <span class="token operator">=</span> <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> new_option <span class="token operator">=</span> old_option <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">;</span>    <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> new_option<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> old_option<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建套接字</span>    <span class="token keyword">int</span> nRet<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m_listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>m_listenfd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail to socket!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// </span>    <span class="token keyword">struct</span> sockaddr_in address<span class="token punctuation">;</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    address<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>    address<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置ip可重用</span>    <span class="token function">setsockopt</span><span class="token punctuation">(</span>m_listenfd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR<span class="token punctuation">,</span> <span class="token operator">&amp;</span>flag<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 绑定端口号</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>m_listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail to bind!,errno :%d"</span><span class="token punctuation">,</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 监听连接fd</span>    ret <span class="token operator">=</span> <span class="token function">listen</span><span class="token punctuation">(</span>m_listenfd<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail to listen!,errno :%d"</span><span class="token punctuation">,</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化红黑树和事件链表结构rdlist结构</span>    epoll_event events<span class="token punctuation">[</span>MAX_EVENT_NUMBER<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建epoll实例</span>    <span class="token keyword">int</span> m_epollfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>m_epollfd<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail to epoll create!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> m_epollfd<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 创建节点结构体将监听连接句柄</span>    epoll_event event<span class="token punctuation">;</span>    event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> m_listenfd<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置该句柄为边缘触发（数据没处理完后续不会再触发事件，水平触发是不管数据有没有触发都返回事件），</span>    event<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN <span class="token operator">|</span> EPOLLET <span class="token operator">|</span> EPOLLRDHUP<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加监听连接句柄作为初始节点进入红黑树结构中，该节点后续处理连接的句柄</span>    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> m_listenfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//进入服务器循环</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> events<span class="token punctuation">,</span> MAX_EVENT_NUMBER<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">!=</span> EINTR<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"epoll failure"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> number<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> sockfd <span class="token operator">=</span> events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 属于处理新到的客户连接</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sockfd <span class="token operator">==</span> m_listenfd<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">struct</span> sockaddr_in client_address<span class="token punctuation">;</span>                socklen_t client_addrlength <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>m_listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>connfd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errno is:%d accept error"</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                epoll_event event<span class="token punctuation">;</span>                event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> connfd<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//设置该句柄为边缘触发（数据没处理完后续不会再触发事件，水平触发是不管数据有没有触发都返回事件），</span>                event<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN <span class="token operator">|</span> EPOLLRDHUP<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 添加监听连接句柄作为初始节点进入红黑树结构中，该节点后续处理连接的句柄</span>                <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> connfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setnonblocking</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> <span class="token punctuation">(</span>EPOLLRDHUP <span class="token operator">|</span> EPOLLHUP <span class="token operator">|</span> EPOLLERR<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//服务器端关闭连接，</span>                <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_DEL<span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//处理客户连接上接收到的数据</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLIN<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token function">read</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"from client :%s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 将事件设置为写事件返回数据给客户端</span>                events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> sockfd<span class="token punctuation">;</span>                events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLOUT <span class="token operator">|</span> EPOLLET <span class="token operator">|</span> EPOLLONESHOT <span class="token operator">|</span> EPOLLRDHUP<span class="token punctuation">;</span>                <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_MOD<span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLOUT<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                std<span class="token operator">::</span>string response <span class="token operator">=</span> <span class="token string">"server response \n"</span><span class="token punctuation">;</span>                <span class="token function">write</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>response<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>response<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 将事件设置为读事件，继续监听客户端</span>                events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> sockfd<span class="token punctuation">;</span>                events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN <span class="token operator">|</span> EPOLLRDHUP<span class="token punctuation">;</span>                <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>m_epollfd<span class="token punctuation">,</span> EPOLL_CTL_MOD<span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//else if 可以加管道，unix套接字等等数据</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="epoll的边缘触发与水平触发"><a href="#epoll的边缘触发与水平触发" class="headerlink" title="epoll的边缘触发与水平触发"></a>epoll的边缘触发与水平触发</h3><p><strong>水平触发(LT)</strong></p><p>关注点是数据是否有无，只要读缓冲区不为空，写缓冲区不满，那么epoll_wait就会一直返回就绪，水平触发是epoll的默认工作方式。</p><p><strong>边缘触发(ET)</strong></p><p>关注点是变化，只要缓冲区的数据有变化，epoll_wait就会返回就绪。这里的数据变化并不单纯指缓冲区从有数据变为没有数据，或者从没有数据变为有数据，还包括了数据变多或者变少。即当buffer长度有变化时，就会触发。</p><p>假设epoll被设置为了边缘触发，当客户端写入了100个字符，由于缓冲区从0变为了100，于是服务端epoll_wait触发一次就绪，服务端读取了2个字节后不再读取。这个时候再去调用epoll_wait会发现不会就绪，只有当客户端再次写入数据后，才会触发就绪。这就导致如果使用ET模式，那就必须保证要「一次性把数据读取&amp;写入完」，否则会导致数据长期无法读取/写入。</p><h3 id="epoll更高效的原因"><a href="#epoll更高效的原因" class="headerlink" title="epoll更高效的原因"></a>epoll更高效的原因</h3><p>epoll比select和poll高效的原因主要有下面几点： </p><ol><li>将文件描述符添加和检测分离，减少了用户态和内核态之间的文件描述符拷贝 </li><li>减少了对就绪文件描述符的遍历，内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</li><li>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</li></ol><p>深入阅读的话可以看：<a href="https://zhuanlan.zhihu.com/p/361750240">深入揭秘 epoll 是如何实现 IO 多路复用的</a>，<a href="https://mp.weixin.qq.com/s/X6c_H5_4OInR8nFQVn7IMA">最多能创建多少个TCP连接</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>select，poll，epoll都是IO多路复用机制，即可以监视多个描述符，一旦某个描述符就绪（读或写就绪），能够通知程序进行相应读写操作。 但select，poll，epoll本质上都是<strong>同步I/O</strong>（注意啊，select/poll 模型是一种<strong>阻塞模型</strong>，epoll 是<strong>非阻塞模型</strong>，同步≠阻塞），因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><ul><li>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</li><li>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</li></ul><table><thead><tr><th></th><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td>性能</td><td>随着连接数的增加，性能急剧下降，处理成千上万的并发连接数时，性能很差</td><td>随着连接数的增加，性能急剧下降，处理成千上万的并发连接数时，性能很差</td><td>随着连接数的增加，性能基本没有变化</td></tr><tr><td>连接数</td><td>一般1024</td><td>无限制</td><td>无限制</td></tr><tr><td>内存拷贝</td><td>每次调用select拷贝</td><td>每次调用poll拷贝</td><td>fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝</td></tr><tr><td>数据结构</td><td>bitmap</td><td>数组</td><td>红黑树</td></tr><tr><td>内在处理机制</td><td>线性轮询</td><td>线性轮询</td><td>FD挂在红黑树，通过事件回调callback</td></tr><tr><td>时间复杂度</td><td>O(n)</td><td>O(n)</td><td>O(1)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;”Everything is File“，在Linux &lt;strong&gt;·&lt;/strong&gt; 古事迹中是这么记载的。在了解多路复用selec
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记</title>
    <link href="https://joytsing.github.io/posts/30038/"/>
    <id>https://joytsing.github.io/posts/30038/</id>
    <published>2024-03-23T09:27:30.000Z</published>
    <updated>2024-03-23T14:50:29.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，学习一个项目最好的方法就是看文档，<a href="https://redis.io/docs/">redis文档</a>里面就介绍了怎么直接通过加apt源的方式便捷安装(类似之前的llvm镜像源)，本文章主要介绍redis的基础知识，但同时就像简介上说的，重点在于怎么用好怎么设计而不是死扣细节知识，不过凡事都要讲究一个先后顺序，不积跬步无以至千里。</p><h2 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1. 简单动态字符串"></a>1. 简单动态字符串</h2><ul><li>在大多数情况下，Redis 使用 SDS（Simple Dynamic String，简单动态字符串）作为字符串表示</li></ul><h3 id="1-1-SDS-的结构体定义"><a href="#1-1-SDS-的结构体定义" class="headerlink" title="1.1 SDS 的结构体定义"></a>1.1 SDS 的结构体定义</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> sdshdr <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 记录 buf 数组中已使用字节的数量</span>    <span class="token comment" spellcheck="true">// 等于 SDS 所保存字符串的长度</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录 buf 数组中未使用字节的数量</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 字节数组，用于保存字符串，会自动在数组末尾添加一个字节，用于保存'\0'，不计入 len 值中</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-SDS-相对于-C-字符串的优点"><a href="#1-2-SDS-相对于-C-字符串的优点" class="headerlink" title="1.2 SDS 相对于 C 字符串的优点"></a>1.2 SDS 相对于 C 字符串的优点</h3><ol><li>常数复杂度获取字符串长度</li></ol><p>Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1)，这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈</p><ul><li>杜绝缓冲区溢出</li><li>减少修改字符串时带来的内存重分配次数</li></ul><p>通过未使用空间（free），SDS 实现了 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong> 两种优化策略</p><ol start="2"><li>二进制安全</li></ol><p>为了确保 Redis 可以适用于各种不同的适用场景，SDS 的 API 都是二进制安全的，因此使得 Redis 不仅可以保存文本数据，还可以保存任意格式的二进制数据，因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束</p><ol start="3"><li>兼容部分C字符串函数</li></ol><p>通过遵循C字符串以空字符结尾的惯例，SDS 可以在有需要时重用 <code>&lt;string.h&gt;</code> 函数库，从而避免了不必要的代码重复</p><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h2><p>链表被广泛用于实现 Redis 的各种功能，比如列表键、发布与订阅、慢查询、监视器等</p><p>Redis 的链表是由一个 <code>list</code> 结构和 n 个 <code>listNode</code> 结构组成，list 里面可以存储该链表的头指针、尾指针、以及长度计数器和用于实现多态链表所需的类型特定函数，Redis 的链表是 <strong>双端</strong>、<strong>无环</strong> 的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 每个链表节点使用一个 adlist.h/listNode</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> listNode <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 前置节点</span>    <span class="token keyword">struct</span> listNode <span class="token operator">*</span> prev<span class="token punctuation">;</span>    <span class="token keyword">struct</span> listNode <span class="token operator">*</span> next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点的值</span>    <span class="token keyword">void</span> <span class="token operator">*</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span>listNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 虽然仅仅使用多个listNode结构就可以构成链表，</span><span class="token comment" spellcheck="true">// 但使用adlist.h/list来持有链表的话，操作起来会更方便</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> list <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 表头节点</span>    listNode <span class="token operator">*</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 表尾节点</span>    listNode <span class="token operator">*</span> tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 链表所包含的节点数量</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点值复制函数</span>    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点值释放函数</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点值对比函数</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>list<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h2><ul><li>Redis 的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对</li></ul><h3 id="3-1-哈希表"><a href="#3-1-哈希表" class="headerlink" title="3.1 哈希表"></a>3.1 哈希表</h3><ul><li>Redis 字典所使用的哈希表由 <code>dict.h/dictht</code> 结构定义：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dicht <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 哈希表数组</span>    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 哈希表大小</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 哈希表大小掩码，用于计算索引值</span>    <span class="token comment" spellcheck="true">// 总是等于 size - 1</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 该哈希表已有节点的数量</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token punctuation">}</span>dictht<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-哈希表节点"><a href="#3-2-哈希表节点" class="headerlink" title="3.2 哈希表节点"></a>3.2 哈希表节点</h3><ul><li>哈希表节点使用 <code>dictEntry</code> 结构表示，每个 <code>dictEntry</code> 结构都保存着一个键值对：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictEntry <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 键</span>    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 值</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>        uint64_tu64<span class="token punctuation">;</span>        int64_ts64<span class="token punctuation">;</span>    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指向下个哈希表节点，形成链表</span>    <span class="token keyword">struct</span> dictEntry <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>dictEntry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-字典"><a href="#3-3-字典" class="headerlink" title="3.3 字典"></a>3.3 字典</h3><ul><li>Redis 中的字典由 <code>dict.h/dict</code> 结构表示：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dict <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 类型特定函数</span>    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 私有数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 哈希表</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// rehash 索引</span>    <span class="token comment" spellcheck="true">// 当 rehash 不在进行时，值为 -1</span>    <span class="token keyword">int</span> trehashidx<span class="token punctuation">;</span><span class="token punctuation">}</span> dict<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-普通状态下的字典"><a href="#3-4-普通状态下的字典" class="headerlink" title="3.4 普通状态下的字典"></a>3.4 普通状态下的字典</h3><p><img src="/posts/30038/image-20240323221208002.png" alt></p><h3 id="3-5-哈希算法"><a href="#3-5-哈希算法" class="headerlink" title="3.5 哈希算法"></a>3.5 哈希算法</h3><ul><li>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新的键值对的哈希表节点放到哈希表数组的指定索引上面。</li></ul><p>Redis 计算哈希值和索引值的方法如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 使用字典设置的哈希函数，计算键key的哈希值</span>hash <span class="token operator">=</span> dict <span class="token operator">-></span> type <span class="token operator">-></span> <span class="token function">hashFunction</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用哈希表的sizemask属性和哈希值，计算出索引值</span><span class="token comment" spellcheck="true">// 根据情况不同，ht[x]可以是ht[0]或者ht[1]</span>index <span class="token operator">=</span> hash <span class="token operator">&amp;</span> dict <span class="token operator">-></span> ht<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>sizemask<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Redis 使用 <code>MurmurHash2</code> 算法来计算键的哈希值</p></blockquote><h3 id="3-6-解决键冲突"><a href="#3-6-解决键冲突" class="headerlink" title="3.6 解决键冲突"></a>3.6 解决键冲突</h3><p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个 next 指针，多个哈希表节点可以用 next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题</p><p>因为 <code>dictEntry</code> 节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置（复杂度为O(1)）,排在其他已有节点的前面。</p><h3 id="3-7-rehash"><a href="#3-7-rehash" class="headerlink" title="3.7 rehash"></a>3.7 rehash</h3><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。</p><p>Redis 对字典的哈希表执行 rehash 的步骤如下：</p><ol><li>为字典的 ht[1] 哈希表分配空间</li><li>如果是扩展操作，那么 ht[1] 的大小为第一个大于等于 <code>ht[0].used*2 的 2 ^ n</code>（2 的 n 次方）</li><li>如果执行的是收缩操作，那么 ht[1] 的大小为第一个大于等于 <code>ht[0].used 的 2 ^ n</code></li><li>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面：rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到 ht[1] 哈希表的指定位置上</li><li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表），释放 ht[0]，将 ht[1] 设置为 ht[0] ，并在 ht[1] 新创建一个空白哈希表，为下一次 rehash 做准备</li></ol><h3 id="3-8-执行扩展或收缩操作的条件"><a href="#3-8-执行扩展或收缩操作的条件" class="headerlink" title="3.8 执行扩展或收缩操作的条件"></a>3.8 执行扩展或收缩操作的条件</h3><p>当以下条件中的任意一个被满足时，程序会自动对哈希表执行扩展操作：</p><ol><li>服务目前没有在执行 <code>BGSAVE</code> 命令或者 <code>BGREWRITEAOF</code> 命令，并且哈希表的负载因子大于等于 1 。</li><li>服务器目前正在执行 <code>BGSAVE</code> 命令或者 <code>BGREWRITEAOF</code> 命令，并且哈希表的负载因子大于等于 5 。</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 负载因子 = 哈希表已保存的节点数量 / 哈希表大小</span>load_factor <span class="token operator">=</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">/</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另一方面，当哈希表的负载因子小于 0.1 时，程序自动开始对哈希表执行收缩操作</p><p>但是，为了避免 rehash 对服务器性能造成影响，服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ，而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1]。</p><p>其方法是通过在字典中维护一个索引计数器变量 <code>rehashidx</code>，当 <code>rehashidx</code> 为 0 时，表示 rehash 工作正式开始，在 rehash 工作期间，每次对字典执行增删改查操作，都会顺带将 ht[0] 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 ht[1]，rehash 完成之后，<code>rehashidx</code> 自增一，最终在某个时间点 ht[0] 上所有键值对都会被 rehash 至 ht[1] ，这时程序将 <code>rehashidx</code> 属性值设为 1，表示 rehash 操作已完成。</p><p>渐进式 rehash 的好处在于它采取分而治之的方式，将 rehash 键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式 rehash 而带来的庞大计算量。</p><h2 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4. 跳跃表"></a>4. 跳跃表</h2><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均 O(logN) 、最坏 O(N) 度的节点查找，还可以通过顺序性操作来批量处理节点。Redis 只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p><h3 id="4-1-跳跃表的实现"><a href="#4-1-跳跃表的实现" class="headerlink" title="4.1 跳跃表的实现"></a>4.1 跳跃表的实现</h3><p>Redis 的跳跃表由 <code>redis.h/zskiplistNode</code> 和 <code>redis.h/zskiplist</code> 两个结构定义，其中 <code>zskiplistNode</code> 结构用于表示跳跃表节点，而 <code>zskiplist</code> 结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等。</p><p><img src="/posts/30038/image-20240323221355732.png" alt></p><h3 id="4-2-跳跃表节点"><a href="#4-2-跳跃表节点" class="headerlink" title="4.2 跳跃表节点"></a>4.2 跳跃表节点</h3><p>跳跃表节点的实现由 <code>redis.h/zskiplistNode</code> 结构定义</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplistNode <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 层</span>    <span class="token keyword">struct</span> zskiplistLevel <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 前进指针</span>        <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>forward<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 跨度</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span>    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 后退指针</span>    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>backward<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分值</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 成员变量</span>    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span><span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5. 整数集合"></a>5. 整数集合</h2><ul><li>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</li></ul><p>每个 <code>intset.h/intset</code> 结构表示一个整数集合</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> intset <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 编码方式</span>    uint32_t encoding<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 集合中包含的元素数量</span>    uint32_t length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保存元素的数组</span>    int8_t contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> intset<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>contents</code> 数组是整数集合的底层实现：整数集合的每个元素都是 <code>contents</code> 数组的一个数组项（item），各个项在数组中按值的大小从小到大有序的排列，并且数组中不包含任何重复项。</p><h3 id="5-1-升级"><a href="#5-1-升级" class="headerlink" title="5.1 升级"></a>5.1 升级</h3><ul><li>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现在所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面</li></ul><h3 id="5-2-升级的好处"><a href="#5-2-升级的好处" class="headerlink" title="5.2 升级的好处"></a>5.2 升级的好处</h3><ul><li>整数集合的升级策略有两个好处，一个是提升整数集合的灵活性，另一个是尽可能的节约内存。</li></ul><blockquote><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p></blockquote><h2 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6. 压缩列表"></a>6. 压缩列表</h2><ul><li>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么 Redis 就会使用压缩列表来做列表键的底层实现。</li><li>压缩列表是 Redis 为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的 <strong>顺序型（sequential）数据结构</strong>。一个压缩列表可以包含任意 <strong>多个节点（entry）</strong>，每个节点可以保存一个字节数组或者一个整数值。</li><li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。</li></ul><h2 id="7-对象"><a href="#7-对象" class="headerlink" title="7. 对象"></a>7. 对象</h2><blockquote><p>前面已经介绍了 Redis 用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。<br>Redis 并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。<br>通过这五种不同类型的对象，Redis 可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。<br>除此之外，Redis 的对象系统还实现了基于引用计数技术的内存回收机制以及对象共享机制，Redis 对象还带有访问时间记录信息，可以用于计算数据库键的空转时长等等。</p></blockquote><h3 id="7-1-对象的类型与编码"><a href="#7-1-对象的类型与编码" class="headerlink" title="7.1 对象的类型与编码"></a>7.1 对象的类型与编码</h3><p>Redis 使用对象来表示数据库中的键和值，每次当我们在 Redis 的数据库中新创建一个键值对时，我们 <strong>至少会创建两个对象</strong>，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。</p><p>Redis 中每个对象都由一个 <code>redisObject</code> 结构表示</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> redisObject <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 类型</span>    <span class="token keyword">unsigned</span> type<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 编码</span>    <span class="token keyword">unsigned</span> encoding<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指向底层实现数据结构的指针</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 引用计数</span>    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 对象最后一次被命令程序访问的时间</span>    <span class="token keyword">unsigned</span> lru<span class="token punctuation">:</span><span class="token number">22</span><span class="token punctuation">;</span><span class="token punctuation">}</span> robj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-1-1-类型"><a href="#7-1-1-类型" class="headerlink" title="7.1.1 类型"></a>7.1.1 类型</h4><p>对象的 <code>type</code> 属性记录了对象的类型，其值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象。</p><p>对于 Redis 数据库保存的键值对来说，键总是一个字符串对象，而值则可以是其他类型对象中的一种，因此：</p><ul><li>当我们称呼一个数据库键为 “字符串键” 时，我们指的是 “这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为 “列表键” 时，我们指的是 “这个数据库键所对应的值为列表对象” 。</li></ul><p><code>TYPE</code> 命令的实现方式也与此类似，当我们对一个数据库键执行 <code>TYPE</code> 命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型。</p><h4 id="7-1-2-编码和底层实现"><a href="#7-1-2-编码和底层实现" class="headerlink" title="7.1.2 编码和底层实现"></a>7.1.2 编码和底层实现</h4><p>对象的 <code>ptr</code> 指针指向对象的底层实现数据结构，而这些数据结构由对象的 <code>encoding</code> 属性决定。</p><p><code>encoding</code> 属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现。</p><p>使用 <code>OBJECT ENCODING</code> 命令可以查看一个数据库键的值对象的编码</p><h3 id="7-2-字符串对象"><a href="#7-2-字符串对象" class="headerlink" title="7.2 字符串对象"></a>7.2 字符串对象</h3><p>字符串对象的编码可以是 <code>int</code> 、<code>raw</code> 、或者 <code>embstr</code> 。</p><ul><li>如果一个字符串对象保存的是整数值，并且这个整数值可以用 <code>long</code> 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 <code>ptr</code> 属性里面（将 void* 转换成 long），并将字符串对象的编码设置为 <code>int</code> 。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于 32 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为 <code>raw</code> 。</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于 32 字节，那么字符串对象将使用 <code>embstr</code> 编码的方式来保存这个字符串值 。</li></ul><blockquote><p><code>raw</code> 与 <code>embstr</code> 的区别是：<code>raw</code> 编码会调用两次内存分配函数来分别创建 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构，而 <code>embstr</code> 编码则通过一次内存分配函数来分配一块连续的空间，空间中依次包含 <code>redisObject</code> 和 <code>sdshdr</code> 两个结构 。<br>最后，long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的，保存时会先将浮点数转换成字符串值，然后再保存所得字符串值 。</p></blockquote><h4 id="7-2-1-编码的转换"><a href="#7-2-1-编码的转换" class="headerlink" title="7.2.1 编码的转换"></a>7.2.1 编码的转换</h4><p>对于 <code>int</code> 编码的字符串对象来说，如果我们向对象执行了一些命令，使这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从 <code>int</code> 变为 <code>raw</code> 。</p><p>另外 Redis 没有为 <code>embstr</code> 编码的字符串对象编写任何相应的修改程序（<code>int</code> 和 <code>raw</code> 有），所以 <code>embstr</code> 编码的字符串对象实际上是只读的，当对 <code>embstr</code> 编码的字符串对象执行任何修改命令时，程序会先将对象的编码从 <code>embstr</code> 转换成 <code>raw</code>，然后再执行修改命令。因为这个原因，<code>embstr</code> 编码的对象在执行修改命令之后，总会变成一个 <code>raw</code> 编码的字符串对象。</p><h3 id="7-3-列表对象"><a href="#7-3-列表对象" class="headerlink" title="7.3 列表对象"></a>7.3 列表对象</h3><p>列表对象的编码可以是 <code>ziplist</code> 或者 <code>linkedlist</code> 。</p><ul><li><code>ziplist</code> 编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。</li><li><code>linkedlist</code> 编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素</li></ul><h4 id="7-3-1-编码转换"><a href="#7-3-1-编码转换" class="headerlink" title="7.3.1 编码转换"></a>7.3.1 编码转换</h4><p>当列表对象可以同时满足以下两个条件时，列表对象使用 <strong>ziplist</strong> 编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li><li>列表对象保存的元素数量小于 512 个；</li></ul><p>不能满足这两个条件的列表对象需要使用 <strong>linkedlist</strong> 编码。注意这两个条件的上限值是可以修改的。</p><h3 id="7-4-哈希对象"><a href="#7-4-哈希对象" class="headerlink" title="7.4 哈希对象"></a>7.4 哈希对象</h3><p>哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code> 。</p><p>使用 <code>ziplist</code> 编码的哈希对象有以下特点：</p><ol><li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后。</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ol><p>使用 <code>hashtable</code> 编码的哈希对象有以下特点：</p><ol><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值；</li></ol><h4 id="7-4-1-编码转换"><a href="#7-4-1-编码转换" class="headerlink" title="7.4.1 编码转换"></a>7.4.1 编码转换</h4><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用 <strong>ziplist</strong> 编码：</p><ol><li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li><li>哈希对象保存的键值对数量小于 512 个；</li></ol><p>这两个条件的上限值也是可以修改的，不满足条件的哈希对象需要使用 <strong>hashtable</strong> 编码。</p><h3 id="7-5-集合对象"><a href="#7-5-集合对象" class="headerlink" title="7.5 集合对象"></a>7.5 集合对象</h3><p>集合对象的编码可以是 <code>intset</code> 或者 <code>hashtable</code> 。</p><ul><li><code>intset</code> 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</li><li><code>hashtable</code> 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为 null 。</li></ul><h4 id="7-5-1-编码转换"><a href="#7-5-1-编码转换" class="headerlink" title="7.5.1 编码转换"></a>7.5.1 编码转换</h4><p>当集合对象可以同时满足以下两个条件时，对象使用 <code>intset</code> 编码：</p><ol><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过 512 个；</li></ol><p>第二个条件的上限值是可以修改的，不满足这两个条件的集合对象需要使用 <code>hashtable</code> 编码。</p><h3 id="7-6-有序集合对象"><a href="#7-6-有序集合对象" class="headerlink" title="7.6 有序集合对象"></a>7.6 有序集合对象</h3><p>有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code> 。</p><p>ziplist 编码的压缩对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score），压缩列表内的集合元素按分值从小到大进行排序。</p><p><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现，一个 <code>zset</code> 结构同时包含一个字典和一个跳跃表。</p><h4 id="7-6-1-编码转换"><a href="#7-6-1-编码转换" class="headerlink" title="7.6.1 编码转换"></a>7.6.1 编码转换</h4><p>当有序集合对象可以同时满足以下两个条件时，对象使用 <code>ziplist</code> 编码：</p><ol><li>有序集合保存的元素数量小于 128 个；</li><li>有序集合保存的所有元素成员长度都小于 64 字节；</li></ol><p>以上两个上限值都是可以修改的，不能满足这两个条件的有序集合对象将使用 <code>skiplist</code> 编码 。</p><h3 id="7-7-内存回收-amp-对象共享"><a href="#7-7-内存回收-amp-对象共享" class="headerlink" title="7.7 内存回收 &amp; 对象共享"></a>7.7 内存回收 &amp; 对象共享</h3><p>因为 C 语言并不具备自动内存回收功能，所以 Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。每个对象的引用计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录。</p><p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。尽管共享更复杂的对象可以节约更多的内存，但受 CPU 时间的限制，Redis 只对包含整数值的字符串对象进行共享。</p><h3 id="7-8-对象的空转时长"><a href="#7-8-对象的空转时长" class="headerlink" title="7.8 对象的空转时长"></a>7.8 对象的空转时长</h3><p>除了之前介绍了 <code>type</code> 、<code>encoding</code> 、<code>ptr</code> 和 <code>refcount</code> 四个属性之外，<code>redisObject</code> 结构包含的最后一个属性为 <code>lru</code> 属性，该属性记录了对象最后一次被命令程序访问的时间。</p><p>使用命令 <code>OBJECT IDLETIME 给定键</code> 可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的。</p><blockquote><p>除了可以被 <code>OBJECT IDLETIME 给定键</code> 命令打印出来之外，键的空转时长还有另外一项作用：如果服务器打开了 <code>maxmemory</code> 选项，并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ，那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p></blockquote><h2 id="8-数据库"><a href="#8-数据库" class="headerlink" title="8. 数据库"></a>8. 数据库</h2><h3 id="8-1-服务器中的数据库"><a href="#8-1-服务器中的数据库" class="headerlink" title="8.1 服务器中的数据库"></a>8.1 服务器中的数据库</h3><p>Redis 服务器将所有数据库都保存在服务器状态 <code>redis.h/redisServer</code> 结构的 db 数组中，db 数组的每个项都是一个 <code>redis.h/redisDb</code> 结构，每个 <code>redisDb</code> 结构代表一个数据库。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> redisServer <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 一个数组，保存着服务器中的所有数据库</span>    redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 初始化服务器时，程序会根据服务器状态的 dbnum 属性</span>    <span class="token comment" spellcheck="true">// 来决定应该创建多少个数据库，默认是 16</span>    <span class="token keyword">int</span> dbnum<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过命令 <code>SELECT n</code> 来切换到 n 号数据库。</p><h3 id="8-2-数据库键空间"><a href="#8-2-数据库键空间" class="headerlink" title="8.2 数据库键空间"></a>8.2 数据库键空间</h3><p><code>redisDb</code> 结构的 <code>dict</code> 字典保存了数据库中所有键值对，我们将这个字典称为键空间（key space）。</p><p>键空间和用户所见的数据库是直接对应的</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种 Redis 对象。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> redisDb <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token comment" spellcheck="true">// 数据库键空间，保存着数据库中的所有键值对</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 过期字典，保存着键的过期时间</span>    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-3-键的生存时间或过期时间"><a href="#8-3-键的生存时间或过期时间" class="headerlink" title="8.3 键的生存时间或过期时间"></a>8.3 键的生存时间或过期时间</h3><p>redisDb 结构的 <code>expires</code> 字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中某个键对象（也即是某个数据库键）。</li><li>过期字典的值是一个 long long 类型的整数，这个整数保存了键所指向的数据库键的过期时间–一个毫秒精度的 UNIX 时间戳。</li></ul><p><img src="/posts/30038/image-20240323224406093.png" alt></p><h3 id="8-4-过期键的删除策略"><a href="#8-4-过期键的删除策略" class="headerlink" title="8.4 过期键的删除策略"></a>8.4 过期键的删除策略</h3><p>有三种不同的删除策略：</p><ol><li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除该键；如果没有，就返回该键。</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ol><p>为了更好更合理的在 CPU 时间以及避免浪费内存空间之间取得平衡，Redis 服务器使用 <strong>惰性删除</strong> 和 <strong>定期删除</strong> 两种策略。</p><h3 id="8-5-AOF、RDB-和复制功能对过期键的处理"><a href="#8-5-AOF、RDB-和复制功能对过期键的处理" class="headerlink" title="8.5 AOF、RDB 和复制功能对过期键的处理"></a>8.5 AOF、RDB 和复制功能对过期键的处理</h3><h4 id="8-5-1-载入-RDB-文件"><a href="#8-5-1-载入-RDB-文件" class="headerlink" title="8.5.1 载入 RDB 文件"></a>8.5.1 载入 RDB 文件</h4><p>在启动服务器时，如果服务器开启了 RDB 功能，那么服务器将对 RDB 文件进行载入：</p><ul><li>如果服务器以主服务器模式运行，那么在载入 RDB 文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入 RDB 文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模式运行，那么在载入 RDB 文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入 RDB 文件的从服务器也不会造成影响。</li></ul><h4 id="8-5-1-AOF-文件写入"><a href="#8-5-1-AOF-文件写入" class="headerlink" title="8.5.1 AOF 文件写入"></a>8.5.1 AOF 文件写入</h4><p>当服务器以 AOF 持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么 AOF 文件不会因为这个过期键而产生任何影响。</p><p>当过期键被惰性删除或者定期删除之后，程序回向 AOF 文件追加（append）一条 DEL 命令，来显式地记录该键已经被删除。</p><h4 id="8-5-2-AOF-重写"><a href="#8-5-2-AOF-重写" class="headerlink" title="8.5.2 AOF 重写"></a>8.5.2 AOF 重写</h4><p>和生成 RDB 文件时类似，在执行 AOF 重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的 AOF 文件中。</p><h4 id="8-5-3-复制"><a href="#8-5-3-复制" class="headerlink" title="8.5.3 复制"></a>8.5.3 复制</h4><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p><ul><li>主服务器在删除一个过期键之后，会显式的向所有从服务器发送一个 <code>DEL</code> 命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>从服务器只有在接到主服务器发来的 <code>DEL</code> 命令之后，才会删除过期键。</li></ul><p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。</p><h4 id="8-5-4-数据库通知"><a href="#8-5-4-数据库通知" class="headerlink" title="8.5.4 数据库通知"></a>8.5.4 数据库通知</h4><p>数据库通知功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</p><ul><li>“某个键执行了什么命令” 的通知称为键空间通知（key-space notification）</li><li>“某个命令被什么键执行了” 的通知称为键事件通知（key-event notification）</li></ul><p>当 Redis 命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</p><h2 id="9-RDB-持久化"><a href="#9-RDB-持久化" class="headerlink" title="9. RDB 持久化"></a>9. RDB 持久化</h2><h3 id="9-1-RDB-文件的创建与载入"><a href="#9-1-RDB-文件的创建与载入" class="headerlink" title="9.1 RDB 文件的创建与载入"></a>9.1 RDB 文件的创建与载入</h3><p>有两个 Redis 命令可以用于生成 RDB 文件，一个是 <code>SAVE</code> ，另一个是 <code>BGSAVE</code>。</p><ul><li><code>SAVE</code> 命令会阻塞 <code>Redis</code> 服务器进程，直到 RDB 文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。</li><li>与 <code>SAVE</code> 命令直接阻塞服务器进程的做法不同，<code>BGSAVE</code> 命令会派生出一个子进程，然后由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理命令请求。</li></ul><p>RDB 文件的载入工作是在服务器启动时自动执行的，所以 Redis 并没有专门用于载入 RDB 文件的命令，只要 Redis 服务器在启动时检测到 RDB 文件存在，它就会自动载入 RDB 文件。</p><p>另外，因为 AOF 文件的更新频率通常比 RDB 文件的更新频率高，所以：</p><ul><li>如果服务器开启了 AOF 持久化功能，那么服务器会优先使用 AOF 文件来还原数据库状态。</li><li>只有在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态。</li></ul><p>服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p><h3 id="9-2-自动间隔性保存"><a href="#9-2-自动间隔性保存" class="headerlink" title="9.2 自动间隔性保存"></a>9.2 自动间隔性保存</h3><p>因为 <code>BGSAVE</code> 命令可以在不阻塞服务器进程的情况下执行，所以 Redis 允许用户通过设置服务器配置的 <code>save</code> 选项，让服务器每个一段时间自动执行一次 <code>BGSAVE</code> 命令。</p><p>用户可以通过 <code>save</code> 选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行 <code>BGSAVE</code> 命令。</p><p>Redis 的服务器周期性操作函数 <code>serverCron</code> 默认每个 100 毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查 <code>save</code> 选项所设置的保存条件是否已经满足，如果满足的话，就执行 <code>BGSAVE</code> 命令。</p><h2 id="10-AOF-持久化"><a href="#10-AOF-持久化" class="headerlink" title="10. AOF 持久化"></a>10. AOF 持久化</h2><p>与 RDB 持久化通过保存数据库中的键值对来记录数据库状态不同，AOF（Append Only File）持久化时通过保存 Redis 服务器所执行的写命令来记录数据库状态的。</p><h3 id="10-1-AOF-持久化的实现"><a href="#10-1-AOF-持久化的实现" class="headerlink" title="10.1 AOF 持久化的实现"></a>10.1 AOF 持久化的实现</h3><p>AOF 持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p><h4 id="10-1-1-命令追加"><a href="#10-1-1-命令追加" class="headerlink" title="10.1.1 命令追加"></a>10.1.1 命令追加</h4><p>当 AOF 持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的 <code>aof_buf</code> 缓冲区的末尾。</p><h4 id="10-1-2-文件的写入与同步"><a href="#10-1-2-文件的写入与同步" class="headerlink" title="10.1.2 文件的写入与同步"></a>10.1.2 文件的写入与同步</h4><blockquote><p>为了提高文件的写入效率，在现代操作系统中，当用户调用 <code>write</code> 函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正的将缓冲区中的数据写入到磁盘里面。<br>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。</p></blockquote><p>因此，Redis 服务器配置 <code>appendfsync</code> 选项的值直接决定 AOF 持久化功能的效率和安全性。</p><p>下面是配置可选值：</p><p><img src="/posts/30038/image-20240323224837065.png" alt></p><h3 id="10-2-AOF-文件的载入与数据还原"><a href="#10-2-AOF-文件的载入与数据还原" class="headerlink" title="10.2 AOF 文件的载入与数据还原"></a>10.2 AOF 文件的载入与数据还原</h3><p>因为 AOF 文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍 AOF 文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><p>步骤如下：</p><ol><li>创建一个不带网络连接的伪客户端（fake client）</li><li>从 AOF 文件中分析并读取一条写命令</li><li>使用伪客户端执行被读出的写命令</li><li>重复执行步骤 2 与 步骤 3 ，直到 AOF 中的所有写命令都被处理完毕为止。</li></ol><h3 id="10-3-AOF-重写"><a href="#10-3-AOF-重写" class="headerlink" title="10.3 AOF 重写"></a>10.3 AOF 重写</h3><p>因为 AOF 持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF 文件中的内容越来越多，文件体积也会越来越大，如果不加以控制，体积过大的 AOF 文件很可能对 Redis 服务器、甚至整个宿主计算机造成影响，并且 AOF 文件体积越大，使用 AOF 文件来进行数据还原所需的时间就越多。</p><p>为了解决 AOF 文件体积膨胀的问题，Redis 提供了 AOF 文件重写（rewrite）功能。通过该功能，Redis 服务器可以创建一个新的 AOF 文件来替代现有的 AOF 文件，新旧两个 AOF 文件所保存的数据库状态相同，但新 AOF 文件不会包含任何浪费空间的冗余命令，所以新 AOF 文件的体积通常会比旧 AOF 文件的体积要小得多。</p><p>AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p><p>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是 AOF 重写功能的实现原理。</p><p>Redis 将 AOF 重写程序放到子进程里执行，这样子进程在进行 AOF 重写期间，服务器进程（父进程）可以继续处理命令请求，并且可以避免在使用锁的情况下，保证数据的安全性。</p><p>但是，使用子进程也有一个问题需要解决，因为子进程在进行 AOF 重写期间，服务器还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库状态不一致。</p><p>为了解决这种数据不一致的问题，Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当 Redis 服务器执行完一个写命令之后，它会同时将这个命令发送给 AOF 缓冲区和 AOF 重写缓冲区。</p><p>当子进程完成 AOF 重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p><ol><li>将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中，这时新 AOF 文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的 AOF 文件进行改名，原子地（atomic）覆盖现有的 AOF 文件，完成新旧两个 AOF 文件的替换。</li></ol><p>这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。</p><p>在整个 AOF 后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其它时候，AOF 后台重写都不会阻塞父进程，这将 AOF 重写对服务器性能造成的影响降到了最低。</p><blockquote><p>总结 AOF 重写就是，在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新的 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p></blockquote><h2 id="11-事件"><a href="#11-事件" class="headerlink" title="11. 事件"></a>11. 事件</h2><p>Redis 服务器是一个事件驱动器，服务器需要处理以下两类事件：</p><ul><li>文件事件（file event）：Redis 服务器通过套接字与客户端（或者其它 Redis 服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其它服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件（time event）：Redis 服务器中的一些操作（比如 <code>serverCron</code> 函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h3 id="11-1-文件事件"><a href="#11-1-文件事件" class="headerlink" title="11.1 文件事件"></a>11.1 文件事件</h3><p>Redis 基于 <code>Reactor</code> 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：</p><ul><li>文件事件处理器使用 I / O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其它同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p><p>文件事件分为 <code>AE_READABLE</code> 事件（读事件）和 <code>AE_WRITEABLE</code> 事件（写事件）两类。</p><h3 id="11-2-时间事件"><a href="#11-2-时间事件" class="headerlink" title="11.2 时间事件"></a>11.2 时间事件</h3><p>Redis 的时间事件分为以下两类：</p><ul><li>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序 X 在当前时间的 30 毫秒之后执行一次。</li><li>周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序 X 每隔 30 毫秒就执行一次。</li></ul><p>服务器在一般情况下只执行 <code>serverCron</code> 函数一个时间事件，并且这个事件是周期性事件。</p><p>时间事件的实际处理时间通常会比设定的到达时间晚一些。</p><blockquote><p>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</p></blockquote><h2 id="12-复制"><a href="#12-复制" class="headerlink" title="12. 复制"></a>12. 复制</h2><p>在 Redis 中，用户可以通过执行 <code>SLAVEOF</code> 命令或者设置 <code>slaveof</code> 选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器被称为从服务器（slave）。</p><h3 id="12-1-复制功能的实现"><a href="#12-1-复制功能的实现" class="headerlink" title="12.1 复制功能的实现"></a>12.1 复制功能的实现</h3><p>Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p><ul><li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。</li></ul><p>在 Redis 的旧版复制功能中存在着缺陷，也就是当从服务器断线后重复制的效率非常低。在旧版复制功能中，从服务器断线之后重连，需要请求主服务器重新执行 <code>BGSAVE</code> 命令生成包含全部数据库状态的 RDB 文件，然后再传输给从服务器，从服务器接受载入 RDB 文件，其效率非常低下。</p><p>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis 从 2.8 版本开始，使用 <code>PSYNC</code> 命令代替 <code>SYNC</code> 命令来执行复制时的同步操作。</p><p><code>PSYNC</code> 命令具有两种模式：</p><ul><li>完整重同步（full resynchronization）：用于处理初次复制情况，执行步骤与 <code>SYNC</code> 命令的执行步骤基本一样，它们都是通过让主服务器创建并发送 RDB 文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。</li><li>部分重同步（partial resynchronization）：用于处理断线后的重复制情况，当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</li></ul><h3 id="12-2-心跳检测"><a href="#12-2-心跳检测" class="headerlink" title="12.2 心跳检测"></a>12.2 心跳检测</h3><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令 <code>REPLCONF ACK &lt;replication_offset&gt;</code> ，其中 <code>replication_offset</code> 是从服务器当前的复制偏移量。</p><p>发送 <code>REPLCONF ACK</code> 命令对于从服务器有三个作用：</p><ul><li>检测主从服务器的网络连接状态。</li><li>辅助实现 <code>min-slaves</code> 选项。</li><li>检测命令是否丢失。</li></ul><h2 id="13-Sentinel"><a href="#13-Sentinel" class="headerlink" title="13. Sentinel"></a>13. Sentinel</h2><p>Sentinel（哨岗、哨兵）是 Redis 的高可用性解决方案：由一个或多个 Sentinel 实例（instance）组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p><p>Sentinel 本质上只是一个运行在特殊模式下的 Redis 服务器。</p><p>Sentinel 的启动命令</p><pre class="line-numbers language-text"><code class="language-text">redis-sentinel /path/to/your/sentinel.conf# 或者是redis-server /path/to/your/sentinel.conf --sentinel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="13-1-主观下线"><a href="#13-1-主观下线" class="headerlink" title="13.1 主观下线"></a>13.1 主观下线</h3><p>在默认情况下，Sentinel 会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其它 Sentinel 在内）发送 <code>PING</code> 命令，并通过实例返回的 <code>PING</code> 命令回复来判断实例是否在线。</p><p>如果在默认配置的间隔时间内，有一服务器并没有进行有效回复，那此 Sentinel 就会将此服务器标记为主观下线。</p><h3 id="13-2-客观下线"><a href="#13-2-客观下线" class="headerlink" title="13.2 客观下线"></a>13.2 客观下线</h3><p>当 Sentinel 将一个服务器判断为主观下线之后，为了确定此服务器是否是真的下线了，它会去询问其它 Sentinel 此服务器是否已下线，当得到足够数量的确定回复之后，Sentinel 就会将此服务器标记为客观下线状态，如果此服务器是主服务器，就执行故障转移操作。</p><h3 id="13-3-选举领头-Sentinel"><a href="#13-3-选举领头-Sentinel" class="headerlink" title="13.3 选举领头 Sentinel"></a>13.3 选举领头 Sentinel</h3><p>当一个主服务器被判定为客观下线之后，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头 Sentinel，并由领头 Sentinel 对下线主服务器执行故障转移操作。</p><h3 id="13-4-故障转移"><a href="#13-4-故障转移" class="headerlink" title="13.4 故障转移"></a>13.4 故障转移</h3><p>在选举产生领头 Sentinel 之后，领头 Sentinel 将对已下线的主服务器执行故障转移操作，包含以下三个步骤：</p><ol><li>在已下线主服务器的所有从服务器中，选择一个从服务器将其转换为新的主服务器。</li><li>让已下线主服务器的所有从服务器改为复制新的从服务器。</li><li>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，他就会成为新的主服务器的从服务器。</li></ol><h2 id="14-集群"><a href="#14-集群" class="headerlink" title="14. 集群"></a>14. 集群</h2><p>Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p><p>一个 Redis 集群通常由多个节点组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。</p><pre class="line-numbers language-text"><code class="language-text"># 连接各个节点的工作可以使用这个命令来完成CLUSTER MEET <ip> <port><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="14-1-槽指派"><a href="#14-1-槽指派" class="headerlink" title="14.1 槽指派"></a>14.1 槽指派</h3><p>Redis 集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为 16384 个槽（slot），数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给了其它节点。</p><p>当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。</p><p>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</p><p>对 Redis 集群的重新分片工作是由 <code>redis-trib</code> 负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。</p><p>如果节点 A 正在迁移槽 i 至节点 B ，那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时，节点 A 会向客户端返回一个 ASK 错误，指引客户端到节点 B 继续查找指定的数据库键。</p><p>MOVED 错误表示槽的负责权已经从一个节点转移到了另一个节点，而 ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施。</p><p>集群中的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。</p><p>集群中的节点通过发送和接收消息来进行通信，常见的消息包括 <code>MEET</code>、<code>PING</code>、<code>PONG</code>、<code>PUBLISH</code>、<code>FAIL</code> 五种。</p><h2 id="15-发布与订阅"><a href="#15-发布与订阅" class="headerlink" title="15. 发布与订阅"></a>15. 发布与订阅</h2><p>Redis 的发布与订阅功能由 <code>PUBLISH</code>、<code>SUBSCRIBE</code>、<code>PSUBSCRIBE</code> 等命令组成</p><ul><li><code>SUBSCRIBE</code> 是频道订阅，客户端可以订阅一个或多个频道，成为这些频道的订阅者（<code>subscriber</code>），每当有其它客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息</li><li><code>PSUBSCRIBE</code> 是基于模式的订阅，除了订阅频道之外，客户端还可以通过执行 <code>PSUBSCRIBE</code> 命令订阅一个或多个模式，从而成为这些模式的订阅者，每当有其它客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会发送给所有与这个频道相匹配的模式的订阅者。</li></ul><p>客户端可以通过 <code>PUBSUB</code> 命令来查看频道或者模式的相关信息，比如某个频道目前有多少订阅者，又或者某个模式目前有多少订阅者等等。</p><p>当一个 Redis 客户端执行 <code>PUBLISH &lt;channel&gt; &lt;message&gt;</code> 命令将消息 message 发送给频道 channel 的时候，服务器需要执行以下两个动作：</p><ol><li>将消息 message 发送给 channel 频道的所有订阅者。</li><li>如果有一个或多个模式的 <code>pattern</code> 与频道 channel 相匹配，那么将消息 message 发送给 <code>pattern</code> 模式的订阅者。</li></ol><h2 id="16-事务"><a href="#16-事务" class="headerlink" title="16. 事务"></a>16. 事务</h2><p>Redis 通过 <code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code> 等命令来实现事务功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其它客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其它客户端的命令请求。事务以 <code>MULTI</code> 开始，以 <code>EXEC</code> 命令结束。</p><h3 id="16-1-事务的实现"><a href="#16-1-事务的实现" class="headerlink" title="16.1 事务的实现"></a>16.1 事务的实现</h3><ol><li><code>MULTI</code> 命令的执行代表事务的开始，<code>MULTI</code> 通过将客户端状态的 <code>flags</code> 属性中的 <code>REDIS_MULTI</code> 标识打开来将执行该命令的客户端切换至事务状态。</li><li>每个客户端都有自己的事务状态，它保存在客户端状态的 <code>mstate</code> 属性里面，<code>mstate</code> 里面包含一个事务队列，以及一个已入队命令的计数器，事务队列是一个 <code>multiCmd</code> 类型的数组，每个 <code>multiCmd</code> 结构都保存着一个已入队命令的相关信息，事务队列以先进先出（FIFO）的方式保存入队命令。</li><li>当一个处于事务状态的客户端向服务器发送 <code>EXEC</code> 命令时，这个 <code>EXEC</code> 命令会立即被执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</li></ol><h3 id="16-2-WATCH-命令的实现"><a href="#16-2-WATCH-命令的实现" class="headerlink" title="16.2 WATCH 命令的实现"></a>16.2 WATCH 命令的实现</h3><blockquote><p><code>WATCH</code> 命令是一个乐观锁，它可以在 <code>EXEC</code> 命令执行之前，监视任意数量的数据库键，并在 <code>EXEC</code> 命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的回复。</p></blockquote><p>每个Redis 数据库都保存着一个 <code>watched_keys</code> 字典，这个字典的键是某个被 <code>WATCH</code> 命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端。通过 <code>watched_keys</code> 字典，服务器可以清楚地知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。</p><p>通过执行 <code>WATCH</code> 命令，客户端可以在 <code>watched_keys</code> 字典中与被监视的键进行关联。</p><p>当前客户端为 c10086 ，在执行 <code>WATCH &quot;name&quot; &quot;age&quot;</code> 命令之后，如下图所示：</p><p><img src="/posts/30038/image-20240323224948348.png" alt></p><p>所有对数据库进行修改的命令，在执行之后都会调用 <code>touchWatchKey</code> 函数对 <code>watched_key</code> 字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么 <code>touchWatchKey</code> 函数会将监视被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 标识打开，表示该客户端的事务安全性已经被破坏。</p><p>当服务器接收到一个客户端发来的 <code>EXEC</code> 命令时，服务器会根据这个客户端是否打开了 <code>REDIS_DIRTY_CAS</code> 标识来决定是否执行事务，如果标识被打开，说明客户端所监视的键当中，至少有一个键已经被修改过了，服务器会拒绝执行客户端所提交的事务；如果标识没有被打开，说明事务仍然是安全的，服务器会执行客户端提交的事务。</p><h3 id="16-3-事务的-ACID-性质"><a href="#16-3-事务的-ACID-性质" class="headerlink" title="16.3 事务的 ACID 性质"></a>16.3 事务的 ACID 性质</h3><p>Redis 的事务总是具有 ACID 中的原子性、一致性和隔离性，当服务器运行在 AOF 持久化模式下，并且 <code>appendfsync</code> 选项的值为 <code>always</code> 时，事务也具有耐久性。</p><h2 id="17-排序"><a href="#17-排序" class="headerlink" title="17. 排序"></a>17. 排序</h2><p>Redis 的 <code>SORT</code> 命令可以对列表键、集合键或者有序集合键的值进行排序。</p><p><code>SORT</code> 命令通过将被排序键包含的元素载入到数组里面，然后对数组进行排序来完成对键进行排序的工作，排序操作由快速排序算法实现。</p><h2 id="18-二进制位数组"><a href="#18-二进制位数组" class="headerlink" title="18. 二进制位数组"></a>18. 二进制位数组</h2><p>Redis 提供了 <code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code> 四个命令用于处理二进制位数组，又称 “位数组”</p><ul><li><code>SETBIT</code> 命令用于为位数组指定偏移量上的二进制位设置值，可以是 0 或者 1</li><li><code>GETBIT</code> 用于获取指定偏移量上的二进制位的值</li><li><code>BITCOUNT</code> 用于统计位数组里面，值为 1 的二进制位的数量</li><li><code>BITOP</code> 可以对多个位数组进行按位与（and）、按位或（or）、按位异或（xor）、取反（not）运算</li></ul><p>Redis 使用 SDS 来保存位数组</p><h2 id="19-慢查询日志"><a href="#19-慢查询日志" class="headerlink" title="19. 慢查询日志"></a>19. 慢查询日志</h2><ul><li>Redis 的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</li></ul><h2 id="20-监视器"><a href="#20-监视器" class="headerlink" title="20. 监视器"></a>20. 监视器</h2><ul><li>客户端可以通过执行 <code>MONITOR</code> 命令，将客户端转换成监视器，接收并打印服务器处理的每个命令请求的相关信息</li><li>当一个客户端从普通客户端变为监视器时，该客户端的 <code>REDIS_MONITOR</code> 标识会被打开</li><li>服务器将所有监视器都记录在 <code>monitors</code> 链表中</li><li>每次处理命令时，服务器都会遍历 <code>monitors</code> 链表，将相关信息发送给监视器。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先，学习一个项目最好的方法就是看文档，&lt;a href=&quot;https://redis.io/docs/&quot;&gt;redis文档&lt;/a&gt;里面就介绍了
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Go并发基础</title>
    <link href="https://joytsing.github.io/posts/1938/"/>
    <id>https://joytsing.github.io/posts/1938/</id>
    <published>2024-03-21T16:38:19.000Z</published>
    <updated>2024-03-22T06:44:55.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>基本上大部分编程语言在并发上的编程范式都差不多，配合Cpp食用更佳。这里推荐一本书，&lt;&lt;深入理解Go并发编程&gt;&gt;。</p><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><h3 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h3><p>操作系统的线程一般都有固定的栈内存（通常为2MB）,而 Go 语言中的 goroutine 非常轻量级，一个 goroutine 的初始栈空间很小（一般为2KB），所以在 Go 语言中一次创建数万个 goroutine 也是可能的。并且 goroutine 的栈不是固定的，可以根据需要动态地增大或缩小， Go 的 runtime 会自动为 goroutine 分配合适的栈空间。</p><h3 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h3><p>操作系统内核在调度时会挂起当前正在执行的线程并将寄存器中的内容保存到内存中，然后选出接下来要执行的线程并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。从一个线程切换到另一个线程需要完整的上下文切换。因为可能需要多次内存访问，索引这个切换上下文的操作开销较大，会增加运行的cpu周期。</p><p>区别于操作系统内核调度操作系统线程，goroutine 的调度是Go语言运行时（runtime）层面的实现，是完全由 Go 语言本身实现的一套调度系统——go scheduler。它的作用是按照一定的规则将所有的 goroutine 调度到操作系统线程上执行。</p><p>在经历数个版本的迭代之后，目前 Go 语言的调度器采用的是 <code>GPM</code> 调度模型。</p><p><img src="/posts/1938/gpm.png" alt></p><p>其中：</p><ul><li>G：表示 goroutine，每执行一次<code>go f()</code>就创建一个 G，包含要执行的函数和上下文信息。</li><li>全局队列（Global Queue）：存放等待运行的 G。</li><li>P：表示 goroutine 执行所需的资源，最多有 GOMAXPROCS 个。</li><li>P 的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建 G 时，G 优先加入到 P 的本地队列，如果本地队列满了会批量移动部分 G 到全局队列。</li><li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P 的本地队列为空时，M 也会尝试从全局队列或其他 P 的本地队列获取 G。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li><li>Goroutine 调度器和操作系统调度器是通过 M 结合起来的，每个 M 都代表了1个内核线程，操作系统调度器负责把内核线程分配到 CPU 的核上执行。</li></ul><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。</p><ul><li><p>Work stealing</p><p>所有P放满了才会放到全局队列，如果某个M没东西了，会从其他P偷一个G过来，· 其他P没得偷从全局中拿一个</p></li><li><p>handoff</p></li></ul><p>如果某P的本地队列中的某G使得M阻塞，P会移动到另一个唤醒/创建的M，原来的M在G运行完之后睡眠或者销毁</p><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>可以用<code>sync.WaitGroup</code>来让主线程在其他用户线程之后退出</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 声明全局等待组变量</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 告知当前goroutine完成</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 登记1个goroutine</span>    <span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好"</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻塞等待登记的goroutine完成</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>Go语言采用的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p><p>只读通道：<code>v &lt;-chan int</code></p><p>只写通道：<code>v chan&lt;- int</code></p><p><strong>注意：</strong>一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致 panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致 panic。</li></ol><p>无缓冲通道：<code>c := make(chan int)</code></p><p>有缓冲通道：<code>cc := make(chan int, 3)</code></p><p>对无缓冲通道发送消息而不接收会造成死锁，我们要创建一个goroutine来接收通道中的内容：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">recv</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ret <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"接收成功"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">recv</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 创建一个 goroutine 从通道接收值</span>    ch <span class="token operator">&lt;-</span> <span class="token number">10</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以用多返回值模式来判断通道是否关闭：</p><pre class="line-numbers language-go"><code class="language-go">value<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中：</p><ul><li>value：从通道中取出的值，如果通道被关闭则返回对应类型的零值。</li><li>ok：通道ch关闭时返回 false，否则返回 true。</li></ul><h3 id="Worker-Pool"><a href="#Worker-Pool" class="headerlink" title="Worker Pool"></a>Worker Pool</h3><p>E.g：三个线程干五个活</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>id <span class="token builtin">int</span><span class="token punctuation">,</span> jobs <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> results <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> job <span class="token operator">:=</span> <span class="token keyword">range</span> jobs <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"worker id: "</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> <span class="token string">"doing job: "</span><span class="token punctuation">,</span> job<span class="token punctuation">)</span>        results <span class="token operator">&lt;-</span> job <span class="token operator">*</span> <span class="token number">2</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"worker id: "</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> <span class="token string">"finished job: "</span><span class="token punctuation">,</span> job<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    jobs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>    results <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> jobs<span class="token punctuation">,</span> results<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        jobs <span class="token operator">&lt;-</span> i    <span class="token punctuation">}</span>    <span class="token function">close</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>results<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>Select 语句具有以下特点。</p><ul><li>可处理一个或多个 channel 的发送/接收操作。</li><li>如果多个 case 同时满足，select 会<strong>随机</strong>选择一个执行。</li><li>对于没有 case 的 select 会一直阻塞，可用于阻塞 main 函数，防止退出</li></ul><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">select</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果多个case都满足，随机选一个执行</span>        <span class="token keyword">case</span> x <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">//可以从channel中取值</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Receiving"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>        <span class="token keyword">case</span> ch <span class="token operator">&lt;-</span> i<span class="token punctuation">:</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Sending "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//可以从channel中存放值</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"do nothing"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="并发安全和互斥锁"><a href="#并发安全和互斥锁" class="headerlink" title="并发安全和互斥锁"></a>并发安全和互斥锁</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go 语言中使用<code>sync</code>包中提供的<code>Mutex</code>类型来实现互斥锁。</p><p><code>sync.Mutex</code>提供了两个方法供我们使用。</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>func (m *Mutex) Lock()</td><td>获取互斥锁</td></tr><tr><td>func (m *Mutex) Unlock()</td><td>释放互斥锁</td></tr></tbody></table><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// sync.Mutex</span><span class="token keyword">var</span> <span class="token punctuation">(</span>    x <span class="token builtin">int64</span>    wg sync<span class="token punctuation">.</span>WaitGroup <span class="token comment" spellcheck="true">// 等待组</span>    m sync<span class="token punctuation">.</span>Mutex <span class="token comment" spellcheck="true">// 互斥锁</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// add 对全局变量x执行5000次加1操作</span><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 修改x前加锁</span>        x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>        m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 改完解锁</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h3><p>互斥锁是完全互斥的，但是实际上有很多场景是读多写少的，当我们并发的去读取一个资源而不涉及资源修改的时候是没有必要加互斥锁的，这种场景下使用读写锁是更好的一种选择。读写锁在 Go 语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p><p><code>sync.RWMutex</code>提供了以下5个方法。</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>func (rw *RWMutex) Lock()</td><td>获取写锁</td></tr><tr><td>func (rw *RWMutex) Unlock()</td><td>释放写锁</td></tr><tr><td>func (rw *RWMutex) RLock()</td><td>获取读锁</td></tr><tr><td>func (rw *RWMutex) RUnlock()</td><td>释放读锁</td></tr><tr><td>func (rw *RWMutex) RLocker() Locker</td><td>返回一个实现Locker接口的读写锁</td></tr></tbody></table><p>读写锁分为两种：读锁和写锁。当一个 goroutine 获取到读锁之后，其他的 goroutine 如果是获取读锁会继续获得锁，如果是获取写锁就会等待；而当一个 goroutine 获取写锁之后，其他的 goroutine 无论是获取读锁还是写锁都会等待。</p><p>在读多写少（相差一个数量级）的情况下，使用读写互斥锁比起使用互斥锁可以提高执行效率</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 使用互斥锁，10并发写，1000并发读</span><span class="token function">do</span><span class="token punctuation">(</span>writeWithLock<span class="token punctuation">,</span> readWithLock<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// x:10 cost:1.466500951s</span><span class="token comment" spellcheck="true">// 使用读写互斥锁，10并发写，1000并发读</span><span class="token function">do</span><span class="token punctuation">(</span>writeWithRWLock<span class="token punctuation">,</span> readWithRWLock<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// x:10 cost:117.207592ms</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sync-WaitGroup-1"><a href="#sync-WaitGroup-1" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>func (wg * WaitGroup) Add(delta int)</td><td>计数器+delta</td></tr><tr><td>(wg *WaitGroup) Done()</td><td>计数器-1</td></tr><tr><td>(wg *WaitGroup) Wait()</td><td>阻塞直到计数器变为0</td></tr></tbody></table><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Goroutine!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 启动另外一个goroutine去执行hello函数</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。</p><p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案——<code>sync.Once</code>，<code>sync.Once</code>只有一个<code>Do</code>方法</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> singleton<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">type</span> singleton <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> instance <span class="token operator">*</span>singleton<span class="token keyword">var</span> once sync<span class="token punctuation">.</span>Once<span class="token keyword">func</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>singleton <span class="token punctuation">{</span>    once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token operator">&amp;</span>singleton<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> instance<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>Go 语言中内置的 map 不是并发安全的，当并发地写map时会报错<code>fatal error: concurrent map writes</code>，因此我们可以使用<code>sync.Map</code></p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>func (m *Map) Store(key, value interface{})</td><td>存储key-value数据</td></tr><tr><td>func (m *Map) Load(key interface{}) (value interface{}, ok bool)</td><td>查询key对应的value</td></tr><tr><td>func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)</td><td>查询或存储key对应的value</td></tr><tr><td>func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool)</td><td>查询并删除key</td></tr><tr><td>func (m *Map) Delete(key interface{})</td><td>删除key</td></tr><tr><td>func (m *Map) Range(f func(key, value interface{}) bool)</td><td>对map中的每个key-value依次调用f</td></tr></tbody></table><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wg <span class="token operator">:=</span> sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">{</span><span class="token punctuation">}</span>    m <span class="token operator">:=</span> sync<span class="token punctuation">.</span>Map<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            m<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span>            t<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>            wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;基本上大部分编程语言在并发上的编程范式都差不多，配合Cpp食用更佳。这里推荐一本书，&amp;lt;&amp;lt;深入理解Go并发编程&amp;gt;&amp;gt;。&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="https://JoyTsing.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://JoyTsing.github.io/tags/Go/"/>
    
  </entry>
  
</feed>
