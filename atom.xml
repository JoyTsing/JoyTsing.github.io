<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoyTsing</title>
  
  <subtitle>深海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joytsing.github.io/"/>
  <updated>2024-04-25T07:21:30.122Z</updated>
  <id>https://joytsing.github.io/</id>
  
  <author>
    <name>JoyTsing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024,F1上海站</title>
    <link href="https://joytsing.github.io/posts/8251/"/>
    <id>https://joytsing.github.io/posts/8251/</id>
    <published>2024-04-25T07:05:15.000Z</published>
    <updated>2024-04-25T07:21:30.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="20年的道路"><a href="#20年的道路" class="headerlink" title="20年的道路"></a>20年的道路</h2><p><img src="/posts/8251/zhou.jpg" alt="周冠宇"></p><p>很遗憾没能去现场，也许二十年后，新的年轻中国车手可以在领奖台上说，二十年前在上海，中国的第一位F1车手曾激励了我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;20年的道路&quot;&gt;&lt;a href=&quot;#20年的道路&quot; class=&quot;headerlink&quot; title=&quot;20年的道路&quot;&gt;&lt;/a&gt;20年的道路&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/posts/8251/zhou.jpg&quot; alt=&quot;周冠宇&quot;&gt;&lt;/p&gt;
&lt;p&gt;很遗憾没
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Boost中Asio网络编程</title>
    <link href="https://joytsing.github.io/posts/24827/"/>
    <id>https://joytsing.github.io/posts/24827/</id>
    <published>2024-04-21T12:52:08.000Z</published>
    <updated>2024-04-21T13:13:29.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为什么要学这个呢？首先，arpa那套网络编程只能在linux下用，其次，个人觉得C语言风格的接口实在是太丑陋了，第三，cpp的net库提上日程，大概率是boost的asio，所以可以学习一下，别在用老套的接口了。</p><h2 id="Boost-Asio基本原理"><a href="#Boost-Asio基本原理" class="headerlink" title="Boost.Asio基本原理"></a>Boost.Asio基本原理</h2><p>这一章涵盖了使用Boost.Asio时必须知道的一些事情。我们也将深入研究比同步编程更复杂、更有乐趣(迫真)的异步编程。</p><h3 id="网络API"><a href="#网络API" class="headerlink" title="网络API"></a>网络API</h3><p>这一部分包含了当使用Boost.Asio编写网络应用程序时必须知道的事情。</p><h3 id="Boost-Asio命名空间"><a href="#Boost-Asio命名空间" class="headerlink" title="Boost.Asio命名空间"></a>Boost.Asio命名空间</h3><p>Boost.Asio的所有内容都包含在boost::asio命名空间或者其子命名空间内。</p><ul><li><em><code>boost::asio</code></em>：这是核心类和函数所在的地方。重要的类有<code>io_service</code>(现在是<code>io_context</code>)和<code>streambuf</code>。类似<em>read, read_at, read_until</em>方法，它们的异步方法，它们的写方法和异步写方法等自由函数也在这里。</li><li><em><code>boost::asio::ip</code></em>：这是网络通信部分所在的地方。重要的类有<em><code>address</code>, <code>endpoint</code>, <code>tcp</code>, <code>udp</code>和<code>icmp</code></em>，重要的自由函数有<em><code>connect</code></em>和<em><code>async_connect</code></em>。要注意的是在<em><code>boost::asio::ip::tcp::socket</code></em>中间，<em>socket</em>只是<em><code>boost::asio::ip::tcp</code></em>类中间的一个<em>typedef</em>关键字。</li><li><em><code>boost::asio::error</code></em>：这个命名空间包含了调用I/O例程时返回的错误码</li><li><em><code>boost::asio::ssl</code></em>：包含了SSL处理类的命名空间</li><li><em><code>boost::asio::local</code></em>：这个命名空间包含了POSIX特性的类</li><li><em><code>boost::asio::windows</code></em>：这个命名空间包含了Windows特性的类</li></ul><blockquote><p>小tip:  <code>namespace asio = boost::asio;</code> 可以少打<code>boost::</code></p></blockquote><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>对于IP地址的处理，Boost.Asio提供了<em>ip::address , ip::address_v4</em>和<em>ip::address_v6</em>类。 它们提供了相当多的函数。下面列出了最重要的几个：</p><ul><li><em>ip::address(v4_or_v6_address)</em>:这个函数把一个v4或者v6的地址转换成<em>ip::address</em></li><li><em>ip::address::from_string(str)</em>：这个函数根据一个IPv4地址（用.隔开的）或者一个IPv6地址（十六进制表示）创建一个地址。</li><li><em>ip::address::to_string()</em> ：这个函数返回这个地址的字符串。</li><li><em>ip::address_v4::broadcast([addr, mask])</em>:这个函数创建了一个广播地址 <em>ip::address_v4::any()</em>：这个函数返回一个能表示任意地址的地址。</li><li><em>ip::address_v4::loopback(), ip_address_v6::loopback()</em>：这个函数返回环路地址（为v4/v6协议）</li><li><em>ip::host_name()</em>：这个函数用string数据类型返回当前的主机名。</li></ul><p>大多数情况你会选择用<em>ip::address::from_string</em>：</p><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:address</span> addr <span class="token operator">=</span> ip<span class="token punctuation">:</span><span class="token symbol">:address</span><span class="token punctuation">:</span><span class="token symbol">:from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你想通过一个主机名进行连接，下面的代码片段是无用的：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token comment" spellcheck="true">// 抛出异常</span>ip<span class="token punctuation">:</span><span class="token punctuation">:</span>address addr <span class="token operator">=</span> ip<span class="token punctuation">:</span><span class="token punctuation">:</span>address<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_string</span><span class="token punctuation">(</span><span class="token string">"www.yahoo.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h3><p>端点是使用某个端口连接到的一个地址。不同类型的socket有它自己的<em>endpoint<em>类，比如</em>ip::tcp::endpoint、ip::udp::endpoint<em>和</em>ip::icmp::endpoint</em></p><p>如果想连接到本机的80端口，你可以这样做：</p><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> <span class="token function">ep</span><span class="token punctuation">(</span> ip<span class="token punctuation">:</span><span class="token symbol">:address</span><span class="token punctuation">:</span><span class="token symbol">:from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有三种方式来让你建立一个端点：</p><ul><li><em>endpoint()</em>：这是默认构造函数，某些时候可以用来创建UDP/ICMP socket。</li><li><em>endpoint(protocol, port)</em>：这个方法通常用来创建可以接受新连接的服务器端socket。</li><li><em>endpoint(addr, port)</em>:这个方法创建了一个连接到某个地址和端口的端点。</li></ul><p>例子如下：</p><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> ep1<span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> <span class="token function">ep2</span><span class="token punctuation">(</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:v4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> <span class="token function">ep3</span><span class="token punctuation">(</span> ip<span class="token punctuation">:</span><span class="token symbol">:address</span><span class="token punctuation">:</span><span class="token symbol">:from_string</span><span class="token punctuation">(</span>"<span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你想连接到一个主机（不是IP地址），你需要这样做：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string host <span class="token operator">=</span> <span class="token string">"joytsing.cn"</span><span class="token punctuation">;</span>std<span class="token operator">::</span>string port <span class="token operator">=</span> <span class="token string">"3333"</span><span class="token punctuation">;</span>asio<span class="token operator">::</span>io_context ioc<span class="token punctuation">;</span>sio<span class="token operator">::</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>resolver<span class="token operator">::</span>query <span class="token function">resolver_query</span><span class="token punctuation">(</span>    host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> asio<span class="token operator">::</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>resolver<span class="token operator">::</span>query<span class="token operator">::</span>numeric_service<span class="token punctuation">)</span><span class="token punctuation">;</span>asio<span class="token operator">::</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>resolver <span class="token function">resolver</span><span class="token punctuation">(</span>ioc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    asio<span class="token operator">::</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>resolver<span class="token operator">::</span>iterator it <span class="token operator">=</span> resolver<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>resolver_query<span class="token punctuation">)</span><span class="token punctuation">;</span>    asio<span class="token operator">::</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>ioc<span class="token punctuation">)</span><span class="token punctuation">;</span>    asio<span class="token operator">::</span><span class="token function">connect</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> it<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>boost<span class="token operator">::</span>system<span class="token operator">::</span>system_error <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"error. error_code = "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"message is "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> e<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以用你需要的socket类型来替换tcp。首先，为你想要查询的名字创建一个查询器，然后用resolve()函数解析它。如果成功，它至少会返回一个入口。你可以利用返回的迭代器，使用第一个入口或者遍历整个列表来拿到全部的入口。</p><p>给定一个端点，可以获得他的地址，端口和IP协议（v4或者v6）：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ep<span class="token punctuation">.</span><span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> ep<span class="token punctuation">.</span><span class="token function">port</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;&lt;</span> ep<span class="token punctuation">.</span><span class="token function">protocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>Boost.Asio有三种类型的套接字类：<em>ip::tcp, ip::udp</em>和<em>ip::icmp</em>。当然它也是可扩展的，你可以创建自己的socket类，尽管这相当复杂。如果你选择这样做，参照一下<em>boost/asio/ip/tcp.hpp, boost/asio/ip/udp.hpp</em>和<em>boost/asio/ip/icmp.hpp</em>。它们都是含有内部typedef关键字的超小类。</p><p>你可以把<em>ip::tcp, ip::udp, ip::icmp</em>类当作占位符；它们可以让你便捷地访问其他类/函数，如下所示：</p><ul><li><em>ip::tcp::socket, ip::tcp::acceptor, ip::tcp::endpoint,ip::tcp::resolver, ip::tcp::iostream</em></li><li><em>ip::udp::socket, ip::udp::endpoint, ip::udp::resolver</em></li><li><em>ip::icmp::socket, ip::icmp::endpoint, ip::icmp::resolver</em></li></ul><p><em>socket</em>类创建一个相应的<em>socket</em>。而且总是在构造的时候传入io_service(新版本的是io_context，后面不再提示)实例：</p><pre class="line-numbers language-ruby"><code class="language-ruby">io_service service<span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token symbol">:udp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span> <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span>sock<span class="token punctuation">.</span><span class="token function">set_option</span><span class="token punctuation">(</span>ip<span class="token punctuation">:</span><span class="token symbol">:udp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span><span class="token punctuation">:</span><span class="token symbol">:reuse_address</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>每一个socket的名字都是一个typedef关键字</p><ul><li><em>ip::tcp::socket = basic_stream_socket<tcp></tcp></em></li><li><em>ip::udp::socket = basic_datagram_socket<udp></udp></em></li><li><em>ip::icmp::socket = basic_raw_socket<icmp></icmp></em></li></ul><h3 id="同步错误码"><a href="#同步错误码" class="headerlink" title="同步错误码"></a>同步错误码</h3><p>所有的同步函数都有抛出异常或者返回错误码的重载，比如下面的代码片段：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">sync_func</span><span class="token punctuation">(</span> arg1<span class="token punctuation">,</span> arg2 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> argN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 抛出异常</span>boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code ec<span class="token punctuation">;</span><span class="token function">sync_func</span><span class="token punctuation">(</span> arg1 arg2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> argN<span class="token punctuation">,</span> ec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回错误码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="socket成员方法"><a href="#socket成员方法" class="headerlink" title="socket成员方法"></a>socket成员方法</h3><p>这些方法被分成了几组。并不是所有的方法都可以在各个类型的套接字里使用。这个部分的结尾将有一个列表来展示各个方法分别属于哪个socket类。</p><p>注意所有的异步方法都立刻返回，而它们相对的同步实现需要操作完成之后才能返回。</p><h3 id="连接相关的函数"><a href="#连接相关的函数" class="headerlink" title="连接相关的函数"></a>连接相关的函数</h3><p>这些方法是用来连接或绑定socket、断开socket字连接以及查询连接是活动还是非活动的：</p><ul><li><em>assign(protocol,socket)</em>：这个函数分配了一个原生的socket给这个socket实例。当处理老（旧）程序时会使用它（也就是说，原生socket已经被建立了）</li><li><em>open(protocol)</em>：这个函数用给定的IP协议（v4或者v6）打开一个socket。你主要在UDP/ICMP socket，或者服务端socket上使用。</li><li><em>bind(endpoint)</em>：这个函数绑定到一个地址</li><li><em>connect(endpoint)</em>：这个函数用同步的方式连接到一个地址</li><li><em>async_connect(endpoint)</em>：这个函数用异步的方式连接到一个地址</li><li><em>is_open()</em>：如果套接字已经打开，这个函数返回true</li><li><em>close()</em>：这个函数用来关闭套接字。调用时这个套接字上任何的异步操作都会被立即关闭，同时返回<em>error::operation_aborted</em>错误码。</li><li><em>shutdown(type_of_shutdown)</em>：这个函数立即使send或者receive操作失效，或者两者都失效。</li><li><em>cancel()</em>：这个函数取消套接字上所有的异步操作。这个套接字上任何的异步操作都会立即结束，然后返回<em>error::operation_aborted</em>错误码。</li></ul><p>例子如下：</p><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> <span class="token function">ep</span><span class="token punctuation">(</span> ip<span class="token punctuation">:</span><span class="token symbol">:address</span><span class="token punctuation">:</span><span class="token symbol">:from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span> <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:v4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> nsock<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">write_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token string">"GET /index.html\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>char buff<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span> sock<span class="token punctuation">.</span><span class="token function">read_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span><span class="token punctuation">:</span><span class="token symbol">:shutdown_receive</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读写函数"><a href="#读写函数" class="headerlink" title="读写函数"></a>读写函数</h3><p>这些是在套接字上执行I/O操作的函数。</p><p>对于异步函数来说，处理程序的格式<em>void handler(const boost::system::error_code&amp; e, size_t bytes)</em>都是一样的</p><ul><li><em>async_receive(buffer, [flags,] handler)</em>：这个函数启动从套接字异步接收数据的操作。</li><li><em>async_read_some(buffer,handler)</em>：这个函数和<em>async_receive(buffer, handler)</em>功能一样。</li><li><em>async_receive_from(buffer, endpoint[, flags], handler)</em>：这个函数启动从一个指定端点异步接收数据的操作。</li><li><em>async_send(buffer [, flags], handler)</em>：这个函数启动了一个异步发送缓冲区数据的操作。</li><li><em>async_write_some(buffer, handler)</em>：这个函数和a<em>sync_send(buffer, handler)</em>功能一致。</li><li><em>async_send_to(buffer, endpoint, handler)</em>：这个函数启动了一个异步send缓冲区数据到指定端点的操作。</li><li><em>receive(buffer [, flags])</em>：这个函数异步地从所给的缓冲区读取数据。在读完所有数据或者错误出现之前，这个函数都是阻塞的。</li><li><em>read_some(buffer)</em>：这个函数的功能和<em>receive(buffer)</em>是一致的。</li><li><ul><li>receive_from(buffer, endpoint [, flags])*：这个函数异步地从一个指定的端点获取数据并写入到给定的缓冲区。在读完所有数据或者错误出现之前，这个函数都是阻塞的。</li></ul></li><li><em>send(buffer [, flags])</em>：这个函数同步地发送缓冲区的数据。在所有数据发送成功或者出现错误之前，这个函数都是阻塞的。</li><li><em>write_some(buffer)</em>：这个函数和<em>send(buffer)</em>的功能一致。</li><li><em>send_to(buffer, endpoint [, flags])</em>：这个函数同步地把缓冲区数据发送到一个指定的端点。在所有数据发送成功或者出现错误之前，这个函数都是阻塞的。</li><li><em>available()</em>：这个函数返回有多少字节的数据可以无阻塞地进行同步读取。</li></ul><p>稍后我们将讨论缓冲区。让我们先来了解一下标记。标记的默认值是0，但是也可以是以下几种：</p><ul><li><em>ip::socket_type::socket::message_peek</em>：这个标记只监测并返回某个消息，但是下一次读消息的调用会重新读取这个消息。</li><li><em>ip::socket_type::socket::message_out_of_band</em>：这个标记处理带外（OOB）数据，OOB数据是被标记为比正常数据更重要的数据。关于OOB的讨论在这本书的内容之外。</li><li><em>ip::socket_type::socket::message_do_not_route</em>：这个标记指定数据不使用路由表来发送。</li><li><em>ip::socket_type::socket::message_end_of_record</em>：这个标记指定的数据标识了记录的结束。在Windows下不支持。</li></ul><p>你最常用的可能是<em>message_peek</em>，使用方法请参照下面的代码片段：</p><pre class="line-numbers language-ruby"><code class="language-ruby">char buff<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span><span class="token punctuation">:</span><span class="token symbol">:message_peek</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span> 重新读取之前已经读取过的内容sock<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的是一些教你如何同步或异步地从不同类型的套接字上读取数据的例子：</p><ul><li>例1是在一个TCP套接字上进行同步读写：</li></ul><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> <span class="token function">ep</span><span class="token punctuation">(</span> ip<span class="token punctuation">:</span><span class="token symbol">:address</span><span class="token punctuation">:</span><span class="token symbol">:from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span> <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">write_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token string">"GET /index.html\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token symbol">:cout</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"bytes available "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> sock<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token symbol">:endl</span><span class="token punctuation">;</span>char buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>size_t read <span class="token operator">=</span> sock<span class="token punctuation">.</span><span class="token function">read_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>例2是在一个UDP套接字上进行同步读写：</li></ul><pre class="line-numbers language-css"><code class="language-css"><span class="token property">ip</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">udp</span><span class="token punctuation">:</span><span class="token punctuation">:</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token number">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token property">ip</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">udp</span><span class="token punctuation">:</span><span class="token punctuation">:</span>v<span class="token number">4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token property">ip</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">udp</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endpoint receiver_<span class="token function">ep</span><span class="token punctuation">(</span><span class="token string">"87.248.112.181"</span>, <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token number">.</span>send_<span class="token function">to</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token string">"testing\n"</span><span class="token punctuation">)</span>, receiver_ep<span class="token punctuation">)</span><span class="token punctuation">;</span>char buff[<span class="token number">512</span>]<span class="token punctuation">;</span><span class="token property">ip</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">udp</span><span class="token punctuation">:</span><span class="token punctuation">:</span>endpoint sender_ep<span class="token punctuation">;</span>sock<span class="token number">.</span>receive_<span class="token function">from</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span>, sender_ep<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>[？注意：就像上述代码片段所展示的那样，使用receive_from从一个UDP套接字读取数据时，你需要构造一个默认的端点]</em></p><ul><li>例3是从一个UDP服务套接字中异步读取数据：</li></ul><pre class="line-numbers language-php"><code class="language-php">using <span class="token keyword">namespace</span> <span class="token package">boost</span><span class="token punctuation">:</span><span class="token punctuation">:</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token punctuation">:</span>udp<span class="token punctuation">:</span><span class="token punctuation">:</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>boost<span class="token punctuation">:</span><span class="token punctuation">:</span>asio<span class="token punctuation">:</span><span class="token punctuation">:</span>ip<span class="token punctuation">:</span><span class="token punctuation">:</span>udp<span class="token punctuation">:</span><span class="token punctuation">:</span>endpoint sender_ep<span class="token punctuation">;</span>char buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>void <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>system<span class="token punctuation">:</span><span class="token punctuation">:</span>error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>size_t read_bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"read "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> read_bytes <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">async_receive_from</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> sender_ep<span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>int <span class="token function">main</span><span class="token punctuation">(</span>int argc<span class="token punctuation">,</span> char<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ip<span class="token punctuation">:</span><span class="token punctuation">:</span>udp<span class="token punctuation">:</span><span class="token punctuation">:</span>endpoint <span class="token function">ep</span><span class="token punctuation">(</span>ip<span class="token punctuation">:</span><span class="token punctuation">:</span>address<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">8001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>ep<span class="token punctuation">.</span><span class="token function">protocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">set_option</span><span class="token punctuation">(</span>boost<span class="token punctuation">:</span><span class="token punctuation">:</span>asio<span class="token punctuation">:</span><span class="token punctuation">:</span>ip<span class="token punctuation">:</span><span class="token punctuation">:</span>udp<span class="token punctuation">:</span><span class="token punctuation">:</span>socket<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">reuse_address</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">async_receive_from</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sender_ep<span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="套接字控制："><a href="#套接字控制：" class="headerlink" title="套接字控制："></a>套接字控制：</h3><p>这些函数用来处理套接字的高级选项：</p><ul><li><em>get_io_service()</em>：这个函数返回构造函数中传入的io_service实例</li><li><em>get_option(option)</em>：这个函数返回一个套接字的属性</li><li><em>set_option(option)</em>：这个函数设置一个套接字的属性</li><li><em>io_control(cmd)</em>：这个函数在套接字上执行一个I/O指令</li></ul><p>这些是你可以获取/设置的套接字选项：</p><table><thead><tr><th>名字</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>broadcast</td><td>如果为true，允许广播消息</td><td>bool</td></tr><tr><td>debug</td><td>如果为true，启用套接字级别的调试</td><td>bool</td></tr><tr><td>do_not_route</td><td>如果为true，则阻止路由选择只使用本地接口</td><td>bool</td></tr><tr><td>enable_connection_aborted</td><td>如果为true，记录在accept()时中断的连接</td><td>bool</td></tr><tr><td>keep_alive</td><td>如果为true，会发送心跳</td><td>bool</td></tr><tr><td>linger</td><td>如果为true，套接字会在有未发送数据的情况下挂起close()</td><td>bool</td></tr><tr><td>receive_buffer_size</td><td>套接字接收缓冲区大小</td><td>int</td></tr><tr><td>receive_low_watemark</td><td>规定套接字输入处理的最小字节数</td><td>int</td></tr><tr><td>reuse_address</td><td>如果为true，套接字能绑定到一个已用的地址</td><td>bool</td></tr><tr><td>send_buffer_size</td><td>套接字发送缓冲区大小</td><td>int</td></tr><tr><td>send_low_watermark</td><td>规定套接字数据发送的最小字节数</td><td>int</td></tr><tr><td>ip::v6_only</td><td>如果为true，则只允许IPv6的连接</td><td>bool</td></tr></tbody></table><p>每个名字代表了一个内部套接字typedef或者类。下面是对它们的使用：</p><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:endpoint</span> <span class="token function">ep</span><span class="token punctuation">(</span> ip<span class="token punctuation">:</span><span class="token symbol">:address</span><span class="token punctuation">:</span><span class="token symbol">:from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span> <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span> <span class="token constant">TCP</span>套接字可以重用地址ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span><span class="token punctuation">:</span><span class="token symbol">:reuse_address</span> <span class="token function">ra</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">set_option</span><span class="token punctuation">(</span>ra<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span> 获取套接字读取的数据ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span><span class="token punctuation">:</span><span class="token symbol">:receive_buffer_size</span> rbs<span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">get_option</span><span class="token punctuation">(</span>rbs<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token symbol">:cout</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> rbs<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token symbol">:endl</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span> 把套接字的缓冲区大小设置为<span class="token number">8192</span>ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span><span class="token punctuation">:</span><span class="token symbol">:send_buffer_size</span> <span class="token function">sbs</span><span class="token punctuation">(</span><span class="token number">8192</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">set_option</span><span class="token punctuation">(</span>sbs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>[?在上述特性工作之前，套接字要被打开。否则，会抛出异常]</em></p><h3 id="TCP-VS-UDP-VS-ICMP"><a href="#TCP-VS-UDP-VS-ICMP" class="headerlink" title="TCP VS UDP VS ICMP"></a>TCP VS UDP VS ICMP</h3><p>就像我之前所说，不是所有的成员方法在所有的套接字类中都可用。我做了一个包含成员函数不同点的列表。如果一个成员函数没有出现在这，说明它在所有的套接字类都是可用的。</p><table><thead><tr><th>名字</th><th>TCP</th><th>UDP</th><th>ICMP</th></tr></thead><tbody><tr><td>async_read_some</td><td>是</td><td>-</td><td>-</td></tr><tr><td>async_receive_from</td><td>-</td><td>是</td><td>是</td></tr><tr><td>async_write_some</td><td>是</td><td>-</td><td>-</td></tr><tr><td>async_send_to</td><td>-</td><td>是</td><td>是</td></tr><tr><td>read_some</td><td>是</td><td>-</td><td>-</td></tr><tr><td>receive_from</td><td>-</td><td>是</td><td>是</td></tr><tr><td>write_some</td><td>是</td><td>-</td><td>-</td></tr><tr><td>send_to</td><td>-</td><td>是</td><td>是</td></tr></tbody></table><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>其他与连接和I/O无关的函数如下：</p><ul><li><em>local_endpoint()</em>：这个方法返回套接字本地连接的地址。</li><li><em>remote_endpoint()</em>：这个方法返回套接字连接到的远程地址。</li><li><em>native_handle()</em>：这个方法返回原始套接字的处理程序。你只有在调用一个Boost.Asio不支持的原始方法时才需要用到它。</li><li><em>non_blocking()</em>：如果套接字是非阻塞的，这个方法返回true，否则false。</li><li><em>native_non_blocking()</em>：如果套接字是非阻塞的，这个方法返回true，否则返回false。但是，它是基于原生的套接字来调用本地的api。所以通常来说，你不需要调用这个方法（non_blocking()已经缓存了这个结果）；你只有在直接调用native_handle()这个方法的时候才需要用到这个方法。</li><li><em>at_mark()</em>：如果套接字要读的是一段OOB数据，这个方法返回true。这个方法你很少会用到。</li></ul><h3 id="其他需要考虑的事情"><a href="#其他需要考虑的事情" class="headerlink" title="其他需要考虑的事情"></a>其他需要考虑的事情</h3><p>最后要注意的一点，套接字实例不能被拷贝，因为拷贝构造方法和＝操作符是不可访问的。</p><pre class="line-numbers language-ruby"><code class="language-ruby">ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span> <span class="token function">s1</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s2</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>s1 <span class="token operator">=</span> s2<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 编译时报错ip<span class="token punctuation">:</span><span class="token symbol">:tcp</span><span class="token punctuation">:</span><span class="token symbol">:socket</span> <span class="token function">s3</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 编译时报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是非常有意义的，因为每一个实例都拥有并管理着一个资源（原生套接字本身）。如果我们允许拷贝构造，结果是我们会有两个实例拥有同样的原生套接字；这样我们就需要去处理所有者的问题（让一个实例拥有所有权？或者使用引用计数？还是其他的方法）Boost.Asio选择不允许拷贝（如果你想要创建一个备份，请使用共享指针）</p><pre class="line-numbers language-php"><code class="language-php">typedef boost<span class="token punctuation">:</span><span class="token punctuation">:</span>shared_ptr<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">ip:</span>:tcp::socket</span><span class="token punctuation">></span></span></span> socket_ptr<span class="token punctuation">;</span>socket_ptr <span class="token function">sock1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ip</span><span class="token punctuation">:</span><span class="token punctuation">:</span>tcp<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">socket</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>socket_ptr <span class="token function">sock2</span><span class="token punctuation">(</span>sock1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>socket_ptr sock3<span class="token punctuation">;</span>           sock3 <span class="token operator">=</span> sock1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="套接字缓冲区"><a href="#套接字缓冲区" class="headerlink" title="套接字缓冲区"></a>套接字缓冲区</h3><p>当从一个套接字读写内容时，你需要一个缓冲区，用来保存读取和写入的数据。缓冲区内存的有效时间必须比I/O操作的时间要长；你需要保证它们在I/O操作结束之前不被释放。 对于同步操作来说，这很容易；当然，这个缓冲区在receive和send时都存在。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> <span class="token string">"ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是在异步操作时就没这么简单了，看下面的代码片段：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 非常差劲的代码 ...</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t read_bytes<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">async_receive</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在我们调用<em>async_receive()</em>之后，buff就已经超出有效范围，它的内存当然会被释放。当我们开始从套接字接收一些数据时，我们会把它们拷贝到一片已经不属于我们的内存中；它可能会被释放，或者被其他代码重新开辟来存入其他的数据，结果就是：内存冲突。</p><p>对于上面的问题有几个解决方案：</p><ul><li>使用全局缓冲区</li><li>创建一个缓冲区，然后在操作结束时释放它</li><li>使用一个集合对象管理这些套接字和其他的数据，比如缓冲区数组</li></ul><p>第一个方法显然不是很好，因为我们都知道全局变量非常不好。此外，如果两个实例使用同一个缓冲区怎么办？</p><p>下面是第二种方式的实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> ptr<span class="token punctuation">,</span> <span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t read_bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                           <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ptr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">char</span> <span class="token operator">*</span> buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_receive</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>on_read<span class="token punctuation">,</span>buff<span class="token punctuation">,</span>_1<span class="token punctuation">,</span>_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者，如果你想要缓冲区在操作结束后自动超出范围，使用共享指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> shared_buffer <span class="token punctuation">{</span>    boost<span class="token operator">::</span>shared_array<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> buff<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token function">shared_buffer</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">buff</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    mutable_buffers_1 <span class="token function">asio_buff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当on_read超出范围时, boost::bind对象被释放了,</span><span class="token comment" spellcheck="true">// 同时也会释放共享指针</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span>shared_buffer<span class="token punctuation">,</span> <span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t read_bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>sock<span class="token punctuation">.</span><span class="token function">async_receive</span><span class="token punctuation">(</span>buff<span class="token punctuation">.</span><span class="token function">asio_buff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>on_read<span class="token punctuation">,</span>buff<span class="token punctuation">,</span>_1<span class="token punctuation">,</span>_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shared_buffer类拥有实质的<em>shared_array&lt;&gt;</em>，<em>shared_array&lt;&gt;</em>存在的目的是用来保存<em>shared_buffer</em>实例的拷贝－当最后一个<em>share_array&lt;&gt;</em>元素超出范围时，<em>shared_array&lt;&gt;</em>就被自动销毁了，而这就是我们想要的结果。</p><p>因为Boost.Asio会给完成处理句柄保留一个拷贝，当操作完成时就会调用这个完成处理句柄，所以你的目的达到了。那个拷贝是一个boost::bind的仿函数，它拥有着实际的<em>shared_buffer</em>实例。这是非常优雅的！</p><p>第三个选择是使用一个连接对象来管理套接字和其他数据，比如缓冲区，通常来说这是正确的解决方案但是非常复杂。在这一章的末尾我们会对这种方法进行讨论。</p><h3 id="缓冲区封装函数"><a href="#缓冲区封装函数" class="headerlink" title="缓冲区封装函数"></a>缓冲区封装函数</h3><p>纵观所有代码，你会发现：无论什么时候，当我们需要对一个buffer进行读写操作时，代码会把实际的缓冲区对象封装在一个buffer()方法中，然后再把它传递给方法调用：</p><pre class="line-numbers language-css"><code class="language-css">char buff[<span class="token number">512</span>]<span class="token punctuation">;</span>sock<span class="token number">.</span>async_<span class="token function">receive</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span>, on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>基本上我们都会把缓冲区包含在一个类中以便Boost.Asio的方法能遍历这个缓冲区，比方说，使用下面的代码：</p><pre class="line-numbers language-css"><code class="language-css">sock<span class="token number">.</span>async_<span class="token function">receive</span><span class="token punctuation">(</span>some_buffer, on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实例<em>some_buffer</em>需要满足一些需求，叫做<em>ConstBufferSequence</em>或者<em>MutableBufferSequence</em>（你可以在Boost.Asio的文档中查看它们）。创建你自己的类去处理这些需求的细节是非常复杂的，但是Boost.Asio已经提供了一些类用来处理这些需求。所以你不用直接访问这些缓冲区，而可以使用<em>buffer()</em>方法。</p><p>自信地讲，你可以把下面列出来的类型都包装到一个buffer()方法中：</p><ul><li>一个char[] const 数组</li><li>一个字节大小的void *指针</li><li>一个std::string类型的字符串</li><li>一个POD const数组（POD代表纯数据，这意味着构造器和释放器不做任何操作）</li><li>一个pod数据的std::vector</li><li>一个包含pod数据的boost::array</li><li>一个包含pod数据的std::array</li></ul><p>下面的代码都是有效的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> pod_sample <span class="token punctuation">{</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token keyword">long</span> l<span class="token punctuation">;</span> <span class="token keyword">char</span> c<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">char</span> b1<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>std<span class="token operator">::</span>string b3<span class="token punctuation">;</span> b3<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pod_sample b4<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>pod_sample<span class="token operator">></span> b5<span class="token punctuation">;</span> b5<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>boost<span class="token operator">::</span>array<span class="token operator">&lt;</span>pod_sample<span class="token punctuation">,</span><span class="token number">16</span><span class="token operator">></span> b6<span class="token punctuation">;</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span>pod_sample<span class="token punctuation">,</span><span class="token number">16</span><span class="token operator">></span> b7<span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b3<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b4<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b5<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b6<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span>sock<span class="token punctuation">.</span><span class="token function">async_send</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>b7<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的来说就是：与其创建你自己的类来处理<em>ConstBufferSequence</em>或者<em>MutableBufferSequence</em>的需求，不如创建一个能在你需要的时候保留缓冲区，然后返回一个mutable_buffers_1实例的类，而我们早在shared_buffer类中就这样做了。</p><h3 id="read-write-connect自由函数"><a href="#read-write-connect自由函数" class="headerlink" title="read/write/connect自由函数"></a>read/write/connect自由函数</h3><p>Boost.Asio提供了处理I/O的自由函数，我们分四组来分析它们。</p><h4 id="connect方法"><a href="#connect方法" class="headerlink" title="connect方法"></a>connect方法</h4><p>这些方法把套接字连接到一个端点。</p><ul><li><em>connect(socket, begin [, end] [, condition])</em>：这个方法遍历队列中从start到end的端点来尝试同步连接。begin迭代器是调用<em>socket_type::resolver::query</em>的返回结果（你可能需要回顾一下端点这个章节）。特别提示end迭代器是可选的；你可以忽略它。你还可以提供一个condition的方法给每次连接尝试之后调用。用法是<em>Iterator connect_condition(const boost::system::error_code &amp; err,Iterator next);</em>。你可以选择返回一个不是<em>next</em>的迭代器，这样你就可以跳过一些端点。</li><li><em>async_connect(socket, begin [, end] [, condition], handler)</em>：这个方法异步地调用连接方法，在结束时，它会调用完成处理方法。用法是<em>void handler(constboost::system::error_code &amp; err, Iterator iterator);</em>。传递给处理方法的第二个参数是连接成功端点的迭代器（或者end迭代器）。</li></ul><p>它的例子如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> boost<span class="token operator">::</span>asio<span class="token operator">::</span>ip<span class="token punctuation">;</span>tcp<span class="token operator">::</span>resolver <span class="token function">resolver</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>tcp<span class="token operator">::</span>resolver<span class="token operator">::</span>iterator iter <span class="token operator">=</span> resolver<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>tcp<span class="token operator">::</span>resolver<span class="token operator">::</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"www.yahoo.com"</span><span class="token punctuation">,</span><span class="token string">"80"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tcp<span class="token operator">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">connect</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> iter<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个主机名可以被解析成多个地址，而<em>connect</em>和<em>async_connect</em>能很好地把你从尝试每个地址然后找到一个可用地址的繁重工作中解放出来，因为它们已经帮你做了这些。</p><h4 id="read-write方法"><a href="#read-write方法" class="headerlink" title="read/write方法"></a>read/write方法</h4><p>这些方法对一个流进行读写操作（可以是套接字，或者其他表现得像流的类）：</p><ul><li><em>async_read(stream, buffer [, completion] ,handler)<em>：这个方法异步地从一个流读取。结束时其处理方法被调用。处理方法的格式是：</em>void handler(const boost::system::error_ code &amp; err, size_t bytes)</em>;。你可以选择指定一个完成处理方法。完成处理方法会在每个<em>read<em>操作调用成功之后调用，然后告诉Boost.Asio *async_read</em>操作是否完成（如果没有完成，它会继续读取）。它的格式是：*size_t completion(const boost::system::error_code&amp; err, size_t bytes_transfered)</em> 。当这个完成处理方法返回0时，我们认<em>为read</em>操作完成；如果它返回一个非0值，它表示了下一个<em>async_read_some</em>操作需要从流中读取的字节数。接下来会有一个例子来详细展示这些。</li><li><em>async_write(stream, buffer [, completion], handler)</em>：这个方法异步地向一个流写入数据。参数的意义和<em>async_read</em>是一样的。</li><li><em>read(stream, buffer [, completion])</em>：这个方法同步地从一个流中读取数据。参数的意义和<em>async_read</em>是一样的。</li><li><em>write(stream, buffer [, completion])</em>: 这个方法同步地向一个流写入数据。参数的意义和<em>async_read</em>是一样的。</li></ul><pre class="line-numbers language-css"><code class="language-css">async_<span class="token function">read</span><span class="token punctuation">(</span>stream, stream_buffer [, completion], handler<span class="token punctuation">)</span>async_<span class="token function">write</span><span class="token punctuation">(</span>strean, stream_buffer [, completion], handler<span class="token punctuation">)</span><span class="token function">write</span><span class="token punctuation">(</span>stream, stream_buffer [, completion]<span class="token punctuation">)</span><span class="token function">read</span><span class="token punctuation">(</span>stream, stream_buffer [, completion]<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>首先，要注意第一个参数变成了流，而不单是socket。这个参数包含了socket但不仅仅是socket。比如，你可以用一个Windows的文件句柄来替代socket。 当下面情况出现时，所有read和write操作都会结束：</p><ul><li>可用的缓冲区满了（当读取时）或者所有的缓冲区已经被写入（当写入时）</li><li>完成处理方法返回0（如果你提供了这么一个方法）</li><li>错误发生时</li></ul><p>下面的代码会异步地从一个socket中间读取数据直到读取到’\n’：</p><pre class="line-numbers language-cpp"><code class="language-cpp">io_service service<span class="token punctuation">;</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>size_t <span class="token function">up_to_enter</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span><span class="token punctuation">,</span> size_t bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bytes<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> buff<span class="token punctuation">[</span>i <span class="token operator">+</span> offset<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\n'</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">async_read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> up_to_enter<span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Boost.Asio也提供了一些简单的完成处理仿函数：</p><ul><li>transfer_at_least(n)</li><li>transfer_exactly(n)</li><li>transfer_all()</li></ul><p>例子如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 读取32个字节 </span><span class="token function">async_read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">transfer_exactly</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述的4个方法，不使用普通的缓冲区，而使用由Boost.Asio的<em>std::streambuf</em>类继承来的<em>stream_buffer</em>方法。stl流和流缓冲区非常复杂；下面是例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp">io_service service<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span>streambuf<span class="token operator">&amp;</span> buf<span class="token punctuation">,</span> <span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span> <span class="token punctuation">{</span>     std<span class="token operator">::</span>istream <span class="token function">in</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string line<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">getline</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first line: "</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     HANDLE file <span class="token operator">=</span> <span class="token operator">::</span><span class="token function">CreateFile</span><span class="token punctuation">(</span><span class="token string">"readme.txt"</span><span class="token punctuation">,</span> GENERIC_READ<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> OPEN_ALWAYS<span class="token punctuation">,</span> FILE_ATTRIBUTE_NORMAL <span class="token operator">|</span> FILE_FLAG_OVERLAPPED<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    windows<span class="token operator">::</span>stream_handle <span class="token function">h</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>    streambuf buf<span class="token punctuation">;</span>    <span class="token function">async_read</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">transfer_exactly</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>on_read<span class="token punctuation">,</span>boost<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span>_1<span class="token punctuation">,</span>_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，我向你们展示了如何在一个Windows文件句柄上调用<em>async_read</em>。读取前256个字符，然后把它们保存到缓冲区中，当操作结束时。<em>on_read</em>被调用，再创建<em>std::istream</em>用来传递缓冲区，读取第一行（<em>std::getline</em>），最后把它输出到命令行中。</p><h4 id="read-until-async-read-until方法"><a href="#read-until-async-read-until方法" class="headerlink" title="read_until/async_read_until方法"></a>read_until/async_read_until方法</h4><p>这些方法在条件满足之前会一直读取：</p><ul><li><em>async_read_until(stream, stream_buffer, delim, handler)</em>:这个方法启动一个异步<em>read</em>操作。<em>read</em>操作会在读取到某个分隔符时结束。分隔符可以是字符,<em>std::string</em>或者<em>boost::regex</em>。处理方法的格式为：<em>void handler(const boost::system::error_code &amp; err, size_t bytes);</em>。</li><li><em>async_read_until(strem, stream_buffer, completion, handler)</em>：这个方法和之前的方法是一样的，但是没有分隔符，而是一个完成处理方法。完成处理方法的格式为：<em>pair&lt; iterator,bool &gt; completion(iterator begin, iterator end);</em>，其中迭代器的类型为<em>buffers_iterator&lt; streambuf::const_buffers_type &gt;</em>。你需要记住的是这个迭代器是支持随机访问的。你扫描整个区间（begin，end），然后决定read操作是否应该结束。返回的结果是一个结果对，第一个成员是一个迭代器，它指向最后被这个方法访问的字符；第二个成员指定read操作是否需要结束，需要时返回true，否则返回false。</li><li><em>read_until(stream, stream_buffer, delim)</em>：这个方法执行一个同步的<em>read</em>操作，参数的意义和<em>async_read_until</em>一样。</li><li><em>read_until(stream, stream_buffer, completion)</em>：这个方法执行一个同步的read操作，参数的意义和<em>async_read_until</em>一样。</li></ul><p>下面这个例子在读到一个指定的标点符号之前会一直读取：</p><pre class="line-numbers language-ruby"><code class="language-ruby">typedef buffers_iterator<span class="token operator">&lt;</span>streambuf<span class="token punctuation">:</span><span class="token symbol">:const_buffers_type</span><span class="token operator">></span> iterator<span class="token punctuation">;</span>std<span class="token punctuation">:</span><span class="token symbol">:pair</span><span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> bool<span class="token operator">></span> <span class="token function">match_punct</span><span class="token punctuation">(</span>iterator <span class="token keyword">begin</span><span class="token punctuation">,</span> iterator <span class="token keyword">end</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token keyword">begin</span> <span class="token operator">!=</span> <span class="token keyword">end</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> std<span class="token punctuation">:</span><span class="token symbol">:ispunct</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">begin</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token symbol">:make_pair</span><span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token punctuation">,</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token punctuation">:</span><span class="token symbol">:make_pair</span><span class="token punctuation">(</span><span class="token keyword">end</span><span class="token punctuation">,</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void <span class="token function">on_read</span><span class="token punctuation">(</span>const boost<span class="token punctuation">:</span><span class="token symbol">:system</span><span class="token punctuation">:</span><span class="token symbol">:error_code</span> <span class="token operator">&amp;</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>streambuf buf<span class="token punctuation">;</span><span class="token function">async_read_until</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> match_punct<span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们想读到一个空格时就结束，我们需要把最后一行修改为：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token function">async_read_until</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="at方法"><a href="#at方法" class="headerlink" title="*_at方法"></a>*_at方法</h4><p>这些方法用来在一个流上面做随机存取操作。由你来指定<em>read</em>和<em>write</em>操作从什么地方开始（<em>offset</em>）：</p><ul><li><em>async_read_at(stream, offset, buffer [, completion], handler)</em>：这个方法在指定的流的offset处开始执行一个异步的read操作，当操作结束时，它会调用handler。handler的格式为：<em>void handler(const boost::system::error_code&amp; err, size_t bytes);</em>。<em>buffer</em>可以是普通的<em>wrapper()</em>封装或者<em>streambuf</em>方法。如果你指定一个completion方法，它会在每次read操作成功之后调用，然后告诉Boost.Asio <em>async_read_at</em>操作已经完成（如果没有，则继续读取）。它的格式为：<em>size_t completion(const boost::system::error_code&amp; err, size_t bytes);</em>。当completion方法返回0时，我们认为<em>read</em>操作完成了；如果返回一个非零值，它代表了下一次调用流的<em>async_read_some_at</em>方法的最大读取字节数。</li><li><em>async_write_at(stream, offset, buffer [, completion], handler)</em>：这个方法执行一个异步的write操作。参数的意义和<em>async_read_at</em>是一样的</li><li><em>read_at(stream, offset, buffer [, completion])</em>：这个方法在一个执行的流上，指定的<em>offset</em>处开始read。参数的意义和<em>async_read_at</em>是一样的</li><li><em>write_at(stream, offset, buffer [, completion])</em>：这个方法在一个执行的流上，指定的<em>offset</em>处开始write。参数的意义和<em>async_read_at</em>是一样的</li></ul><p>这些方法不支持套接字。它们用来处理流的随机访问；也就是说，流是可以随机访问的。套接字显然不是这样（套接字是不可回溯的）。</p><p>下面这个例子告诉你怎么从一个文件偏移为256的位置读取128个字节：</p><pre class="line-numbers language-cpp"><code class="language-cpp">io_service service<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    HANDLE file <span class="token operator">=</span> <span class="token operator">::</span><span class="token function">CreateFile</span><span class="token punctuation">(</span><span class="token string">"readme.txt"</span><span class="token punctuation">,</span> GENERIC_READ<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> OPEN_ALWAYS<span class="token punctuation">,</span> FILE_ATTRIBUTE_NORMAL <span class="token operator">|</span> FILE_FLAG_OVERLAPPED<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    windows<span class="token operator">::</span>random_access_handle <span class="token function">h</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>    streambuf buf<span class="token punctuation">;</span>    <span class="token function">read_at</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">transfer_exactly</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>istream <span class="token function">in</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string line<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">getline</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first line: "</span> <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><p>这部分对异步编程时可能碰到的一些问题进行了深入的探究。我建议你先读一遍，然后在接下来读这本书的过程中，再经常回过头来看看，从而增强你对这部分的理解。</p><h4 id="异步的需求"><a href="#异步的需求" class="headerlink" title="异步的需求"></a>异步的需求</h4><p>就像我之前所说的，同步编程比异步编程简单很多。这是因为，线性的思考是很简单的（调用A，调用A结束，调用B，调用B结束，然后继续，这是以事件处理的方式来思考）。后面你会碰到这种情况，比如：五件事情，你不知道它们执行的顺序，也不知道他们是否会执行！</p><p>尽管异步编程更难，但是你会更倾向于选择使用它，比如：写一个需要处理很多并发访问的服务端。并发访问越多，异步编程就比同步编程越简单。</p><p>假设：你有一个需要处理1000个并发访问的应用，从客户端发给服务端的每个信息都会再返回给客户端，以‘\n’结尾。</p><p>同步方式的代码，1个线程：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> boost<span class="token operator">::</span>asio<span class="token punctuation">;</span><span class="token keyword">struct</span> client <span class="token punctuation">{</span>    ip<span class="token operator">::</span>tcp<span class="token operator">::</span>socket sock<span class="token punctuation">;</span>    <span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每个信息最多这么大</span>    <span class="token keyword">int</span> already_read<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 你已经读了多少</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>client<span class="token operator">></span> clients<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">handle_clients</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> clients<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token function">on_read</span><span class="token punctuation">(</span>clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span>client <span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> to_read <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">min</span><span class="token punctuation">(</span> <span class="token number">1024</span> <span class="token operator">-</span> c<span class="token punctuation">.</span>already_read<span class="token punctuation">,</span> c<span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c<span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">read_some</span><span class="token punctuation">(</span> <span class="token function">buffer</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>buff <span class="token operator">+</span> c<span class="token punctuation">.</span>already_read<span class="token punctuation">,</span> to_read<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c<span class="token punctuation">.</span>already_read <span class="token operator">+</span><span class="token operator">=</span> to_read<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>buff<span class="token punctuation">,</span> c<span class="token punctuation">.</span>buff <span class="token operator">+</span> c<span class="token punctuation">.</span>already_read<span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> c<span class="token punctuation">.</span>buff <span class="token operator">+</span> c<span class="token punctuation">.</span>already_read<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pos <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>buff<span class="token punctuation">,</span> c<span class="token punctuation">.</span>buff <span class="token operator">+</span> c<span class="token punctuation">.</span>already_read<span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token operator">-</span> c<span class="token punctuation">.</span>buff<span class="token punctuation">;</span>        std<span class="token operator">::</span>string <span class="token function">msg</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>buff<span class="token punctuation">,</span> c<span class="token punctuation">.</span>buff <span class="token operator">+</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>buff <span class="token operator">+</span> pos<span class="token punctuation">,</span> c<span class="token punctuation">.</span>buff <span class="token operator">+</span> <span class="token number">1024</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span>already_read <span class="token operator">-</span><span class="token operator">=</span> pos<span class="token punctuation">;</span>        <span class="token function">on_read_msg</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">on_read_msg</span><span class="token punctuation">(</span>client <span class="token operator">&amp;</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 分析消息，然后返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> msg <span class="token operator">==</span> <span class="token string">"request_login"</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span> <span class="token string">"request_ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有一种情况是在任何服务端（和任何基于网络的应用）都需要避免的，就是代码无响应的情况。在我们的例子里，我们需要<em>handle_clients()</em>方法尽可能少的阻塞。如果方法在某个点上阻塞，任何进来的信息都需要等待方法解除阻塞才能被处理。</p><p>为了保持响应，只在一个套接字有数据的时候我们才读，也就是说，<em>if ( clients[i].sock.available() ) on_read(clients[i])</em>。在<em>on_read</em>时，我们只读当前可用的；调用<em>read_until(c.sock, buffer(…), ‘\n’)</em>会是一个非常糟糕的选择，因为直到我们从一个指定的客户端读取了完整的消息之前，它都是阻塞的（我们永远不知道它什么时候会读取到完整的消息）</p><p>这里的瓶颈就是<em>on_read_msg()</em>方法；当它执行时，所有进来的消息都在等待。一个良好的<em>on_read_msg()</em>方法实现会保证这种情况基本不会发生，但是它还是会发生（有时候向一个套接字写入数据，缓冲区满了时，它会被阻塞） 同步方式的代码，10个线程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> boost<span class="token operator">::</span>asio<span class="token punctuation">;</span><span class="token keyword">struct</span> client <span class="token punctuation">{</span>　  <span class="token comment" spellcheck="true">// ... 和之前一样</span>    <span class="token keyword">bool</span> <span class="token function">set_reading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        boost<span class="token operator">::</span>mutex<span class="token operator">::</span>scoped_lock <span class="token function">lk</span><span class="token punctuation">(</span>cs_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> is_reading_<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 已经在读取</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span> is_reading_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">unset_reading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        boost<span class="token operator">::</span>mutex<span class="token operator">::</span>scoped_lock <span class="token function">lk</span><span class="token punctuation">(</span>cs_<span class="token punctuation">)</span><span class="token punctuation">;</span>        is_reading_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    boost<span class="token operator">::</span>mutex cs_<span class="token punctuation">;</span>    <span class="token keyword">bool</span> is_reading_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>client<span class="token operator">></span> clients<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">handle_clients</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        boost<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span> handle_clients_thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">handle_clients_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> clients<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">set_reading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">on_read</span><span class="token punctuation">(</span>clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">unset_reading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span>client <span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 和之前一样</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">on_read_msg</span><span class="token punctuation">(</span>client <span class="token operator">&amp;</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 和之前一样</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了使用多线程，我们需要对线程进行同步，这就是<em>set_reading()</em>和<em>set_unreading()</em>所做的。<em>set_reading()</em>方法非常重要，比如你想要一步实现“判断是否在读取然后标记为读取中”。但这是有两步的（“判断是否在读取”和“标记为读取中”），你可能会有两个线程同时为一个客户端判断是否在读取，然后你会有两个线程同时为一个客户端调用<em>on_read</em>，结果就是数据冲突甚至导致应用崩溃。</p><p>你会发现代码变得极其复杂。</p><p>同步编程有第三个选择，就是为每个连接开辟一个线程。但是当并发的线程增加时，这就成了一种灾难性的情况。</p><p>然后，让我们来看异步编程。我们不断地异步读取。当一个客户端请求某些东西时，<em>on_read</em>被调用，然后回应，然后等待下一个请求（然后开始另外一个异步的read操作）。</p><p>异步方式的代码，10个线程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> boost<span class="token operator">::</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span><span class="token keyword">struct</span> client <span class="token punctuation">{</span>    ip<span class="token operator">::</span>tcp<span class="token operator">::</span>socket sock<span class="token punctuation">;</span>    streambuf buff<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从客户端取回结果</span><span class="token punctuation">}</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>client<span class="token operator">></span> clients<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">handle_clients</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> clients<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token function">async_read_until</span><span class="token punctuation">(</span>clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sock<span class="token punctuation">,</span> clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>buff<span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">,</span> boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>on_read<span class="token punctuation">,</span> clients<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> _1<span class="token punctuation">,</span> _2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        boost<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span>handle_clients_thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">handle_clients_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span>client <span class="token operator">&amp;</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> size_t read_bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>istream <span class="token function">in</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string msg<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">getline</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> msg <span class="token operator">==</span> <span class="token string">"request_login"</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">async_write</span><span class="token punctuation">(</span> <span class="token string">"request_ok\n"</span><span class="token punctuation">,</span> on_write<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 等待同一个客户端下一个读取操作</span>    <span class="token function">async_read_until</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>sock<span class="token punctuation">,</span> c<span class="token punctuation">.</span>buff<span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">,</span> boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>on_read<span class="token punctuation">,</span> c<span class="token punctuation">,</span> _1<span class="token punctuation">,</span> _2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现代码变得有多简单了吧？client结构里面只有两个成员，<em>handle_clients()</em>仅仅调用了<em>async_read_until</em>，然后它创建了10个线程，每个线程都调用<em>service.run()</em>。这些线程会处理所有来自客户端的异步read操作，然后分发所有向客户端的异步write操作。另外需要注意的一件事情是：<em>on_read()</em>一直在为下一次异步read操作做准备（看最后一行代码）。</p><h4 id="异步run-runone-poll-poll-one"><a href="#异步run-runone-poll-poll-one" class="headerlink" title="异步run(), runone(), poll(), poll one()"></a>异步run(), run<em>one(), poll(), poll</em> one()</h4><p>为了实现监听循环，<em>io_service</em>类提供了4个方法，比如：<em>run(), run_one(), poll()</em>和<em>poll_one()</em>。虽然大多数时候使用<em>service.run()</em>就可以，但是你还是需要在这里学习其他方法实现的功能。</p><h5 id="持续运行"><a href="#持续运行" class="headerlink" title="持续运行"></a>持续运行</h5><p>再一次说明，如果有等待执行的操作，<em>run()</em>会一直执行，直到你手动调用<em>io_service::stop()</em>。为了保证<em>io_service</em>一直执行，通常你添加一个或者多个异步操作，然后在它们被执行时，你继续一直不停地添加异步操作，比如下面代码：</p><pre class="line-numbers language-php"><code class="language-php">using <span class="token keyword">namespace</span> <span class="token package">boost</span><span class="token punctuation">:</span><span class="token punctuation">:</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span>ip<span class="token punctuation">:</span><span class="token punctuation">:</span>tcp<span class="token punctuation">:</span><span class="token punctuation">:</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>char buff_read<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buff_write<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ok"</span><span class="token punctuation">;</span>void <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>system<span class="token punctuation">:</span><span class="token punctuation">:</span>error_code <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>size_t bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>void <span class="token function">on_write</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>system<span class="token punctuation">:</span><span class="token punctuation">:</span>error_code <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>size_t bytes<span class="token punctuation">)</span><span class="token punctuation">{</span>    sock<span class="token punctuation">.</span><span class="token function">async_read_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff_read<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>system<span class="token punctuation">:</span><span class="token punctuation">:</span>error_code <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>size_t bytes<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ... 处理读取操作 ...</span>    sock<span class="token punctuation">.</span><span class="token function">async_write_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff_write<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> on_write<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void <span class="token function">on_connect</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>system<span class="token punctuation">:</span><span class="token punctuation">:</span>error_code <span class="token operator">&amp;</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sock<span class="token punctuation">.</span><span class="token function">async_read_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>buff_read<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>int <span class="token function">main</span><span class="token punctuation">(</span>int argc<span class="token punctuation">,</span> char<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ip<span class="token punctuation">:</span><span class="token punctuation">:</span>tcp<span class="token punctuation">:</span><span class="token punctuation">:</span>endpoint <span class="token function">ep</span><span class="token punctuation">(</span> ip<span class="token punctuation">:</span><span class="token punctuation">:</span>address<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock<span class="token punctuation">.</span><span class="token function">async_connect</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> on_connect<span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>当<em>service.run()</em>被调用时，有一个异步操作在等待。</li><li>当socket连接到服务端时，<em>on_connect</em>被调用了，它会添加一个异步操作。</li><li>当<em>on_connect</em>结束时，我们会留下一个等待的操作（<em>read</em>）。</li><li>当<em>on_read</em>被调用时，我们写入一个回应，这又添加了另外一个等待的操作。</li><li>当<em>on_read</em>结束时，我们会留下一个等待的操作<em>（write</em>）。</li><li>当<em>on_write</em>操作被调用时，我们从服务端读取另外一个消息，这也添加了另外一个等待的操作。</li><li>当<em>on_write</em>结束时，我们有一个等待的操作（read）。</li><li>然后一直继续循环下去，直到我们关闭这个应用。</li></ol><h5 id="run-one-poll-poll-one-方法"><a href="#run-one-poll-poll-one-方法" class="headerlink" title="run_one(), poll(), poll_one() 方法"></a>run_one(), poll(), poll_one() 方法</h5><p>我在之前说过异步方法的handler是在调用了<em>io_service::run</em>的线程里被调用的。因为在至少90%～95%的时候，这是你唯一要用到的方法，所以我就把它说得简单了。对于调用了<em>run_one(), poll()</em>或者<em>poll_one()</em>的线程这一点也是适用的。</p><p><em>run_one()</em>方法最多执行和分发一个异步操作：</p><ul><li>如果没有等待的操作，方法立即返回0</li><li>如果有等待操作，方法在第一个操作执行之前处于阻塞状态，然后返回1</li></ul><p>你可以认为下面两段代码是等效的：</p><pre class="line-numbers language-javascript"><code class="language-javascript">io_service service<span class="token punctuation">;</span>service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 或者</span><span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">!</span>service<span class="token punctuation">.</span><span class="token function">stopped</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> service<span class="token punctuation">.</span><span class="token function">run_once</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你可以使用<em>run_once()</em>启动一个异步操作，然后等待它执行完成。</p><pre class="line-numbers language-php"><code class="language-php">io_service service<span class="token punctuation">;</span>bool write_complete <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>void <span class="token function">on_write</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>system<span class="token punctuation">:</span><span class="token punctuation">:</span>error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> size_t bytes<span class="token punctuation">)</span><span class="token punctuation">{</span> write_complete <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> …std<span class="token punctuation">:</span><span class="token punctuation">:</span>string data <span class="token operator">=</span> "login ok”<span class="token punctuation">;</span>write_complete <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token function">async_write</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token function">buffer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> on_write<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">do</span> service<span class="token punctuation">.</span><span class="token function">run_once</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>write_complete<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一些使用<em>run_one()</em>方法的例子，包含在Boost.Asio诸如<em>blocking_tcp_client.cpp</em>和<em>blocking_udp_client.cpp</em>的文件中。</p><p><em>poll_one</em>方法以非阻塞的方式最多运行一个准备好的等待操作：</p><ul><li>如果至少有一个等待的操作，而且准备好以非阻塞的方式运行，poll_one方法会运行它并且返回1</li><li>否则，方法立即返回0</li></ul><p>操作正在等待并准备以非阻塞方式运行，通常意味着如下的情况：</p><ul><li>一个计时器过期了，然后它的<em>async_wait</em>处理方法需要被调用</li><li>一个I/O操作完成了（比如<em>async_read</em>），然后它的hanlder需要被调用</li><li>之前被加入<em>io_services</em>实例队列中的自定义handler（这会在之后的章节中详解）</li></ul><p>你可以使用<em>poll_one</em>去保证所有I/O操作的handler完成运行，同时做一些其他的工作</p><pre class="line-numbers language-javascript"><code class="language-javascript">io_service service<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 运行所有完成了IO操作的handler</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> service<span class="token punctuation">.</span><span class="token function">poll_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ... 在这里做其他的事情 …</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>poll()</em>方法会以非阻塞的方式运行所有等待的操作。下面两段代码是等效的：</p><pre class="line-numbers language-javascript"><code class="language-javascript">io_service service<span class="token punctuation">;</span>service<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 或者</span><span class="token keyword">while</span> <span class="token punctuation">(</span> service<span class="token punctuation">.</span><span class="token function">poll_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所有上述方法都会在失败的时候抛出<em>boost::system::system_error</em>异常。这是我们所不希望发生的事情；这里抛出的异常通常都是致命的，也许是资源耗尽，或者是你handler的其中一个抛出了异常。另外，每个方法都有一个不抛出异常，而是返回一个<em>boost::system::error_code</em>的重载：</p><pre class="line-numbers language-cpp"><code class="language-cpp">io_service service<span class="token punctuation">;</span>boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> err<span class="token punctuation">)</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error "</span> <span class="token operator">&lt;&lt;</span> err <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="异步工作"><a href="#异步工作" class="headerlink" title="异步工作"></a>异步工作</h4><p>异步工作不仅仅指用异步地方式接受客户端到服务端的连接、异步地从一个socket读取或者写入到socket。它包含了所有可以异步执行的操作。</p><p>默认情况下，你是不知道每个异步handler的调用顺序的。除了通常的异步调用（来自异步socket的读取/写入/接收）。你可以使用<em>service.post()</em>来使你的自定义方法被异步地调用。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;boost/thread.hpp></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;boost/bind.hpp></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;boost/asio.hpp></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> boost<span class="token operator">::</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func called, i= "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">worker_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        service<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    boost<span class="token operator">::</span>thread_group threads<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        threads<span class="token punctuation">.</span><span class="token function">create_thread</span><span class="token punctuation">(</span>worker_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 等待所有线程被创建完</span>    boost<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep</span><span class="token punctuation">(</span> boost<span class="token operator">::</span>posix_time<span class="token operator">::</span><span class="token function">millisec</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    threads<span class="token punctuation">.</span><span class="token function">join_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，<em>service.post(some_function)</em>添加了一个异步方法调用。</p><p>这个方法在某一个调用了<em>service.run()</em>的线程中请求<em>io_service</em>实例，然后调用给定的<em>some_funtion</em>之后立即返回。在我们的例子中，这个线程是我们之前创建的三个线程中的一个。你不能确定异步方法调用的顺序。你不要期待它们会以我们调用<em>post()</em>方法的顺序来调用。下面是运行之前代码可能得到的结果：</p><pre class="line-numbers language-swift"><code class="language-swift"><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">4</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">6</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">7</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">8</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有时候你会想让一些异步处理方法顺序执行。比如，你去一个餐馆（<em>go_to_restaurant</em>），下单（<em>order</em>），然后吃（<em>eat</em>）。你需要先去餐馆，然后下单，最后吃。这样的话，你需要用到<em>io_service::strand</em>，这个方法会让你的异步方法被顺序调用。看下面的例子：</p><pre class="line-numbers language-php"><code class="language-php">using <span class="token keyword">namespace</span> <span class="token package">boost</span><span class="token punctuation">:</span><span class="token punctuation">:</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span>void <span class="token function">func</span><span class="token punctuation">(</span>int i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"func called, i= "</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> i <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>this_thread<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>void <span class="token function">worker_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>int <span class="token function">main</span><span class="token punctuation">(</span>int argc<span class="token punctuation">,</span> char<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    io_service<span class="token punctuation">:</span><span class="token punctuation">:</span>strand <span class="token function">strand_one</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">strand_two</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        service<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span> strand_one<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> int i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        service<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span> strand_two<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    boost<span class="token punctuation">:</span><span class="token punctuation">:</span>thread_group threads<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        threads<span class="token punctuation">.</span><span class="token function">create_thread</span><span class="token punctuation">(</span>worker_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 等待所有线程被创建完</span>    boost<span class="token punctuation">:</span><span class="token punctuation">:</span>this_thread<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">sleep</span><span class="token punctuation">(</span> boost<span class="token punctuation">:</span><span class="token punctuation">:</span>posix_time<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">millisec</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    threads<span class="token punctuation">.</span><span class="token function">join_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中，我们保证前面的5个线程和后面的5个线程是顺序执行的。<em>func called, i = 0</em>在<em>func called, i = 1</em>之前被调用，然后调用<em>func called, i = 2</em>……同样<em>func called, i = 5</em>在<em>func called, i = 6</em>之前，<em>func called, i = 6</em>在<em>func called, i = 7</em>被调用……你需要注意的是尽管方法是顺序调用的，但是不意味着它们都在同一个线程执行。运行这个程序可能得到的一个结果如下：</p><pre class="line-numbers language-swift"><code class="language-swift"><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">0</span><span class="token operator">/</span>002A60C8<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">5</span><span class="token operator">/</span>002A6138<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">6</span><span class="token operator">/</span>002A6530<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span>002A6138<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">7</span><span class="token operator">/</span>002A6530<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">2</span><span class="token operator">/</span>002A6138<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">8</span><span class="token operator">/</span>002A6530<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">3</span><span class="token operator">/</span>002A6138<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">9</span><span class="token operator">/</span>002A6530<span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">4</span><span class="token operator">/</span>002A6138<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="异步post-VS-dispatch-VS-wrap"><a href="#异步post-VS-dispatch-VS-wrap" class="headerlink" title="异步post() VS dispatch() VS wrap()"></a>异步post() VS dispatch() VS wrap()</h4><p>Boost.Asio提供了三种让你把处理方法添加为异步调用的方式：</p><ul><li><em>service.post(handler)</em>：这个方法能确保其在请求<em>io_service</em>实例，然后调用指定的处理方法之后立即返回。handler稍后会在某个调用了<em>service.run()</em>的线程中被调用。</li><li><em>service.dispatch(handler)</em>：这个方法请求<em>io_service</em>实例去调用给定的处理方法，但是另外一点，如果当前的线程调用了<em>service.run()</em>，它可以在方法中直接调用handler。</li><li><em>service.wrap(handler)</em>：这个方法创建了一个封装方法，当被调用时它会调用<em>service.dispatch(handler)</em>，这个会让人有点困惑，接下来我会简单地解释它是什么意思。</li></ul><p>在之前的章节中你会看到关于<em>service.post()</em>的一个例子，以及运行这个例子可能得到的一种结果。我们对它做一些修改，然后看看<em>service.dispatch()</em>是怎么影响输出的结果的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> boost<span class="token operator">::</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func called, i= "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">run_dispatch_and_post</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    service<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span>boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>boost<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    service<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>run_dispatch_and_post<span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在解释发生了什么之前，我们先运行程序，观察结果：</p><pre class="line-numbers language-swift"><code class="language-swift"><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">4</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">6</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">8</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">7</span><span class="token keyword">func</span> called<span class="token punctuation">,</span> i<span class="token operator">=</span> <span class="token number">9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>偶数先输出，然后是奇数。这是因为我用<em>dispatch()</em>输出偶数，然后用<em>post()</em>输出奇数。<em>dispatch()</em>会在返回之前调用hanlder，因为当前的线程调用了<em>service.run()</em>，而<em>post()</em>每次都立即返回了。</p><p>现在，让我们讲讲<em>service.wrap(handler)</em>。<em>wrap()</em>返回了一个仿函数，它可以用来做另外一个方法的参数：</p><pre class="line-numbers language-java"><code class="language-java">using namespace boost<span class="token operator">:</span><span class="token operator">:</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dispatched_func_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"dispatched 1"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">dispatched_func_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"dispatched 2"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>boost<span class="token operator">:</span><span class="token operator">:</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> func<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"test"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span>dispatched_func_1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">service_run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    service<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">test</span><span class="token punctuation">(</span> service<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>dispatched_func_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    boost<span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">th</span><span class="token punctuation">(</span>service_run<span class="token punctuation">)</span><span class="token punctuation">;</span>    boost<span class="token operator">:</span><span class="token operator">:</span>this_thread<span class="token operator">:</span><span class="token operator">:</span><span class="token function">sleep</span><span class="token punctuation">(</span> boost<span class="token operator">:</span><span class="token operator">:</span>posix_time<span class="token operator">:</span><span class="token operator">:</span><span class="token function">millisec</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    th<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>test(service.wrap(dispatched_func_2));</em>会把<em>dispatched_ func_2</em>包装起来创建一个仿函数，然后传递给<em>test</em>当作一个参数。当<em>test()</em>被调用时，它会分发调用方法1，然后调用<em>func()</em>。这时，你会发现调用<em>func()</em>和<em>service.dispatch(dispatched_func_2)</em>是等价的，因为它们是连续调用的。程序的输出证明了这一点：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">test</span>dispatched 1dispatched 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em>io_service::strand</em> 类（用来序列化异步调用）也包含了<em>poll(), dispatch()</em>和 <em>wrap()</em>等成员函数。它们的作用和<em>io_service</em>的<em>poll(), dispatch()</em>和<em>wrap()</em>是一样的。然而，大多数情况下你只需要把<em>io_service::strand::wrap()</em>方法做为<em>io_service::poll()</em>或者<em>io_service::dispatch()</em>方法的参数即可。</p><h3 id="保持活动"><a href="#保持活动" class="headerlink" title="保持活动"></a>保持活动</h3><p>假设你需要做下面的操作：</p><pre class="line-numbers language-cpp"><code class="language-cpp">io_service service<span class="token punctuation">;</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<em>sock</em>和<em>buff</em>的存在时间都必须比<em>read()</em>调用的时间要长。也就是说，在调用<em>read()</em>返回之前，它们都必须有效。这就是你所期望的；你传给一个方法的所有参数在方法内部都必须有效。当我们采用异步方式时，事情会变得比较复杂。</p><pre class="line-numbers language-cpp"><code class="language-cpp">io_service service<span class="token punctuation">;</span>ip<span class="token operator">::</span>tcp<span class="token operator">::</span>socket <span class="token function">sock</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> boost<span class="token operator">::</span>system<span class="token operator">::</span>error_code <span class="token operator">&amp;</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">async_read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token function">buffer</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> on_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<em>sock</em>和<em>buff</em>的存在时间都必须比<em>read()</em>操作本身时间要长，但是read操作持续的时间我们是不知道的，因为它是异步的。</p><p>当使用socket缓冲区的时候，你会有一个<em>buffer</em>实例在异步调用时一直存在（使用<em>boost::shared_array&lt;&gt;</em>）。在这里，我们可以使用同样的方式，通过创建一个类并在其内部管理socket和它的读写缓冲区。然后，对于所有的异步操作，传递一个包含智能指针的<em>boost::bind</em>仿函数给它：</p><pre class="line-numbers language-java"><code class="language-java">using namespace boost<span class="token operator">:</span><span class="token operator">:</span>asio<span class="token punctuation">;</span>io_service service<span class="token punctuation">;</span>struct connection <span class="token operator">:</span> boost<span class="token operator">:</span><span class="token operator">:</span>enable_shared_from_this<span class="token operator">&lt;</span>connection<span class="token operator">></span> <span class="token punctuation">{</span>    typedef boost<span class="token operator">:</span><span class="token operator">:</span>system<span class="token operator">:</span><span class="token operator">:</span>error_code error_code<span class="token punctuation">;</span>    typedef boost<span class="token operator">:</span><span class="token operator">:</span>shared_ptr<span class="token operator">&lt;</span>connection<span class="token operator">></span> ptr<span class="token punctuation">;</span>    <span class="token function">connection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">sock_</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">started_</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span>ip<span class="token operator">:</span><span class="token operator">:</span>tcp<span class="token operator">:</span><span class="token operator">:</span>endpoint ep<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sock_<span class="token punctuation">.</span><span class="token function">async_connect</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> boost<span class="token operator">:</span><span class="token operator">:</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>connection<span class="token operator">:</span><span class="token operator">:</span>on_connect<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>started_<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        started_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        sock_<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    bool <span class="token function">started</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> started_<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">on_connect</span><span class="token punctuation">(</span><span class="token keyword">const</span> error_code <span class="token operator">&amp;</span> err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里你决定用这个连接做什么: 读取或者写入</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>err<span class="token punctuation">)</span> <span class="token function">do_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">on_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> size_t bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">started</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        std<span class="token operator">:</span><span class="token operator">:</span>string <span class="token function">msg</span><span class="token punctuation">(</span>read_buffer_<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> msg <span class="token operator">==</span> <span class="token string">"can_login"</span><span class="token punctuation">)</span> <span class="token function">do_write</span><span class="token punctuation">(</span><span class="token string">"access_data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> msg<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"data "</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">process_data</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> msg <span class="token operator">==</span> <span class="token string">"login_fail"</span><span class="token punctuation">)</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">on_write</span><span class="token punctuation">(</span><span class="token keyword">const</span> error_code <span class="token operator">&amp;</span> err<span class="token punctuation">,</span> size_t bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">do_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">do_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sock_<span class="token punctuation">.</span><span class="token function">async_read_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>read_buffer_<span class="token punctuation">)</span><span class="token punctuation">,</span> boost<span class="token operator">:</span><span class="token operator">:</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>connection<span class="token operator">:</span><span class="token operator">:</span>on_read<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   _1<span class="token punctuation">,</span> _2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">do_write</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">:</span><span class="token operator">:</span>string <span class="token operator">&amp;</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">started</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注意: 因为在做另外一个async_read操作之前你想要发送多个消息, </span>        <span class="token comment" spellcheck="true">// 所以你需要多个写入buffer</span>        std<span class="token operator">:</span><span class="token operator">:</span><span class="token function">copy</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> write_buffer_<span class="token punctuation">)</span><span class="token punctuation">;</span>        sock_<span class="token punctuation">.</span><span class="token function">async_write_some</span><span class="token punctuation">(</span><span class="token function">buffer</span><span class="token punctuation">(</span>write_buffer_<span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boost<span class="token operator">:</span><span class="token operator">:</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>connection<span class="token operator">:</span><span class="token operator">:</span>on_write<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _1<span class="token punctuation">,</span> _2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">process_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">:</span><span class="token operator">:</span>string <span class="token operator">&amp;</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 处理服务端来的内容，然后启动另外一个写入操作</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    ip<span class="token operator">:</span><span class="token operator">:</span>tcp<span class="token operator">:</span><span class="token operator">:</span>socket sock_<span class="token punctuation">;</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span> max_msg <span class="token operator">=</span> <span class="token number">1024</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> read_buffer_<span class="token punctuation">[</span>max_msg<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> write_buffer_<span class="token punctuation">[</span>max_msg<span class="token punctuation">]</span><span class="token punctuation">;</span>    bool started_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ip<span class="token operator">:</span><span class="token operator">:</span>tcp<span class="token operator">:</span><span class="token operator">:</span>endpoint <span class="token function">ep</span><span class="token punctuation">(</span> ip<span class="token operator">:</span><span class="token operator">:</span>address<span class="token operator">:</span><span class="token operator">:</span><span class="token function">from_string</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">8001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    connection<span class="token operator">:</span><span class="token operator">:</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">connection</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在所有异步调用中，我们传递一个<em>boost::bind</em>仿函数当作参数。这个仿函数内部包含了一个智能指针，指向<em>connection</em>实例。只要有一个异步操作等待时，Boost.Asio就会保存<em>boost::bind</em>仿函数的拷贝，这个拷贝保存了指向连接实例的一个智能指针，从而保证<em>connection</em>实例保持活动。问题解决！</p><p>当然，<em>connection</em>类仅仅是一个框架类；你需要根据你的需求对它进行调整（它看起来会和当前服务端例子的情况相当不同）。</p><p>你需要注意的是创建一个新的连接是相当简单的：<em>connection::ptr(new connection)- &gt;start(ep)</em>。这个方法启动了到服务端的（异步）连接。当你需要关闭这个连接时，调用<em>stop()</em>。</p><p>当实例被启动时（<em>start()</em>），它会等待客户端的连接。当连接发生时。<em>on_connect()</em>被调用。如果没有错误发生，它启动一个read操作（<em>do_read()</em>）。当read操作结束时，你就可以解析这个消息；当然你应用的<em>on_read()</em>看起来会各种各样。而当你写回一个消息时，你需要把它拷贝到缓冲区，然后像我在<em>do_write()</em>方法中所做的一样将其发送出去，因为这个缓冲区同样需要在这个异步写操作中一直存活。最后需要注意的一点——当写回时，你需要指定写入的数量，否则，整个缓冲区都会被发送出去。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络api实际上要繁杂得多，这个章节只是做为一个参考，当你在实现自己的网络应用时可以回过头来看看。</p><p>Boost.Asio实现了端点的概念，你可以认为是IP和端口。如果你不知道准确的IP，你可以使用<em>resolver</em>对象将主机名，例如<em><a href="http://www.yahoo.com">www.yahoo.com</a></em>转换为一个或多个IP地址。</p><p>我们也可以看到API的核心——socket类。Boost.Asio提供了<em>TCP、UDP</em>和 <em>ICMP</em>的实现。而且你还可以用你自己的协议来对它进行扩展；当然，这个工作不适合缺乏勇气的人。</p><p>异步编程是刚需。你应该已经明白为什么有时候需要用到它，尤其在写服务端的时候。调用<em>service.run()</em>来实现异步循环就已经可以让你很满足，但是有时候你需要更进一步，尝试使用<em>run_one()、poll()</em>或者<em>poll_one()</em>。</p><p>当实现异步时，你可以异步执行你自己的方法；使用<em>service.post()</em>或者<em>service.dispatch()</em>。</p><p>最后，为了使socket和缓冲区（read或者write）在整个异步操作的生命周期中一直活动，我们需要采取特殊的防护措施。你的连接类需要继承自<em>enabled_shared_from_this</em>，然后在内部保存它需要的缓冲区，而且每次异步调用都要传递一个智能指针给<em>this</em>操作。</p><p>下一章会进行实战操作；在实现回显客户端/服务端应用时会有大量的编程实践。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;为什么要学这个呢？首先，arpa那套网络编程只能在linux下用，其次，个人觉得C语言风格的接口实在是太丑陋了，第三，cpp的net库提上日
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>有栈协程与无栈协程</title>
    <link href="https://joytsing.github.io/posts/21849/"/>
    <id>https://joytsing.github.io/posts/21849/</id>
    <published>2024-04-19T08:46:06.000Z</published>
    <updated>2024-04-19T14:50:04.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，先问自己一个问题，<code>什么是协程？</code>，<code>为什么需要协程？</code>，<code>能解决什么痛点？</code></p><h2 id="协程，what，why？"><a href="#协程，what，why？" class="headerlink" title="协程，what，why？"></a>协程，what，why？</h2><p>什么是协程，现在流行的有几种说法：</p><ul><li>第一种： “可以暂停和恢复执行” 的函数，<strong>其“全部精神就在于控制流的主动让出和恢复”</strong>。这种观点来自协程概念的提出者Conway在1963年发表的论文”<strong><a href="http://melconway.com/Home/pdf/compiler.pdf">Design of a separable transition-diagram compiler</a></strong>“</li><li>第二种：是运行在用户态的线程，避免了向内核态下陷从而提高性能。实现一个用户态线程有两个必须要处理的问题：一是碰着阻塞式I\O会导致整个进程被挂起；二是由于缺乏时钟阻塞，进程需要自己拥有调度线程的能力。如果一种实现使得每个线程需要自己通过调用某个方法，主动交出控制权。那么我们就称这种用户态线程是协作式的，即是<strong>协程</strong>。</li><li>第三种：Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. —— from <strong><a href="https://en.wikipedia.org/wiki/Coroutine">Wikipieda</a></strong></li></ul><p>所以这几种定义哪个才是协程，还是说他们都对？然后是我们为什么要协程？</p><ul><li>让原来需要使用异步+回调方式写的非人类代码,用看似同步的方式写出来</li><li>既要同步编程风格，能够让业务开发人员很便捷地去开发业务逻辑代码，同时能够达到「异步回调模型的性能」。</li></ul><h2 id="有栈协程与无栈协程"><a href="#有栈协程与无栈协程" class="headerlink" title="有栈协程与无栈协程"></a>有栈协程与无栈协程</h2><p>如今协程已经成为大多数语言的标配，例如 Golang 里的 goroutine，JavaScript 里的 async/await。尽管名称可能不同，但它们都可以被划分为两大类，一类是有栈（stackful）协程，例如 goroutine；一类是无栈（stackless）协程，例如 async/await。</p><p>此处「有栈」和「无栈」的含义不是指协程在运行时是否需要栈，对于大多数语言来说，一个函数调用另一个函数，总是存在调用栈的；而是指协程是否可以在其<strong>任意</strong>嵌套函数中被挂起，此处的嵌套函数读者可以理解为子函数、匿名函数等。显然有栈协程是可以的，而无栈协程则不可以。似乎难以理解？不要慌，让我们先从函数调用栈开始讲起。</p><h3 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h3><p>调用栈是一段连续的地址空间，无论是 caller（调用方）还是 callee（被调用方）都位于这段空间之内。而调用栈中一个函数所占用的地址空间我们称之为「栈帧」（stack frame），调用栈便是由若干个栈帧拼接而成的。</p><p><img src="/posts/21849/call-stack.png" alt="DrawSquare 是 caller，DrawLine 是 callee"></p><p>Stack Pointer 即栈顶指针，总是指向调用栈的顶部地址，该地址由 esp 寄存器存储；Frame Pointer 即基址指针，总是指向当前栈帧（当前正在运行的子函数）的底部地址，该地址由 ebp 寄存器存储。Return Address 则在是 callee 返回后，caller 将继续执行的指令所在的地址；而指令地址是由 eip 寄存器负责读取的，且 eip 寄存器总是预先读取了<strong>当前栈帧中</strong>下一条将要执行的指令的地址。</p><p>我们可以很轻易地构造一段 C 代码，然后将其转换为汇编，看看底层究竟做了什么。网页上推荐使用 <a href="https://godbolt.org/">Compiler Explorer</a> 查看汇编更加简洁清晰。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">callee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// callee:</span>               <span class="token comment" spellcheck="true">//   pushl %ebp</span>               <span class="token comment" spellcheck="true">//   movl  %esp, %ebp</span>               <span class="token comment" spellcheck="true">//   subl  $16, %esp</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//   movl  $0, -4(%ebp)</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//   movl -4(%ebp), %eax</span>               <span class="token comment" spellcheck="true">//   leave</span>               <span class="token comment" spellcheck="true">//   ret</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">caller</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// caller:</span>               <span class="token comment" spellcheck="true">//   pushl %ebp</span>               <span class="token comment" spellcheck="true">//   movl  %esp, %ebp</span>    <span class="token function">callee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//   call  callee</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//   movl  $0, %eax</span>               <span class="token comment" spellcheck="true">//   popl  %ebp</span>               <span class="token comment" spellcheck="true">//   ret</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 caller 调用 callee 时，执行了以下步骤（注意注释中的执行顺序：</p><pre class="line-numbers language-assembly"><code class="language-assembly">callee:    // 3. 将 caller 的栈帧底部地址入栈保存    pushl %ebp    // 4. 将此时的调用栈顶部地址作为 callee 的栈帧底部地址    movl  %esp, %ebp    // 5. 将调用栈顶部扩展 16 bytes 作为 callee 的栈帧空间；    //    在 x86 平台中，调用栈的地址增长方向是从高位向低位增长的，    //    所以这里用的是 subl 指令而不是 addl 指令    subl  $16, %esp    ...caller:    ...    // "call callee" 等价于如下两条指令：    // 1. 将 eip 存储的指令地址入栈保存；    //    此时的指令地址即为 caller 的 return address，    //    即 caller 的 "movl $0, %eax" 这条指令所在的地址    // 2. 然后跳转到 callee    pushl %eip    jmp callee    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/21849/caller-to-callee.png" alt="caller 调用 callee 的调用栈变化（忽略传参）">caller 调用 callee 的调用栈变化（忽略传参）</p><p>当 callee 返回 caller 时，则执行了以下步骤（注意注释中的执行顺序：</p><pre class="line-numbers language-assembly"><code class="language-assembly">callee:    ...    // "leave" 等价于如下两条指令：    // 6. 将调用栈顶部与 callee 栈帧底部对齐，释放 callee 栈帧空间    // 7. 将之前保存的 caller 的栈帧底部地址出栈并赋值给 ebp    movl %ebp, %esp    popl %ebp    // "ret" 等价如下指令：    // 8. 将之前保存的 caller 的 return address 出栈并赋值给 eip，    //    即 caller 的 "movl $0, %eax" 这条指令所在的地址    popl eipcaller:    ...    // 9. 从 callee 返回了，继续执行后续指令    movl $0, %eax    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/21849/callee-to-caller.png" alt="callee 返回 caller 的调用栈变化（忽略传参）">callee 返回 caller 的调用栈变化（忽略传参)</p><p>以上便是函数调用栈的大致运行过程了。当然真实的调用栈运行过程要复杂一些，需要带上参数传递等等，对此感兴趣，则推荐阅读这篇文章 <a href="https://www.csee.umbc.edu/~chang/cs313.s02/stack.shtml">C Function Call Conventions and the Stack</a>。</p><h3 id="有栈协程"><a href="#有栈协程" class="headerlink" title="有栈协程"></a>有栈协程</h3><p>实现一个协程的关键点在于如何保存、恢复和切换上下文。已知函数运行在调用栈上；如果将一个函数作为协程，我们很自然地联想到，保存上下文即是保存从这个函数及其嵌套函数的（连续的）栈帧存储的值，以及此时寄存器存储的值；恢复上下文即是将这些值分别重新写入对应的栈帧和寄存器；而切换上下文无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的函数的上下文。有栈协程便是这种朴素思想下的产物，即类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核而已。</p><p>有栈协程是可以在其任意嵌套函数中被挂起的 —— 毕竟它都能保存和恢复自己完整的上下文了，那自然是在哪里被挂起都可以。我们可以自己实现一个简单的例子证明这个事实，同时也有助于我们从底层理解有栈协程的运行过程。</p><p>首先我们需要申请一段能存储上下文的内存空间。在保存上下文时，我们可以选择把上下文都拷贝到这段内存；亦或者直接将这段内存作为协程运行时的栈帧空间，这样就能避免拷贝带来的性能损失了。注意，如果申请的内存空间小了，协程在运行时会爆栈；如果大了，则浪费内存；不过具体的分配策略我们就不做过多讨论了。</p><p>同时还需要保存寄存器的值。这里便涉及到了函数调用栈中的一个知识点，<a href="https://en.wikipedia.org/wiki/X86_calling_conventions#Caller-saved_(volatile)_registers">根据约定</a>，有的寄存器是由 caller 负责保存的，如 eax、ecx 和 edx；而有的寄存器是 callee 负责保存的，如 ebx、edi 和 esi。对于被调用的协程而言，只需要保存 callee 相关的寄存器的值，调用栈相关的 ebp 和 esp 的值，以及 eip 存储的 return address。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 1) 存储 return address</span><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 2) 存储 ebx</span><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 3) 存储 edi</span><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 4) 存储 esi</span><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 5) 存储 ebp</span><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 6) 存储 esp</span><span class="token comment" spellcheck="true">// 注意 x86 的栈增长方向是从高位向低位增长的，所以寻址是向下偏移的</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 动态申请 CTX_SIZE 内存用于存储协程上下文</span>    size_t size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> CTX_SIZE<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>ctx <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将 func 的地址作为其栈帧 return address 的初始值，</span>    <span class="token comment" spellcheck="true">// 当 func 第一次被调度时，将从其入口处开始执行</span>    <span class="token operator">*</span><span class="token punctuation">(</span>ctx <span class="token operator">+</span> CTX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> func<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// https://github.com/mthli/blog/pull/12</span>    <span class="token comment" spellcheck="true">// 需要预留 6 个寄存器内容的存储空间，</span>    <span class="token comment" spellcheck="true">// 余下的内存空间均可以作为 func 的栈帧空间</span>    <span class="token operator">*</span><span class="token punctuation">(</span>ctx <span class="token operator">+</span> CTX_SIZE <span class="token operator">-</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx <span class="token operator">+</span> CTX_SIZE <span class="token operator">-</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ctx <span class="token operator">+</span> CTX_SIZE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，为了保存和恢复寄存器的值，我们还需要撰写几段汇编代码。假设此时我们已经将存储上下文的内存地址赋值给了 eax，则保存的逻辑如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly">// 依次将各个寄存器的值存储；// 注意 x86 的栈增长方向是从高位向低位增长的，所以寻址是向下偏移的movl %ebx,  -8(%eax)movl %edi, -12(%eax)movl %esi, -16(%eax)movl %ebp, -20(%eax)movl %esp, -24(%eax)//  %esp  存储的是当前调用栈的顶部所在的地址，// (%esp) 是顶部地址所指向的内存区域存储的值，// 将这个值存储为 return addressmovl (%esp), %ecxmovl %ecx, -4(%eax)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而与之相对应的恢复逻辑如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly">// 依次将存储的值写入各个寄存器；// 注意 x86 的栈增长方向是从高位向低位增长的，所以寻址是向下偏移的movl  -8(%eax), %ebxmovl -12(%eax), %edimovl -16(%eax), %esimovl -20(%eax), %ebpmovl -24(%eax), %esp//  %esp  存储的是当前调用栈的顶部所在的地址，// (%esp) 是顶部地址所指向的内存区域存储的值，// 将存储的 return address 写入到该内存区域movl -4(%eax), %ecxmovl %ecx, (%esp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而前文已经说过，切换上下文无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的函数的上下文。于是我们可以基于上述两段汇编构造一个 <code>void swap_ctx(char **current, char **next)</code> 函数，分别传入 <code>char **init_ctx(char *func)</code> 构造好的上下文即可实现切换。为了方便使用，我们可以将 <code>swap_ctx()</code> 封装成 <code>yield()</code> 函数，在这个函数里简单实现了不同函数的调度逻辑。于是一个简单的例子便完成了：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>MAIN_CTX<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>NEST_CTX<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>FUNC_CTX_1<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>FUNC_CTX_2<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">nest_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">nest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 随机生成一个整数作为 tag</span>    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"nest, tag: %d, index: %d\n"</span><span class="token punctuation">,</span> tag<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">nest_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 随机生成一个整数作为 tag</span>    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"func, tag: %d, index: %d\n"</span><span class="token punctuation">,</span> tag<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    MAIN_CTX <span class="token operator">=</span> <span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> main<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 证明 nest() 可以在其任意嵌套函数中被挂起</span>    NEST_CTX <span class="token operator">=</span> <span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> nest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 证明同一个函数在不同的栈帧空间上运行</span>    FUNC_CTX_1 <span class="token operator">=</span> <span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>    FUNC_CTX_2 <span class="token operator">=</span> <span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"main, tag: %d, index: %d\n"</span><span class="token punctuation">,</span> tag<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">free</span><span class="token punctuation">(</span>MAIN_CTX <span class="token operator">-</span> CTX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>NEST_CTX <span class="token operator">-</span> CTX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>FUNC_CTX_1 <span class="token operator">-</span> CTX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>FUNC_CTX_2 <span class="token operator">-</span> CTX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整的代码可通过 <a href="https://github.com/mthli/blog/blob/master/content/blog/stackful-stackless/">这个链接</a> 获得，使用 <code>gcc -m32 stackful.c stackful.s</code> 编译，然后运行 <code>./a.out</code> 的得到如下结果：</p><p><img src="/posts/21849/image-20240419205041630.png" alt></p><p>可以注意到 <code>tag</code> 的值在每次调度过程中均未改变，而循环叠加 <code>index</code> 的逻辑也并未因为挂起和恢复受到影响。所以 <code>nest()</code> 的确是可以在其任意嵌套函数中被挂起；同时我们还证明了同一个函数被调用多次时，的确是在不同的栈帧空间上运行的。</p><h2 id="无栈协程"><a href="#无栈协程" class="headerlink" title="无栈协程"></a>无栈协程</h2><p>相比于有栈协程直接切换栈帧的思路，无栈协程在不改变函数调用栈的情况下，采用类似生成器（generator）的思路实现了上下文切换，此处请直接阅读文章 <a href="https://mthli.xyz/coroutines-in-c/">使用 C 语言实现协程</a> —— 尽管作者在文中没有说明，但这正是一种无栈协程的实现。<strong>无栈协程的本质就是一个状态机（state machine）</strong>，它可以理解为在另一个角度去看问题，即<strong>同一协程协程的切换本质不过是指令指针寄存器的改变</strong>。</p><p>此外我们还可以通过译文提供的 <a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutine.h">coroutine.h</a> 看到，作者通过 C 语言的宏将所有协程的变量统一包装进了一个结构体，然后再为这个结构体申请内存空间，从而实现了分配确定大小的内存空间，避免了内存浪费 —— 而这正是有栈协程所做不到的。</p><p>从执行时栈的角度来看，其实所有的协程共用的都是一个栈，即系统栈，也就也不必我们自行去给协程分配栈，因为是函数调用，我们当然也不必去显示的保存寄存器的值，而且<strong>相比有栈协程把局部变量放在新开的空间上，无栈协程直接使用系统栈使得CPU cache局部性更好，同时也使得无栈协程的中断和函数返回几乎没有区别</strong>，这样也可以凸显出无栈协程的高效。</p><h2 id="对称协程和非对称协程"><a href="#对称协程和非对称协程" class="headerlink" title="对称协程和非对称协程"></a>对称协程和非对称协程</h2><p>其实对于“对称”这个名词，阐述的实际是协程之间的关系，用大白话来说就是对称协程就是说协程之间人人平等，没有谁调用谁一说，大家都是一样的，而非对称协程就是协程之间存在明显的调用关系。</p><p>简单来说就是这样：</p><ul><li>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。</li><li>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。</li></ul><p>回到开头的问题，协程分为无栈协程和有栈协程两种，无栈指可挂起/恢复的函数，有栈协程则相当于用户态线程。有栈协程切换的成本是用户态线程切换的成本，而无栈协程切换的成本则相当于函数调用的成本。</p><ul><li>无栈协程和线程的区别：无栈协程只能被线程调用，本身并不抢占内核调度，而线程则可抢占内核调度。</li><li>协程函数与普通函数的区别：普通函数执行完返回，则结束，协程函数可以运行到一半，返回并保留上下文；下次唤醒时恢复上下文，可以接着执行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先，先问自己一个问题，&lt;code&gt;什么是协程？&lt;/code&gt;，&lt;code&gt;为什么需要协程？&lt;/code&gt;，&lt;code&gt;能解决什么痛点？&lt;/
      
    
    </summary>
    
    
      <category term="Go" scheme="https://JoyTsing.github.io/categories/Go/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Go" scheme="https://JoyTsing.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go里的GMP协程调度</title>
    <link href="https://joytsing.github.io/posts/59192/"/>
    <id>https://joytsing.github.io/posts/59192/</id>
    <published>2024-04-19T08:42:55.000Z</published>
    <updated>2024-04-19T14:47:38.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Go调度器的详细调度过程是什么？</p><h2 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h2><p>M个协程绑定1个线程，模型大概如下：</p><p><img src="/posts/59192/1460000021951130.png" alt></p><h3 id="G（Goroutine）"><a href="#G（Goroutine）" class="headerlink" title="G（Goroutine）"></a>G（Goroutine）</h3><p>G 取自Goroutine的首字母，一个G代表一个Goroutine，Goroutine是一个与其他Goroutines并行运行在同一地址空间的go函数或方法。当 Goroutine 被调离 CPU 时，调度器代码负责把 CPU 寄存器的值保存在 G 对象的成员变量之中，当 Goroutine 被调度起来运行时，调度器代码又负责把 G 对象的成员变量所保存的寄存器的值恢复到 CPU 的寄存器。</p><p>协程之于Go调度器好比内核线程之于OS调度器，也是有着多种状态的，但因为它不可见底层核心线程的状态，因此会有更细致和复杂的状态迁移图，如下图所示：</p><p><img src="/posts/59192/v2-96be756d5230b84b66a9ce52d4adcde3_720w.webp" alt></p><p>不同状态的描述如下图所示：</p><p><img src="/posts/59192/v2-842e12010eedd6c181adb26ffe955c8d_720w.webp" alt></p><p>Go协程状态图相比进程状态图多了<strong>收缩/扩展栈</strong>和<strong>执行系统调用</strong>两个更加细分的状态，而且同时runnable和running状态和OS的状态<strong>不是一一对应</strong>的，其实用户态无法感知到OS的就绪态、运行态和阻塞态。</p><h3 id="M（Machine）"><a href="#M（Machine）" class="headerlink" title="M（Machine）"></a>M（Machine）</h3><p>OS 底层线程的抽象，它本身就与一个内核线程进行绑定，每个工作线程都有唯一的一个 M 结构体的实例对象与之对应，它代表着真正执行计算的资源，由操作系统的调度器调度和管理。M 结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的 Goroutine 以及是否空闲等等状态信息之外，还通过指针维持着与 P 结构体的实例对象之间的绑定关系。</p><p>最多只会有 GOMAXPROCS 个活跃线程能够正常运行，因为M需要和P绑定才能运行G，而P的个数取决于设置的GOMAXPROCS，一个M阻塞了就会创建新的M。</p><h3 id="P（Processor）"><a href="#P（Processor）" class="headerlink" title="P（Processor）"></a>P（Processor）</h3><p>表示逻辑处理器。对 G 来说，P 相当于 CPU 核，G 只有绑定到 P(在 P 的 local runq 中)才能被调度。对 M 来说，P 提供了<strong>相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)</strong>等。它维护一个局部 Goroutine 可运行 G 队列，工作线程<strong>优先使用自己的局部运行队列，只有必要时才会去访问全局运行队列</strong>，这可以大大减少锁冲突，提高工作线程的并发性，并且可以良好的运用程序的局部性原理。</p><h3 id="GMP概述"><a href="#GMP概述" class="headerlink" title="GMP概述"></a>GMP概述</h3><p><img src="/posts/59192/v2-2b01b8aaabcf52d060a0f128133e6d96_720w.png" alt></p><ol><li><strong>全局队列</strong>（Global Queue）：存放等待运行的G。</li><li><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li><li><strong>P列表</strong>：所有的P都在程序启动时创建，并保存在数组中，最多有<code>GOMAXPROCS</code>(可配置)个。</li><li><strong>M</strong>：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列<strong>拿</strong>一批G放到P的本地队列，或从其他P的本地队列<strong>偷</strong>一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li></ol><p><strong>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行</strong>。对于<strong>本地运行队列</strong>，每个逻辑处理器有一个本地运行队列。如果创建一个goroutine并准备运行，这个goroutine首先会被放到调度器的全局运行队列中。之后，调度器会将全局运行队列中的goroutine分配给一个逻辑处理器，并放到这个逻辑处理器的本地运行队列中。本地运行队列中的goroutine会一直等待直到被分配的逻辑处理器执行。下图展示了操作系统线程、逻辑处理器和本地运行队列之间的关系：</p><p><img src="/posts/59192/640.webp" alt></p><p>有时，正在运行的goroutine需要执行一个阻塞的系统调用，如打开一个文件。当这类调用发生时，线程和goroutine会从逻辑处理器上分离，该线程会继续阻塞，等待系统调用的返回。与此同时，这个逻辑处理器就失去了用来运行的线程。所以，调度器会创建一个新线程，并将其绑定到该逻辑处理器上。之后，调度器会从本地运行队列里选择另一个goroutine来运行。一旦被阻塞的系统调用执行完成并返回，对应的goroutine会放回到本地运行队列，而之前的线程会保存好，以便之后可以继续使用。</p><p><img src="/posts/59192/640-1713536584650-11.webp" alt></p><p>如果一个goroutine需要做一个网络I/O调用，流程上会有些不一样。在这种情况下，goroutine会和逻辑处理器分离，并移到集成了网络轮询器的运行时。一旦该轮询器指示某个网络读或者写操作已经就绪，对应的goroutine 就会重新分配到逻辑处理器上来完成操作。 </p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="调度器设计策略"><a href="#调度器设计策略" class="headerlink" title="调度器设计策略"></a>调度器设计策略</h3><p><strong>复用线程</strong>：避免频繁的创建、销毁线程，而是对线程的复用。</p><ul><li><p>1）work stealing机制</p><p>当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p></li><li><p>2）hand off机制</p><p>当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p></li></ul><p><strong>利用并行</strong>：<code>GOMAXPROCS</code>设置P的数量，最多有<code>GOMAXPROCS</code>个线程分布在多个CPU上同时运行。<code>GOMAXPROCS</code>也限制了并发的程度，比如<code>GOMAXPROCS = 核数/2</code>，则最多利用了一半的CPU核进行并行。</p><p><strong>抢占</strong>：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p><p><strong>全局G队列</strong>：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</p><h3 id="全局goroutine队列"><a href="#全局goroutine队列" class="headerlink" title="全局goroutine队列"></a>全局goroutine队列</h3><p>当创建一个新的G之后优先加入本地队列，如果本地队列满了，会将本地队列的G移动到全局队列里面，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</p><p>我们创建一个协程 go func()经历过程如下图：</p><p><img src="/posts/59192/webp.webp" alt></p><blockquote><p><strong>说明：</strong></p><p>这里有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；处理器本地队列是一个使用数组构成的环形链表，它最多可以存储 256 个待执行任务。</p><p>G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；一个M调度G执行的过程是一个循环机制；会一直从本地队列或全局队列中获取G</p></blockquote><h3 id="M缓冲池"><a href="#M缓冲池" class="headerlink" title="M缓冲池"></a>M缓冲池</h3><p>上面说到P的个数默认等于CPU核数，每个M必须持有一个P才可以执行G，一般情况下M的个数会略大于P的个数，这多出来的M将会在G产生系统调用时发挥作用。类似线程池，Go也提供一个M的池子，需要时从池子中获取，用完放回池子，不够用时就再创建一个。</p><h3 id="调度例外"><a href="#调度例外" class="headerlink" title="调度例外"></a>调度例外</h3><p>如果一切正常，调度器会以上述的那种方式顺畅地运行，但这个世界没这么美好，总有意外发生，以下分析goroutine在两种例外情况下的行为。</p><p>Go runtime会在下面的goroutine被阻塞的情况下运行另外一个goroutine：</p><p><strong>用户态阻塞/唤醒</strong></p><p>当goroutine因为channel操作或者network I/O而阻塞时（实际上golang已经用netpoller实现了goroutine网络I/O阻塞不会导致M被阻塞，仅阻塞G，这里仅仅是举个栗子），对应的G会被放置到某个wait队列(如channel的waitq)，该G的状态由_Gruning变为_Gwaitting，而M会跳过该G尝试获取并执行下一个G，如果此时没有可运行的G供M运行，那么M将解绑P，并进入sleep状态；当阻塞的G被另一端的G2唤醒时（比如channel的可读/写通知），G被标记为，尝试加入G2所在P的runnext（runnext是线程下一个需要执行的 Goroutine。）， 然后再是P的本地队列和全局队列。</p><p><strong>系统调用阻塞</strong></p><p>当M执行某一个G时候如果发生了阻塞操作，M会阻塞，如果当前有一些G在执行，调度器会把这个线程M从P中摘除，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P。当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p><p><strong>队列轮转</strong></p><p>可见每个P维护着一个包含G的队列，不考虑G进入系统调用或IO操作的情况下，P周期性的将G调度到M中执行，执行一小段时间，将上下文保存下来，然后将G放到队列尾部，然后从队列中重新取出一个G进行调度。</p><p>除了每个P维护的G队列以外，还有一个全局的队列，每个P会周期性地查看全局队列中是否有G待运行并将其调度到M中执行，全局队列中G的来源，主要有从系统调用中恢复的G。之所以P会周期性地查看全局队列，也是为了防止全局队列中的G被饿死。</p><p>除了每个P维护的G队列以外，还有一个全局的队列，每个P会周期性地查看全局队列中是否有G待运行并将其调度到M中执行，全局队列中G的来源，主要有从系统调用中恢复的G。之所以P会周期性地查看全局队列，也是为了防止全局队列中的G被饿死。</p><h3 id="全局队列与公平性"><a href="#全局队列与公平性" class="headerlink" title="全局队列与公平性"></a>全局队列与公平性</h3><ul><li>由于在G1中创建的新协程会优先放到当前P上，因此容易发生<strong>P的runqueue满</strong>的情况，这种情况下会尝试将该P上的一部分G放到别的P上或者放到全局队列中</li><li>为了保证公平，当全局运行队列中有待执行的Goroutine 时，通过schedtick 保证有一定几率（1/61）会从<strong>全局的运行队列</strong>中查找对应的Goroutine</li><li>从处理器本地的运行队列中查找待执行的Goroutine</li><li>如果前两种方法都没有找到Goroutine，会通过runtime.findrunnable 进行阻塞地查找Goroutine，寻找的路径有以下几种，包括：<ol><li>从全局运行队列中查找。</li><li>从网络轮询器中查找是否有Goroutine 等待运行。</li><li>通过runtime.runqsteal 尝试从其他随机的处理器中<strong>窃取</strong>待运行的Goroutine。</li></ol></li></ul><p><img src="/posts/59192/v2-6191a82a67daafeea11387f7b8071b10_720w.png" alt></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="正常情况下"><a href="#正常情况下" class="headerlink" title="正常情况下"></a>正常情况下</h3><p>所有的goroutine运行在同一个M系统线程中，每一个M系统线程维护一个Processor，任何时刻，一个Processor中只有一个goroutine，其他goroutine在runqueue中等待。一个goroutine运行完自己的时间片后，让出上下文，回到runqueue中。 多核处理器的场景下，为了运行goroutines，每个M系统线程会持有一个Processor。</p><p><img src="/posts/59192/v2-cdea56998262fe18039da2832207bc45_720w.webp" alt></p><h3 id="协程创建与更替"><a href="#协程创建与更替" class="headerlink" title="协程创建与更替"></a>协程创建与更替</h3><p>P 拥有 G1，M1 获取 P 后开始运行 G1，G1 使用<code>go func()</code>创建了 G2，为了局部性 G2 优先加入到 P1 的本地队列。G1运行完之后会按照runqueue的顺序继续运行G2。</p><h3 id="协程阻塞"><a href="#协程阻塞" class="headerlink" title="协程阻塞"></a>协程阻塞</h3><p>当正在运行的goroutine（G0）阻塞的时候，例如进行系统调用，会再创建一个系统线程（M1)，当前的M0线程放弃了它的Processor（P），P转到新的线程中去运行。</p><p><img src="/posts/59192/v2-7c530372d59c05b633f10f64088f88cb_720w.webp" alt></p><h2 id="特殊的-M0-和-G0"><a href="#特殊的-M0-和-G0" class="headerlink" title="特殊的 M0 和 G0"></a><strong>特殊的 M0 和 G0</strong></h2><p><strong>M0</strong></p><p>M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量rutime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G，在之后M0就和其他的M一样了</p><p><strong>G0</strong></p><p>G0是每次启动一个M都会第一个创建的goroutine，G0仅用于负责调度G，G0不指向任何可执行的函数，每个M都会有一个自己的G0，在调度或系统调用时会使用G0的栈空间，全局变量的G0是M0的G0</p><p>那么一个G由于调度被中断，此后如何恢复？中断的时候将寄存器里的栈信息，保存到自己的G对象里面。当再次轮到自己执行时，将自己保存的栈信息复制到寄存器里面，这样就接着上次之后运行了。</p><p><a href="https://segmentfault.com/a/1190000021951119">延伸阅读</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Go调度器的详细调度过程是什么？&lt;/p&gt;
&lt;h2 id=&quot;GMP&quot;&gt;&lt;a href=&quot;#GMP&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Go" scheme="https://JoyTsing.github.io/categories/Go/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Go" scheme="https://JoyTsing.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>虚拟地址空间与编译链接</title>
    <link href="https://joytsing.github.io/posts/60390/"/>
    <id>https://joytsing.github.io/posts/60390/</id>
    <published>2024-04-18T16:04:23.000Z</published>
    <updated>2024-04-20T07:52:03.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>如果它存在，而且你能看见它，它是物理的（real）<br>如果它不存在，但你能看见它，它是虚拟的（virtual）<br>如果它存在，但你看不见它，它是透明的（transparent）</p></blockquote><h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p>虚拟地址空间和虚拟内存是两码子事，</p><blockquote><p>虚拟地址空间是一种内存管理技术，它允许程序以一种抽象的方式访问内存资源，从而实现对物理内存的高效管理。虚拟地址空间将物理内存抽象为一个连续的地址空间，使得每个进程都拥有自己独立的虚拟地址空间。操作系统负责管理虚拟地址到物理地址的映射。</p></blockquote><p><strong>在Linux中，虚拟地址空间通常分为两个区域：用户区域和内核区域。</strong></p><ul><li>用户区域： 用户区域包含了用户程序的代码、数据和堆栈等信息。具体包括以下部分：<ul><li>程序代码：存放编译后的可执行二进制代码，这部分内存区域是只读的，防止程序意外或恶意修改代码。</li><li>数据段：存放程序的全局变量和静态变量。</li><li>堆：用于存储程序运行时动态分配的内存。堆从低地址向高地址增长。</li><li>文件映射区(mmap)：存储映射到内存中的文件数据，如用于装载动态共享库、内存映射文件等。</li><li>栈：存放程序的局部变量、函数调用的参数和返回地址等信息。栈从高地址向低地址增长。</li><li>环境变量和命令行参数：存放传递给程序的环境变量和命令行参数。</li></ul></li><li>内核区域：内核区域是操作系统内核代码和数据的存储区域。用户进程无法直接访问这部分内存，只能通过系统调用与内核进行交互。内核空间包括以下部分：<ul><li>内核代码：操作系统内核的代码。</li><li>内核数据：操作系统的全局数据结构，如进程表、文件系统缓存等。</li><li>内核栈：为内核模式下的函数调用提供栈空间。</li><li>物理内存映射：将物理内存映射到内核虚拟地址空间，便于内核访问。</li><li>高速缓存：缓存一些常用的内核数据结构，提高访问速度。</li></ul></li></ul><p>用户空间和内核空间的主要区别在于访问权限和功能。用户空间主要用于存储用户程序的代码和数据，而内核空间则存放操作系统内核的代码和数据。用户空间的程序无法直接访问内核空间，只能通过系统调用与内核进行交互。这种设计有助于保护内核数据结构的完整性，避免用户程序意外或恶意破坏操作系统。</p><p>当计算机程序运行时，它需要访问一些内存，例如使用的变量或代码等。虚拟地址空间是一种使程序可以直接访问这些内存而不必真正了解这些内存在物理上所处的位置的技术。虚拟地址由处理器内存管理单元映射到实际物理地址。每个进程都有自己的独立虚拟地址空间，同时操作系统负责将每个进程的虚拟地址映射到主存中的物理内存地址。</p><p><img src="/posts/60390/238146a26c87497682fc47aac4e908cf.png" alt></p><p><strong>在32位Linux系统中，虚拟地址空间大小为4GB，分为内核空间和用户空间。以下是一个简要概述：</strong></p><ul><li><strong>内核空间</strong>（Kernel Space）：<ul><li><code>内核空间位于高地址段，通常在3GB到4GB之间</code>。这个区域存放内核代码和数据结构，如内存管理、进程管理、设备驱动等。这部分内存只能由内核模式下的代码访问。</li></ul></li><li><strong>用户空间</strong>（User Space）：<ul><li><code>用户空间位于低地址段，通常在0到3GB之间</code>。这个区域存放用户程序和相关数据结构。用户空间从高地址到低地址包含以下部分：<ul><li><strong>环境变量和命令行参数</strong>：位于用户空间的高地址部分。</li><li><strong>栈空间</strong>（Stack）：位于环境变量和命令行参数之下，用于存放函数调用栈、局部变量和返回地址等。</li><li><strong>动态链接库</strong>（Shared Libraries）：位于栈空间下方，存放动态链接的共享库。内存映射文件也会被加载到这个区域。</li><li><strong>堆空间</strong>（Heap）：位于动态链接库下方，用于存放动态分配的内存。堆空间在程序运行期间可以根据需要增长或缩小。</li><li><strong>未初始化数据段</strong>（BSS）、<strong>初始化数据段</strong>（Data）和<strong>代码段</strong>（Text）：位于堆空间下方，存放程序的全局变量、静态变量和程序代码。</li></ul></li></ul></li></ul><p><code>内存映射文件和动态链接库通常位于用户空间的共享库部分</code>。其中应该熟悉的区有这几个：</p><h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h3><p>   BSS(Block Started by Symbol)段中通常存放程序中以下符号：</p><ul><li><p>未初始化的全局变量和静态局部变量</p></li><li><p>初始值为0的全局变量和静态局部变量(依赖于编译器实现)</p></li><li><p>未定义且初值不为0的符号(该初值即common block的大小)</p><p> C语言中，未显式初始化的静态分配变量被初始化为0(算术类型)或空指针(指针类型)。由于程序加载时，BSS会被操作系统清零，所以未赋初值或初值为0的全局变量都在BSS中。BSS段仅为未初始化的静态分配变量预留位置，在目标文件中并不占据空间，这样可减少目标文件体积。但程序运行时需为变量分配内存空间，故目标文件必须记录所有未初始化的静态分配变量大小总和(通过start_bss和end_bss地址写入机器代码)。当加载器(loader)加载程序时，将为BSS段分配的内存初始化为0。在嵌入式软件中，进入main()函数之前BSS段被C运行时系统映射到初始化为全零的内存(效率较高)。</p><p> 注意，尽管均放置于BSS段，但初值为0的全局变量是强符号，而未初始化的全局变量是弱符号。若其他地方已定义同名的强符号(初值可能非0)，则弱符号与之链接时不会引起重定义错误，但运行时的初值可能并非期望值(会被强符号覆盖)。因此，定义全局变量时，若只有本文件使用，则尽量使用static关键字修饰；否则需要为全局变量定义赋初值(哪怕0值)，保证该变量为强符号，以便链接时发现变量名冲突，而不是被未知值覆盖。</p><p> 某些编译器将未初始化的全局变量保存在common段，链接时再将其放入BSS段。在编译阶段可通过-fno-common选项来禁止将未初始化的全局变量放入common段。</p><p> 此外，由于目标文件不含BSS段，故程序烧入存储器(Flash)后BSS段地址空间内容未知。U-Boot启动过程中<a href="http://blog.csdn.net/king_bingge/article/details/8741987">，</a>将U-Boot的Stage2代码(通常位于lib_xxxx/board.c文件)搬迁(拷贝)到SDRAM空间后必须人为添加清零BSS段的代码，而不可依赖于Stage2代码中变量定义时赋0值。</p></li></ul><blockquote><p>【扩展阅读】<strong>BSS历史</strong> </p><p>BSS(Block Started by Symbol，以符号开始的块)一词最初是UA-SAP汇编器(United Aircraft Symbolic Assembly Program)中的伪指令，用于为符号预留一块内存空间。该汇编器由美国联合航空公司于20世纪50年代中期为IBM 704大型机所开发。   后来该词被作为关键字引入到了IBM 709和7090/94机型上的标准汇编器FAP(Fortran Assembly Program)，用于定义符号并且为该符号预留指定字数的未初始化空间块。   在采用段式内存管理的架构中(如Intel 80x86系统)，BSS段通常指用来存放程序中未初始化全局变量的一块内存区域，该段变量只有名称和大小却没有值。程序开始时由系统初始化清零。   BSS段不包含数据，仅维护开始和结束地址，以便内存能在运行时被有效地清零。BSS所需的运行时空间由目标文件记录，但BSS并不占用目标文件内的实际空间，即BSS节段应用程序的二进制映象文件中并不存在。</p></blockquote><h3 id="Data段"><a href="#Data段" class="headerlink" title="Data段"></a>Data段</h3><p>   数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态局部变量。数据段属于静态内存分配(静态存储区)，可读可写。</p><p>   数据段保存在目标文件中(在嵌入式系统里一般固化在镜像文件中)，其内容由程序初始化。例如，对于全局变量int gVar = 10，必须在目标文件数据段中保存10这个数据，然后在程序加载时复制到相应的内存。</p><p>   数据段与BSS段的区别如下： </p><p>1) BSS段不占用物理文件尺寸，但占用内存空间；数据段占用物理文件，也占用内存空间。</p><p>   对于大型数组如int ar0[10000] = {1, 2, 3, …}和int ar1[10000]，ar1放在BSS段，只记录共有10000*4个字节需要初始化为0，而不是像ar0那样记录每个数据1、2、3…，此时BSS为目标文件所节省的磁盘空间相当可观。</p><p>2) 当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。</p><p>   运行时数据段和BSS段的整个区段通常称为数据区。某些资料中“数据段”指代数据段 + BSS段 + 堆。</p><h3 id="text段"><a href="#text段" class="headerlink" title="text段"></a>text段</h3><p>   代码段也称正文段或文本段，通常用于存放程序执行代码(即CPU执行的机器指令)。一般C语言执行语句都编译成机器代码保存在代码段。通常代码段是可共享的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可。代码段通常属于只读，以防止其他程序意外地修改其指令(对该段的写操作将导致段错误)。某些架构也允许代码段为可写，即允许修改程序。</p><p>   代码段指令根据程序设计流程依次执行，对于顺序指令，只会执行一次(每个进程)；若有反复，则需使用跳转指令；若进行递归，则需要借助栈来实现。</p><p>   代码段指令中包括操作码和操作对象(或对象地址引用)。若操作对象是立即数(具体数值)，将直接包含在代码中；若是局部数据，将在栈区分配空间，然后引用该数据地址；若位于BSS段和数据段，同样引用该数据地址。</p><p>   代码段最容易受优化措施影响。</p><h3 id="段和节"><a href="#段和节" class="headerlink" title="段和节"></a>段和节</h3><p>段是程序执行的必要组成部分，在每一个段中，会有着代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。节头对于程序的执行来说不是必需的，没有节头表，程序仍可以正常执行，因为节头表没有对程序的内存布局进行描述，对程序内存布局的描述是程序头表的任务。节头是对程序头的补充。</p><p>如果二进制文件中缺少节头，并不意味着节不存在，只是没有办法通过节头来引用节，对于调试器或者反编译器程序来说，只是可以参考的信息变少了而已。</p><p><img src="/posts/60390/640.webp" alt></p><p>保留区的上边就是代码段和数据段，它们是从程序的二进制文件中直接加载进内存中的，BSS 段中的数据也存在于二进制文件中，因为内核知道这些数据是没有初值的，所以在二进制文件中只会记录 BSS 段的大小，在加载进内存时会生成一段 0 填充的内存空间。</p><p>堆空间的上边是一段待分配区域，用于扩展堆空间的使用。接下来就来到了文件映射与匿名映射区域。进程运行时所依赖的动态链接库中的代码段，数据段，BSS 段就加载在这里。还有我们调用 mmap 映射出来的一段虚拟内存空间也保存在这个区域。<strong>注意：在文件映射与匿名映射区的地址增长方向是从高地址向低地址增长</strong>。</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328">推荐阅读</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;如果它存在，而且你能看见它，它是物理的（real）&lt;br&gt;如果它不存在，但你能看见它，它是虚拟的（virtual）
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/categories/Linux/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="https://JoyTsing.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>mmap,比想象的更重要一点</title>
    <link href="https://joytsing.github.io/posts/30090/"/>
    <id>https://joytsing.github.io/posts/30090/</id>
    <published>2024-04-18T15:42:56.000Z</published>
    <updated>2024-04-18T16:08:28.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、mmap基础概念"><a href="#1、mmap基础概念" class="headerlink" title="1、mmap基础概念"></a>1、mmap基础概念</h2><p>mmap 是一种内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一映射关系。</p><p>实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必调用read,write等系统调用函数。相反，内核空间的这段区域的修改也直接反应用户空间，从而可以实现不同进程的文件共享。如下图所示：</p><p><img src="/posts/30090/640.webp" alt></p><p>由上图可以看出，进程的<strong>虚拟地址空间</strong>，由多个<strong>虚拟内存</strong>区域构成。<strong>虚拟内存区域是进程的虚拟地址空间中的一个同质区间</strong>，即具有同样特性的连续地址范围。上图中所示的<code>.text数据段</code>、<code>初始数据段</code>、<code>.bss数据段</code>、堆、栈、内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。</p><p>linux 内核使用的<code>vm_area_struct</code> 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制不同；因此同一个进程使用多个<code>vm_area_struct</code>结构来分别表示不同类型的虚拟内存区域。各个<code>vm_area_struct</code> 结构使用链表或者树形结构链接，方便进程快速访问。如下图所示：</p><p><img src="/posts/30090/640-1713455374225-1.webp" alt></p><p><code>vm_area_struct</code> 结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个vm_ops 指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作都需要的信息，都可以从<code>vm_area_struct</code> 中获得。mmap函数就是要创建一个新的<code>vm_area_struct</code>结构 ，并将其与文件的物理磁盘地址相连。具体步骤如下：</p><h2 id="2、mmap-内存映射原理"><a href="#2、mmap-内存映射原理" class="headerlink" title="2、mmap 内存映射原理"></a>2、mmap 内存映射原理</h2><p>mmap 内存映射实现过程，总的来说可以分为三个阶段：</p><p>（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</p><p>1、进程在用户空间调用函数mmap ，原型：<code>void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</code></p><p>2、在当前进程虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p><p>3、为此虚拟区分配一个<code>vm_area_struct</code> 结构，接着对这个结构各个区域进行初始化</p><p>4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中</p><p>（二）调用内核空间的系统调用函数<strong>mmap</strong> （不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</p><p>5、为映射分配新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文集”中该文件结构体，每个文件结构体维护者和这个已经打开文件相关各项信息。</p><p>6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。</p><p>7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p><p>8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</p><p>（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。</p><p>前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据拷贝至主存。真正的文件读取是当进程发起读或者写操作时。</p><p>9、进程的读写操作访问虚拟地址空间这一段映射地址后，通过查询页表，先这一段地址并不在物理页面。因为目前只建立了映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p><p>10、缺页异常进行一系列判断，确定无法操作后，内核发起请求掉页过程。</p><p>11、调页过程先在交换缓存空间中寻找需要访问的内存页，，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p><p>12、之后进程即可对这片主存进行读或者写的操作了，如果写操作改变了内容，一定时间后系统自动回写脏页面到对应的磁盘地址，也即完成了写入到文件的过程。</p><p>注：修改过的脏页面并不会立即更新回文件，而是有一段时间延迟，可以调用msync() 来强制同步，这样所写的内容就能立即保存到文件里了。</p><h2 id="3、mmap和常规文件操作的区别"><a href="#3、mmap和常规文件操作的区别" class="headerlink" title="3、mmap和常规文件操作的区别"></a>3、mmap和常规文件操作的区别</h2><p>首先我们来回顾一下常规文件操作，函数的调用过程：</p><p>1、进程发起读文件请求</p><p>2、内核通过查找进程文件符表。</p><p>3、inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p><p>总的来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制，这样造成了读文件时需要先将文件页从磁盘拷贝到缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对用的用户空间中。这样通过两次拷贝过程，才能完成进程对文件内容的获取。写操作也一样，待写入的Buffer在内核空间不能直接访问，必须先拷贝到内核空间对应的主存，再回写磁盘中，也是需要两次数据拷贝。</p><p>而使用mmap 操作文件中，创建新的虚拟内存区域、建立文件磁盘地址和内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时，发现内存中并无数据而发起的缺失页异常过程，可以通过建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供过程使用。</p><p><strong>总而言之，常规的文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝，而mmap操作文件，只需要从磁盘到用户主存的一次数据拷贝过程。</strong>说白了，mmap的关键点是实现了用户空间和内核的数据直接交互省去了空间不同数据不通的繁琐过程。因此 mmap效率更高。</p><h3 id="mmap优点总结"><a href="#mmap优点总结" class="headerlink" title="mmap优点总结"></a>mmap优点总结</h3><p>由上文讨论可知，mmap 优点共有以下几点：</p><ol><li>对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代了I/O读写，提高了读取的效率。</li><li>实现了用户空间和内核空间的高校交互方式，两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</li><li>提供进程间共享内存及互相通信的方式。不管是父子进程还是无亲缘关系进程，都可以将自身空间用户映射到同一个文件或者匿名映射到同一片区域。从而通过各自映射区域的改动，打到进程间通信和进程间共享的目的。同时，如果进程A和进程 B 都映射了区域C,当A第一次读取C时候，通过缺页从磁盘复制文件页到内存中，但当B再读C的相同页面时，虽然也会产生缺页异常，但是不会从磁盘中复制文件过来，而是直接使用已经保存再内存中的文件数据。</li><li>可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助于硬盘空间的协助，补充内存的不足。但是进一步造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡需要磁盘空间代替内存的时候，mmap都可以发挥功效。</li></ol><h3 id="mmap使用细节"><a href="#mmap使用细节" class="headerlink" title="mmap使用细节"></a>mmap使用细节</h3><p>使用mmap需要注意一点，mmap映射区域大小必须是物理页大小（page_size）的整数倍，原因是：内存的最小粒度是页，而进程虚拟地址空间和内存的映射单位也是以页为单位，为了匹配内存操作，mmap从磁盘到虚拟地址空间的映射也必须是页。</p><p>内核可以跟踪被内存映射的底层对象，大小。就是说，如果文件的大小一直再扩张，只要再映射区域范围内的数据，进程都可以依法得到，这和映射建立时文件的大小无关。</p><p>映射建立后，即使文件关闭，映射依然存在。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关，同时可用于进程间通信的有效地址空间，不完全受限于被映射文件的大小，因为是按页映射。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、mmap基础概念&quot;&gt;&lt;a href=&quot;#1、mmap基础概念&quot; class=&quot;headerlink&quot; title=&quot;1、mmap基础概念&quot;&gt;&lt;/a&gt;1、mmap基础概念&lt;/h2&gt;&lt;p&gt;mmap 是一种内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/categories/Linux/"/>
    
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中move的原理</title>
    <link href="https://joytsing.github.io/posts/1343/"/>
    <id>https://joytsing.github.io/posts/1343/</id>
    <published>2024-04-16T01:12:07.000Z</published>
    <updated>2024-04-16T02:27:14.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>怎么用就不多说了，也不扯语言学家的问题，主要来研究一下实现原理是什么？</p><h2 id="移动不移动"><a href="#移动不移动" class="headerlink" title="移动不移动"></a>移动不移动</h2><p>正如完美转发不完美。</p><p>右值引用本身其实就是一个栈上的普通变量，它是 <strong>lvalue</strong>。而使用右值引用做函数参数是为了优先匹配直接传入函数返回值的情况，从而跟常引用做参数来进行区分。通常情况下，用右值引用接收一个对象，是为了复用它的资源，来进行浅复制的。就好像，我们把原本的资源「移动」到了新的对象当中去，因此称之为「移动语义」。含有移动语义的构造函数就称为「移动构造函数」、含有移动语义的赋值函数就称为「移动赋值函数」。所以大家一定要清楚，这里的「移动」是「语义」上的，并没有真的移动，一般就是用来做浅复制的。</p><p><code>std::move</code>就是帮助我们做一件事情，即在构造一个变量（或者其他情况）的时候不使用拷贝构造而是使用移动构造。我们已经知道，如果想进行移动语义，那么就需要用右值引用来接收。但目前我们要操作的值是一个左值（不然也就不存在需要移动的情况），那么如何让编译器知道我们要进行的操作？让它当作右值来处理，因为就像上文说的，移动不移动，又不会真的去 check 入参的左右性。</p><p>以下面的代码为例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  String str1<span class="token punctuation">;</span>  String str2 <span class="token operator">=</span> str1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里会调用拷贝构造，因为str1是左值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要把这个 str1，伪装成右值，骗过编译器去触发右值引用的重载函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  String str1<span class="token punctuation">;</span>  String str2 <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>String <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 强制转成右值引用，去触发移动构造函数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的=号不是赋值的等号，而是构造参数的语法糖，即等价于：</p><pre class="line-numbers language-cpp"><code class="language-cpp">String <span class="token function">str2</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>String <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 构造参数，所以是用来匹配函数参数的</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么<code>std::move</code>怎么实现的大概大家就有个数了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">constexpr</span> std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;&amp;</span><span class="token function">move</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span>ref<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一定一定要把握一个原则，<code>std::move</code><strong>的本质是为了伪装，它并不能改变变量的左右性。</strong>也就是说，<code>std::move(str1)</code>并不能把 str 变成 rvalue，它本身是个变量，那么它就是 <strong>lvalue</strong>，一直都是。move 的作用仅仅在于，构造 str2 的时候能触发移动构造函数，仅此而已，其他的什么都没变。</p><p>那么也就是说，尽管我们用了「移动语义」来构造了 str2，但其实 str1 还是存在的，该是什么样还是什么样，并不会真的被「移动」。而此时的 str2 是 str1 的浅复制版本，原本的话它们的 buf_ 会指向同一片空间的，但因为我们在移动构造函数中强制把原来的对象 buf_ 给置空了，因此这里 str1 内部会出现空指针。所以这里有一次印证了「移动语义是软约束」这件事，使用之后行为如何，会不会出问题，完全取决代码怎么写。</p><h3 id="一些实现细节"><a href="#一些实现细节" class="headerlink" title="一些实现细节"></a>一些实现细节</h3><p>理解 std::move() 需要明白如下几点：</p><p>（1）引用折叠</p><ul><li>间接创建（只能间接，如类型别名或模板参数，语法不支持直接创建）引用的引用，这些引用会形成“折叠”</li><li>T&amp; &amp;、T&amp; &amp;&amp;、T&amp;&amp; &amp; 都会折叠成左值引用 T&amp;</li><li>T&amp;&amp; &amp;&amp; 折叠成右值引用 T&amp;&amp;</li></ul><p>（2）模板右值引用参数</p><ul><li>模板函数形参类型是 T&amp;&amp;，而实参是一个左值，推断出的模板实参类型将是 T&amp;，且函数参数将被实例化一个普通的左值引用参数 T&amp;</li><li>模板函数形参类型是 T&amp;&amp;，而实参是一个右值，推断出的模板实参类型将是 T，且函数参数将被实例化一个普通参数 T</li></ul><p>（3）从一个左值 static_cast 到一个右值引用是允许的，而static_cast之所以能使用类型转换，是通过<code>remove_refrence::type</code>模板移除T&amp;&amp;，T&amp;的引用，获取具体类型T</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//原始的，最通用的版本</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">struct</span> remove_reference<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义T的类型别名为type</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//部分版本特例化，将用于左值引用和右值引用</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">struct</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&amp;</span><span class="token operator">></span> <span class="token comment" spellcheck="true">//左值引用</span><span class="token punctuation">{</span> <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">struct</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span> <span class="token comment" spellcheck="true">//右值引用</span><span class="token punctuation">{</span> <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//举例如下,下列定义的a、b、c三个变量都是int类型</span><span class="token keyword">int</span> i<span class="token punctuation">;</span>remove_refrence<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type a<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//使用原版本，</span>remove_refrence<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type  b<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//左值引用特例版本</span>remove_refrence<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type  b<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//右值引用特例版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;怎么用就不多说了，也不扯语言学家的问题，主要来研究一下实现原理是什么？&lt;/p&gt;
&lt;h2 id=&quot;移动不移动&quot;&gt;&lt;a href=&quot;#移动不移动
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="原理剖析" scheme="https://JoyTsing.github.io/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>人祖传小故事一则</title>
    <link href="https://joytsing.github.io/posts/16525/"/>
    <id>https://joytsing.github.io/posts/16525/</id>
    <published>2024-04-16T00:48:23.000Z</published>
    <updated>2024-04-16T00:54:05.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>看小说看到的，感触很大。</p><p>“一个人的坚持有多难？”</p><p>“一定要坚持啊，方源。”</p><p>“活下去，坚持下去。”</p><p>“这是我对你的忠告，唯一的礼物。咱们这种小人物，哭是没有用的，喊也是没人听，只能自己坚持。”</p><p>“坚持下去，直至成就伟大，脱离平凡，或者迎接死亡。“</p><h2 id="人祖传第二十九节-坚持蛊"><a href="#人祖传第二十九节-坚持蛊" class="headerlink" title="人祖传第二十九节-坚持蛊"></a>人祖传第二十九节-坚持蛊</h2><p>人祖的女儿森海轮回，被困在了平凡深渊当中。</p><p>她和一位小人交上了朋友，然后小人带着森海轮回，观看了他的家园——市井。</p><p>森海轮回观看了市井之后，忽然仰头看向天空。</p><p>“我明白了。”森海轮回望着自己的头顶。</p><p>她被困在平凡深渊当中，其实和生活在井底的小人是一样的。小人仰头，看向井口描绘的天空，无异于森海轮回仰头，看向平凡深渊勾勒出来的天空。</p><p>“我决定了，我要自己努力，走出这处深渊，和父亲汇合！”森海轮回捏起双拳，下定了决心。</p><p>小人很高兴：“好啊。我也想离开平凡深渊，看看更大更辽阔的世界。我看到深渊里有不少树木，我们可以将这些树木都砍了，做成梯子，然后一步步地爬出去。”</p><p>森海轮回咦了一声，奇怪地看向小人：“小人啊，小人，你不是长着一对翅膀的吗？为什么不能直接飞走呢？”</p><p>小人苦笑道：“人啊，别看我有这么一对翅膀，其实它薄弱而且无力，只能带动我的身体缓缓地飞一小段距离。我当初离开市井，也是搭梯子爬出来的。”</p><p>“原来是这样啊。”森海轮回恍然大悟。</p><p>接下来的日子里，她便和小人一起，砍伐树木，搭建梯子。</p><p>一棵棵树木倒下来，飞出智慧蛊。</p><p>森海轮回感到很惊讶：“智慧蛊，你怎么在这里？”</p><p>“平凡中隐藏着智慧，我当然能在这里。”智慧蛊答道。</p><p>然后智慧蛊又说：“你们很聪明嘛，懂得运用前人的成就，来帮助自己脱离平凡。但是你们两个想要走出平凡深渊，必须每一个人都搭自己的梯子，整个过程独自完成，否则的话，你们是走不出去的。”</p><p>森海轮回连忙点头：“智慧蛊啊，谢谢你的提醒，我们会注意的。”</p><p>她和小人分别做自己的梯子。</p><p>梯子越做越高，很快，森海轮回的梯子就超越了小人。</p><p>小人的梯子又矮又小，每一个横杆之间，间距也短。</p><p>一比较起来，森海轮回的梯子，又长又高。</p><p>森海轮回就取笑小人：“小人啊小人，我耗费半天时间做出来的梯子，就抵得上你半个月的功夫了。你这样做，何年何月才能做出一个高高的梯子，让你踩着，走出平凡深渊啊？”</p><p>小人无奈地道：“我也没有办法啊。我已经用尽了全力，可是我耗费半天时间，扛过来的木条。你用一只手，就能拿过来一捆。我辛苦好久才能砍断的小树，你两三下就能砍倒。我已经拼尽了全力，只能达到这种程度了。”</p><p>森海轮回点点头：“可惜了，我们只能各自做自己的梯子。”</p><p>小人道：“没错，脱离平凡深渊，可以依赖前人的成就，但是真正依靠的，只有自己。咱们继续加油努力吧。”</p><p>森海轮回和小人便继续伐树，做成梯子。</p><p>树木一棵棵的倒下来，从中又飞出了力量蛊。</p><p>森海轮回感到很惊讶：“力量蛊啊，你怎么在这里？”</p><p>“平凡中潜藏着力量，我当然能在这里。”力量蛊答道。</p><p>森海轮回想了想，问道：“力量蛊啊，你有什么可以指点我的呢？就像智慧蛊那样。”</p><p>力量蛊说：“我没有什么可以指点你的。但是我可以赋予你更强大的力量，只要你奉献出你的青年就可以了。”</p><p>森海轮回陷入犹豫当中。</p><p>力量蛊又道：“按照你现在的力量，什么时候才能搭建出足够高的梯子，走出平凡深渊呢？”</p><p>森海轮回想了想：“时间很长，需要二三十年。”</p><p>力量蛊道：“是啊，那个时候你已经不再年轻，失去了青年，到了中年。与其这样，你不如将青年交给我，虽然你会直接步入中年，但你只需要几年的时间，就能搭建好梯子了。”</p><p>森海轮回一想，点点头：“你说的太对了，力量蛊，就依你吧。”</p><p>于是森海轮回拥有了力量蛊，她建立梯子的速度变得更快了，一次能砍伐的树木更多了。一年之后，她将梯子搭到了很高很高的地方。</p><p>她走在梯子的最高处，往下看。</p><p>她看到树木变得很小，草都化为了一片绿色，很开心：“原来站在高处，平日里很大的东西，都变得很小了。就像我之前看市井一样。”</p><p>她再看一旁，小人搭建的梯子，很矮小，连她的梯子的百分之一都不如，不由地撇撇嘴。</p><p>森海轮回便走下梯子，对小人说：“你怎么才搭建了这么点高度啊，你看我的梯子已经有这么高了！”</p><p>小人仰望着她的梯子，十分崇拜，又十分无奈：“你真是让我羡慕啊，自身的力量就超越了我，现在又有力量蛊帮忙。可惜我什么帮手都没有，只有靠自己。我已经尽力了，每天除了休息和吃饭，我都用来搭建自己的梯子，可是根本比不上你啊。”</p><p>森海轮回点点头：“那是当然的。”</p><p>又一年过去了。</p><p>森海轮回又将梯子搭建得更高。</p><p>她站在最顶端，往下看。</p><p>树木变得跟小草一样，比树更小的东西，她都有点看不清了。</p><p>她再看小人搭建的梯子，虽然它比一般的树更高，但连森海轮回梯子的千分之一都没有。</p><p>森海轮回走下梯子，笑着对小人说：“小人啊小人，我劝你不要费劲了吧。你的力量太小太小，恐怕花费一生的时间，都搭建不了那样的梯子出来。你还不如用这个时间，好好享受一下生活。”</p><p>“其实你已经足够优秀啦，你比你的那些小人同胞见识更广，你已经走出了市井。不如好好地享受一下生活。”</p><p>小人认真地想了想，然后摇摇头：“可是我已经不满足平凡了。当我不满足平凡之后，平凡对我而言就是一座深渊，我想走出去。即便最终不成功，但我也想要努力。因为我如果不努力，我就感到活得不开心。”</p><p>于是，小人继续搭建他的梯子。</p><p>第三年过去了。</p><p>森海轮回再次将梯子建得非常高。</p><p>她站在最顶端，往下看。</p><p>只看到一片片的云和雾，遮蔽了她的视野。</p><p>她想看小人建的梯子，勉勉强强看到了，发现他的梯子和自己相比，连万分之一都不如。</p><p>森海轮回叹息一声，感到了孤独。</p><p>风一吹，她浑身一颤，又感到了寒冷。</p><p>“原来站在高处，不仅孤独，而且寒冷呐。”森海轮回走下了梯子，将这个感受告诉了小人。</p><p>小人摇头道：“我的梯子还不够高，不知道你这种是什么样的感觉。”</p><p>森海轮回感到很无趣。</p><p>她仍旧继续搭建梯子，但是每天耗费在这里的时间，越来越少。</p><p>力量蛊偶尔问她道：“人啊，你怎么不去搭建你的梯子呢？”</p><p>森海轮回便回答道：“梯子太高了，太寒冷，我得好好歇一歇，让身体回暖。”</p><p>就这样一年过去了。</p><p>森海轮回感到很无聊。</p><p>她继续搭建自己的梯子，只是每天努力的时间更少了。</p><p>力量蛊偶然的时候问她：“人啊，你怎么不去搭建你的梯子呢？”</p><p>森海轮回回答道：“梯子太高了，我每一次往下看，都感到有些害怕。我得充分休息，让自己的心平静下来。”</p><p>再一年过去。</p><p>森海轮回变得更加懒散。</p><p>力量蛊问她：“你看你身边的小人，他总是在搭建自己的梯子，从没有懈怠过，拼尽全力。你再这样懒散下去，迟早有一天会被她超越的。”</p><p>森海轮回笑道：“怎么可能？我一天的时间，能抵他辛辛苦苦一个月。我怎么可能被他超越呢？”</p><p>就这样年复一年，日复一日。</p><p>终于有一天，小人找到躺在树荫下休息的森海轮回，对她道：“我的朋友啊，我的梯子已经够上了深渊的崖边，我明天就可以出去，离开平凡深渊了。”</p><p>森海轮回哈哈大笑：“小人啊，你不要骗我了，这种话太可笑。”</p><p>小人摇摇头，认真地道：“伟大和可笑，只是一点点的差距。现在我已经不可笑了，我已经变得伟大，可以脱离这个平凡深渊了。你不相信的话，就看我爬出去吧。”</p><p>于是，小人开始爬他的梯子。</p><p>森海轮回这才吃惊地看到，小人的梯子真的已经搭上了崖边，他就真的这样爬上去，渐渐要离开平凡深渊。</p><p>森海轮回大叫：“小人啊，难道你没有感受到寒冷吗？”</p><p>小人说：“有啊，但我要搭梯子，想要爬出去。”</p><p>森海轮回又大叫：“小人啊，难道没有感到孤独吗？”</p><p>小人说：“有啊，但我要搭梯子，想要爬出去。”</p><p>森海轮回再大叫：“小人啊，难道没有感到害怕吗？”</p><p>小人说：“有啊，但我要搭梯子，想要爬出去。”</p><p>小人答完这三句话后，忽然他的身体绽放出了耀眼的光辉，很快光辉变成了一只蛊虫。</p><p>“我的名字叫做坚持，小人啊，谢谢你孵育了我。”坚持蛊向小人道谢。</p><p>小人笑道：“太好了，我虽然没有力量，但我有坚持。”</p><p>小人说着，爬出了平凡深渊，踏足外面的世界。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;看小说看到的，感触很大。&lt;/p&gt;
&lt;p&gt;“一个人的坚持有多难？”&lt;/p&gt;
&lt;p&gt;“一定要坚持啊，方源。”&lt;/p&gt;
&lt;p&gt;“活下去，坚持下去。
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中新时代格式化输出方法</title>
    <link href="https://joytsing.github.io/posts/17315/"/>
    <id>https://joytsing.github.io/posts/17315/</id>
    <published>2024-04-15T13:44:57.000Z</published>
    <updated>2024-04-15T14:20:53.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>别的语言早就有的东西，积重难返的C++总是晚了很多年才有，在这之前搞了很多格式化方案，直到C++20才大刀阔斧改掉。</p><p><img src="/posts/17315/image-20240415215042243.png" alt></p><h2 id="Formatting"><a href="#Formatting" class="headerlink" title="Formatting"></a>Formatting</h2><p>最基础的格式化函数 format 开始，其定义是这样:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>std<span class="token operator">::</span>string <span class="token function">format</span><span class="token punctuation">(</span>std<span class="token operator">::</span>format_string<span class="token operator">&lt;</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> fmt<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一个参数是格式化字符串，描述文本格式，后续参数就是需要被格式化的其他参数。C++20 在 C++11 的基础上，为 chrono 库提供了完善的 format 支持，我们再也不需要使用旧的 C 风格时间格式化函数了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 使用 std::chrono 来打印日志的时间</span><span class="token keyword">using</span> TimePoint <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>time_point<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里简单说明一下 format 的格式化字符串格式。格式化字符串由以下三类元素组成。</p><ul><li>普通字符（除了 { 和 } 以外），这些字符会被直接拷贝到输出中，不会做任何更改。</li><li>转义序列，包括 ，在输出中分别会被替换成{和}。</li><li>替换字段，由 { … } 构成，这些替换字段会替换成 format 后续参数中对应的参数，并根据格式控制描述生成输出。</li></ul><p>对于替换字段的两种形式:</p><p><img src="/posts/17315/image-20240415215439722.png" alt></p><p>除了最简单的 format 参数，C++20 还提供了三个有用的工具函数，作为扩展功能: 1. <code>format_to</code> 2.<code>format_to_n</code> 3. <code>formatted_size</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;format></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// format_to</span>    <span class="token comment" spellcheck="true">// 将生成的文本输出到一个输出迭代器中，</span>    <span class="token comment" spellcheck="true">// 其他与format一致，这样可以兼容标准STL算法函数的风格，</span>    <span class="token comment" spellcheck="true">// 也便于将文本输出到其他的流中或者自建的字符串类中。</span>    std<span class="token operator">::</span>string resultLine1<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">format_to</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>resultLine1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"{} + {} = {}"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> resultLine1 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// format_to_n</span>    <span class="token comment" spellcheck="true">// 将生成的文本输出到一个输出迭代器中，同时指定输出的最大字符数量。</span>    <span class="token comment" spellcheck="true">// 其他与format一致，相当于format_to的扩展版本，</span>    <span class="token comment" spellcheck="true">// 在输出目标有字符限制的时候非常有效。</span>    std<span class="token operator">::</span>string <span class="token function">resultLine2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">format_to_n</span><span class="token punctuation">(</span>resultLine2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"{} + {} = {}"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> resultLine2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// formatted_sizes</span>    <span class="token comment" spellcheck="true">// 获取生成文本的长度，参数与format完全一致。</span>    <span class="token keyword">auto</span> resultSize <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">formatted_size</span><span class="token punctuation">(</span><span class="token string">"{} + {} = {}"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> resultSize <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>string <span class="token function">resultLine3</span><span class="token punctuation">(</span>resultSize<span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">format_to</span><span class="token punctuation">(</span>resultLine3<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"{} + {} = {}"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> resultLine3 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="格式化参数包"><a href="#格式化参数包" class="headerlink" title="格式化参数包"></a>格式化参数包</h3><p>format 函数，可以直接以函数参数形式进行传递。此外，C++20 还提供了 format_args 相关接口，可以把“待格式化的参数”合并成一个集合，通过 vformat 函数进行文本格式化。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;format></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdint></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string resultLine1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">vformat</span><span class="token punctuation">(</span><span class="token string">"{} * {} = {}"</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">make_format_args</span><span class="token punctuation">(</span>        <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">4</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> resultLine1 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>format_args args <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">make_format_args</span><span class="token punctuation">(</span>        <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">4</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>string resultLine2<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">vformat_to</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>resultLine2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"{} * {} = {}"</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> resultLine2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对上述代码中用到的类型和函数:</p><ul><li><strong>第一，format_args 类型</strong>，表示一个待格式化的参数集合，可以包装任意类型的待格式化参数。这里需要注意的是 format_args 中包装的参数是引用语义，也就是并不会拷贝或者扩展包装参数的生命周期，所以开发者需要确保被包装参数的生命周期。所以一般来说，format_args 也就用于格式化函数的参数，不建议用于其他用途。</li><li><strong>第二，make_format_args 函数</strong>，用于通过一系列参数构建一个 format_args 对象。类似地，需要注意返回的 format_args 的引用语义。</li><li><strong>第三，vformat 函数</strong>。包含两个参数，分别是格式化字符串（具体规范与 format 函数完全一致）和 format_args 对象。该函数会根据格式化字符串定义去 format_args 对象中获取相关参数并进行格式化输出，其他与 format 函数没有差异。</li><li><strong>第四，vformat_to 函数</strong>。该函数与 format_to 类似，都是通过一个输出迭代器进行输出的。差异在于，该函数接收的“待格式化参数”，需要通过 format_args 对象进行包装。因此，vformat 可以在某些场景下替代 format。至于具体使用哪个，你可以根据自己的喜好进行选择。</li></ul><h3 id="formatting"><a href="#formatting" class="headerlink" title="formatting"></a>formatting</h3><p>Formatting 库的核心是 formatter 类，对于所有希望使用 format 进行格式化的参数类型来说，都需要按照约定实现 formatter 类的特化版本。</p><p>formatter 类主要完成的工作就是：格式化字符串的解析、数据的实际格式化输出。C++20 为基础类型与 string 类型定义了标准的 formatter。此外，我们还可以通过特化的 formatter 来实现其他类型、自定义类型的格式化输出。</p><h2 id="标准格式化规范"><a href="#标准格式化规范" class="headerlink" title="标准格式化规范"></a>标准格式化规范</h2><p>C++ Formatting 的标准格式化规范，是以 Python 的格式化规范为基础的。基本语法:</p><pre><code>填充与对齐   符号   #   0   宽度   精度L   类型</code></pre><p>这里的每个参数都是可选参数。</p><h3 id="填充与对齐"><a href="#填充与对齐" class="headerlink" title="填充与对齐"></a>填充与对齐</h3><p>第一个为填充与对齐，用于设置填充字符与对齐规则。</p><p>该参数包含两部分，第一部分为填充字符，如果没有设定，默认使用空格作为填充。第二部分为填充数量与对齐方式，填充数量就是指定输出的填充字符数量，对齐方式指的是待格式化参数输出时相对于填充字符的位置。</p><p>目前 C++ 支持三种对齐方式：</p><p><img src="/posts/17315/image-20240415220500132.png" alt></p><h3 id="符号前缀显示"><a href="#符号前缀显示" class="headerlink" title="符号前缀显示"></a>符号前缀显示</h3><p>“符号” “#” 和“0”，用于设定数值类型的前缀显示方式。</p><p><strong>“符号”可以设置数字前缀的正负号显示规则。</strong>需要注意的是，“符号”也会影响 inf 和 nan 的显示方式。</p><p><img src="/posts/17315/image-20240415220544677.png" alt></p><p><strong>“#” 会对整数和浮点数有不同显示行为。</strong></p><p>如果被格式化参数为整数，并且将整数输出设定为二进制、八进制或十六进制时会在数字前添加进制前缀，也就是 0b、0 和 0x。 如果被格式化参数为浮点数，那么即使浮点数没有小数位数，也会强制在数字后面追加一个小数点。</p><p><strong>“0” 用于为数值输出填充 0，并支持设置填充位数。</strong>比如 04 就会填充 4 个 0。</p><h3 id="宽度与精度"><a href="#宽度与精度" class="headerlink" title="宽度与精度"></a>宽度与精度</h3><p>宽度用于设置字段输出的最小宽度，可以使用一个十进制数，也可以通过 {} 引用一个参数。</p><p>精度是一个以 . 符号开头的非负十进制数，也可以通过{}引用一个参数。对于浮点数，该字段可以设置小数点的显示位数。对于字符串，可以限制字符串的字符输出数量。</p><p>宽度与精度都支持通过 {} 引用参数，此时如果参数不是一个非负整数，在执行 format 时就会抛出异常。</p><h3 id="L-与类型"><a href="#L-与类型" class="headerlink" title="L 与类型"></a>L 与类型</h3><p>L 用于指定参数以特定语言环境（locale）方式输出参数，类型选项用于设置参数的显示方式。</p><p><img src="/posts/17315/image-20240415220757769.png" alt></p><h2 id="自定义-formatter"><a href="#自定义-formatter" class="headerlink" title="自定义 formatter"></a>自定义 formatter</h2><p>Formatting 库中的 formatter 类型对各种类型的格式化输出毕竟是有限的——它不可能覆盖所有的场景，特别是我们的自定义类型。我们先看一个最简单的自定义 formatter 案例。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;format></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdint></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">CharT</span><span class="token operator">></span><span class="token keyword">struct</span> std<span class="token operator">::</span>formatter<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>int32_t<span class="token operator">></span><span class="token punctuation">,</span> CharT<span class="token operator">></span> <span class="token operator">:</span> std<span class="token operator">::</span>formatter<span class="token operator">&lt;</span>int32_t<span class="token punctuation">,</span> CharT<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">FormatContext</span><span class="token operator">></span>    <span class="token keyword">auto</span> <span class="token function">format</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>int32_t<span class="token operator">></span> t<span class="token punctuation">,</span> FormatContext<span class="token operator">&amp;</span> fc<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span>formatter<span class="token operator">&lt;</span>int32_t<span class="token punctuation">,</span> CharT<span class="token operator">></span><span class="token operator">::</span><span class="token function">format</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int32_t v <span class="token operator">:</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">*</span>it <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">;</span>            it<span class="token operator">++</span><span class="token punctuation">;</span>            it <span class="token operator">=</span> std<span class="token operator">::</span>formatter<span class="token operator">&lt;</span>int32_t<span class="token punctuation">,</span> CharT<span class="token operator">></span><span class="token operator">::</span><span class="token function">format</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> fc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> it<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>int32_t<span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 首先，调用format输出vector的长度，</span>    <span class="token comment" spellcheck="true">// 然后遍历vector，每次输出一个空格后再调用format输出数字。</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"{:#x}"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这段代码中，实现了格式化显示 vector 类型的对象的功能。我们重点关注的是第 7 行实现的 formatter 特化——std::formatter, CharT&gt;。</p><p>其中，CharT 表示字符类型，它可以根据用户的实际情况替换成 char 或者 wchar_t 等。</p><p>通过代码你会发现，我们重载了 format 成员函数，该函数用于控制格式化显示。该函数包含两个参数:</p><ul><li>t: std::vector: 被传入的待格式化参数</li><li>fc: FormatContext&amp;: 描述格式化的上下文</li></ul><h2 id="一个实践"><a href="#一个实践" class="headerlink" title="一个实践"></a>一个实践</h2><p>可以尝试用<code>format</code>库和<code>source_location</code>配合实现一个日志库，当然能用就行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;别的语言早就有的东西，积重难返的C++总是晚了很多年才有，在这之前搞了很多格式化方案，直到C++20才大刀阔斧改掉。&lt;/p&gt;
&lt;p&gt;&lt;img
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中还不完美的Coroutines</title>
    <link href="https://joytsing.github.io/posts/55948/"/>
    <id>https://joytsing.github.io/posts/55948/</id>
    <published>2024-04-15T07:23:58.000Z</published>
    <updated>2024-04-19T13:16:56.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Coroutines重要的不是它的性能，而是它带来的编程思维的改变，它能让你用同步的眼光去编写代码，也就是在对网络编程来说能消灭掉那些烦人的回调函数，仅此一点它的重要程度就不下于C++11，其次本篇文章为极客时间卢誉声老师的现代 C++20 实战高手课笔记，如果觉得本篇文章对你有帮助可以前去购买。</p><h2 id="C-协程"><a href="#C-协程" class="headerlink" title="C++协程"></a>C++协程</h2><p>首先，需要先纠正网络上盛传的观点“线程是轻量的进程，协程是更轻量的线程”，协程用一句话概括就是可以暂停恢复的函数。</p><p>而现代 C++20 标准下的协程，是一种可休眠、可恢复、不基于栈实现的函数。协程相较于函数来说是一个更加泛化的概念。函数只有“调用”和“返回”两个行为，而协程在这一基础上进行了扩展，增加了“休眠”和“恢复”。</p><p>同时，C++的协程属于无栈协程（与传统意义上的GO的协程不同），因此 C++ 并没有提供标准调度器，需要开发者按照规定的规则实现所需的接口约定（也就是需要在类或者结构体内部按照约定的名称命名函数，俗称硬编码），一般需要实现这么几个：</p><ul><li>调用者的传参方式。</li><li>将值返回给调用者的方式。</li><li>休眠与恢复执行的规则。</li><li>异常处理方式。</li></ul><h3 id="协程执行"><a href="#协程执行" class="headerlink" title="协程执行"></a>协程执行</h3><p>相较于函数，协程是一种可休眠、可恢复、不基于栈实现的函数。因此，它的生命周期管理自然与普通函数不同。也可以预见，C++ 中的协程是基于堆来实现的：</p><p><img src="/posts/55948/image-20240415154637876.png" alt></p><ol><li>调用函数在堆上创建协程帧（coroutine frame），用于存储协程的各类数据。协程帧的结构属于内存模型，因此不同编译器可能会有不同实现。</li><li>调用被调协程，开始执行协程代码。</li><li>被调协程执行到某个特定点，通过 co_await/co_yield 将当前协程休眠，线程 1 恢复自身原本的执行流程继续执行剩余代码</li><li>线程 2 通过协程句柄 coroutine_handle 的恢复函数 resume 恢复协程执行。</li><li>协程在线程 2 上恢复执行，继续向下执行，直到协程执行结束为止。结束后回到线程 2 的原本执行流程继续执行代码。</li><li>最后，线程 2 负责通过协程句柄 coroutine_handle 销毁协程帧。</li></ol><p>C++ 中的协程并不会像函数调用那样在栈上执行，它的状态储存在堆上。因此，我们只能在函数调用过程中，通过协程句柄 coroutine_handle 改变“部分”协程的状态——恢复或销毁。</p><p><img src="/posts/55948/v2-7c27069e79979fc3bc5c206d03dc8eab_720w.webp" alt></p><p>图中浅蓝色部分的方法就是 Return_t 关联的 promise 对象的函数，浅红色部分就是 co_await 等待的 awaiter。这个流程的驱动是由编译器根据协程函数生成的代码驱动的，分成三部分：</p><ul><li>协程创建；</li><li>co_await awaiter 等待 task 完成；</li><li>获取协程返回值和释放协程帧。</li></ul><h2 id="接口规定"><a href="#接口规定" class="headerlink" title="接口规定"></a>接口规定</h2><p>C++ 的协程要求开发者实现大量接口约定，而我们很难通过阅读标准文档来编写实际的代码，所以我们有必要学习一下实现接口约定的实践方法，这对我们在 C++ 里熟练应用协程非常重要。</p><p>实践里，有两个重要的用户自定义类型 Promise 和 Awaitable。我们先来看看 Promise（这里的promise和std::future里的promise没有任何关系，是协程和开发者约定的数据类型），Promise允许我们通过这个对象提供值，这个值会在之后计算得出：</p><p><img src="/posts/55948/image-20240415155849323.png" alt></p><p>生成器 Generator 用来控制协程，包括协程调用、返回值的操作、co_await/co_yield 的具体行为以及 promise_type 的具体定义。</p><p>我们要从 coroutine_traits 这一 concept 开始说起。标准中提供的代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token keyword">struct</span> coroutine_traits <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>requires requires <span class="token punctuation">{</span> <span class="token keyword">typename</span> R<span class="token operator">::</span>promise_type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">struct</span> coroutine_traits<span class="token operator">&lt;</span>R<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">using</span> promise_type <span class="token operator">=</span> <span class="token keyword">typename</span> R<span class="token operator">::</span>promise_type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际编程代码中特化的 coroutine_traits 必须定义一个公有的 promise_type 成员（见代码第 7 行）。否则，这就不是一个有效的协程类且属于未定义行为。也就是说，编译器会查找协程类中的 promise_type 作为 Promise，若 promise_type 不存在，就会发生编译时报错。</p><p>与此同时，一个协程类需要包含三个成员，分别是 <code>promise_type</code>、<code>coroutine_handle</code>和<code>coroutine_state</code>，这些都是硬编码，编译器不会给你任何提示（支持还不够好），其中：</p><p><strong>promise_type</strong> 在协程内操作时使用，它必须满足一定规则的类型，包含一系列约束的函数来支持休眠和恢复等功能，包括提交协程的返回值、提交协程异常。通常来说，编译器会通过 promise_type 的具体实现来判断协程是否合法。</p><p><strong>coroutine_handle</strong> 在协程外部操作时使用，可供调用者使用来休眠协程。它的类型是标准库提供的模板类，封装了协程帧的指针以及恢复、销毁协程帧的接口。</p><p><strong>coroutine_state</strong> 用于支持协程的生命周期，是运行时分配在堆（如果开启了编译器优化选项，则有可能会被优化使用寄存器）上的对象，目的是进一步规范说明协程执行时在堆上创建的数据，包括以下内容:</p><ul><li>promise 对象</li><li>参数（在协程创建时，会拷贝所有函数参数进入协程帧）</li><li>当前休眠的状态（在运行时，供后续恢复或销毁协程帧使用）</li><li>局部变量（在运行时，供协程帧使用）</li><li>临时变量（在运行时，供协程帧使用，它的生命周期是整个协程帧的生命周期）</li></ul><p>coroutine_state 参数还可以细分成这两种情况。</p><ul><li>值类型的参数会被移动或拷贝。</li><li>引用类型的参数会拷贝引用，当被引用的内存被释放了，那么协程状态中的引用会变成一个野引用。</li></ul><p>这三个成员里，coroutine_state 是比较特殊的抽象，是支持协程运行时的。</p><h3 id="promise-type"><a href="#promise-type" class="headerlink" title="promise_type"></a>promise_type</h3><p>对于 promise_type，它是实现协程的最关键一环。开发者需要自己来实现它，代码如下所示:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> promise<span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> Generator <span class="token operator">:</span> std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>promise<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token punctuation">{</span>  <span class="token keyword">using</span> promise_type <span class="token operator">=</span> promise<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> promise <span class="token punctuation">{</span>  T _value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 待计算的值</span>  std<span class="token operator">::</span>exception_ptr _exception<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 待抛出的异常</span>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Ty<span class="token operator">></span>  <span class="token function">promise</span><span class="token punctuation">(</span>Ty<span class="token operator">&amp;&amp;</span> lambdaObj<span class="token punctuation">,</span> T value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">promise</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  Generator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span> Generator<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">from_promise</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  std<span class="token operator">::</span>suspend_always <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  std<span class="token operator">::</span>suspend_always <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// optional，但co_yield需要这一函数实现</span>  std<span class="token operator">::</span>suspend_always <span class="token function">yield_value</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      _value <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// optional，但co_return需要这一函数实现或return_void</span>  std<span class="token operator">::</span>suspend_always <span class="token function">return_value</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      _value <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> _exception <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的调用流程和需要实现的函数如下：</p><p><img src="/posts/55948/image-20240415162354807.png" alt></p><h3 id="coroutine-handle"><a href="#coroutine-handle" class="headerlink" title="coroutine_handle"></a>coroutine_handle</h3><p>看看标准库提供的 coroutine_handle 这一模版类的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Promise</span><span class="token operator">></span><span class="token keyword">struct</span> coroutine_handle <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 构造函数和赋值函数</span>  <span class="token keyword">constexpr</span> <span class="token function">coroutine_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">constexpr</span> <span class="token function">coroutine_handle</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> coroutine_handle <span class="token function">from_promise</span><span class="token punctuation">(</span>Promise<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  coroutine_handle<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 导入和导出</span>  <span class="token keyword">constexpr</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取coroutine_handle内部数据的指针</span>  <span class="token keyword">static</span> <span class="token keyword">constexpr</span> coroutine_handle <span class="token function">from_address</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将内部数据指针转换为对应的coroutine_handle对象，会创建一个新对象</span>  <span class="token comment" spellcheck="true">// 转换函数</span>  <span class="token keyword">constexpr</span> <span class="token keyword">operator</span> coroutine_handle<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 查询协程状态</span>  <span class="token keyword">constexpr</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于确定coroutine_handle是否有效</span>  <span class="token keyword">bool</span> <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于确定协程是否已经执行完成</span>  <span class="token comment" spellcheck="true">// 控制协程执行</span>  <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 行为同resume，用于唤醒协程</span>  <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于唤醒协程</span>  <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于销毁协程</span>  <span class="token comment" spellcheck="true">// 访问Promise对象</span>  Promise<span class="token operator">&amp;</span> <span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// exposition only </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">struct</span> coroutine_handle<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 构造函数和赋值函数</span>  <span class="token keyword">constexpr</span> <span class="token function">coroutine_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">constexpr</span> <span class="token function">coroutine_handle</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  coroutine_handle<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 导入和导出</span>  <span class="token keyword">constexpr</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">constexpr</span> coroutine_handle <span class="token function">from_address</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 查询协程状态</span>  <span class="token keyword">constexpr</span> <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 恢复协程执行</span>  <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// exposition only</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相比于 void 类型的特化版本，如果开发者指定了 promise 类型，那么就会用通用版本的 coroutine_handle，这个类多了以下几个成员函数。</p><ul><li>from_promise：获取 promise 对应的 coroutine_handle。实际行为会根据 promise 创建新的 coroutine_handle 对象。</li><li>operator coroutine_handle&lt;&gt;：将 promise 版本的 coroutine_handle 转换为 void 类型的 coroutine_handle。</li><li>promise：获取 coroutine_handle 内部的 promise 对象。</li></ul><p>两个版本最后一行用“exposition only”标识出来的部分，就是 coroutine_handle 的内部存储内容，这部分只是为了说明标准做的示例，实际不同编译器可以根据自己的需求定义这里的实现。</p><h2 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h2><p>除了定义外，还需要学习如何对协程进行调度，包括协程休眠、控制权转移和待计算值的传递。对协程进行调度的关键在于 co_await 和 co_yield 操作符（关键字）。</p><h3 id="co-await"><a href="#co-await" class="headerlink" title="co_await"></a>co_await</h3><p>co_await 是协程中必须要了解的与编译器的约定。只有了解它，我们才能知道如何通过 co_await 灵活处理线程的休眠与唤醒。而搞清楚 co_await 操作符的具体行为表现，是我们理解 Awaitable 的重点。co_await 操作符用于休眠协程，并将控制权返还给协程调用者，用法如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">co_await 表达式<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与此同时，co_await 的表达式需要满足下列两个条件之一。</p><ul><li>表达式类型必须定义了 co_await 操作符重载。</li><li>可以通过当前协程的 Promise::await_transform 转换为定义了 co_await 操作符的类型。</li></ul><p>co_await 只能出现在函数体的执行表达式中，不能出现在异常处理、声明语句、简单声明表达式、默认参数和带 static 和 thread_local 的局部变量定义中。另外，co_await 的执行过程较为复杂，其中涉及到两个类型。</p><ul><li>Awaitable：用于获取 Awaiter 对象。</li><li>Awaiter：用于控制实际的休眠操作细节。</li></ul><p>我们需要将其分为编译时和运行时两个阶段来理解。先看编译时:</p><p><img src="/posts/55948/image-20240415164924809.png" alt></p><p><strong>编译时，</strong>编译器通过以下方式，将表达式转换成 Awaitable 对象。</p><ul><li>如果表达式是通过初始休眠点、结束休眠点或 yield 产生的，那么表达式本身就是 Awaitable 对象。</li><li>否则，如果当前协程的 promise 中包含 await_transform 函数，那么就会调用 promise.await_transform 将表达式转换为 Awaitable 对象。</li><li>否则，表达式本身就是 Awaitable 对象。</li></ul><p>接着，编译器就会通过以下操作获取 Awaiter 对象。</p><ul><li>如果 Awaitable 类型包含 co_await 操作符重载，那么就会将 co_await 重载的执行结果作为 Awaiter。</li><li>如果没有找到 co_await 操作符重载，那么就会将 Awaitable 对象自身作为 Awaiter 对象。</li></ul><p>再了解一下 co_await 在运行时的执行过程:</p><p><img src="/posts/55948/image-20240415165240467.png" alt></p><p>在运行时，代码会调用 Awaiter 对象的 await_ready 函数，如果该函数返回值为 false，那么就会执行以下行为：首先，将协程休眠；然后，使用当前协程的句柄，调用 Awaiter 对象的 await_suspend(handle) 函数。</p><p>我们可以在 await_suspend 中通过句柄获取到当前协程的各种信息，在自己编写的调度器中选择何时唤醒或者销毁这个协程。</p><p><img src="/posts/55948/image-20240415165319160.png" alt></p><p>在唤醒协程时，会调用 Awaiter 的 await_resume 函数，并使用该函数的返回值作为 co_await 表达式的值。其中，await_resume 函数的执行，会根据 await_ready 和 await_suspend 的执行结果有所不同。</p><p><img src="/posts/55948/image-20240415165331019.png" alt></p><p>这里可能会有一些关于多线程上执行协程的疑问。<strong>如果协程的执行涉及在不同线程上执行，会有线程安全问题吗？</strong>答案其实是不会。协程在进入 await_suspend 之前会休眠，因此 await_suspend 函数可以将协程句柄传递给任意的线程，而不需要考虑额外的线程同步问题。</p><p>举例来说，通过协程处理异步任务，await_suspend 函数是某个 Awaiter 类的成员函数，其 this 指针指向 Awaiter 对象。</p><p><img src="/posts/55948/image-20240415165503995.png" alt></p><p>我们将句柄存储在一个回调函数中（如图中的 lambda 表达式）。然后，在预先设定的线程池中完成异步任务。最后，调用回调函数利用协程句柄调度唤醒协程。</p><p>在这种情况下，代码块 2 依然会在本线程继续执行，回调函数中的代码则会在其他线程执行。由于其他线程的调度时序是未知的，因此本线程在执行代码块 2 时，协程可能已经被其他线程唤醒。这种多线程同时访问同一内存块上数据的情况，我们通常称为数据竞争问题。</p><p>为了避免出现这种数据竞争问题，将协程句柄传递给其他线程后，await_suspend 后续代码（示例中代码块 2）必须假定 *this（也就是调用 await_suspend 的 Awaiter 对象）已经被销毁，并且再也不对其进行访问。</p><p>这是一种典型的使用异步 I/O 处理的场景。</p><h3 id="生成器和-co-yield"><a href="#生成器和-co-yield" class="headerlink" title="生成器和 co_yield"></a>生成器和 co_yield</h3><p>除了 co_await，在协程的上下文中还有一个常见操作符（关键字）——co_yield，它本质上是 co_await 的语法糖，一般用在生成器这种协程的常见场景中。那么，<strong>什么是生成器呢？</strong></p><p>生成器是基于协程的异步编程中常见的一种编程模式。最常见的应用场景就是，通过生成或其他数据源来获取某种序列。</p><p>生成器的核心思路是让协程的调用者和被调用的协程进行协同调度，其中被调用的协程就是生成器。</p><p>这个协同调度过程是这样的：首先，调用者唤醒生成器，生成器返回一个值，接着就会主动进入休眠状态；然后，调用者使用这个值来执行相应代码逻辑，然后重新唤醒生成器……这个过程如此往复，直到调用者从生成器获取了所需的值为止。</p><p><img src="/posts/55948/image-20240415165933860.png" alt></p><p>从图中可以看出，在生成器这种模式下，主要就是两个操作。</p><ul><li>调用者作为调度方恢复协程执行。</li><li>协程将获取或生成的值返回给调用者并继续休眠，等待调用者恢复执行。</li></ul><p>而其中的关键就是 co_yield 关键字，用法是这样。</p><pre class="line-numbers language-cpp"><code class="language-cpp">co_yield 表达式<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>协程可以通过该关键字将表达式的结果传回给调用方并自动休眠。代码等价于：</p><pre class="line-numbers language-cpp"><code class="language-cpp">co_await promise<span class="token punctuation">.</span><span class="token function">yield_value</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看出，调用 co_yield 的本质就是调用了 promise 的 yield_value 函数，并通过 co_await 将自身休眠。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;coroutine></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdint></span></span><span class="token keyword">struct</span> CountGenerator <span class="token punctuation">{</span>    <span class="token keyword">struct</span> promise_type <span class="token punctuation">{</span>        int32_t _value<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token operator">~</span><span class="token function">promise_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"promise_type 对象销毁"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        CountGenerator <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span>              <span class="token punctuation">.</span>_handle <span class="token operator">=</span> std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>promise_type<span class="token operator">></span><span class="token operator">::</span><span class="token function">from_promise</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        std<span class="token operator">::</span>suspend_never <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        std<span class="token operator">::</span>suspend_always <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        std<span class="token operator">::</span>suspend_always <span class="token function">yield_value</span><span class="token punctuation">(</span>int32_t value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            _value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>promise_type<span class="token operator">></span> _handle<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>CountGenerator <span class="token function">doCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int32_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        co_yield i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> h <span class="token operator">=</span> <span class="token function">doCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>_handle<span class="token punctuation">;</span>    <span class="token keyword">auto</span><span class="token operator">&amp;</span> promise <span class="token operator">=</span> h<span class="token punctuation">.</span><span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>h<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"计数: "</span> <span class="token operator">&lt;&lt;</span> promise<span class="token punctuation">.</span>_value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    h<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里定义了一个协程类 CountGenerator，比较特殊的是，这个类定义了一个 yield_value 成员函数，用于把 co_yield 的表达式值存储到 promise 对象内部，调用者通过这一方式来获取值。</p><p>由于调用方不知道协程什么时候结束执行，所以通过 coroutine_handle 中的 done 函数获取运行时状态。如果协程尚未结束执行，就获取相应的值并继续，否则就销毁协程并退出程序。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;coroutine></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token keyword">namespace</span> Coroutine <span class="token punctuation">{</span>  <span class="token keyword">struct</span> task <span class="token punctuation">{</span>    <span class="token keyword">struct</span> promise_type <span class="token punctuation">{</span>      <span class="token function">promise_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1.create promie object\n"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      task <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2.create coroutine return object, and the coroutine is created now\n"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>task<span class="token operator">::</span>promise_type<span class="token operator">></span><span class="token operator">::</span><span class="token function">from_promise</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      std<span class="token operator">::</span>suspend_never <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"3.do you want to susupend the current coroutine?\n"</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"4.don't suspend because return std::suspend_never, so continue to execute coroutine body\n"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      std<span class="token operator">::</span>suspend_never <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"13.coroutine body finished, do you want to susupend the current coroutine?\n"</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"14.don't suspend because return std::suspend_never, and the continue will be automatically destroyed, bye\n"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"12.coroutine don't return value, so return_void is called\n"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>task<span class="token operator">::</span>promise_type<span class="token operator">></span> handle_<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">struct</span> awaiter <span class="token punctuation">{</span>    <span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"6.do you want to suspend current coroutine?\n"</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"7.yes, suspend becase awaiter.await_ready() return false\n"</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">await_suspend</span><span class="token punctuation">(</span>      std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>task<span class="token operator">::</span>promise_type<span class="token operator">></span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"8.execute awaiter.await_suspend()\n"</span><span class="token punctuation">;</span>      std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>handle<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"9.a new thread lauched, and will return back to caller\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  task <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"5.begin to execute coroutine body, the thread id="</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//#1</span>    co_await awaiter<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"11.coroutine resumed, continue execcute coroutine body now, the thread id="</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//#3</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// namespace Coroutine</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  Coroutine<span class="token operator">::</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"10.come back to caller becuase of co_await awaiter\n"</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre><code>1.create promie object2.create coroutine return object, and the coroutine is created now3.do you want to susupend the current coroutine?4.don&#39;t suspend because return std::suspend_never, so continue to execute coroutine body5.begin to execute coroutine body, the thread id=0x10e1c1dc06.do you want to suspend current coroutine?7.yes, suspend becase awaiter.await_ready() return false8.execute awaiter.await_suspend()9.a new thread lauched, and will return back to caller10.come back to caller becuase of co_await awaiter11.coroutine resumed, continue execcute coroutine body now, the thread id=0x700001dc700012.coroutine don&#39;t return value, so return_void is called13.coroutine body finished, do you want to susupend the current coroutine?14.don&#39;t suspend because return std::suspend_never, and the continue will be automatically destroyed, bye</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>协程是彻底迈向现代编程语言的关键标志之一，一个协程类（Generator 类）包含 promise_type、coroutine_handle、coroutine_state。</p><p>但是 C++20 的协程缺乏具体实现，<strong>接口约定都需要开发者来实现，换句话说目前只提供了跟编译器沟通的协议，</strong>相信以后的标准肯定会支持得更加完美。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ============= Promise的Concept定义 ===================</span><span class="token comment" spellcheck="true">// PromiseType是Promise的类型，ValueType是协程中待计算的值的类型</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> PromiseType<span class="token punctuation">,</span> <span class="token keyword">typename</span> ValueType<span class="token operator">></span>concept Promise <span class="token operator">=</span> <span class="token function">requires</span><span class="token punctuation">(</span>PromiseType promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Coroutine<span class="token operator">&lt;</span>PromiseType<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Awaiter<span class="token punctuation">;</span>  <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Awaiter<span class="token punctuation">;</span>  <span class="token function">requires</span> <span class="token punctuation">(</span><span class="token function">requires</span><span class="token punctuation">(</span>ValueType value<span class="token punctuation">)</span> <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">return_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">||</span> <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> promise<span class="token punctuation">.</span><span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ============= Awaiter的Concept定义 ===================</span><span class="token comment" spellcheck="true">// AwaitSuspendResult约束了await_suspend的返回值类型</span><span class="token comment" spellcheck="true">// AwaiterType是Awaiter的类型，Promise是协程的Promise类型，下同</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> ResultType<span class="token punctuation">,</span> <span class="token keyword">typename</span> Promise<span class="token operator">></span>concept AwaitSuspendResult <span class="token operator">=</span> std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span>ResultType<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">></span> <span class="token operator">||</span>  std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span>ResultType<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> <span class="token operator">||</span>  std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span>ResultType<span class="token punctuation">,</span> std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>Promise<span class="token operator">>></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Awaiter约束定义，Awaiter类型必须满足requires中的所有接口约定</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> AwaiterType<span class="token punctuation">,</span> <span class="token keyword">typename</span> Promise<span class="token operator">></span>concept Awaiter <span class="token operator">=</span> <span class="token function">requires</span><span class="token punctuation">(</span>AwaiterType awaiter<span class="token punctuation">,</span> std<span class="token operator">::</span>coroutine_handle<span class="token operator">&lt;</span>Promise<span class="token operator">></span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    awaiter<span class="token punctuation">.</span><span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span> awaiter<span class="token punctuation">.</span><span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> std<span class="token operator">::</span>same_as<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">;</span>    <span class="token punctuation">{</span> awaiter<span class="token punctuation">.</span><span class="token function">await_suspend</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> AwaitSuspendResult<span class="token operator">&lt;</span>Promise<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ============= Awaitable的Concept定义 ===================</span><span class="token comment" spellcheck="true">// ValidCoAwait约束用于判断对于AwaitableType是否存在正确的co_await操作符重载</span><span class="token comment" spellcheck="true">// co_await可以重载为成员函数或者非成员函数，约束中都需要判断</span><span class="token comment" spellcheck="true">// AwaitableType是Awaitable的类型，Promise是协程的Promise类型，下同</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> AwaitableType<span class="token punctuation">,</span> <span class="token keyword">typename</span> Promise<span class="token operator">></span>concept ValidCoAwait <span class="token operator">=</span> <span class="token function">requires</span><span class="token punctuation">(</span>AwaitableType awaitable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span> awaitable<span class="token punctuation">.</span><span class="token keyword">operator</span> <span class="token function">co_await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Awaiter<span class="token operator">&lt;</span>Promise<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token operator">||</span> <span class="token function">requires</span><span class="token punctuation">(</span>AwaitableType awaitable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span> <span class="token keyword">operator</span> <span class="token function">co_await</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>AwaitableType<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>awaitable<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">></span> Awaiter<span class="token operator">&lt;</span>Promise<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Awaitable约束定义</span><span class="token comment" spellcheck="true">// Awaitable必须存在正确的co_await操作符重载，或者自身是一个Awaiter</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> AwaitableType<span class="token punctuation">,</span> <span class="token keyword">typename</span> Promise<span class="token operator">></span>concept Awaitable <span class="token operator">=</span> ValidCoAwait<span class="token operator">&lt;</span>AwaitableType<span class="token punctuation">,</span> Promise<span class="token operator">></span> <span class="token operator">||</span>  Awaiter<span class="token operator">&lt;</span>AwaitableType<span class="token punctuation">,</span> Promise<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Coroutines重要的不是它的性能，而是它带来的编程思维的改变，它能让你用同步的眼光去编写代码，也就是在对网络编程来说能消灭掉那些烦人的
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="读书笔记" scheme="https://JoyTsing.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis会遇到的15个坑</title>
    <link href="https://joytsing.github.io/posts/42709/"/>
    <id>https://joytsing.github.io/posts/42709/</id>
    <published>2024-04-11T15:21:45.000Z</published>
    <updated>2024-04-10T16:41:15.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，这篇文章是转载的，哥们暂时还没这个工程经验（捂脸）。</p><ul><li>明明一个 key 设置了过期时间，怎么变成不过期了？</li><li>使用 O(1) 复杂度的 SETBIT 命令，Redis 竟然被 OOM 了？</li><li>执行 RANDOMKEY 随机拿出一个 key，竟然也会阻塞 Redis？</li><li>同样的命令，为什么主库查不到数据，从库却可以查到？</li><li>从库内存为什么比主库用得还多？</li><li>写入到 Redis 的数据，为什么莫名其妙丢了？</li><li>…</li></ul><p>这些问题划分成了三大部分：</p><ol><li>常见命令有哪些坑？</li><li>数据持久化有哪些坑？</li><li>主从库同步有哪些坑？</li></ol><h2 id="常见命令有哪些坑？"><a href="#常见命令有哪些坑？" class="headerlink" title="常见命令有哪些坑？"></a>常见命令有哪些坑？</h2><p>首先，我们来看一下，平时在使用 Redis 时，有哪些常见的命令会遇到「意料之外」的结果。</p><p><strong>1) 过期时间意外丢失？</strong></p><p>你在使用 Redis 时，肯定经常使用 SET 命令，它非常简单。</p><p>SET 除了可以设置 key-value 之外，还可以设置 key 的过期时间，就像下面这样：</p><pre><code>127.0.0.1:6379&gt; SET testkey val1 EX 60OK127.0.0.1:6379&gt; TTL testkey(integer) 59</code></pre><p>此时如果你想修改 key 的值，但只是单纯地使用 SET 命令，而没有加上「过期时间」的参数，那这个 key 的过期时间将会被「擦除」。</p><pre><code>127.0.0.1:6379&gt; SET testkey val2OK127.0.0.1:6379&gt; TTL testkey  // key永远不过期了！(integer) -1</code></pre><p>看到了么？testkey 变成永远不过期了！</p><p><img src="/posts/42709/640.webp" alt></p><p>导致这个问题的原因在于：<strong>SET 命令如果不设置过期时间，那么 Redis 会自动「擦除」这个 key 的过期时间。</strong></p><p>如果你发现 Redis 的内存持续增长，而且很多 key 原来设置了过期时间，后来发现过期时间丢失了，很有可能是因为这个原因导致的。</p><p>这时你的 Redis 中就会存在大量不过期的 key，消耗过多的内存资源。</p><p>所以，你在使用 SET 命令时，如果刚开始就设置了过期时间，那么之后修改这个 key，也务必要加上过期时间的参数，避免过期时间丢失问题。</p><p><strong>2) DEL 竟然也会阻塞 Redis？</strong></p><p>删除一个 key，你肯定会用 DEL 命令，不知道你没有思考过它的时间复杂度是多少？O(1)？其实不一定。</p><p>如果有阅读 Redis 的官方文档，就会发现：<strong>删除一个 key 的耗时，与这个 key 的类型有关。</strong></p><p>Redis 官方文档在介绍 DEL 命令时，是这样描述的：</p><ul><li>key 是 String 类型，DEL 时间复杂度是 O(1)</li><li>key 是 List/Hash/Set/ZSet 类型，DEL 时间复杂度是 O(M)，M 为元素数量</li></ul><p><strong>也就是说，如果你要删除的是一个非 String 类型的 key，这个 key 的元素越多，那么在执行 DEL 时耗时就越久！</strong></p><p>为什么会这样？原因在于，删除这种 key 时，Redis 需要依次释放每个元素的内存，元素越多，这个过程就会越耗时。</p><p>而这么长的操作耗时，势必会阻塞整个 Redis 实例，影响 Redis 的性能。</p><p><img src="/posts/42709/640-1712762722266-3.webp" alt></p><p>所以，当你在删除 List/Hash/Set/ZSet 类型的 key 时，一定要格外注意，不能无脑执行 DEL，而是应该用以下方式删除：</p><ol><li>查询元素数量：执行 LLEN/HLEN/SCARD/ZCARD 命令</li><li>判断元素数量：如果元素数量较少，可直接执行 DEL 删除，否则分批删除</li><li>分批删除：执行 LRANGE/HSCAN/SSCAN/ZSCAN + LPOP/RPOP/HDEL/SREM/ZREM 删除</li></ol><p>了解了 DEL 对于 List/Hash/Set/ZSet 类型数据的影响，我们再来分析下，删除一个 String 类型的 key 会不会有这种问题？啊？前面不是提到，Redis 官方文档的描述，删除 String 类型的 key，时间复杂度是 O(1) 么？这不会导致 Redis 阻塞吧？</p><p>其实这也不一定！如果这个 key 占用的内存非常大呢？</p><p>例如，这个 key 存储了 500MB 的数据（很明显，它是一个 bigkey），那在执行 DEL 时，耗时依旧会变长！这是因为，Redis 释放这么大的内存给操作系统，也是需要时间的，所以操作耗时也会变长。</p><p>所以，对于 String 类型来说，你最好也不要存储过大的数据，否则在删除它时，也会有性能问题。此时，你可能会想：<strong>Redis 4.0 不是推出了 lazy-free 机制么？打开这个机制，释放内存的操作会放到后台线程中执行，那是不是就不会阻塞主线程了？</strong></p><p>这个问题非常好。真的会是这样吗？<strong>即使 Redis 打开了 lazy-free，在删除一个 String 类型的 bigkey 时，它仍旧是在主线程中处理，而不是放到后台线程中执行。所以，依旧有阻塞 Redis 的风险！</strong></p><p><strong>3) RANDOMKEY 竟然也会阻塞 Redis？</strong></p><p>如果想随机查看 Redis 中的一个 key，通常会使用 RANDOMKEY 这个命令。这个命令会从 Redis 中「随机」取出一个 key。</p><p>既然是随机，那这个执行速度肯定非常快吧？其实不然。</p><p>要解释清楚这个问题，就要结合 Redis 的过期策略来讲。如果你对 Redis 的过期策略有所了解，应该知道 Redis 清理过期 key，是采用定时清理 + 懒惰清理 2 种方式结合来做的。</p><p>而 RANDOMKEY 在随机拿出一个 key 后，首先会先检查这个 key 是否已过期。如果该 key 已经过期，那么 Redis 会删除它，这个过程就是<strong>懒惰清理</strong>。但清理完了还不能结束，Redis 还要找出一个「不过期」的 key，返回给客户端。此时，Redis 则会继续随机拿出一个 key，然后再判断是它否过期，直到找出一个未过期的 key 返回给客户端。</p><p>整个流程就是这样的：</p><ol><li>master 随机取出一个 key，判断是否已过期</li><li>如果 key 已过期，删除它，继续随机取 key</li><li>以此循环往复，直到找到一个不过期的 key，返回</li></ol><p>但这里就有一个问题了：<strong>如果此时 Redis 中，有大量 key 已经过期，但还未来得及被清理掉，那这个循环就会持续很久才能结束，而且，这个耗时都花费在了清理过期 key + 寻找不过期 key 上。</strong></p><p>导致的结果就是，RANDOMKEY 执行耗时变长，影响 Redis 性能。</p><p><img src="/posts/42709/640-1712766321625-6.webp" alt></p><p>以上流程，其实是在 master 上执行的。如果在 slave 上执行 RANDOMEKY，那么问题会更严重！</p><p>为什么？</p><p>主要原因就在于，slave 自己是不会清理过期 key。那 slave 什么时候删除过期 key 呢？其实，当一个 key 要过期时，master 会先清理删除它，之后 master 向 slave 发送一个 DEL 命令，告知 slave 也删除这个 key，以此达到主从库的数据一致性。</p><p>还是同样的场景：Redis 中存在大量已过期，但还未被清理的 key，那在 slave 上执行 RANDOMKEY 时，就会发生以下问题：</p><ol><li>slave 随机取出一个 key，判断是否已过期</li><li>key 已过期，但 slave 不会删除它，而是继续随机寻找不过期的 key</li><li>由于大量 key 都已过期，那 slave 就会寻找不到符合条件的 key，此时就会陷入「<strong>死循环</strong>」！</li></ol><p><strong>也就是说，在 slave 上执行 RANDOMKEY，有可能会造成整个 Redis 实例卡死！</strong></p><p><img src="/posts/42709/640-1712766365074-9.webp" alt></p><p>是不是没想到？在 slave 上随机拿一个 key，竟然有可能造成这么严重的后果？这其实是 Redis 的一个 Bug，这个 Bug 一直持续到 5.0 才被修复。</p><p>修复的解决方案是，在 slave 上执行 RANDOMKEY 时，会先判断整个实例所有 key 是否都设置了过期时间，如果是，为了避免长时间找不到符合条件的 key，<strong>slave 最多只会在哈希表中寻找 100 次</strong>，无论是否能找到，都会退出循环。</p><p>这个方案就是增加上了一个最大重试次数，这样一来，就避免了陷入死循环。虽然这个方案可以避免了 slave 陷入死循环、卡死整个实例的问题，但是，在 master 上执行这个命令时，依旧有概率导致耗时变长。</p><p>所以，你在使用 RANDOMKEY 时，如果发现 Redis 发生了「抖动」，很有可能是因为这个原因导致的！</p><p><strong>4) O(1) 复杂度的 SETBIT，竟然会导致 Redis OOM？</strong></p><p>在使用 Redis 的 String 类型时，除了直接写入一个字符串之外，还可以把它当做 bitmap 来用。具体来讲就是，我们可以把一个 String 类型的 key，拆分成一个个 bit 来操作，就像下面这样：</p><pre><code>127.0.0.1:6379&gt; SETBIT testkey 10 1(integer) 1127.0.0.1:6379&gt; GETBIT testkey 10(integer) 1</code></pre><p><img src="/posts/42709/640-1712766388874-12.webp" alt></p><p>其中，操作的每一个 bit 位叫做 offset。但是，这里有一个坑，你需要注意起来。如果这个 key 不存在，或者 key 的内存使用很小，此时你要操作的 offset 非常大，那么 Redis 就需要分配「更大的内存空间」，这个操作耗时就会变长，影响性能。</p><p><img src="/posts/42709/640-1712766400480-15.webp" alt></p><p>所以，当你在使用 SETBIT 时，也一定要注意 offset 的大小，操作过大的 offset 也会引发 Redis 卡顿。这种类型的 key，也是典型的 bigkey，除了分配内存影响性能之外，在删除它时，耗时同样也会变长。</p><p><strong>5) 执行 MONITOR 也会导致 Redis OOM？</strong></p><p>这个坑你肯定听说过很多次了。当你在执行 MONITOR 命令时，Redis 会把每一条命令写到客户端的「输出缓冲区」中，然后客户端从这个缓冲区读取服务端返回的结果。</p><p><img src="/posts/42709/640-1712766412176-18.webp" alt></p><p>但是，如果你的 Redis QPS 很高，这将会导致这个输出缓冲区内存持续增长，占用 Redis 大量的内存资源，如果恰好你的机器的内存资源不足，那 Redis 实例就会面临被 OOM 的风险。所以，你需要谨慎使用 MONITOR，尤其在 QPS 很高的情况下。</p><p>以上这些问题场景，都是我们在使用常见命令时发生的，而且，很可能都是「无意」就会触发的。</p><p>下面我们来看 Redis「数据持久化」都存在哪些坑？</p><h2 id="数据持久化有哪些坑？"><a href="#数据持久化有哪些坑？" class="headerlink" title="数据持久化有哪些坑？"></a>数据持久化有哪些坑？</h2><p>Redis 的数据持久化，分为 RDB 和 AOF 两种方式。其中，RDB 是数据快照，而 AOF 会记录每一个写命令到日志文件中。在数据持久化方面发生问题，主要也集中在这两大块，我们依次来看。</p><p><strong>1) master 宕机，slave 数据也丢失了？</strong></p><p>如果你的 Redis 采用如下模式部署，就会发生数据丢失的问题：</p><ul><li>master-slave + 哨兵部署实例</li><li>master 没有开启数据持久化功能</li><li>Redis 进程使用 supervisor 管理，并配置为「进程宕机，自动重启」</li></ul><p>如果此时 master 宕机，就会导致下面的问题：</p><ul><li>master 宕机，哨兵还未发起切换，此时 master 进程立即被 supervisor 自动拉起</li><li>但 master 没有开启任何数据持久化，启动后是一个「空」实例</li><li>此时 slave 为了与 master 保持一致，它会自动「清空」实例中的所有数据，slave 也变成了一个「空」实例</li></ul><p>看到了么？在这个场景下，master / slave 的数据就全部丢失了。这时，业务应用在访问 Redis 时，发现缓存中没有任何数据，就会把请求全部打到后端数据库上，这还会进一步引发「缓存雪崩」，对业务影响非常大。</p><p>所以，一定要避免这种情况发生：</p><ol><li>Redis 实例不使用进程管理工具自动拉起</li><li>master 宕机后，让哨兵发起切换，把 slave 提升为 master</li><li>切换完成后，再重启 master，让其退化成 slave</li></ol><p>你在配置数据持久化时，要避免这个问题的发生。</p><p><strong>2) AOF everysec 真的不会阻塞主线程吗？</strong></p><p>当 Redis 开启 AOF 时，需要配置 AOF 的刷盘策略。基于性能和数据安全的平衡，你肯定会采用<code>appendfsync everysec</code> 这种方案。这种方案的工作模式为，Redis 的后台线程每间隔 1 秒，就把 AOF page cache 的数据，刷到磁盘（fsync）上。这种方案的优势在于，把 AOF 刷盘的耗时操作，放到了后台线程中去执行，避免了对主线程的影响。但真的不会影响主线程吗？</p><p>答案是否定的。其实存在这样一种场景：<strong>Redis 后台线程在执行 AOF page cache 刷盘（fysnc）时，如果此时磁盘 IO 负载过高，那么调用 fsync 就会被阻塞住。</strong>此时，主线程仍然接收写请求进来，那么此时的主线程会先判断，上一次后台线程是否已刷盘成功。如何判断呢？</p><p>后台线程在刷盘成功后，都会记录刷盘的时间。主线程会根据这个时间来判断，距离上一次刷盘已经过去多久了。整个流程是这样的：</p><ol><li>主线程在写 AOF page cache（write系统调用）前，先检查后台 fsync 是否已完成？</li><li>fsync 已完成，主线程直接写 AOF page cache</li><li>fsync 未完成，则检查距离上次 fsync 过去多久？</li><li>如果距离上次 fysnc 成功在 2 秒内，那么主线程会直接返回，不写 AOF page cache</li><li>如果距离上次 fysnc 成功超过了 2 秒，那主线程会强制写 AOF page cache（write系统调用）</li><li>由于磁盘 IO 负载过高，此时，后台线程 fynsc 会发生阻塞，那主线程在写 AOF page cache 时，也会发生阻塞等待（操作同一个 fd，fsync 和 write 是互斥的，一方必须等另一方成功才可以继续执行，否则阻塞等待）</li></ol><p><img src="/posts/42709/640-1712766433045-21.webp" alt></p><p>通过分析我们可以发现，即使你配置的 AOF 刷盘策略是 appendfsync everysec，也依旧会有阻塞主线程的风险。其实，产生这个问题的重点在于，磁盘 IO 负载过高导致 fynsc 阻塞，进而导致主线程写 AOF page cache 也发生阻塞。</p><p>所以，你一定要保证磁盘有充足的 IO 资源，避免这个问题。</p><p><strong>3) AOF everysec 真的只会丢失 1 秒数据？</strong></p><p>接着上面的问题继续分析。如上所述，这里我们需要重点关注上面的步骤 4。</p><p>也就是：主线程在写 AOF page cache 时，会先判断上一次 fsync 成功的时间，如果距离上次 fysnc 成功在 2 秒内，那么主线程会直接返回，不再写 AOF page cache。这就意味着，<strong>后台线程在执行 fsync 刷盘时，主线程最多等待 2 秒不会写 AOF page cache。</strong></p><p>如果此时 Redis 发生了宕机，那么，AOF 文件中丢失是 2 秒的数据，而不是 1 秒！我们继续分析，Redis 主线程为什么要等待 2 秒不写 AOF page cache 呢？</p><p>其实，Redis AOF 配置为 appendfsync everysec 时，正常来讲，后台线程每隔 1 秒执行一次 fsync 刷盘，如果磁盘资源充足，是不会被阻塞住的。也就是说，Redis 主线程其实根本不用关心后台线程是否刷盘成功，只要无脑写 AOF page cache 即可。</p><p>但是，Redis 作者考虑到，如果此时的磁盘 IO 资源比较紧张，那么后台线程 fsync 就有概率发生阻塞风险。所以，Redis 作者在主线程写 AOF page cache 之前，先检查一下距离上一次 fsync 成功的时间，如果大于 1 秒没有成功，那么主线程此时就能知道，fsync 可能阻塞了。</p><p>所以，主线程会等待 2 秒不写 AOF page cache，其目的在于：</p><ol><li>降低主线程阻塞的风险（如果无脑写 AOF page cache，主线程则会立即阻塞住）</li><li>如果 fsync 阻塞，主线程就会给后台线程留出 1 秒的时间，等待 fsync 成功</li></ol><p>但代价就是，如果此时发生宕机，AOF 丢失的就是 2 秒的数据，而不是 1 秒。这个方案应该是 Redis 作者对性能和数据安全性的进一步权衡。无论如何，这里你只需要知道的是，即使 AOF 配置为每秒刷盘，在发生上述极端情况时，AOF 丢失的数据其实是 2 秒。</p><p><strong>4) RDB 和 AOF rewrite 时，Redis 发生 OOM？</strong></p><p>最后，我们来看一下，当 Redis 在执行 RDB 快照和 AOF rewrite 时，会发生的问题。</p><p>Redis 在做 RDB 快照和 AOF rewrite 时，会采用创建子进程的方式，把实例中的数据持久化到磁盘上。创建子进程，会调用操作系统的 fork 函数。fork 执行完成后，父进程和子进程会同时共享同一份内存数据。</p><p>但此时的主进程依旧是可以接收写请求的，而进来的写请求，会采用 Copy On Write（写时复制）的方式操作内存数据。也就是说，主进程一旦有数据需要修改，Redis 并不会直接修改现有内存中的数据，而是先将这块内存数据拷贝出来，再修改这块新内存的数据，这就是所谓的「写时复制」。</p><p>写时复制你也可以理解成，谁需要发生写操作，谁就先拷贝，再修改。你应该发现了，如果父进程要修改一个 key，就需要拷贝原有的内存数据，到新内存中，这个过程涉及到了「新内存」的申请。</p><p>如果你的业务特点是「写多读少」，而且 OPS 非常高，那在 RDB 和 AOF rewrite 期间，就会产生大量的内存拷贝工作。这会有什么问题呢？</p><p><strong>因为写请求很多，这会导致 Redis 父进程会申请非常多的内存。在这期间，修改 key 的范围越广，新内存的申请就越多。</strong>如果你的机器内存资源不足，这就会导致 Redis 面临被 OOM 的风险！</p><p><img src="/posts/42709/640-1712766433046-22.webp" alt></p><p>这就是你会从 DBA 同学那里听到的，要给 Redis 机器预留内存的原因。其目的就是避免在 RDB 和 AOF rewrite 期间，防止 Redis OOM。</p><p>下面我们再来看「主从复制」会存在哪些问题。</p><h2 id="主从复制有哪些坑？"><a href="#主从复制有哪些坑？" class="headerlink" title="主从复制有哪些坑？"></a>主从复制有哪些坑？</h2><p>Redis 为了保证高可用，提供了主从复制的方式，这样就可以保证 Redis 有多个「副本」，当主库宕机后，我们依旧有从库可以使用。在主从同步期间，依旧存在很多坑，我们依次来看。</p><p><strong>1) 主从复制会丢数据吗？</strong></p><p>首先，你需要知道，Redis 的主从复制是采用「异步」的方式进行的。这就意味着，如果 master 突然宕机，可能存在有部分数据还未同步到 slave 的情况发生。</p><p>这会导致什么问题呢？</p><p>如果你把 Redis 当做纯缓存来使用，那对业务来说没有什么影响。master 未同步到 slave 的数据，业务应用可以从后端数据库中重新查询到。但是，对于把 Redis 当做数据库，或是当做分布式锁来使用的业务，有可能因为异步复制的问题，导致数据丢失 / 锁丢失。</p><blockquote><p>关于 Redis 分布式锁可靠性的更多细节，这里先不展开，后面会单独写一篇文章详细剖析这个知识点。这里你只需要先知道，Redis 主从复制是有概率发生数据丢失的。</p></blockquote><p><strong>2) 同样命令查询一个 key，主从库却返回不同的结果？</strong></p><p>不知道你是否思考过这样一个问题：<strong>如果一个 key 已过期，但这个 key 还未被 master 清理，此时在 slave 上查询这个 key，会返回什么结果呢？</strong></p><ol><li>slave 正常返回 key 的值</li><li>slave 返回 NULL</li></ol><p>你认为是哪一种？可以思考一下。答案是：<strong>不一定</strong>。</p><p>其实，返回什么结果，这要取决于以下 3 个因素：</p><ol><li>Redis 的版本</li><li>具体执行的命令</li><li>机器时钟</li></ol><p>先来看 Redis 版本。</p><p>如果你使用的是 Redis 3.2 以下版本，只要这个 key 还未被 master 清理，那么，在 slave 上查询这个 key，它会永远返回 value 给你。</p><p><strong>也就是说，即使这个 key 已过期，在 slave 上依旧可以查询到这个 key。</strong></p><pre><code>// Redis 2.8 版本 在 slave 上执行127.0.0.1:6479&gt; TTL testkey(integer) -2    // 已过期127.0.0.1:6479&gt; GET testkey&quot;testval&quot;       // 还能查询到!</code></pre><p>但如果此时在 master 上查询这个 key，发现已经过期，就会把它清理掉，然后返回 NULL。</p><pre><code>// Redis 2.8 版本 在 master 上执行127.0.0.1:6379&gt; TTL testkey(integer) -2127.0.0.1:6379&gt; GET testkey(nil)</code></pre><p>发现了吗？在 master 和 slave 上查询同一个 key，结果竟然不一样？其实，slave 应该要与 master 保持一致，key 已过期，就应该给客户端返回 NULL，而不是还正常返回 key 的值。为什么会发生这种情况？</p><p>其实这是 Redis 的一个 Bug：<strong>3.2 以下版本的 Redis，在 slave 上查询一个 key 时，并不会判断这个 key 是否已过期，而是直接无脑返回给客户端结果。</strong>这个 Bug 在 3.2 版本进行了修复，但是，它修复得「不够彻底」。</p><p>什么叫修复得「不够彻底」？这就要结合前面提到的，第 2 个影响因素「具体执行的命令」来解释了。Redis 3.2 虽然修复了这个 Bug，但却遗漏了一个命令：<strong>EXISTS</strong>。</p><p>也就是说，一个 key 已过期，在 slave 直接查询它的数据，例如执行 GET/LRANGE/HGETALL/SMEMBERS/ZRANGE 这类命令时，slave 会返回 NULL。但如果执行的是 EXISTS，slave 依旧会返回：<strong>key 还存在</strong>。</p><pre><code>// Redis 3.2 版本 在 slave 上执行127.0.0.1:6479&gt; GET testkey(nil)           // key 已逻辑过期127.0.0.1:6479&gt; EXISTS testkey(integer) 1     // 还存在！</code></pre><p>原因在于，EXISTS 与查询数据的命令，使用的不是同一个方法。Redis 作者只在查询数据时增加了过期时间的校验，但 EXISTS 命令依旧没有这么做。</p><p>直到 Redis 4.0.11 这个版本，Redis 才真正把这个遗漏的 Bug 完全修复。如果你使用的是这个之上的版本，那在 slave 上执行数据查询或 EXISTS，对于已过期的 key，就都会返回「不存在」了。</p><p>这里我们先小结一下，slave 查询过期 key，经历了 3 个阶段：</p><ol><li>3.2 以下版本，key 过期未被清理，无论哪个命令，查询 slave，均正常返回 value</li><li>3.2 - 4.0.11 版本，查询数据返回 NULL，但 EXISTS 依旧返回 true</li><li>4.0.11 以上版本，所有命令均已修复，过期 key 在 slave 上查询，均返回「不存在」</li></ol><p>最后，我们来看影响查询结果的第 3 个因素：「机器时钟」。</p><p>假设我们已规避了上面提到的版本 Bug，例如，我们使用 Redis 5.0 版本，在 slave 查询一个 key，还会和 master 结果不同吗？答案是，还是有可能会的。</p><p>这就与 master / slave 的机器时钟有关了。无论是 master 还是 slave，在判断一个 key 是否过期时，都是基于「本机时钟」来判断的。</p><p>如果 slave 的机器时钟比 master 走得「快」，那就会导致，即使这个 key 还未过期，但以 slave 上视角来看，这个 key 其实已经过期了，那客户端在 slave 上查询时，就会返回 NULL。是不是很有意思？一个小小的过期 key，竟然藏匿这么多猫腻。</p><p>如果你也遇到了类似的情况，就可以通过上述步骤进行排查，确认是否踩到了这个坑。</p><p><strong>3) 主从切换会导致缓存雪崩？</strong></p><p>这个问题是上一个问题的延伸。</p><p>我们假设，slave 的机器时钟比 master 走得「快」，而且是「快很多」。此时，从 slave 角度来看，Redis 中的数据存在「大量过期」。如果此时操作「主从切换」，把 slave 提升为新的 master。</p><p>它成为 master 后，就会开始大量清理过期 key，此时就会导致以下结果：</p><ol><li>master 大量清理过期 key，主线程发生阻塞，无法及时处理客户端请求</li><li>Redis 中数据大量过期，引发缓存雪崩</li></ol><p>你看，当 master / slave 机器时钟严重不一致时，对业务的影响非常大！所以，如果你是 DBA 运维，一定要保证主从库的机器时钟一致性，避免发生这些问题。</p><p><strong>4) master / slave 大量数据不一致？</strong></p><p>还有一种场景，会导致 master / slave 的数据存在大量不一致。这就涉及到 Redis 的 maxmemory 配置了。Redis 的 maxmemory 可以控制整个实例的内存使用上限，超过这个上限，并且配置了淘汰策略，那么实例就开始淘汰数据。</p><p>但这里有个问题：<strong>假设 master / slave 配置的 maxmemory 不一样，那此时就会发生数据不一致。</strong></p><p>例如，master 配置的 maxmemory 为 5G，而 slave 的 maxmemory 为 3G，当 Redis 中的数据超过 3G 时，slave 就会「提前」开始淘汰数据，此时主从库数据发生不一致。</p><p><img src="/posts/42709/640-1712766433046-23.webp" alt></p><p>另外，尽管 master / slave 设置的 maxmemory 相同，如果你要调整它们的上限，也要格外注意，否则也会导致 slave 淘汰数据：</p><ul><li>调大 maxmemory 时，先调整 slave，再调整 master</li><li>调小 maxmemory 时，先调整 master，再调整 slave</li></ul><p>以此方式操作，就避免了 slave 提前超过 maxmemory 的问题。其实，你可以思考一下，发生这些问题的关键在哪？其根本原因在于，<strong>slave 超过 maxmemory 后，会「自行」淘汰数据</strong>。</p><p>如果不让 slave 自己淘汰数据，那这些问题是不是都可以规避了？没错。</p><p>针对这个问题，Redis 官方应该也收到了很多用户的反馈。在 Redis 5.0 版本增加了一个配置项：replica-ignore-maxmemory，默认 yes。这个参数表示，尽管 slave 内存超过了 maxmemory，也不会自行淘汰数据了！</p><p><strong>这样一来，slave 永远会向 master 看齐，只会老老实实地复制 master 发送过来的数据，不会自己再搞「小动作」。</strong></p><p>至此，master / slave 的数据就可以保证完全一致了！</p><blockquote><p>如果你使用的恰好是 5.0 版本，就不用担心这个问题了。</p></blockquote><p><strong>5) slave 竟然会有内存泄露问题？</strong></p><p>这是怎么发生的？我们具体来看一下。</p><p>当你在使用 Redis 时，符合以下场景，就会触发 slave 内存泄露：</p><ul><li>Redis 使用的是 4.0 以下版本</li><li>slave 配置项为 read-only=no（从库可写）</li><li>向 slave 写入了有过期时间的 key</li></ul><p>这时的 slave 就会发生内存泄露：<strong>slave 中的 key，即使到了过期时间，也不会自动清理。</strong>如果你不主动删除它，那这些 key 就会一直残留在 slave 内存中，消耗 slave 的内存。</p><p>最麻烦的是，你使用命令查询这些 key，却还查不到任何结果！这就 slave 「内存泄露」问题。</p><p><img src="/posts/42709/640-1712766433046-24.webp" alt></p><p>这其实也是 Redis 的一个 Bug，Redis 4.0 才修复了这个问题。解决方案是，<strong>在可写的 slave 上，写入带有过期时间 key 时，slave 会「记录」下来这些 key。</strong>然后 slave 会定时扫描这些 key，如果到达过期时间，则清理之。</p><p>如果你的业务需要在 slave 上临时存储数据，而且这些 key 也都设置了过期时间，那么就要注意这个问题了。你需要确认你的 Redis 版本，如果是 4.0 以下版本，一定要避免踩这个坑。</p><p>其实，最好的方案是，制定一个 Redis 使用规范，slave 必须强制设置为 read-only，不允许写，这样不仅可以保证 master / slave 的数据一致性，还避免了 slave 内存泄露问题。</p><p><strong>6) 为什么主从全量同步一直失败？</strong></p><p>在主从全量同步时，你可能会遇到同步失败的问题，具体场景如下：slave 向 master 发起全量同步请求，master 生成 RDB 后发给 slave，slave 加载 RDB。由于 RDB 数据太大，slave 加载耗时也会变得很长。此时你会发现，slave 加载 RDB 还未完成，master 和 slave 的连接却断开了，数据同步也失败了。</p><p>之后你又会发现，slave 又发起了全量同步，master 又生成 RDB 发送给 slave。同样地，slave 在加载 RDB 时，master / slave 同步又失败了，以此往复。</p><p>这是怎么回事？其实，这就是 Redis 的「复制风暴」问题。</p><p>什么是复制风暴？就像刚才描述的：<strong>主从全量同步失败，又重新开始同步，之后又同步失败，以此往复，恶性循环，持续浪费机器资源。</strong></p><p>为什么会导致这种问题呢？如果你的 Redis 有以下特点，就有可能发生这种问题：</p><ul><li>master 的实例数据过大，slave 在加载 RDB 时耗时太长</li><li>复制缓冲区（slave client-output-buffer-limit）配置过小</li><li>master 写请求量很大</li></ul><p>主从在全量同步数据时，master 接收到的写请求，会先写到主从「复制缓冲区」中，这个缓冲区的「上限」是配置决定的。当 slave 加载 RDB 太慢时，就会导致 slave 无法及时读取「复制缓冲区」的数据，这就引发了复制缓冲区「溢出」。</p><p>为了避免内存持续增长，此时的 master 会「强制」断开 slave 的连接，这时全量同步就会失败。之后，同步失败的 slave 又会「重新」发起全量同步，进而又陷入上面描述的问题中，以此往复，恶性循环，这就是所谓的「复制风暴」。</p><p>如何解决这个问题呢？</p><ol><li>Redis 实例不要太大，避免过大的 RDB</li><li>复制缓冲区配置的尽量大一些，给 slave 加载 RDB 留足时间，降低全量同步失败的概率</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先，这篇文章是转载的，哥们暂时还没这个工程经验（捂脸）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明明一个 key 设置了过期时间，怎么变成不过期了？&lt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Cpp包管理工具Conan2</title>
    <link href="https://joytsing.github.io/posts/36734/"/>
    <id>https://joytsing.github.io/posts/36734/</id>
    <published>2024-04-11T08:53:27.000Z</published>
    <updated>2024-04-11T10:25:32.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，先把<a href="https://conan.io/center">官网</a>和<a href="https://docs.conan.io/2/introduction.html">官方文档</a>放在这里。</p><p><img src="/posts/36734/conan-systems.png" alt></p><p>这个工具能让cpp开发者免去每个项目依赖都去make install或者都要源码编译的痛苦，相信就这一点经常写cpp的同志们就知道有切中痛点了，能够像pip一样帮你快速构建。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>建议cpp跟python一样内置一个包管理工具，2024年了在这种切实痛点的地方modern一点。</p><p>conan的安装非常简单，只需要</p><pre class="line-numbers language-sh"><code class="language-sh">pip install conan<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://docs.conan.io/2/tutorial/consuming_packages/build_simple_cmake_project.html">官方教程</a>中，把对应项目clone下来，按照对应的地方修改即可，注意，和之前vscode配置的不同，在使用conan初始化项目后编译链就确定了（或者你需要自己手写一套settings），默认的编译链则是输入：</p><pre class="line-numbers language-sh"><code class="language-sh">conan profile detect --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于clang编译链则是如下：</p><pre class="line-numbers language-sh"><code class="language-sh">[settings]arch=x86_64build_type=Releasecompiler=clangcompiler.cppstd=23compiler.version=17os=Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>msvc编译链如下：</p><pre class="line-numbers language-sh"><code class="language-sh">[settings]arch=x86_64build_type=Releasecompiler=msvccompiler.cppstd=14compiler.runtime=dynamiccompiler.version=193os=Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>gcc编译链如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">[</span>settings<span class="token punctuation">]</span>arch<span class="token operator">=</span>x86_64build_type<span class="token operator">=</span>Releasecompiler<span class="token operator">=</span>gcccompiler<span class="token punctuation">.</span>cppstd<span class="token operator">=</span><span class="token number">23</span>compiler<span class="token punctuation">.</span>libcxx<span class="token operator">=</span>libstdc<span class="token operator">++</span>compiler<span class="token punctuation">.</span>version<span class="token operator">=</span><span class="token number">13</span>os<span class="token operator">=</span>Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装包依赖"><a href="#安装包依赖" class="headerlink" title="安装包依赖"></a>安装包依赖</h3><p>对应的在conanfile.txt中写入需要的，对于官方的例子则是给好了：</p><pre><code>[requires]zlib/1.2.11[generators]CMakeDepsCMakeToolchain</code></pre><p>写好依赖后只需要</p><pre class="line-numbers language-sh"><code class="language-sh">conan install . --output-folder=build --build=missing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就帮你配置好依赖性了，非常方便。</p><h3 id="CMake对接"><a href="#CMake对接" class="headerlink" title="CMake对接"></a>CMake对接</h3><p>使用后会帮你生成<code>CMakeUserPresets.json</code>，这时候需要重新点工具链:</p><p><img src="/posts/36734/769b2dae762e41d18208c6469ca11504.png" alt></p><p>选择conan为你生成的toolchain即可，别的都一样</p><p><img src="/posts/36734/6f8cae5feb374f54bfe65845fb065285.png" alt></p><h3 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h3><p>开 <code>CMakeLists.txt</code> 文件，找到之前安装包的时候产生的命令行输出，添加 <code>find_package(你的包 REQUIRED)</code> 一行。并在 <strong>add_executable</strong> 的后面添加 <code>target_link_libraries(${PROJECT_NAME} 你的包::需要的模块)</code>。</p><p>好了，可以正常爽用了，不用再费劲写third-party的cmakelist和编译了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先，先把&lt;a href=&quot;https://conan.io/center&quot;&gt;官网&lt;/a&gt;和&lt;a href=&quot;https://docs.co
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>Redis最佳实践</title>
    <link href="https://joytsing.github.io/posts/41948/"/>
    <id>https://joytsing.github.io/posts/41948/</id>
    <published>2024-04-10T16:56:49.000Z</published>
    <updated>2024-04-10T17:20:38.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>学习他人的经验，首先还是抛出问题：</p><ul><li>我的 Redis 内存为什么增长这么快？</li><li>为什么我的 Redis 操作延迟变大了？</li><li>如何降低 Redis 故障发生的频率？</li><li>日常运维 Redis 需要注意什么？</li><li>部署 Redis 时，如何做好资源规划？</li><li>Redis 监控重点要关注哪些指标？</li></ul><h2 id="如何使用-Redis-更节省内存？"><a href="#如何使用-Redis-更节省内存？" class="headerlink" title="如何使用 Redis 更节省内存？"></a>如何使用 Redis 更节省内存？</h2><p>首先来看一下 Redis 内存方面的优化。</p><p>众所周知，Redis 的性能之所以如此之高，原因就在于它的数据都存储在「内存」中，所以访问 Redis 中的数据速度极快。但从资源利用率层面来说，机器的内存资源相比于磁盘，还是比较昂贵的。</p><p>当你的业务应用在 Redis 中存储数据很少时，你可能并不太关心内存资源的使用情况。但随着业务的发展，你的业务存储在 Redis 中的数据就会越来越多。如果没有提前制定好内存优化策略，那么等业务开始增长时，Redis 占用的内存也会开始膨胀。</p><p>所以，提前制定合理的内存优化策略，对于资源利用率的提升是很有必要的。</p><p><strong>1) 控制 key 的长度</strong></p><p>最简单直接的内存优化，就是控制 key 的长度。在开发业务时，你需要提前预估整个 Redis 中写入 key 的数量，如果 key 数量达到了百万级别，那么，过长的 key 名也会占用过多的内存空间。</p><p>所以，你需要保证 key 在简单、清晰的前提下，尽可能把 key 定义得短一些。例如，原有的 key 为 user:book:123，则可以优化为 u:bk:123。这样一来，你的 Redis 就可以节省大量的内存，这个方案对内存的优化非常直接和高效。</p><p><strong>2) 避免存储 bigkey</strong></p><p>除了控制 key 的长度之外，你同样需要关注 value 的大小，如果大量存储 bigkey，也会导致 Redis 内存增长过快。除此之外，客户端在读写 bigkey 时，还有产生性能问题（下文会具体详述）。</p><p>所以，你要避免在 Redis 中存储 bigkey：</p><ul><li>String：大小控制在 10KB 以下</li><li>List/Hash/Set/ZSet：元素数量控制在 1 万以下</li></ul><p><strong>3) 选择合适的数据类型</strong></p><p>Redis 提供了丰富的数据类型，这些数据类型在实现上，也对内存使用做了优化。具体来说就是，一种数据类型对应多种数据结构来实现：</p><p><img src="/posts/41948/640.webp" alt></p><p>例如，String、Set 在存储 int 数据时，会采用整数编码存储。Hash、ZSet 在元素数量比较少时（可配置），会采用压缩列表（ziplist）存储，在存储比较多的数据时，才会转换为哈希表和跳表。</p><p>作者这么设计的原因，就是为了进一步节约内存资源。那么你在存储数据时，就可以利用这些特性来优化 Redis 的内存。这里我给你的建议如下：</p><ul><li>String、Set：尽可能存储 int 类型数据</li><li>Hash、ZSet：存储的元素数量控制在转换阈值之下，以压缩列表存储，节约内存</li></ul><p><strong>4) 把 Redis 当作缓存使用</strong></p><p>Redis 数据存储在内存中，这也意味着其资源是有限的。你在使用 Redis 时，要把它当做缓存来使用，而不是数据库。所以，应用写入到  Redis 中的数据，尽可能地都设置「过期时间」。</p><p>业务应用在 Redis 中查不到数据时，再从后端数据库中加载到 Redis 中。</p><p><img src="/posts/41948/640-1712768648600-1.webp" alt></p><p>采用这种方案，可以让 Redis 中只保留经常访问的「热数据」，内存利用率也会比较高。</p><p><strong>5) 实例设置 maxmemory + 淘汰策略</strong></p><p>虽然你的 Redis key 都设置了过期时间，但如果你的业务应用写入量很大，并且过期时间设置得比较久，那么短期间内 Redis 的内存依旧会快速增长。如果不控制 Redis 的内存上限，也会导致使用过多的内存资源。</p><p>对于这种场景，需要提前预估业务数据量，然后给这个实例设置 maxmemory 控制实例的内存上限，这样可以避免 Redis 的内存持续膨胀。配置了 maxmemory，此时你还要设置数据淘汰策略，而淘汰策略如何选择，你需要结合你的业务特点来决定：</p><ul><li>volatile-lru / allkeys-lru：优先保留最近访问过的数据</li><li>volatile-lfu / allkeys-lfu：优先保留访问次数最频繁的数据（4.0+版本支持）</li><li>volatile-ttl ：优先淘汰即将过期的数据</li><li>volatile-random / allkeys-random：随机淘汰数据</li></ul><p><strong>6) 数据压缩后写入 Redis</strong></p><p>以上方案基本涵盖了 Redis 内存优化的各个方面。如果还想进一步优化 Redis 内存，还可以在业务应用中先将数据压缩，再写入到 Redis 中（例如采用 snappy、gzip 等压缩算法）。</p><p>当然，压缩存储的数据，客户端在读取时还需要解压缩，在这期间会消耗更多 CPU 资源，需要根据实际情况进行权衡。</p><h2 id="如何持续发挥-Redis-的高性能？"><a href="#如何持续发挥-Redis-的高性能？" class="headerlink" title="如何持续发挥 Redis 的高性能？"></a>如何持续发挥 Redis 的高性能？</h2><p>当决定引入 Redis 时，想必看中它最关键的一点就是：<strong>性能</strong>。</p><p>我们知道，一个单机版 Redis 就可以达到 10W QPS，这么高的性能，也意味着如果在使用过程中发生延迟情况，就会与我们的预期不符。所以，在使用 Redis 时，如何持续发挥它的高性能，避免操作延迟的情况发生，也是我们的关注焦点。</p><p><strong>1) 避免存储 bigkey</strong></p><p>存储 bigkey 除了前面讲到的使用过多内存之外，对 Redis 性能也会有很大影响。</p><p>由于 Redis 处理请求是单线程的，当你的应用在写入一个 bigkey 时，更多时间将消耗在「内存分配」上，这时操作延迟就会增加。同样地，删除一个 bigkey 在「释放内存」时，也会发生耗时。而且，当你在读取这个 bigkey 时，也会在「网络数据传输」上花费更多时间，此时后面待执行的请求就会发生排队，Redis 性能下降。</p><p><img src="/posts/41948/640-1712768648600-2.webp" alt></p><p>所以，业务应用尽量不要存储 bigkey，避免操作延迟发生。</p><blockquote><p>如果确实有存储 bigkey 的需求，可以把 bigkey 拆分为多个小 key 存储。</p></blockquote><p><strong>2) 开启 lazy-free 机制</strong></p><p>如果无法避免存储 bigkey，那么开启 Redis 的 lazy-free 机制。（4.0+版本支持）当开启这个机制后，Redis 在删除一个 bigkey 时，释放内存的耗时操作，将会放到后台线程中去执行，这样可以在最大程度上，避免对主线程的影响。</p><p><img src="/posts/41948/640-1712768648600-3.webp" alt></p><p><strong>3) 不使用复杂度过高的命令</strong></p><p>Redis 是单线程模型处理请求，除了操作 bigkey 会导致后面请求发生排队之外，在执行复杂度过高的命令时，也会发生这种情况。因为执行复杂度过高的命令，会消耗更多的 CPU 资源，主线程中的其它请求只能等待，这时也会发生排队延迟。</p><p>所以，你需要避免执行例如 SORT、SINTER、SINTERSTORE、ZUNIONSTORE、ZINTERSTORE 等聚合类命令。对于这种聚合类操作，我建议你把它放到客户端来执行，不要让 Redis 承担太多的计算工作。</p><p><strong>4) 执行 O(N) 命令时，关注 N 的大小</strong></p><p>规避使用复杂度过高的命令，就可以高枕无忧了么？答案是否定的。</p><p>当在执行 O(N) 命令时，同样需要注意 N 的大小。如果一次性查询过多的数据，也会在网络传输过程中耗时过长，操作延迟变大。所以，对于容器类型（List/Hash/Set/ZSet），在元素数量未知的情况下，一定不要无脑执行 LRANGE key 0 -1 / HGETALL / SMEMBERS / ZRANGE key 0 -1。</p><p>在查询数据时，你要遵循以下原则：</p><ol><li>先查询数据元素的数量（LLEN/HLEN/SCARD/ZCARD）</li><li>元素数量较少，可一次性查询全量数据</li><li>元素数量非常多，分批查询数据（LRANGE/HASCAN/SSCAN/ZSCAN）</li></ol><p><strong>5) 关注 DEL 时间复杂度</strong></p><p>你没看错，在删除一个 key 时，如果姿势不对，也有可能影响到 Redis 性能。删除一个 key，我们通常使用的是 DEL 命令，回想一下，你觉得 DEL 的时间复杂度是多少？O(1) ？其实不一定。</p><p>当你删除的是一个 String 类型 key 时，时间复杂度确实是 O(1)。但当你要删除的 key 是 List/Hash/Set/ZSet 类型，它的复杂度其实为 O(N)，N 代表元素个数。<strong>也就是说，删除一个 key，其元素数量越多，执行 DEL 也就越慢！</strong></p><p>原因在于，删除大量元素时，需要依次回收每个元素的内存，元素越多，花费的时间也就越久！而且，这个过程默认是在主线程中执行的，这势必会阻塞主线程，产生性能问题。</p><p>那删除这种元素比较多的 key，如何处理呢？分批删除：</p><ul><li>List类型：执行多次 LPOP/RPOP，直到所有元素都删除完成</li><li>Hash/Set/ZSet类型：先执行 HSCAN/SSCAN/SCAN 查询元素，再执行 HDEL/SREM/ZREM 依次删除每个元素</li></ul><p>没想到吧？一个小小的删除操作，稍微不小心，也有可能引发性能问题，在操作时需要格外注意。</p><p><strong>6) 批量命令代替单个命令</strong></p><p>当需要一次性操作多个 key 时，应该使用批量命令来处理。批量操作相比于多次单个操作的优势在于，可以显著减少客户端、服务端的来回网络 IO 次数。</p><ul><li>String / Hash 使用 MGET/MSET 替代 GET/SET，HMGET/HMSET 替代 HGET/HSET</li><li>其它数据类型使用 Pipeline，打包一次性发送多个命令到服务端执行</li></ul><p><img src="/posts/41948/640-1712768648600-4.webp" alt></p><p><strong>7) 避免集中过期 key</strong></p><p>Redis 清理过期 key 是采用定时 + 懒惰的方式来做的，而且这个过程都是在主线程中执行。如果业务存在大量 key 集中过期的情况，那么 Redis 在清理过期 key 时，也会有阻塞主线程的风险。</p><p><img src="/posts/41948/640-1712768648600-5.webp" alt></p><p>想要避免这种情况发生，你可以在设置过期时间时，增加一个随机时间，把这些 key 的过期时间打散，从而降低集中过期对主线程的影响。</p><p><strong>8) 使用长连接操作 Redis，合理配置连接池</strong></p><p>业务应该使用长连接操作 Redis，避免短连接。当使用短连接操作 Redis 时，每次都需要经过 TCP 三次握手、四次挥手，这个过程也会增加操作耗时。同时，客户端应该使用连接池的方式访问 Redis，并设置合理的参数，长时间不操作 Redis 时，需及时释放连接资源。</p><p><strong>9) 只使用 db0</strong></p><p>尽管 Redis 提供了 16 个 db，但只建议你使用 db0。为什么呢？</p><ol><li>在一个连接上操作多个 db 数据时，每次都需要先执行 SELECT，这会给 Redis 带来额外的压力</li><li>使用多个 db 的目的是，按不同业务线存储数据，那为何不拆分多个实例存储呢？拆分多个实例部署，多个业务线不会互相影响，还能提高 Redis 的访问性能</li><li>Redis Cluster 只支持 db0，如果后期你想要迁移到 Redis Cluster，迁移成本高</li></ol><p><strong>10) 使用读写分离 + 分片集群</strong></p><p>如果业务读请求量很大，那么可以采用部署多个从库的方式，实现读写分离，让 Redis 的从库分担读压力，进而提升性能。</p><p><img src="/posts/41948/640-1712768648600-6.webp" alt></p><p>如果业务写请求量很大，单个 Redis 实例已无法支撑这么大的写流量，那么此时你需要使用分片集群，分担写压力。</p><p><img src="/posts/41948/640-1712768648600-7.webp" alt></p><p><strong>11) 不开启 AOF 或 AOF 配置为每秒刷盘</strong></p><p>如果对于丢失数据不敏感的业务，我建议你不开启 AOF，避免 AOF 写磁盘拖慢 Redis 的性能。如果确实需要开启 AOF，那么建议配置为 appendfsync everysec，把数据持久化的刷盘操作，放到后台线程中去执行，尽量降低 Redis 写磁盘对性能的影响。</p><p><strong>12) 使用物理机部署 Redis</strong></p><p>Redis 在做数据持久化时，采用创建子进程的方式进行。而创建子进程会调用操作系统的 fork 系统调用，这个系统调用的执行耗时，与系统环境有关。虚拟机环境执行 fork 的耗时，要比物理机慢得多，所以Redis 应该尽可能部署在物理机上。</p><p><strong>13) 关闭操作系统内存大页机制</strong></p><p>Linux 操作系统提供了内存大页机制，其特点在于，每次应用程序向操作系统申请内存时，申请单位由之前的 4KB 变为了 2MB。</p><p>这会导致什么问题呢？当 Redis 在做数据持久化时，会先 fork 一个子进程，此时主进程和子进程共享相同的内存地址空间。当主进程需要修改现有数据时，会采用写时复制（Copy On Write）的方式进行操作，在这个过程中，需要重新申请内存。如果申请内存单位变为了 2MB，那么势必会增加内存申请的耗时，如果此时主进程有大量写操作，需要修改原有的数据，那么在此期间，操作延迟就会变大。</p><p><img src="/posts/41948/640-1712768648600-8.webp" alt></p><p>所以，为了避免出现这种问题，需要在操作系统上关闭内存大页机制。</p><h2 id="如何保证-Redis-的可靠性？"><a href="#如何保证-Redis-的可靠性？" class="headerlink" title="如何保证 Redis 的可靠性？"></a>如何保证 Redis 的可靠性？</h2><p>保证 Redis 可靠性其实并不难，但难的是如何做到「持续稳定」。</p><p>下面会从「资源隔离」、「多副本」、「故障恢复」这三大维度，分析保障 Redis 可靠性的最佳实践。</p><p><strong>1) 按业务线部署实例</strong></p><p>提升可靠性的第一步，就是「资源隔离」。最好按不同的业务线来部署 Redis 实例，这样当其中一个实例发生故障时，不会影响到其它业务。这种资源隔离的方案，实施成本是最低的，但成效却是非常大的。</p><p><strong>2) 部署主从集群</strong></p><p>如果只使用单机版 Redis，那么就会存在机器宕机服务不可用的风险。所以，你需要部署「多副本」实例，即主从集群，这样当主库宕机后，依旧有从库可以使用，避免了数据丢失的风险，也降低了服务不可用的时间。</p><p>在部署主从集群时，还需要注意，主从库需要分布在不同机器上，避免交叉部署。这么做的原因在于，通常情况下，Redis 的主库会承担所有的读写流量，所以我们一定要优先保证主库的稳定性，即使从库机器异常，也不要对主库造成影响。</p><p>而且，有时我们需要对 Redis 做日常维护，例如数据定时备份等操作，这时就可以只在从库上进行，这只会消耗从库机器的资源，也避免了对主库的影响。</p><p><strong>3) 合理配置主从复制参数</strong></p><p>在部署主从集群时，如果参数配置不合理，也有可能导致主从复制发生问题：</p><ul><li>主从复制中断</li><li>从库发起全量复制，主库性能受到影响</li></ul><p>在这方面有以下 2 点：</p><ol><li>设置合理的 repl-backlog 参数：过小的 repl-backlog 在写流量比较大的场景下，主从复制中断会引发全量复制数据的风险</li><li>设置合理的 slave client-output-buffer-limit：当从库复制发生问题时，过小的 buffer 会导致从库缓冲区溢出，从而导致复制中断</li></ol><p><strong>4) 部署哨兵集群，实现故障自动切换</strong></p><p>只部署了主从节点，但故障发生时是无法自动切换的，所以，你还需要部署哨兵集群，实现故障的「自动切换」。而且，多个哨兵节点需要分布在不同机器上，实例为奇数个，防止哨兵选举失败，影响切换时间。</p><p>以上这些就是保障 Redis「高可靠」实践优化，这些都是部署和运维层的优化。</p><h2 id="日常运维-Redis-需要注意什么？"><a href="#日常运维-Redis-需要注意什么？" class="headerlink" title="日常运维 Redis 需要注意什么？"></a>日常运维 Redis 需要注意什么？</h2><p><strong>1) 禁止使用 KEYS/FLUSHALL/FLUSHDB 命令</strong></p><p>执行这些命令，会长时间阻塞 Redis 主线程，危害极大，所以你必须禁止使用它。如果确实想使用这些命令：</p><ul><li>SCAN 替换 KEYS</li><li>4.0+版本可使用 FLUSHALL/FLUSHDB ASYNC，清空数据的操作放在后台线程执行</li></ul><p><strong>2) 扫描线上实例时，设置休眠时间</strong></p><p>不管是使用 SCAN 扫描线上实例，还是对实例做 bigkey 统计分析，在扫描时一定记得设置休眠时间。防止在扫描过程中，实例 OPS 过高对 Redis 产生性能抖动。</p><p><strong>3) 慎用 MONITOR 命令</strong></p><p>有时在排查 Redis 问题时，你会使用 MONITOR 查看 Redis 正在执行的命令。但如果 Redis OPS 比较高，那么在执行 MONITOR 会导致 Redis 输出缓冲区的内存持续增长，这会严重消耗 Redis 的内存资源，甚至会导致实例内存超过 maxmemory，引发数据淘汰。</p><p><img src="/posts/41948/640-1712768648600-9.webp" alt></p><p>所以在执行 MONITOR 命令时，一定要谨慎，尽量少用。</p><p><strong>4) 从库必须设置为 slave-read-only</strong></p><p>从库必须设置为 slave-read-only 状态，避免从库写入数据，导致主从数据不一致。除此之外，从库如果是非 read-only 状态，如果你使用的是 4.0 以下的 Redis，它存在这样的 Bug：</p><p><strong>从库写入了有过期时间的数据，不会做定时清理和释放内存。</strong></p><p>这会造成从库的内存泄露！这个问题直到 4.0 版本才修复，你在配置从库时需要格外注意。</p><p><strong>5) 合理配置 timeout 和 tcp-keepalive 参数</strong></p><p>如果因为网络原因，导致大量客户端连接与 Redis 意外中断，恰好 Redis 配置的 maxclients 参数比较小，此时有可能导致客户端无法与服务端建立新的连接（服务端认为超过了 maxclients）。</p><p>造成这个问题原因在于，客户端与服务端每建立一个连接，Redis 都会给这个客户端分配了一个 client fd。<strong>当客户端与服务端网络发生问题时，服务端并不会立即释放这个 client fd。</strong>什么时候释放呢？</p><p>Redis 内部有一个定时任务，会定时检测所有 client 的空闲时间是否超过配置的 timeout 值。如果 Redis 没有开启 tcp-keepalive 的话，服务端直到配置的 timeout 时间后，才会清理释放这个 client fd。</p><p>在没有清理之前，如果还有大量新连接进来，就有可能导致 Redis 服务端内部持有的 client fd 超过了 maxclients，这时新连接就会被拒绝。针对这种情况的优化建议是：</p><ol><li>不要配置过高的 timeout：让服务端尽快把无效的 client fd 清理掉</li><li>Redis 开启 tcp-keepalive：这样服务端会定时给客户端发送 TCP 心跳包，检测连接连通性，当网络异常时，可以尽快清理僵尸 client fd</li></ol><p><strong>6) 调整 maxmemory 时，注意主从库的调整顺序</strong></p><p>Redis 5.0 以下版本存在这样一个问题：<strong>从库内存如果超过了 maxmemory，也会触发数据淘汰。</strong></p><p>在某些场景下，从库是可能优先主库达到 maxmemory 的（例如在从库执行 MONITOR 命令，输出缓冲区占用大量内存），那么此时从库开始淘汰数据，主从库就会产生不一致。</p><p>要想避免此问题，在调整 maxmemory 时，一定要注意主从库的修改顺序：</p><ul><li>调大 maxmemory：先修改从库，再修改主库</li><li>调小 maxmemory：先修改主库，再修改从库</li></ul><p>直到 Redis 5.0，Redis 才增加了一个配置 replica-ignore-maxmemory，默认从库超过 maxmemory 不会淘汰数据，才解决了此问题。</p><h2 id="Redis-安全如何保证？"><a href="#Redis-安全如何保证？" class="headerlink" title="Redis 安全如何保证？"></a>Redis 安全如何保证？</h2><p>无论如何，在互联网时代，安全问题一定是我们需要随时警戒的。你可能听说过 Redis 被注入可执行脚本，然后拿到机器 root 权限的安全问题，都是因为在部署 Redis 时，没有把安全风险注意起来。针对这方面：</p><ol><li>不要把 Redis 部署在公网可访问的服务器上</li><li>部署时不使用默认端口 6379</li><li>以普通用户启动 Redis 进程，禁止 root 用户启动</li><li>限制 Redis 配置文件的目录访问权限</li><li>推荐开启密码认证</li><li>禁用/重命名危险命令（KEYS/FLUSHALL/FLUSHDB/CONFIG/EVAL）</li></ol><p>只要你把这些做到位，基本上就可以保证 Redis 的安全风险在可控范围内。</p><h2 id="如何预防-Redis-问题？"><a href="#如何预防-Redis-问题？" class="headerlink" title="如何预防 Redis 问题？"></a>如何预防 Redis 问题？</h2><p>要想提前预防 Redis 问题，你需要做好以下两个方面：</p><ol><li>合理的资源规划</li><li>完善的监控预警</li></ol><p>先来说资源规划。在部署 Redis 时，如果你可以提前做好资源规划，可以避免很多因为资源不足产生的问题：</p><ol><li>保证机器有足够的 CPU、内存、带宽、磁盘资源</li><li>提前做好容量规划，主库机器预留一半内存资源，防止主从机器网络故障，引发大面积全量同步，导致主库机器内存不足的问题</li><li>单个实例内存建议控制在 10G 以下，大实例在主从全量同步、RDB 备份时有阻塞风险</li></ol><p>再来看监控如何做。监控预警是提高稳定性的重要环节，完善的监控预警，可以把问题提前暴露出来，这样我们才可以快速反应，把问题最小化：</p><ol><li>做好机器 CPU、内存、带宽、磁盘监控，资源不足时及时报警，任意资源不足都会影响 Redis 性能</li><li>设置合理的 slowlog 阈值，并对其进行监控，slowlog 过多及时报警</li><li>监控组件采集 Redis INFO 信息时，采用长连接，避免频繁的短连接</li><li>做好实例运行时监控，重点关注 expired_keys、evicted_keys、latest_fork_usec 指标，这些指标短时突增可能会有阻塞风险</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;学习他人的经验，首先还是抛出问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我的 Redis 内存为什么增长这么快？&lt;/li&gt;
&lt;li&gt;为什么我的 Red
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="工程经验" scheme="https://JoyTsing.github.io/tags/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群进化之路</title>
    <link href="https://joytsing.github.io/posts/51730/"/>
    <id>https://joytsing.github.io/posts/51730/</id>
    <published>2024-04-10T09:14:02.000Z</published>
    <updated>2024-04-10T14:38:41.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>我使用 Redis 的场景很简单，只使用单机版 Redis 会有什么问题吗？</li><li>我的 Redis 故障宕机了，数据丢失了怎么办？如何能保证我的业务应用不受影响？</li><li>为什么需要主从集群？它有什么优势？</li><li>什么是分片集群？我真的需要分片集群吗？</li><li>…</li></ul><p>高性能的 Redis 集群为了做到稳定、高性能，都采取了哪些优化方案，为什么要这么做？</p><h2 id="从最简单的开始：单机版-Redis"><a href="#从最简单的开始：单机版-Redis" class="headerlink" title="从最简单的开始：单机版 Redis"></a>从最简单的开始：单机版 Redis</h2><p>首先从最简单的场景开始。假设现在有一个业务应用，需要引入 Redis 来提高应用的性能，可以选择部署一个单机版的 Redis 来使用，就像这样：</p><p><img src="/posts/51730/640.webp" alt></p><p>这个架构非常简单，业务应用可以把 Redis 当做缓存来使用，从 MySQL 中查询数据，然后写入到 Redis 中，之后业务应用再从 Redis 中读取这些数据，由于 Redis 的数据都存储在内存中，所以这个速度飞快。</p><p>如果业务体量并不大，那这样的架构模型基本可以满足你的需求。是不是很简单？随着时间的推移，你的业务体量逐渐发展起来了，Redis 中存储的数据也越来越多，此时你的业务应用对 Redis 的依赖也越来越重。但是突然有一天Redis 因为某些原因宕机了，这时所有业务流量，都会打到后端 MySQL 上，这会导致 MySQL 压力剧增，严重的话甚至会压垮 MySQL。</p><p><img src="/posts/51730/640-1712746680741-3.webp" alt></p><p>这时你应该怎么办？首先肯定需要赶紧重启 Redis，让它可以继续提供服务。但是，因为之前 Redis 中的数据都在内存中，尽管你现在把 Redis 重启了，之前的数据也都丢失了。重启后的 Redis 虽然可以正常工作，但是由于 Redis 中没有任何数据，业务流量还是都会打到后端 MySQL 上，MySQL 的压力还是很大。</p><p>这可怎么办？有没有什么好的办法解决这个问题？既然 Redis 只把数据存储在内存中，那是否可以把这些数据也写一份到磁盘上呢？如果采用这种方式，当 Redis 重启时，我们把磁盘中的数据快速<strong>恢复</strong>到内存中，这样它就可以继续正常提供服务了。是的，这是一个很好的解决方案，这个把内存数据写到磁盘上的过程，就是「数据持久化」。</p><h2 id="数据持久化：有备无患"><a href="#数据持久化：有备无患" class="headerlink" title="数据持久化：有备无患"></a>数据持久化：有备无患</h2><p>数据持久化具体应该怎么做呢？最容易想到的一个方案是，Redis 每一次执行写操作，除了写内存之外，同时也写一份到磁盘上，就像这样：</p><p><img src="/posts/51730/640-1712746720874-7.webp" alt></p><p>但仔细想一下，这个方案有个问题：客户端的每次写操作，既需要写内存，又需要写磁盘，而写磁盘的耗时相比于写内存来说，肯定要慢很多！这势必会影响到 Redis 的性能。如何规避这个问题？</p><p>可以这样优化：Redis 写内存由主线程来做，写内存完成后就给客户端返回结果，然后 Redis 用另一个线程去写磁盘，这样就可以避免主线程写磁盘对性能的影响。这确实是一个好方案。除此之外，我们可以换个角度，思考一下还有什么方式可以持久化数据？</p><p>这时就要结合 Redis 的使用场景来考虑了。在使用 Redis 时，通常把它用作什么场景？缓存。把 Redis 当做缓存来用，意味着尽管 Redis 中没有保存全量数据，对于不在缓存中的数据，我们的业务应用依旧可以通过查询后端数据库得到结果，只不过查询后端数据的速度会慢一点而已，但对业务结果其实是没有影响的。基于这个特点，我们的 Redis 数据持久化还可以用「数据快照」的方式来做。</p><p>那什么是数据快照呢？简单来讲可以这么理解：</p><ol><li>把 Redis 想象成一个水杯，向 Redis 写入数据，就相当于往这个杯子里倒水</li><li>此时拿一个相机给这个水杯拍一张照片，拍照的这一瞬间，照片中记录到这个水杯中水的容量，就是水杯的数据快照</li></ol><p><img src="/posts/51730/640-1712746819053-12.webp" alt></p><p>也就是说，Redis 的数据快照，是记录某一时刻下 Redis 中的数据，然后只需要把这个数据快照写到磁盘上就可以了。它的优势在于，只在需要持久化时，把数据「一次性」写入磁盘，其它时间都不需要操作磁盘。基于这个方案可以<strong>定时</strong>给 Redis 做数据快照，把数据持久化到磁盘上。</p><p><img src="/posts/51730/640-1712746906562-15.webp" alt></p><p>其实，上面说的这些持久化方案，就是 Redis 的「RDB」和「AOF」：</p><ul><li>RDB：只持久化某一时刻的数据快照到磁盘上（创建一个子进程来做）</li><li>AOF：每一次写操作都持久到磁盘（主线程写内存，根据策略可以配置由主线程还是子线程进行数据持久化）</li></ul><p>它们的区别除了上面讲到的，还有以下特点：</p><ol><li>RDB 采用二进制 + 数据压缩的方式写磁盘，这样文件体积小，数据恢复速度也快</li><li>AOF 记录的是每一次写命令，数据最全，但文件体积大，数据恢复速度慢</li></ol><p>如果让你来选择持久化方案，可以这样选择：</p><ol><li>如果业务对于数据丢失不敏感，采用 RDB 方案持久化数据</li><li>如果业务对数据完整性要求比较高，采用 AOF 方案持久化数据</li></ol><p>假设业务对 Redis 数据完整性要求比较高，选择了 AOF 方案，那此时你又会遇到这些问题：</p><ol><li>AOF 记录每一次写操作，随着时间增长，AOF 文件体积会越来越大</li><li>这么大的 AOF 文件，在数据恢复时变得非常慢</li></ol><p>这怎么办？数据完整性要求变高了，恢复数据也变困难了？有没有什么方法，可以缩小文件体积？提升恢复速度呢？由于 AOF 文件中记录的都是每一次写操作，但对于同一个 key 可能会发生多次修改，只保留最后一次被修改的值，是不是也可以？这就是「AOF rewrite」，也可以把它理解为 AOF 「瘦身」。</p><p>可以对 AOF 文件定时 rewrite，避免这个文件体积持续膨胀，这样在恢复时就可以缩短恢复时间了。</p><p><img src="/posts/51730/640-1712746985484-18.webp" alt></p><p>再进一步思考一下，还有没有办法继续缩小 AOF 文件？回顾一下我们前面讲到的，RDB 和 AOF 各自的特点：</p><ol><li>RDB 以二进制 + 数据压缩方式存储，文件体积小</li><li>AOF 记录每一次写命令，数据最全</li></ol><p>可否利用它们各自的优势呢？当然可以，这就是 Redis 的「混合持久化」。具体来说，当 AOF rewrite 时，Redis 先以 RDB 格式在 AOF 文件中写入一个数据快照，再把在这期间产生的每一个写命令，追加到 AOF 文件中。因为 RDB 是二进制压缩写入的，这样 AOF 文件体积就变得更小了。</p><p><img src="/posts/51730/640-1712746995883-21.webp" alt></p><blockquote><p>Redis 4.0 以上版本才支持混合持久化。</p></blockquote><p>这么一番优化Redis再也不用担心实例宕机了，当发生宕机时就可以用持久化文件快速恢复 Redis 中的数据。</p><p>但这样就没问题了吗？仔细想一下，虽然我们已经把持久化的文件优化到最小了，但在恢复数据时依旧是需要时间的，在这期间你的业务应用还是会受到影响，这怎么办？有没有更好的方案？</p><p>一个实例宕机，只能用恢复数据来解决，那是否可以部署多个 Redis 实例，然后让这些实例数据保持实时同步，这样当一个实例宕机时，我们在剩下的实例中选择一个继续提供服务就好了。</p><h2 id="主从复制：多副本"><a href="#主从复制：多副本" class="headerlink" title="主从复制：多副本"></a>主从复制：多副本</h2><p>此时，可以部署多个 Redis 实例，架构模型就变成了这样：</p><p><img src="/posts/51730/640-1712759373096-24.webp" alt></p><p>我们这里把实时读写的节点叫做 master，另一个实时同步数据的节点叫做 slave，采用多副本的方案，它的优势是：</p><ol><li>缩短不可用时间：master 发生宕机，我们可以手动把 slave 提升为 master 继续提供服务</li><li>提升读性能：让 slave 分担一部分读请求，提升应用的整体性能</li></ol><p><img src="/posts/51730/640-1712759373096-25.webp" alt></p><p>这个方案不错，不仅节省了数据恢复的时间，还能提升性能，那它有什么问题吗？</p><p>它的问题在于：当 master 宕机时，我们需要「手动」把 slave 提升为 master，这个过程也是需要花费时间的。虽然比恢复数据要快得多，但还是需要人工介入处理。一旦需要人工介入，就必须要算上人的反应时间、操作时间，所以，在这期间业务应用依旧会受到影响。</p><p>怎么解决这个问题？我们是否可以把这个切换的过程，变成自动化呢？对于这种情况，我们需要一个「故障自动切换」机制，这就是我们经常听到的「哨兵」所具备的能力。</p><h2 id="哨兵：故障自动切换"><a href="#哨兵：故障自动切换" class="headerlink" title="哨兵：故障自动切换"></a>哨兵：故障自动切换</h2><p>现在，可以引入一个「观察者」，让这个观察者去实时监测 master 的健康状态，这个观察者就是「哨兵」。具体如何做？</p><ol><li>哨兵每间隔一段时间，询问 master 是否正常</li><li>master 正常回复，表示状态正常，回复超时表示异常</li><li>哨兵发现异常，发起主从切换</li></ol><p><img src="/posts/51730/640-1712759415184-30.webp" alt></p><p>但这里还有一个问题，如果 master 状态正常，但这个哨兵在询问 master 时，它们之间的网络发生了问题，那这个哨兵可能会误判。</p><p><img src="/posts/51730/640-1712759446267-33.webp" alt></p><p>这个问题怎么解决？答案是，可以部署多个哨兵，让它们分布在不同的机器上，它们一起监测 master 的状态，流程就变成了这样：</p><ol><li>多个哨兵每间隔一段时间，询问 master 是否正常</li><li>master 正常回复，表示状态正常，回复超时表示异常</li><li>一旦有一个哨兵判定 master 异常（不管是否是网络问题），就询问其它哨兵，如果多个哨兵（设置一个阈值）都认为 master 异常了，这才判定 master 确实发生了故障</li><li>多个哨兵经过协商后，判定 master 故障，则发起主从切换</li></ol><p>所以，我们用多个哨兵互相协商来判定 master 的状态，这样一来，就可以大大降低误判的概率。哨兵协商判定 master 异常后，这里还有一个问题：<strong>由哪个哨兵来发起主从切换呢？</strong></p><p>答案是，选出一个哨兵「领导者」，由这个领导者进行主从切换。问题又来了，这个领导者怎么选？在选举哨兵领导者时，我们可以制定这样一个选举规则：</p><ol><li>每个哨兵都询问其它哨兵，请求对方为自己投票</li><li>每个哨兵只投票给第一个请求投票的哨兵，且只能投票一次</li><li>首先拿到超过半数投票的哨兵，当选为领导者，发起主从切换</li></ol><p>其实，这个选举的过程就是我们经常听到的：分布式系统领域中的「共识算法」。</p><p>什么是共识算法？我们在多个机器部署哨兵，它们需要共同协作完成一项任务，所以它们就组成了一个「分布式系统」。在分布式系统领域，多个节点如何就一个问题达成共识的算法，就叫共识算法。在这个场景下，多个哨兵共同协商，选举出一个都认可的领导者，就是使用共识算法完成的。</p><p>这个算法还规定节点的数量必须是奇数个，这样可以保证系统中即使有节点发生了故障，剩余超过「半数」的节点状态正常，依旧可以提供正确的结果，也就是说，这个算法还兼容了存在故障节点的情况。</p><blockquote><p>共识算法在分布式系统领域有很多，例如 Paxos、Raft，哨兵选举领导者这个场景，使用的是 Raft 共识算法，因为它足够简单，且易于实现。</p></blockquote><p>现在，我们用多个哨兵共同监测 Redis 的状态，这样一来，就可以避免误判的问题了，架构模型就变成了这样：</p><p><img src="/posts/51730/640-1712759591360-36.webp" alt></p><p>随着时间的发展，业务体量开始迎来了爆炸性增长，此时架构模型，还能够承担这么大的流量吗？一起来分析一下：</p><ol><li>稳定性：Redis 故障宕机，我们有哨兵 + 副本，可以自动完成主从切换</li><li>性能：读请求量增长，我们可以再部署多个 slave，读写分离，分担读压力</li><li>性能：写请求量增长，但我们只有一个 master 实例，这个实例达到瓶颈怎么办？</li></ol><p>看到了么，当你的写请求量越来越大时，一个 master 实例可能就无法承担这么大的写流量了。要想完美解决这个问题，此时你就需要考虑使用「分片集群」了。</p><h2 id="分片集群：横向扩展"><a href="#分片集群：横向扩展" class="headerlink" title="分片集群：横向扩展"></a>分片集群：横向扩展</h2><p>什么是「分片集群」？</p><p>简单来讲，一个实例扛不住写压力，那我们是否可以部署多个实例，然后把这些实例按照一定规则组织起来，把它们当成一个整体，对外提供服务，这样不就可以解决集中写一个实例的瓶颈问题吗？</p><p>所以，现在的架构模型就变成了这样：</p><p><img src="/posts/51730/640-1712759631118-39.webp" alt></p><p>现在问题又来了，这么多实例如何组织呢？我们制定规则如下：</p><ol><li>每个节点各自存储一部分数据，所有节点数据之和才是全量数据</li><li>制定一个路由规则，对于不同的 key，把它路由到固定一个实例上进行读写</li></ol><p>而分片集群根据路由规则所在位置的不同，还可以分为两大类：</p><ol><li>客户端分片</li><li>服务端分片</li></ol><p>客户端分片指的是，key 的路由规则放在客户端来做，就是下面这样：</p><p><img src="/posts/51730/640-1712759646445-42.webp" alt></p><p>这个方案的缺点是，客户端需要维护这个路由规则，也就是说，你需要把路由规则写到你的业务代码中。如何做到不把路由规则耦合在业务代码中呢？你可以这样优化，把这个路由规则封装成一个模块，当需要使用时，集成这个模块就可以了。</p><p>这就是 Redis Cluster 的采用的方案。</p><p><img src="/posts/51730/640-1712759661868-45.webp" alt></p><blockquote><p>Redis Cluster 内置了哨兵逻辑，无需再部署哨兵。</p></blockquote><p>当使用 Redis Cluster 时，业务应用需要使用配套的 Redis SDK，这个 SDK 内就集成好了路由规则，不需要你自己编写了。</p><p>再来看服务端分片，这种方案指的是，路由规则不放在客户端来做，而是在客户端和服务端之间增加一个「中间代理层」，这个代理就是我们经常听到的 Proxy。而数据的路由规则，就放在这个 Proxy 层来维护。这样一来，你就无需关心服务端有多少个 Redis 节点了，只需要和这个 Proxy 交互即可。</p><p>Proxy 会把你的请求根据路由规则，转发到对应的 Redis 节点上，而且，当集群实例不足以支撑更大的流量请求时，还可以横向扩容，添加新的 Redis 实例提升性能，这一切对于你的客户端来说，都是透明无感知的。</p><p>业界开源的 Redis 分片集群方案，例如 Twemproxy、Codis 就是采用的这种方案。</p><p><img src="/posts/51730/640-1712759695847-48.webp" alt></p><blockquote><p>分片集群在数据扩容时，还涉及到了很多细节，这块内容不是本文章重点，所以暂不详述。</p></blockquote><p>至此，当使用分片集群后，对于未来更大的流量压力，都可以从容面对了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如何一步步构建一个稳定、高性能的 Redis 集群：</p><ul><li>首先，在使用最简单的单机版 Redis 时，我们发现当 Redis 故障宕机后，数据无法恢复的问题，因此想到了「数据持久化」，把内存中的数据也持久化到磁盘上一份，这样 Redis 重启后就可以从磁盘上快速恢复数据。</li><li>在进行数据持久化时，我们又面临如何更高效地将数据持久化到磁盘的问题。之后发现 Redis 提供了 RDB 和 AOF 两种方案，分别对应了数据快照和实时的命令记录。当我们对数据完整性要求不高时，可以选择 RDB 持久化方案。如果对于数据完整性要求较高，那么可以选择 AOF 持久化方案。</li><li>但是我们又发现，AOF 文件体积会随着时间增长变得越来越大，此时我们想到的优化方案是，使用 AOF rewrite 的方式对其进行瘦身，减小文件体积，再后来，我们发现可以结合 RDB 和 AOF 各自的优势，在 AOF rewrite 时使用两者结合的「混合持久化」方式，又进一步减小了 AOF 文件体积。</li><li>之后，我们发现尽管可以通过数据恢复的方式还原数据，但恢复数据也是需要花费时间的，这意味着业务应用还是会受到影响。我们进一步优化，采用「多副本」的方案，让多个实例保持实时同步，当一个实例故障时，可以手动把其它实例提升上来继续提供服务。</li><li>但是这样也有问题，手动提升实例上来，需要人工介入，人工介入操作也需要时间，我们开始想办法把这个流程变得自动化，所以我们又引入了「哨兵」集群，哨兵集群通过互相协商的方式，发现故障节点，并可以自动完成切换，这样就大幅降低了对业务应用的影响。</li><li>最后，我们把关注点聚焦在如何支撑更大的写流量上，所以，我们又引入了「分片集群」来解决这个问题，让多个 Redis 实例分摊写压力，未来面对更大的流量，我们还可以添加新的实例，横向扩展，进一步提升集群的性能。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我使用 Redis 的场景很简单，只使用单机版 Redis 会有什么问题吗？&lt;/li&gt;
&lt;li&gt;我的 Redis 故障宕机了，数
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>解决Redis缓存和数据库一致性问题</title>
    <link href="https://joytsing.github.io/posts/10748/"/>
    <id>https://joytsing.github.io/posts/10748/</id>
    <published>2024-04-10T08:29:14.000Z</published>
    <updated>2024-04-10T09:06:42.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>到底是更新缓存还是删缓存？</li><li>到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？</li><li>为什么要引入消息队列保证一致性？</li><li>延迟双删会有什么问题？到底要不要用？</li><li>…</li></ul><h2 id="引入缓存提高性能"><a href="#引入缓存提高性能" class="headerlink" title="引入缓存提高性能"></a>引入缓存提高性能</h2><p>如果业务处于起步阶段，流量非常小，那无论是读请求还是写请求，直接操作数据库即可，这时架构模型是这样的：</p><p><img src="/posts/10748/640.webp" alt></p><p>但随着业务量的增长，项目请求量越来越大，这时如果每次都从数据库中读数据，那肯定会有性能问题。这个阶段通常的做法是，引入「缓存」来提高读性能，架构模型就变成了这样：</p><p><img src="/posts/10748/640-1712737981539-1.webp" alt></p><p>当下优秀的缓存中间件，当属 Redis 莫属，它不仅性能非常高，还提供了很多友好的数据类型，可以很好地满足我们的业务需求。</p><p>但引入缓存之后，就会面临一个问题：<strong>之前数据只存在数据库中，现在要放到缓存中读取，具体要怎么存呢？</strong></p><p>最简单直接的方案是「全量数据刷到缓存中」：</p><ul><li>数据库的数据，全量刷入缓存（不设置失效时间）</li><li>写请求只更新数据库，不更新缓存</li><li>启动一个定时任务，定时把数据库的数据，更新到缓存中</li></ul><p><img src="/posts/10748/640-1712737981539-2.webp" alt></p><p>这个方案的优点是，所有读请求都可以直接「命中」缓存，不需要再查数据库，性能非常高。但缺点也很明显，有 2 个问题：</p><ol><li><strong>缓存利用率低</strong>：不经常访问的数据，还一直留在缓存中</li><li><strong>数据不一致</strong>：因为是「定时」刷新缓存，缓存和数据库存在不一致（取决于定时任务的执行频率）</li></ol><p>所以，这种方案一般更适合业务「体量小」，且对数据一致性要求不高的业务场景。</p><p>那如果我们的业务体量很大，怎么解决这 2 个问题呢？</p><h2 id="缓存利用率和一致性问题"><a href="#缓存利用率和一致性问题" class="headerlink" title="缓存利用率和一致性问题"></a>缓存利用率和一致性问题</h2><p>先来看第一个问题，如何提高缓存利用率？想要缓存利用率「最大化」，我们很容易想到的方案是，缓存中只保留最近访问的「热数据」。但具体要怎么做呢？</p><p>我们可以这样优化：</p><ul><li>写请求依旧只写数据库</li><li>读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存</li><li>同时，写入缓存中的数据，都设置失效时间</li></ul><p><img src="/posts/10748/640-1712738117920-9.webp" alt></p><p>这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「热数据」，缓存利用率得以最大化，再来看数据一致性问题。</p><p>要想保证缓存和数据库「实时」一致，那就不能再用定时任务刷新缓存了。所以，当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存。具体操作就是，修改一条数据时，不仅要更新数据库，也要连带缓存一起更新。但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：</p><ol><li>先更新缓存，后更新数据库</li><li>先更新数据库，后更新缓存</li></ol><p>哪个方案更好呢？先不考虑并发问题，正常情况下，无论谁先谁后，都可以让两者保持一致，但现在我们需要重点考虑「异常」情况。因为操作分为两步，那么就很有可能存在「第一步成功、第二步失败」的情况发生。这 2 种方案我们一个个来分析。</p><p><strong>1) 先更新缓存，后更新数据库</strong></p><p>如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。</p><p>虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。</p><p>这时用户会发现自己之前修改的数据又「变回去」了，对业务造成影响。</p><p><strong>2) 先更新数据库，后更新缓存</strong></p><p>如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。</p><p>这时用户会发现，自己刚刚修改了数据，但却看不到变更，一段时间过后，数据才变更过来，对业务也会有影响。可见，无论谁先谁后，但凡后者发生异常，就会对业务造成影响。那怎么解决这个问题呢？</p><p>除了操作失败问题，还有什么场景会影响数据一致性？<strong>并发问题</strong>。</p><h2 id="并发引发的一致性问题"><a href="#并发引发的一致性问题" class="headerlink" title="并发引发的一致性问题"></a>并发引发的一致性问题</h2><p>假设采用「先更新数据库，再更新缓存」的方案，并且两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：</p><blockquote><ol><li>线程 A 更新数据库（X = 1）</li><li>线程 B 更新数据库（X = 2）</li><li>线程 B 更新缓存（X = 2）</li><li>线程 A 更新缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。也就是说，A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。</p><blockquote><p>同样地，采用「先更新缓存，再更新数据库」的方案，也会有类似问题，这里不再详述。</p></blockquote><p>除此之外，我们从「缓存利用率」的角度来评估这个方案，也是不太推荐的。这是因为每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。</p><p>而且很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列「计算」得出一个值，才把这个值才写到缓存中。由此可见，这种「更新数据库 + 更新缓存」的方案，不仅缓存利用率不高，还会造成机器性能的浪费。</p><p>所以此时我们需要考虑另外一种方案：<strong>删除缓存</strong>。</p><h2 id="删除缓存可以保证一致性吗？"><a href="#删除缓存可以保证一致性吗？" class="headerlink" title="删除缓存可以保证一致性吗？"></a>删除缓存可以保证一致性吗？</h2><p>删除缓存对应的方案也有 2 种：</p><ol><li>先删除缓存，后更新数据库</li><li>先更新数据库，后删除缓存</li></ol><p>经过前面的分析我们已经得知，但凡「第二步」操作失败，都会导致数据不一致。重点来看「并发」问题。</p><p><strong>1) 先删除缓存，后更新数据库</strong></p><p>如果有 2 个线程要并发「读写」数据，可能会发生以下场景：</p><blockquote><ol><li>线程 A 要更新 X = 2（原值 X = 1）</li><li>线程 A 先删除缓存</li><li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</li><li>线程 A 将新值写入数据库（X = 2）</li><li>线程 B 将旧值写入缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。</p><p>可见，先删除缓存，后更新数据库，当发生「读+写」并发时，还是存在数据不一致的情况。</p><p><strong>2) 先更新数据库，后删除缓存</strong></p><p>依旧是 2 个线程并发「读写」数据：</p><blockquote><ol><li>缓存中 X 不存在（数据库 X = 1）</li><li>线程 A 读取数据库，得到旧值（X = 1）</li><li>线程 B 更新数据库（X = 2)</li><li>线程 B 删除缓存</li><li>线程 A 将旧值写入缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？概率「很低」，这是因为它必须满足 3 个条件：</p><ol><li>缓存刚好已失效</li><li>读请求 + 写请求并发</li><li>更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）</li></ol><p>仔细想一下，条件 3 发生的概率其实是非常低的。因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证一定程度的数据一致性。</p><p>所以应该采用这种方案，来操作数据库和缓存。解决了并发问题，我们继续来看前面遗留的，<strong>第二步执行「失败」导致数据不一致的问题</strong>。</p><h2 id="如何保证两步都执行成功？"><a href="#如何保证两步都执行成功？" class="headerlink" title="如何保证两步都执行成功？"></a>如何保证两步都执行成功？</h2><p>前面分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。</p><p><strong>保证第二步成功执行，就是解决问题的关键。</strong></p><p>想一下，程序在执行过程中发生异常，最简单的解决办法是什么？答案是：<strong>重试</strong>。</p><p>无论是先操作缓存，还是先操作数据库，但凡后者执行失败了就可以发起重试，尽可能地去做「补偿」。那这是不是意味着，只要执行失败，我们「无脑重试」就可以了呢？答案是否定的。现实情况往往没有想的这么简单，失败后立即重试的问题在于：</p><ul><li>立即重试很大概率「还会失败」</li><li>「重试次数」设置多少才合理？</li><li>重试会一直「占用」这个线程资源，无法服务其它客户端请求</li></ul><p>虽然想通过重试的方式解决问题，但这种「同步」重试的方案依旧不严谨。那更好的方案应该怎么做？答案是：<strong>异步重试</strong>。</p><p>把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。</p><p>到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。</p><p>所以，这里我们必须把重试或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：</p><ul><li><strong>消息队列保证可靠性</strong>：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）</li><li><strong>消息队列保证消息成功投递</strong>：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）</li></ul><p>至于写队列失败和消息队列的维护成本问题：</p><ul><li><strong>写队列失败</strong>：操作缓存和写消息队列，「同时失败」的概率其实是很小的</li><li><strong>维护成本</strong>：我们项目中一般都会用到消息队列，维护成本并没有新增很多</li></ul><p>所以，引入消息队列来解决这个问题，是比较合适的。这时架构模型就变成了这样：</p><p><img src="/posts/10748/640-1712738505781-12.webp" alt></p><p>如果不想在应用中去写消息队列，是否有更简单的方案，同时又可以保证一致性呢？方案还是有的，这就是近几年比较流行的解决方案：<strong>订阅数据库变更日志，再操作缓存</strong>。</p><p>具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。</p><p><img src="/posts/10748/640-1712738775748-15.webp" alt></p><p>订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：</p><ul><li><strong>无需考虑写消息队列失败情况</strong>：只要写 MySQL 成功，Binlog 肯定会有</li><li><strong>自动投递到下游队列</strong>：canal 自动把数据库变更日志「投递」给下游的消息队列</li></ul><p>当然，与此同时需要投入精力去维护 canal 的高可用和稳定性。</p><blockquote><p>如果你有留意观察很多数据库的特性，就会发现其实很多数据库都逐渐开始提供「订阅变更日志」的功能了，相信不远的将来，我们就不用通过中间件来拉取日志，自己写程序就可以订阅变更日志了，这样可以进一步简化流程。</p></blockquote><p>至此可以得出结论，想要保证数据库和缓存一致性，<strong>推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做</strong>。</p><h2 id="主从库延迟和延迟双删问题"><a href="#主从库延迟和延迟双删问题" class="headerlink" title="主从库延迟和延迟双删问题"></a>主从库延迟和延迟双删问题</h2><p>到这里，还有 2 个问题是没有重点分析过的。</p><p><strong>第一个问题</strong>，还记得前面讲到的「先删除缓存，再更新数据库」方案，导致不一致的场景么？</p><p>2 个线程要并发「读写」数据，可能会发生以下场景：</p><blockquote><ol><li>线程 A 要更新 X = 2（原值 X = 1）</li><li>线程 A 先删除缓存</li><li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</li><li>线程 A 将新值写入数据库（X = 2）</li><li>线程 B 将旧值写入缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。</p><p><strong>第二个问题</strong>：是关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题。</p><p>在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」其实也会导致不一致：</p><blockquote><ol><li>线程 A 更新主库 X = 2（原值 X = 1）</li><li>线程 A 删除缓存</li><li>线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）</li><li>从库「同步」完成（主从库 X = 2）</li><li>线程 B 将「旧值」写入缓存（X = 1）</li></ol></blockquote><p>最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。</p><p>这 2 个问题的核心在于：<strong>缓存都被回种了「旧值」</strong>。那怎么解决这类问题呢？最有效的办法就是，<strong>把缓存删掉</strong>。</p><p>但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：<strong>缓存延迟双删策略</strong>。按照延时双删策略，这 2 个问题的解决方案是这样的：</p><p><strong>解决第一个问题</strong>：在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。</p><p><strong>解决第二个问题</strong>：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。</p><p>这两个方案的目的，都是为了把缓存清掉，这样一来，下次就可以从数据库读取到最新值，写入缓存。但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？</p><ul><li>问题1：延迟时间要大于「主从复制」的延迟时间</li><li>问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间</li></ul><p><strong>这个时间在分布式和高并发场景下，其实是很难评估的</strong>。很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。采用这种方案，也只是尽可能保证一致性而已，极端情况下，还是有可能发生不一致。</p><p>所以实际使用中，建议采用「先更新数据库，再删除缓存」的方案，同时要尽可能地保证「主从复制」不要有太大延迟，降低出问题的概率。</p><h2 id="可以做到强一致吗？"><a href="#可以做到强一致吗？" class="headerlink" title="可以做到强一致吗？"></a>可以做到强一致吗？</h2><p>这些方案还是不够完美，我就想让缓存和数据库「强一致」，到底能不能做到呢？</p><p>其实很难。要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。相反，这时我们换个角度思考一下，我们引入缓存的目的是什么？没错，<strong>性能</strong>。一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。</p><p>而且，就拿我们前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到「中间状态」的数据。所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。虽然我们可以通过加「分布锁」的方式来实现，但我们要付出的代价，很可能会超过引入缓存带来的性能提升。</p><p>所以，既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。同时我们也要知道，缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、想要提高应用的性能，可以引入「缓存」来解决</p><p>2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」</p><p>3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生</p><p>4、在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案</p><p>5、在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性</p><p>6、在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率</p><p>换句话说，最佳实践则是：</p><ul><li>性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案</li><li>掌握缓存和数据库一致性问题，核心问题有 3 点：缓存利用率、并发、缓存 + 数据库一起成功问题</li><li>失败场景下要保证一致性，常见手段就是「重试」，同步重试会影响吞吐量，所以通常会采用异步重试的方案</li><li>订阅变更日志的思想，本质是把权威数据源（例如 MySQL）当做 leader 副本，让其它异质系统（例如 Redis / Elasticsearch）成为它的 follower 副本，通过同步变更日志的方式，保证 leader 和 follower 之间保持一致</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;到底是更新缓存还是删缓存？&lt;/li&gt;
&lt;li&gt;到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁安全之问</title>
    <link href="https://joytsing.github.io/posts/39535/"/>
    <id>https://joytsing.github.io/posts/39535/</id>
    <published>2024-04-09T14:39:06.000Z</published>
    <updated>2024-04-10T15:22:04.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先进行一个问题的抛出：</p><ul><li>基于 Redis 如何实现一个分布式锁？</li><li>Redis 分布式锁真的安全吗？</li><li>Redis 的 Redlock 有什么问题？一定安全吗？</li><li>业界争论 Redlock，到底在争论什么？哪种观点是对的？</li><li>分布式锁到底用 Redis 还是 Zookeeper？</li><li>实现一个有「容错性」的分布式锁，都需要考虑哪些问题？</li></ul><h2 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h2><p>在开始讲分布式锁之前，有必要简单介绍一下，为什么需要分布式锁？</p><p>与分布式锁相对应的是「单机锁」，我们在写多线程程序时，避免同时操作一个共享变量产生数据问题，通常会使用一把锁来「互斥」，以保证共享变量的正确性，其使用范围是在「同一个进程」中。如果换做是多个进程，需要同时操作一个共享资源，如何互斥呢？</p><p>例如，现在的业务应用通常都是微服务架构，这也意味着一个应用会部署多个进程，那这多个进程如果需要修改 MySQL 中的同一行记录时，为了避免操作乱序导致数据错误，此时，我们就需要引入「分布式锁」来解决这个问题了。</p><p><img src="/posts/39535/640.webp" alt></p><p>想要实现分布式锁，必须借助一个外部系统，所有进程都去这个系统上申请「加锁」。而这个外部系统，必须要实现「互斥」的能力，即两个请求同时进来，只会给一个进程返回成功，另一个返回失败（或等待）。</p><p>这个外部系统，可以是 MySQL，也可以是 Redis 或 Zookeeper。但为了追求更好的性能，通常会选择使用 Redis 或 Zookeeper 来做。下面就以 Redis 为主线，由浅入深，带你深度剖析一下，分布式锁的各种「安全性」问题。</p><h2 id="分布式锁怎么实现？"><a href="#分布式锁怎么实现？" class="headerlink" title="分布式锁怎么实现？"></a>分布式锁怎么实现？</h2><p>从最简单的开始讲起。</p><p>想要实现分布式锁，必须要求 Redis 有「互斥」的能力，我们可以使用 SETNX 命令，这个命令表示<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists，即如果 key 不存在，才会设置它的值，否则什么也不做。</p><p>两个客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁。</p><p>客户端 1 申请加锁，加锁成功：</p><pre><code>127.0.0.1:6379&gt; SETNX lock 1(integer) 1     // 客户端1，加锁成功</code></pre><p>客户端 2 申请加锁，因为它后到达，加锁失败：</p><pre><code>127.0.0.1:6379&gt; SETNX lock 1(integer) 0     // 客户端2，加锁失败</code></pre><p>此时，加锁成功的客户端，就可以去操作「共享资源」，例如，修改 MySQL 的某一行数据，或者调用一个 API 请求。操作完成后，还要及时释放锁，给后来者让出操作共享资源的机会。如何释放锁呢？</p><p>也很简单，直接使用 DEL 命令删除这个 key 即可：</p><pre><code>127.0.0.1:6379&gt; DEL lock // 释放锁(integer) 1</code></pre><p>这个逻辑非常简单，整体的路程就是这样：</p><p><img src="/posts/39535/640-1712760520184-3.webp" alt></p><p>但是，它存在一个很大的问题，当客户端 1 拿到锁后，如果发生下面的场景，就会造成「死锁」：</p><ol><li>程序处理业务逻辑异常，没及时释放锁</li><li>进程挂了，没机会释放锁</li></ol><p>这时，这个客户端就会一直占用这个锁，而其它客户端就「永远」拿不到这把锁了。怎么解决这个问题呢？</p><h2 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h2><p>很容易想到的方案是，在申请锁时，给这把锁设置一个「租期」。</p><p>在 Redis 中实现时，就是给这个 key 设置一个「过期时间」。这里我们假设，操作共享资源的时间不会超过 10s，那么在加锁时，给这个 key 设置 10s 过期即可：</p><pre><code>127.0.0.1:6379&gt; SETNX lock 1    // 加锁(integer) 1127.0.0.1:6379&gt; EXPIRE lock 10  // 10s后自动过期(integer) 1</code></pre><p>这样一来，无论客户端是否异常，这个锁都可以在 10s 后被「自动释放」，其它客户端依旧可以拿到锁。但这样真的没问题吗？还是有问题。</p><p>现在的操作，加锁、设置过期是 2 条命令，有没有可能只执行了第一条，第二条却「来不及」执行的情况发生呢？例如：</p><blockquote><ol><li>SETNX 执行成功，执行 EXPIRE 时由于网络问题，执行失败</li><li>SETNX 执行成功，Redis 异常宕机，EXPIRE 没有机会执行</li><li>SETNX 执行成功，客户端异常崩溃，EXPIRE 也没有机会执行</li></ol></blockquote><p>总之，这两条命令不能保证是原子操作（一起成功），就有潜在的风险导致过期时间设置失败，依旧发生「死锁」问题。怎么办？</p><p>在 Redis 2.6.12 版本之前，我们需要想尽办法，保证 SETNX 和 EXPIRE 原子性执行，还要考虑各种异常情况如何处理。但在 Redis 2.6.12 之后，Redis 扩展了 SET 命令的参数，用这一条命令就可以了：</p><pre><code>// 一条命令保证原子性执行127.0.0.1:6379&gt; SET lock 1 EX 10 NXOK</code></pre><p>这样就解决了死锁问题，也比较简单。试想这样一种场景：</p><blockquote><ol><li>客户端 1 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源的时间，「超过」了锁的过期时间，锁被「自动释放」</li><li>客户端 2 加锁成功，开始操作共享资源</li><li>客户端 1 操作共享资源完成，释放锁（但释放的是客户端 2 的锁）</li></ol></blockquote><p>看到了么，这里存在两个严重的问题：</p><ol><li><strong>锁过期</strong>：客户端 1 操作共享资源耗时太久，导致锁被自动释放，之后被客户端 2 持有</li><li><strong>释放别人的锁</strong>：客户端 1 操作共享资源完成后，却又释放了客户端 2 的锁</li></ol><p>导致这两个问题的原因是什么？</p><p><strong>第一个问题，可能是评估操作共享资源的时间不准确导致的。</strong></p><p>例如，操作共享资源的时间「最慢」可能需要 15s，而我们却只设置了 10s 过期，那这就存在锁提前过期的风险。过期时间太短，那增大冗余时间，例如设置过期时间为 20s，这样总可以了吧？这样确实可以「缓解」这个问题，降低出问题的概率，但依旧无法「彻底解决」问题。</p><p>为什么？</p><p>原因在于，客户端在拿到锁之后，在操作共享资源时，遇到的场景有可能是很复杂的，例如，程序内部发生异常、网络请求超时等等。既然是「预估」时间，也只能是大致计算，除非你能预料并覆盖到所有导致耗时变长的场景，但这其实很难。有什么更好的解决方案吗？</p><p><strong>第二个问题在于，一个客户端释放了其它客户端持有的锁。</strong></p><p>想一下，导致这个问题的关键点在哪？重点在于，每个客户端在释放锁时，都是「无脑」操作，并没有检查这把锁是否还「归自己持有」，所以就会发生释放别人锁的风险，这样的解锁流程，很不「严谨」！如何解决这个问题呢？</p><h2 id="锁被别人释放怎么办"><a href="#锁被别人释放怎么办" class="headerlink" title="锁被别人释放怎么办?"></a>锁被别人释放怎么办?</h2><p>解决办法是：客户端在加锁时，设置一个只有自己知道的「唯一标识」进去。例如，可以是自己的线程 ID，也可以是一个 UUID（随机且唯一），这里我们以 UUID 举例：</p><pre><code>// 锁的VALUE设置为UUID127.0.0.1:6379&gt; SET lock $uuid EX 20 NXOK</code></pre><blockquote><p>这里假设 20s 操作共享时间完全足够，先不考虑锁自动过期的问题。</p></blockquote><p>之后，在释放锁时，要先判断这把锁是否还归自己持有，伪代码可以这么写：</p><pre><code>// 锁是自己的，才释放if redis.get(&quot;lock&quot;) == $uuid:    redis.del(&quot;lock&quot;)</code></pre><p>这里释放锁使用的是 GET + DEL 两条命令，这时，又会遇到我们前面讲的原子性问题了。</p><blockquote><ol><li>客户端 1 执行 GET，判断锁是自己的</li><li>客户端 2 执行了 SET 命令，强制获取到锁（虽然发生概率比较低，但我们需要严谨地考虑锁的安全性模型）</li><li>客户端 1 执行 DEL，却释放了客户端 2 的锁</li></ol></blockquote><p>由此可见，这两个命令还是必须要原子执行才行。怎样原子执行呢？Lua 脚本。可以把这个逻辑，写成 Lua 脚本，让 Redis 来执行。</p><p>因为 Redis 处理每一个请求是「单线程」执行的，在执行一个 Lua 脚本时，其它请求必须等待，直到这个 Lua 脚本处理完成，这样一来，GET + DEL 之间就不会插入其它命令了。</p><p><img src="/posts/39535/640-1712760824267-6.webp" alt></p><p>安全释放锁的 Lua 脚本如下：</p><pre class="line-numbers language-lua"><code class="language-lua"><span class="token operator">//</span> 判断锁是自己的，才释放<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">then</span>    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"DEL"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，这样一路优化，整个的加锁、解锁的流程就更「严谨」了。基于 Redis 实现的分布式锁，一个严谨的的流程如下：</p><blockquote><ol><li>加锁：SET lock_key $unique_id EX $expire_time NX</li><li>操作共享资源</li><li>释放锁：Lua 脚本，先 GET 判断锁是否归属自己，再 DEL 释放锁</li></ol></blockquote><p><img src="/posts/39535/640-1712760824267-7.webp" alt></p><p>好，有了这个完整的锁模型，让我们重新回到前面提到的第一个问题。锁过期时间不好评估怎么办？</p><h2 id="锁过期时间不好评估怎么办？"><a href="#锁过期时间不好评估怎么办？" class="headerlink" title="锁过期时间不好评估怎么办？"></a>锁过期时间不好评估怎么办？</h2><p>前面我们提到，锁的过期时间如果评估不好，这个锁就会有「提前」过期的风险。当时给的妥协方案是，尽量「冗余」过期时间，降低锁提前过期的概率。</p><p>这个方案其实也不能完美解决问题，那怎么办呢？</p><p>是否可以设计这样的方案：<strong>加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。</strong></p><p><img src="/posts/39535/640-1712761088227-12.webp" alt></p><p>基于 Redis 的实现分布式锁，前面遇到的问题，以及对应的解决方案：</p><ul><li><strong>死锁</strong>：设置过期时间</li><li><strong>过期时间评估不好，锁提前过期</strong>：守护线程，自动续期</li><li><strong>锁被别人释放</strong>：锁写入唯一标识，释放锁先检查标识，再释放</li></ul><p>还有哪些问题场景，会危害 Redis 锁的安全性呢？</p><p>之前分析的场景都是，锁在「单个」Redis 实例中可能产生的问题，并没有涉及到 Redis 的部署架构细节。而在使用 Redis 时，一般会采用<strong>主从集群 + 哨兵</strong>的模式部署，这样做的好处在于，当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。</p><p><strong>那当「主从发生切换」时，这个分布锁会依旧安全吗？</strong></p><p>试想这样的场景：</p><ol><li>客户端 1 在主库上执行 SET 命令，加锁成功</li><li>此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）</li><li>从库被哨兵提升为新主库，这个锁在新的主库上，丢失了！</li></ol><p><img src="/posts/39535/640-1712761172250-15.webp" alt></p><p>可见，当引入 Redis 副本后，分布锁还是可能会受到影响。怎么解决这个问题？</p><p>为此，Redis 的作者提出一种解决方案，就是我们经常听到的 <strong>Redlock（红锁）</strong>。</p><h2 id="Redlock-真的安全吗？"><a href="#Redlock-真的安全吗？" class="headerlink" title="Redlock 真的安全吗？"></a>Redlock 真的安全吗？</h2><p>Redlock 的方案基于 2 个前提：</p><ol><li>不再需要部署<strong>从库</strong>和<strong>哨兵</strong>实例，只部署<strong>主库</strong></li><li>但主库要部署多个，官方推荐至少 5 个实例</li></ol><p>也就是说，想用使用 Redlock，你至少要部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p><blockquote><p><strong>注意：不是部署 Redis Cluster，就是部署 5 个简单的 Redis 实例。</strong></p></blockquote><p><img src="/posts/39535/640-1712761502480-18.webp" alt></p><p>Redlock 具体如何使用呢？整体的流程是这样的，一共分为 5 步：</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 &gt;=3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p>其中有 4 个重点：</p><blockquote><ol><li>客户端在多个 Redis 实例上申请加锁</li><li>必须保证大多数节点加锁成功</li><li>大多数节点加锁的总耗时，要小于锁设置的过期时间</li><li>释放锁，要向全部节点发起释放锁请求</li></ol></blockquote><p>明白了 Redlock 的流程，我们来看 Redlock 为什么要这么做。</p><p><strong>1) 为什么要在多个实例上加锁？</strong></p><p>本质上是为了「容错」，部分实例异常宕机，剩余的实例加锁成功，整个锁服务依旧可用。</p><p><strong>2) 为什么大多数加锁成功，才算成功？</strong></p><p>多个 Redis 实例一起来用，其实就组成了一个「分布式系统」。</p><p>在分布式系统中，总会出现「异常节点」，所以，在谈论分布式系统问题时，需要考虑异常节点达到多少个，也依旧不会影响整个系统的「正确性」。</p><p>这是一个分布式系统「容错」问题，这个问题的结论是：<strong>如果只存在「故障」节点，只要大多数节点正常，那么整个系统依旧是可以提供正确服务的。</strong></p><blockquote><p>这个问题的模型，就是我们经常听到的「拜占庭将军」问题，感兴趣可以去看算法的推演过程。</p></blockquote><p><strong>3) 为什么步骤 3 加锁成功后，还要计算加锁的累计耗时？</strong></p><p>因为操作的是多个节点，所以耗时肯定会比操作单个实例耗时更久，而且，因为是网络请求，网络情况是复杂的，有可能存在<strong>延迟、丢包、超时</strong>等情况发生，网络请求越多，异常发生的概率就越大。</p><p>所以，即使大多数节点加锁成功，但如果加锁的累计耗时已经「超过」了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁就没有意义了。</p><p><strong>4) 为什么释放锁，要操作所有节点？</strong></p><p>在某一个 Redis 节点加锁时，可能因为「网络原因」导致加锁失败。</p><p>例如，客户端在一个 Redis 实例上加锁成功，但在读取响应结果时，网络问题导致<strong>读取失败</strong>，那这把锁其实已经在 Redis 上加锁成功了。</p><p>所以，释放锁时，不管之前有没有加锁成功，需要释放「所有节点」的锁，以保证清理节点上「残留」的锁。</p><p>好了，明白了 Redlock 的流程和相关问题，看似 Redlock 确实解决了 Redis 节点异常宕机锁失效的问题，保证了锁的「安全性」。</p><p>但事实真的如此吗？</p><h2 id="分布式专家-Martin-对于-Relock-的质疑"><a href="#分布式专家-Martin-对于-Relock-的质疑" class="headerlink" title="分布式专家 Martin 对于 Relock 的质疑"></a>分布式专家 Martin 对于 Relock 的质疑</h2><p>在他的文章中，主要阐述了 4 个论点：</p><p><strong>1) 分布式锁的目的是什么？</strong></p><p>Martin 表示，你必须先清楚你在使用分布式锁的目的是什么？他认为有两个目的。</p><p><strong>第一，效率。</strong></p><p>使用分布式锁的互斥能力，是避免不必要地做同样的两次工作（例如一些昂贵的计算任务）。如果锁失效，并不会带来「恶性」的后果，例如发了 2 次邮件等，无伤大雅。</p><p><strong>第二，正确性。</strong></p><p>使用锁用来防止并发进程互相干扰。如果锁失效，会造成多个进程同时操作同一条数据，产生的后果是<strong>数据严重错误、永久性不一致、数据丢失</strong>等恶性问题，就像给患者服用了重复剂量的药物，后果很严重。</p><p>他认为，如果你是为了前者——效率，那么使用单机版 Redis 就可以了，即使偶尔发生锁失效（宕机、主从切换），都不会产生严重的后果。而使用 Redlock 太重了，没必要。</p><p><strong>而如果是为了正确性，Martin 认为 Redlock 根本达不到安全性的要求，也依旧存在锁失效的问题！</strong></p><p><strong>2) 锁在分布式系统中会遇到的问题</strong></p><p>Martin 表示，一个分布式系统，更像一个复杂的「野兽」，存在着你想不到的各种异常情况。</p><p>这些异常场景主要包括三大块，这也是分布式系统会遇到的三座大山：<strong>NPC</strong>。</p><ul><li>N：Network Delay，网络延迟</li><li>P：Process Pause，进程暂停（GC）</li><li>C：Clock Drift，时钟漂移</li></ul><p>Martin 用一个进程暂停（GC）的例子，指出了 Redlock 安全性问题：</p><blockquote><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC（时间比较久）</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取到了 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到了锁，发生「冲突」</li></ol></blockquote><p><img src="/posts/39535/640-1712761809896-21.webp" alt="图片"></p><p>Martin 认为，GC 可能发生在程序的任意时刻，而且执行时间是不可控的。</p><blockquote><p>注：当然，即使是使用没有 GC 的编程语言，在发生网络延迟、时钟漂移时，也都有可能导致 Redlock 出现问题，这里 Martin 只是拿 GC 举例。</p></blockquote><p><strong>3) 假设时钟正确的是不合理的</strong></p><p>又或者，当多个 Redis 节点「时钟」发生问题时，也会导致 Redlock <strong>锁失效</strong>。</p><blockquote><ol><li>客户端 1 获取节点 A、B、C 上的锁，但由于网络问题，无法访问 D 和 E</li><li>节点 C 上的时钟「向前跳跃」，导致锁到期</li><li>客户端 2 获取节点 C、D、E 上的锁，由于网络问题，无法访问 A 和 B</li><li>客户端 1 和 2 现在都相信它们持有了锁（冲突）</li></ol></blockquote><p>Martin 觉得，Redlock 必须「强依赖」多个节点的时钟是保持同步的，一旦有节点时钟发生错误，那这个算法模型就失效了。</p><blockquote><p>即使 C 不是时钟跳跃，而是「崩溃后立即重启」，也会发生类似的问题。</p></blockquote><p>Martin 继续阐述，机器的时钟发生错误，是很有可能发生的：</p><ul><li>系统管理员「手动修改」了机器时钟</li><li>机器时钟在同步 NTP 时间时，发生了大的「跳跃」</li></ul><p>总之，Martin 认为，Redlock 的算法是建立在「同步模型」基础上的，有大量资料研究表明，同步模型的假设，在分布式系统中是有问题的。</p><p>在混乱的分布式系统的中，你不能假设系统时钟就是对的，所以，你必须非常小心你的假设。</p><p><strong>4) 提出 fecing token 的方案，保证正确性</strong></p><p>相对应的，Martin 提出一种被叫作 fecing token 的方案，保证分布式锁的正确性。</p><p>这个模型流程如下：</p><blockquote><ol><li>客户端在获取锁时，锁服务可以提供一个「递增」的 token</li><li>客户端拿着这个 token 去操作共享资源</li><li>共享资源可以根据 token 拒绝「后来者」的请求</li></ol></blockquote><p><img src="/posts/39535/640-1712761809897-22.webp" alt="图片"></p><p>这样一来，无论 NPC 哪种异常情况发生，都可以保证分布式锁的安全性，因为它是建立在「异步模型」上的。</p><p>而 Redlock 无法提供类似 fecing token 的方案，所以它无法保证安全性。</p><p>他还表示，<strong>一个好的分布式锁，无论 NPC 怎么发生，可以不在规定时间内给出结果，但并不会给出一个错误的结果。也就是只会影响到锁的「性能」（或称之为活性），而不会影响它的「正确性」。</strong></p><p>Martin 的结论：</p><p><strong>1、Redlock 不伦不类</strong>：它对于效率来讲，Redlock 比较重，没必要这么做，而对于正确性来说，Redlock 是不够安全的。</p><p><strong>2、时钟假设不合理</strong>：该算法对系统时钟做出了危险的假设（假设多个节点机器时钟都是一致的），如果不满足这些假设，锁就会失效。</p><p><strong>3、无法保证正确性</strong>：Redlock 不能提供类似 fencing token 的方案，所以解决不了正确性的问题。为了正确性，请使用有「共识系统」的软件，例如 Zookeeper。</p><p>好了，以上就是 Martin 反对使用 Redlock 的观点，看起来有理有据。</p><p>下面我们来看 Redis 作者 Antirez 是如何反驳的。</p><h2 id="Redis-作者-Antirez-的反驳"><a href="#Redis-作者-Antirez-的反驳" class="headerlink" title="Redis 作者 Antirez 的反驳"></a>Redis 作者 Antirez 的反驳</h2><p>在 Redis 作者的文章中，重点有 3 个：</p><p><strong>1) 解释时钟问题</strong></p><p>首先，Redis 作者一眼就看穿了对方提出的最为核心的问题：<strong>时钟问题</strong>。</p><p>Redis 作者表示，Redlock 并不需要完全一致的时钟，只需要大体一致就可以了，允许有「误差」。</p><p>例如要计时 5s，但实际可能记了 4.5s，之后又记了 5.5s，有一定误差，但只要不超过「误差范围」锁失效时间即可，这种对于时钟的精度要求并不是很高，而且这也符合现实环境。</p><p>对于对方提到的「时钟修改」问题，Redis 作者反驳到：</p><ol><li><strong>手动修改时钟</strong>：不要这么做就好了，否则你直接修改 Raft 日志，那 Raft 也会无法工作…</li><li><strong>时钟跳跃</strong>：通过「恰当的运维」，保证机器时钟不会大幅度跳跃（每次通过微小的调整来完成），实际上这是可以做到的</li></ol><blockquote><p>为什么 Redis 作者优先解释时钟问题？因为在后面的反驳过程中，需要依赖这个基础做进一步解释。</p></blockquote><p><strong>2) 解释网络延迟、GC 问题</strong></p><p>之后，Redis 作者对于对方提出的，网络延迟、进程 GC 可能导致 Redlock 失效的问题，也做了反驳：</p><p>我们重新回顾一下，Martin 提出的问题假设：</p><ol><li>客户端 1 请求锁定节点 A、B、C、D、E</li><li>客户端 1 的拿到锁后，进入 GC</li><li>所有 Redis 节点上的锁都过期了</li><li>客户端 2 获取节点 A、B、C、D、E 上的锁</li><li>客户端 1 GC 结束，认为成功获取锁</li><li>客户端 2 也认为获取到锁，发生「冲突」</li></ol><p><img src="/posts/39535/640-1712761809896-21.webp" alt="图片"></p><p>Redis 作者反驳到，这个假设其实是有问题的，Redlock 是可以保证锁安全的。这是怎么回事呢？</p><p>还记得前面介绍 Redlock 流程的那 5 步吗？</p><ol><li>客户端先获取「当前时间戳T1」</li><li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li><li>如果客户端从 3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li><li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li><li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li></ol><p><strong>注意，重点是 1-3，在步骤 3，加锁成功后为什么要重新获取「当前时间戳T2」？还用 T2 - T1 的时间，与锁的过期时间做比较？</strong></p><p>Redis 作者强调：如果在 1-3 发生了网络延迟、进程 GC 等耗时长的异常情况，那在第 3 步 T2 - T1，是可以检测出来的，如果超出了锁设置的过期时间，那这时就认为加锁会失败，之后释放所有节点的锁就好了！</p><p>Redis 作者继续论述，如果对方认为，发生网络延迟、进程 GC 是在步骤 3 之后，也就是客户端确认拿到了锁，去操作共享资源的途中发生了问题，导致锁失效，那这<strong>不止是 Redlock 的问题，任何其它锁服务例如 Zookeeper，都有类似的问题，这不在讨论范畴内。</strong></p><p>举个例子解释一下这个问题：</p><ol><li>客户端通过 Redlock 成功获取到锁（通过了大多数节点加锁成功、加锁耗时检查逻辑）</li><li>客户端开始操作共享资源，此时发生网络延迟、进程 GC 等耗时很长的情况</li><li>此时，锁过期自动释放</li><li>客户端开始操作 MySQL（此时的锁可能会被别人拿到，锁失效）</li></ol><p>Redis 作者这里的结论就是：</p><ul><li>客户端在拿到锁之前，无论经历什么耗时长问题，Redlock 都能够在第 3 步检测出来</li><li>客户端在拿到锁之后，发生 NPC，那 Redlock、Zookeeper 都无能为力</li></ul><p>所以，Redis 作者认为 Redlock 在保证时钟正确的基础上，是可以保证正确性的。</p><p><strong>3) 质疑 fencing token 机制</strong></p><p>Redis 作者对于对方提出的 fecing token 机制，也提出了质疑，主要分为 2 个问题:</p><p><strong>第一</strong>，这个方案必须要求要操作的「共享资源服务器」有拒绝「旧 token」的能力。</p><p>例如，要操作 MySQL，从锁服务拿到一个递增数字的 token，然后客户端要带着这个 token 去改 MySQL 的某一行，这就需要利用 MySQL 的「事物隔离性」来做。</p><pre><code>// 两个客户端必须利用事物和隔离性达到目的// 注意 token 的判断条件UPDATE table T SET val = $new_val WHERE id = $id AND current_token &lt; $token</code></pre><p>但如果操作的不是 MySQL 呢？例如向磁盘上写一个文件，或发起一个 HTTP 请求，那这个方案就无能为力了，这对要操作的资源服务器，提出了更高的要求。</p><p>也就是说，大部分要操作的资源服务器，都是没有这种互斥能力的。</p><p><strong>再者，既然资源服务器都有了「互斥」能力，那还要分布式锁干什么？</strong></p><p>所以，Redis 作者认为这个方案是站不住脚的。</p><p><strong>第二</strong>，退一步讲，即使 Redlock 没有提供 fecing token 的能力，但 Redlock 已经提供了随机值（就是前面讲的 UUID），利用这个随机值，也可以达到与 fecing token 同样的效果。</p><p>如何做呢？</p><blockquote><p>Redis 作者只是提到了可以完成 fecing token 类似的功能，但却没有展开相关细节，大概流程应该如下</p></blockquote><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端在操作共享资源之前，先把这个锁的 VALUE，在要操作的共享资源上做标记</li><li>客户端处理业务逻辑，最后，在修改共享资源时，判断这个标记是否与之前一样，一样才修改（类似 CAS 的思路）</li></ol><p>还是以 MySQL 为例，举个例子就是这样的：</p><ol><li>客户端使用 Redlock 拿到锁</li><li>客户端要修改 MySQL 表中的某一行数据之前，先把锁的 VALUE 更新到这一行的某个字段中（这里假设为 current_token 字段)</li><li>客户端处理业务逻辑</li><li>客户端修改 MySQL 的这一行数据，把 VALUE 当做 WHERE 条件，再修改</li></ol><pre><code>UPDATE table T SET val = $new_val WHERE id = $id AND current_token = $redlock_value</code></pre><p>可见，这种方案依赖 MySQL 的事物机制，也达到对方提到的 fecing token 一样的效果。</p><p>但这里还有个小问题，是网友参与问题讨论时提出的：<strong>两个客户端通过这种方案，先「标记」再「检查+修改」共享资源，那这两个客户端的操作顺序无法保证啊？</strong></p><p>而用 Martin 提到的 fecing token，因为这个 token 是单调递增的数字，资源服务器可以拒绝小的 token 请求，保证了操作的「顺序性」！</p><p>Redis 作者对这问题做了不同的解释，他解释道：<strong>分布式锁的本质，是为了「互斥」，只要能保证两个客户端在并发时，一个成功，一个失败就好了，不需要关心「顺序性」。</strong></p><blockquote><p>前面 Martin 的质疑中，一直很关心这个顺序性问题，但 Redis 的作者的看法却不同。</p></blockquote><p>综上，Redis 作者的结论：</p><p><strong>1、作者同意对方关于「时钟跳跃」对 Redlock 的影响，但认为时钟跳跃是可以避免的，取决于基础设施和运维。</strong></p><p><strong>2、Redlock 在设计时，充分考虑了 NPC 问题，在 Redlock 步骤 3 之前出现 NPC，可以保证锁的正确性，但在步骤 3 之后发生 NPC，不止是 Redlock 有问题，其它分布式锁服务同样也有问题，所以不在讨论范畴内。</strong></p><h2 id="基于-Zookeeper-的锁安全吗？"><a href="#基于-Zookeeper-的锁安全吗？" class="headerlink" title="基于 Zookeeper 的锁安全吗？"></a>基于 Zookeeper 的锁安全吗？</h2><p>没用过，但是查询后知道，基于它实现的分布式锁是这样的：</p><ol><li>客户端 1 和 2 都尝试创建「临时节点」，例如 /lock</li><li>假设客户端 1 先到达，则加锁成功，客户端 2 加锁失败</li><li>客户端 1 操作共享资源</li><li>客户端 1 删除 /lock 节点，释放锁</li></ol><p>Zookeeper 不像 Redis 那样，需要考虑锁的过期时间问题，它是采用了「临时节点」，保证客户端 1 拿到锁后，只要连接不断，就可以一直持有锁。而且，如果客户端 1 异常崩溃了，那么这个临时节点会自动删除，保证了锁一定会被释放。</p><p><strong>不错，没有锁过期的烦恼，还能在异常时自动释放锁，是不是觉得很完美？</strong>其实不然。思考一下，客户端 1 创建临时节点后，Zookeeper 是如何保证让这个客户端一直持有锁呢？</p><p>原因就在于，<strong>客户端 1 此时会与 Zookeeper 服务器维护一个 Session，这个 Session 会依赖客户端「定时心跳」来维持连接。</strong>如果 Zookeeper 长时间收不到客户端的心跳，就认为这个 Session 过期了，也会把这个临时节点删除。</p><p><img src="/posts/39535/640-1712762020030-27.webp" alt="图片"></p><p>同样地，基于此问题，我们也讨论一下 GC 问题对 Zookeeper 的锁有何影响：</p><blockquote><ol><li>客户端 1 创建临时节点 /lock 成功，拿到了锁</li><li>客户端 1 发生长时间 GC</li><li>客户端 1 无法给 Zookeeper 发送心跳，Zookeeper 把临时节点「删除」</li><li>客户端 2 创建临时节点 /lock 成功，拿到了锁</li><li>客户端 1 GC 结束，它仍然认为自己持有锁（冲突）</li></ol></blockquote><p>可见，即使是使用 Zookeeper，也无法保证进程 GC、网络延迟异常场景下的安全性。</p><p><strong>这就是前面 Redis 作者在反驳的文章中提到的：如果客户端已经拿到了锁，但客户端与锁服务器发生「失联」（例如 GC），那不止 Redlock 有问题，其它锁服务都有类似的问题，Zookeeper 也是一样！</strong></p><p>所以，这里我们就能得出结论了：<strong>一个分布式锁，在极端情况下，不一定是安全的。</strong>如果业务数据非常敏感，在使用分布式锁时，一定要注意这个问题，不能假设分布式锁 100% 安全。</p><p>Zookeeper 的优点：</p><ol><li>不需要考虑锁的过期时间</li><li>watch 机制，加锁失败，可以 watch 等待锁释放，实现乐观锁</li></ol><p>但它的劣势是：</p><ol><li>性能不如 Redis</li><li>部署和运维成本高</li><li>客户端与 Zookeeper 的长时间失联，锁被释放问题</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>1) 到底要不要用 Redlock？</strong></p><p>前面也分析了，Redlock 只有建立在「时钟正确」的前提下，才能正常工作，如果你可以保证这个前提，那么可以拿来使用。但保证时钟正确并不是想的那么简单就能做到的。</p><p>在不使用Redlock的时候可以考虑使用主从+ 哨兵的模式 实现分布式锁。</p><p><strong>2) 如何正确使用分布式锁？</strong></p><p>在分析 Martin 观点时，它提到了 fecing token 的方案，虽然这种方案有很大的局限性，但对于保证「正确性」的场景，是一个非常好的思路。所以，我们可以把这两者结合起来用：</p><p><strong>1、使用分布式锁，在上层完成「互斥」目的，虽然极端情况下锁会失效，但它可以最大程度把并发请求阻挡在最上层，减轻操作资源层的压力。</strong></p><p><strong>2、但对于要求数据绝对正确的业务，在资源层一定要做好「兜底」，设计思路可以借鉴 fecing token 的方案来做。</strong></p><p>两种思路结合对于大多数业务场景，已经可以满足要求了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先进行一个问题的抛出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 Redis 如何实现一个分布式锁？&lt;/li&gt;
&lt;li&gt;Redis 分布式锁真的安全
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://JoyTsing.github.io/categories/Redis/"/>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://JoyTsing.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(七)</title>
    <link href="https://joytsing.github.io/posts/48821/"/>
    <id>https://joytsing.github.io/posts/48821/</id>
    <published>2024-04-09T09:04:07.000Z</published>
    <updated>2024-04-10T08:58:09.896Z</updated>
    
    <content type="html"><![CDATA[<p>在应用程序里，我们使用多少内存都是自己能掌握和控制的，但是纵观Linux整台服务器，除了应用程序以外，内核也会申请和管理大量的内存。</p><h3 id="一、相关实际问题"><a href="#一、相关实际问题" class="headerlink" title="一、相关实际问题"></a>一、相关实际问题</h3><ol><li>内核是如何管理内存的</li><li>如何查看内核使用的内存信息</li><li>服务器上一条ESTABLISH状态的空连接需要消耗多少内存</li><li>机器上出现了3万多个TIME_WAIT，内存开销会不会很大</li></ol><h3 id="二、Linux内核如何管理内存"><a href="#二、Linux内核如何管理内存" class="headerlink" title="二、Linux内核如何管理内存"></a>二、Linux内核如何管理内存</h3><p>内核针对自己的应用场景，使用了一种叫做SLAB/SLUB的内存管理机制。这种管理机制通过四个步骤把物理内存条管理起来，供内核申请和分配内核对象。</p><h4 id="1）node划分"><a href="#1）node划分" class="headerlink" title="1）node划分"></a>1）node划分</h4><p>早期的计算机中，内存控制器还没有整合到CPU，所有的内存访问都需要经过北桥芯片组来完成，即内存控制器集成在北桥中。<strong>CPU访存需要通过前端总线连接到北桥芯片，然后北桥芯片连接到内存，这样的架构被称为UMA（一致性内存访问）</strong>。总线模型保证了所有的内存访问都是一致的（即每个处理器共享相同的内存地址空间）。<strong>在UMA架构下，CPU和内存之间的通信全部都要通过前端总线，而提高性能的方式就是不断提高CPU、前端总线和内存的工作频率。</strong></p><p>而随着物理条件的限制，CPU朝着高频率的方向发展遇到了天花板，性能的提升开始供提高主频转向增加CPU数量（多核、多CPU）。<strong>而越来越多的 CPU 对前端总线的争用，使前端总线成为了瓶颈。为了消除 UMA 架构的瓶颈，NUMA（非一致性内存访问）架构诞生了。</strong>在NUMA架构下，<strong>每个CPU会有自己的独立的内存控制器，并且独立连接到一部分内存（直连的这部分内存称为本地内存），组成一个node，不同node之间通过QPI（Quick Path Interconnect）进行通信访问远程内存。</strong>如下图所示：</p><p><img src="/posts/48821/d4611b458796469c8caacfa92107d0b1.png" alt></p><p>在 NUMA 架构下，内存的访问出现了本地和远程的区别：访问远程内存的延时会明显高于访问本地内存。</p><blockquote><p>系统 boot 的时候，硬件会把 NUMA 信息发送给 os，如果系统支持 NUMA ，会发生以下几件事：</p><ul><li>获取 NUMA 配置信息</li><li>将 processors（不是 cores） 分成很多 nodes，一般是一个 processor 一个 node。</li><li>将 processor 附近的 memory 分配给它。</li><li>计算node 间通信的cost（距离）。</li></ul></blockquote><p>Linux 识别到 NUMA 架构后，每个进程、线程都会继承一个 numa policy，定义了可以使用那些CPU（甚至是那些 core），哪些内存可以使用，以及 policy 的强制程度，即是优先还是强制性只允许。<strong>每个 thread 被分配到了一个”优先” 的 node 上面运行</strong>，thread 可以在其他地方运行（如果 policy 允许的话），但是 os 会尝试让他在优先地 node 上面去运行。默认的内存分配方案是：<strong>优先从本地分配内存。如果本地内存不足，优先淘汰本地内存中无用的内存。使内存页尽可能地和调用线程处在同一个 node。</strong></p><blockquote><p>只是优先从本地分配内存，进程同样可以访问到其他内存条。因为在计算机系统中，物理内存地址是由内存管理单元（Memory Management Unit，MMU）管理的，它会把CPU发出的地址请求转换为实际的物理内存地址。即使系统中有多个内存条（也就是说，有多个物理内存块），MMU也会把它们看作是一个连续的地址空间进行管理。</p><p>当系统启动时，BIOS或者UEFI会检测所有的硬件设备，包括内存条。每个内存条的大小和位置信息会被记录在一个叫做内存映射（Memory Map）的数据结构中。这个内存映射会被传递给操作系统。</p><p>在操作系统启动时，它会读取这个内存映射，然后建立起自己的物理内存管理数据结构，如页帧数组。操作系统会把每个物理内存页的地址和状态（比如是否被使用，被哪个进程使用）记录在struct page的一个实例中。页帧数组中的每个元素对应物理内存中的一个页，页帧数组的索引直接映射到物理内存地址。</p><p>在多个内存条的情况下，页帧数组会涵盖所有的内存条。即使内存条在物理上是分离的，但在页帧数组中它们看起来是连续的。当一个物理页面被分配给一个进程时，操作系统会在页表中创建一个页表项，将虚拟地址映射到这个物理页面的地址。</p></blockquote><p>这种默认的分配策略一般情况下可能没有问题，但是对于一些需要分配大量内存的应用上可能会出现性能问题。如使用MySQL时，假如每个node有32G的内存，而MySQL配置了48G 的 innodb buffer pool，那么可能会出现尽管系统还有很多空余的内容，但是很多内存都被 swap 出去了。这就是因为默认的内存分配方案是优先从本地分配，所以当node0内存快被占满时，尽管node1还有很多内存，但是node0里面的内存还是会被swap出去。</p><blockquote><p>以上是硬件层面上的NUMA（hardware view），而作为软件层面的Linux，则对NUMA的概念进行了抽象。即便硬件上是一整块连续内存的UMA，Linux也可将其划分为若干的node（所有node其实是个软件上的概念）。同样，即便硬件上是物理内存不连续的NUMA，Linux也可将其视作UMA（software view）。</p><p>所以，在<a href="https://so.csdn.net/so/search?q=Linux系统&spm=1001.2101.3001.7020">Linux系统</a>中，你可以基于一个UMA的平台测试NUMA上的应用特性。从另一个角度，UMA就是只有一个node的特殊NUMA，所以两者可以统一用NUMA模型表示。</p></blockquote><h4 id="2）zone划分"><a href="#2）zone划分" class="headerlink" title="2）zone划分"></a>2）zone划分</h4><p>NUMA模型中，<strong>物理内存</strong>被划分为几个节点（node），一个node对应一个内存簇bank，即每个内存簇认为是一个节点。</p><p>首先，内存被划分为结点，每个节点关联到系统中的一个处理器。接着各个节点又被划分为内存管理区域，一个管理区域通过struct zone_struct描述，其被定义为zone_t，用以表示内存的某个范围。主要分为以下几种类型的内存管理区域：</p><ol><li>ZONE_DMA：地址段最低的一块内存区域（物理内存起始的16M），供IO设备DMA访问。<ul><li>一些使用 DMA 的外设并没有像 CPU 那样的 32 位地址总线，比如只有 16 位总线，就只能访问 64 KB 的空间，24 位总线就只能访问 16 MB 的空间，如果给 DMA 分配的内存地址超出了这个范围，设备就没法（寻址）访问了。也应该成为ZONE_DMA24</li></ul></li><li>ZONE_DMA32：到了 64 位系统，外设的寻址能力增强，因此又加入了一个 ZONE_DMA32，空间大小为 16MB 到 4GB</li><li>ZONE_NORMAL：可<strong>直接映射</strong>到内核的普通内存域（16M-896M），在X86-64架构下，DMA和DMA32之外的内存全部在NORMAL的zone里管理</li><li>ZONE_HIGHMEM：高端内存，内核不能直接使用（896M-4G），<strong>动态映射</strong>到内核空间3G+896M-4G的位置。即要访问的物理地址空间大于虚拟地址空间，不能直接建立映射的场景。适用于32位CPU系统，64位的CPU系统虚拟地址空间足够大，直接映射即可，所以都是NORMAL。</li></ol><p><img src="/posts/48821/969d18e411f3417abe1318c9b2349f45.png" alt></p><p>每个zone下都包含了许许多多个Page（页面），在Linux下一个页面的大小一般是4KB（处理器架构决定的，操作系统编译的时候固定下来）。</p><p>可以使用zoneinfo命令查看机器上zone的划分，也可以看到每个zone下所管理的页面有多少。</p><h4 id="3）基于伙伴系统管理空闲页面"><a href="#3）基于伙伴系统管理空闲页面" class="headerlink" title="3）基于伙伴系统管理空闲页面"></a>3）基于伙伴系统管理空闲页面</h4><blockquote><p>伙伴系统中的伙伴指的是两个内存块、大小相同、地址连续，同属于一个大块区域</p></blockquote><p>每个zone下面都有很多的页面，Linux使用伙伴系统对这些页面进行高效的管理。在内核中，表示zone的数据结构是struct zone。其下面的一个数组free_area管理了绝大部分可用的空闲页面。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> MAX_ORDER 11</span><span class="token keyword">struct</span> zone<span class="token punctuation">{</span>    free_area free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>free_area是一个包含11个元素的数组。每一个元素分别代表不同大小（4KB、8KB、16KB、32KB…）的空闲可分配的连续内存链表。</strong></p><p>即每一个元素都代表一种大小的内存块，数组的索引表示了内存块包含的页框数量。例如，free_area[0]中存放的是单独的空闲页框（4KB），free_area[1]中存放的是包含两个页框的空闲内存块（8KB），等等。这种方式可以方便地查找和分配满足特定大小需求的内存块。</p><p><img src="/posts/48821/a74c3cf0ab4d4c61b2c5db5a79870151.png" alt></p><p>每个free_area元素都有一个或多个链表：</p><ol><li>MIGRATE_UNMOVABLE：表示不可移动的pages，例如内核数据结构的pages。</li><li>MIGRATE_RECLAIMABLE：表示可回收的pages，例如系统中的缓存，当内存紧张时可以回收其内存。</li><li>MIGRATE_MOVABLE：表示可移动的pages，例如用户进程的pages。当需要大块连续的内存空间，或者进行内存碎片整理时，可以移动这类page。</li><li>MIGRATE_PCPTYPES：表示特殊用途的pages，一般用于不可移动和可回收page的临时备份。</li><li>MIGRATE_HIGHATOMIC：表示高优先级的分配请求，这种类型的page只有在内存非常紧张时才会被使用。</li></ol><p>链表中的每一个元素都是一个空闲内存块。这些内存块在物理内存中是连续的，也就是说，它们包含的页框在物理内存中是紧邻的。这样，当内核需要分配一个连续的内存区域时，可以直接从这些链表中查找和分配。但要注意，虽然这些内存块在物理内存中是连续的，但在虚拟内存中可能并不连续。因为虚拟地址到物理地址的映射是通过页表完成的，不同的页框可以被映射到虚拟内存中的任意位置（不一定在相邻的页表项）。</p><blockquote><p>free_area数组里的链表元素存储了一个叫struct page的结构体。struct page是内核用来描述<strong>物理内存页</strong>的主要数据结构。</p><p>每个物理页在内核中都有一个对应的struct page实例。这个结构体包含了许多用于页管理的字段，如用于链接空闲页的链表节点字段等。内核可以通过这个结构体找到对应的物理页。为了映射物理内存和struct page实例，Linux内核使用了一种叫做mem_map的数组。这个数组的每个元素都是一个struct page实例，整个数组的顺序与物理内存页的顺序相同。因此，内核可以通过简单的指针运算在物理地址和对应的struct page实例之间进行转换。</p></blockquote><p>通过cat /proc/pagetypeinfo可以看到当前系统中伙伴系统各个尺寸的可用连续内存块数量。</p><p>内核提供分配器函数alloc_pages到上面的多个链表中寻找可用连续页面。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> page <span class="token operator">*</span> <span class="token function">alloc_pages</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如要申请8KB（连续两个页框的内存），<strong>在基于伙伴系统的内存分配中，有可能需要将大块内存拆分成两个小伙伴。在释放中，可能会将两个小伙伴合并，在此组成更大块的连续内存。</strong>具体的工作步骤：</p><ol><li>先到free_area[1]，即8KB的链表中查询</li><li>如果无可用，则到free_area[2]，即16KB的链表中查询</li><li>如果找到了则将其拆分成两个小伙伴，使用掉其中一个</li><li>将另一个小伙伴放置到8KB的链表中</li></ol><h4 id="4、slab分配器"><a href="#4、slab分配器" class="headerlink" title="4、slab分配器"></a>4、slab分配器</h4><p>到目前介绍的内存分配都是以页面4KB为单位的。而内核代码经常需要在运行时分配和释放小块的内存区域。如果每次都使用普通的页分配器（即每次分配至少一个页的内存）来完成，可能会浪费大量内存。为了更高效地分配小块内存，内核在伙伴系统之上又引入了一个专用的内存分配器slab（或叫slub）</p><p>这个分配器最大的特点就是<strong>一个slab内只分配特定大小、甚至是特定的对象，当一个对象释放内存后，另一个同类对象可以直接使用这块内存</strong>。通过这样的方式极大地降低了碎片发生的概率。</p><p>在SLAB分配器中，<strong>当内核需要频繁创建和销毁某种类型的对象时（比如文件描述符、进程描述符等），它会创建一个kmem_cache，并根据需要的对象大小进行初始化</strong>。<strong>每个kmem_cache都包含一些预分配的内存块（SLABs）</strong>，这些内存块的大小都与需要的对象大小相匹配。当内核代码需要分配一个新的对象时，可以直接从对应的kmem_cache中取出一个预先分配的内存块，而不需要每次都去进行页分配。同样，当一个对象被释放时，它的内存块可以被直接归还到kmem_cache中，以便再次使用。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> kmem_cache <span class="token punctuation">{</span>    <span class="token keyword">struct</span> kmem_cache_node <span class="token operator">*</span><span class="token operator">*</span>node<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> kmem_cache_node <span class="token punctuation">{</span>    <span class="token keyword">struct</span> list_head slabs_partial<span class="token punctuation">;</span>    <span class="token keyword">struct</span> list_head slabs_full<span class="token punctuation">;</span>    <span class="token keyword">struct</span> list_head slabs_free<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>一个kmem_cache可以有多个kmem_cache_node，每个kmem_cache_node代表该kmem_cache在一个特定的NUMA节点上的状态。</strong>NUMA是一种针对多处理器系统的内存架构，其主要思想是将物理内存划分为多个节点，每个处理器可以直接访问所有的内存，但访问不同节点的内存的延迟和带宽可能会有所不同。因此，在NUMA系统中，内存的分配策略可能会影响到程序的性能。为了在NUMA系统中更高效地管理内存，Linux内核引入了kmem_cache_node。在每个kmem_cache中，每个NUMA节点都有一个对应的kmem_cache_node。这个kmem_cache_node包含了该节点上的空闲对象列表，以及其他一些与该节点相关的信息。当从kmem_cache中分配或释放对象时，内核会优先考虑当前CPU对应的NUMA节点，这样可以提高内存访问的性能。</p><p><strong>每个kmem_cache_node中都有满、半满、空三个链表。每个链表节点都对应一个slab，一个slab由一个或多个内页也组成。</strong></p><p><strong>每一个slab内都保存的是同等大小的对象。</strong></p><p>当cache中内存不够时，会调用基于伙伴系统的分配器请求整页连续内存的分配。</p><p><img src="/posts/48821/c5a0449280aa42e593cf86d90c29092d.png" alt></p><p>内核中会有很多个kmem_cache存在，它们是在Linux初始化或者是运行的过程中分配出来的。其中有的是通用的，有的是专用的。</p><p><img src="/posts/48821/d06a875b50c649e5bb57d84ddfb1986d.png" alt></p><p>从图中可以<strong>看到socket_alloc内核对象都存在TCP的专用kmem_cache中</strong>。通过查看/proc/slabinfo可以查看所有的kmem_cahce。</p><p><strong>并不是所有的对象都会使用SLAB分配器进行分配。SLAB分配器是针对频繁分配和释放的小型对象设计的</strong>，比如内核中的各种数据结构（例如，文件描述符、信号量、进程描述符等）。对于这些对象，SLAB分配器可以显著提高分配效率，减少内存碎片，并提高缓存利用率。然而，对于大型对象（比如用户请求的大块内存），或者不常用的对象（即分配和释放不频繁的对象），直接使用页分配器（Page Allocator）或者伙伴系统（Buddy System）进行分配通常更为高效。页分配器可以处理任何大小的内存请求，但对于小型对象，可能会造成内存的浪费。</p><p>此外，用户空间的内存分配（例如，通过malloc()或者new进行的分配）通常不直接使用SLAB分配器。用户空间的内存分配通常由C库（例如，glibc）提供的内存分配器处理，这个分配器使用系统调用（例如，brk()或者mmap()）从内核获取或释放内存。</p><blockquote><p>Linux还提供了一个特别方便的命令slabtop来按照内存从大到小进行排列，可以用来分析slab内存开销。</p><p>此外slab管理器组件提供了若干接口函数方便使用：</p><ol><li>kmem_cache_create：创建一个基于slab的内核对象管理器。</li><li>kmem_cache_alloc：快速为某个对象申请内存。</li><li>kmem_cache_free：将对象占用的内存归还给slab分配器</li></ol></blockquote><h4 id="5）小结"><a href="#5）小结" class="headerlink" title="5）小结"></a>5）小结</h4><p>内核使用内存的方式：</p><ol><li>把所有内存条和CPU换分成node</li><li>把每一个node划分成zone</li><li>每个zone下都用伙伴系统管理空闲页面</li><li>内核提供slab分配器为自己专用</li></ol><p><strong>前三步是基础模块，为应用程序分配内存时的请求调页组件页能够用到，但是第四步就是内核给自己专用的了。</strong></p><h3 id="三、TCP连接相关内核对象"><a href="#三、TCP连接相关内核对象" class="headerlink" title="三、TCP连接相关内核对象"></a>三、TCP连接相关内核对象</h3><p>TCP连接建立的过程中，每申请一个内核对象也都需要到相应的缓存里申请一块内存。</p><h4 id="1）socket函数直接创建"><a href="#1）socket函数直接创建" class="headerlink" title="1）socket函数直接创建"></a>1）socket函数直接创建</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__sock_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分配socket对象</span>    sock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用协议族的创建函数创建sock对象</span>    err <span class="token operator">=</span> pf<span class="token operator">-></span><span class="token function">create</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-sock-inode-cache对象申请"><a href="#1-sock-inode-cache对象申请" class="headerlink" title="1. sock_inode_cache对象申请"></a>1. sock_inode_cache对象申请</h5><p>在sock_alloc函数中，申请了一个struct socket_alloc的内核对象。<strong>socket_alloc内核对象将socket和inode信息关联了起来。</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> socket_alloc <span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket socket<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inode vfs_inode<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在sock_alloc的实现逻辑中，最后就<strong>调用了kmem_cache_alloc从sock_inode_cache中申请了一个struct socket_alloc对象</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token function">sock_alloc_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket_alloc <span class="token operator">*</span>ei<span class="token punctuation">;</span>    <span class="token keyword">struct</span> socket_wq <span class="token operator">*</span>wq<span class="token punctuation">;</span>    ei <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>sock_inode_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ei<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    wq <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>wq<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>sock_inode_cache是专门用来存储struct socket_alloc的slab缓存</strong>，它是在init_inodecache中通过<code>kmem_cache(&quot;sock_inode_cache&quot;, sizeof(struct socket_alloc), ...)</code>初始化的。</p><p>另外还可以看到通过kmalloc申请了一个socket_wq，这是个用来记录在socket上等待事件的等待项。</p><h5 id="2-tcp对象申请"><a href="#2-tcp对象申请" class="headerlink" title="2. tcp对象申请"></a>2. tcp对象申请</h5><p>对于IPv4来说，inet协议族对应的create函数是inet_create，因此__sock_create中对pf-&gt;create的调用会执行到inet_create中去。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">inet_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 这个answer_prot其实就是tcp_prot</span>    answer_prot <span class="token operator">=</span> answer<span class="token operator">-></span>prot<span class="token punctuation">;</span>    sk <span class="token operator">=</span> <span class="token function">sk_alloc</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> PF_INET<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> answer_prot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">sk_alloc</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    sturct sock <span class="token operator">*</span>sk<span class="token punctuation">;</span>    sk <span class="token operator">=</span> <span class="token function">sk_prot_alloc</span><span class="token punctuation">(</span>prot<span class="token punctuation">,</span> priority <span class="token operator">|</span> __GFP_ZERO<span class="token punctuation">,</span> family<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">sk_prot_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> proto <span class="token operator">*</span>prot<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    slab <span class="token operator">=</span> prot<span class="token operator">-></span>slab<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>slab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      sk <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>slab<span class="token punctuation">,</span> priority <span class="token operator">&amp;</span> <span class="token operator">~</span>__GFP_ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个函数中，<strong>将会到TCP这个slab缓存中使用kmem_cache_alloc从slab中申请一个struct sock内核对象出来</strong>。TCP这个slab缓存是在协议栈初始化的时候在inet_init中使用<code>kmem_cache_create(prot-&gt;name, prot-&gt;obj_size, ...)</code>（这里prot是一个tcp_prot）初始化好的一个名为TCP、大小为sizeof(struct tcp_sock)的kmem_cache，并把它记到tcp_prot-&gt;slab的字段下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> proto tcp_prot <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"TCP"</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span>obj_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tcp_sock<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要记住的是，在<strong>TCP slab缓存中实际存放的是struct tcp_sock对象，是struct sock的扩展</strong>，由于tcp_sock、inet_connection_sock、inet_sock、sock是逐层嵌套的关系，所以tcp_sock是可以当作sock来使用的。</p><h5 id="3-dentry和flip对象申请"><a href="#3-dentry和flip对象申请" class="headerlink" title="3. dentry和flip对象申请"></a>3. dentry和flip对象申请</h5><p>回到socket系统调用的入口处，除了sock_create以外，还调用了一个sock_map_fd</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">sock_create</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sock_map_fd</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>0_CLOEXEC <span class="token operator">|</span> ONONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以此为入口将完成struct dentry的和struct file申请。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> dentry <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> dentry <span class="token operator">*</span>d_parent<span class="token punctuation">;</span>    <span class="token keyword">struct</span> qstr d_name<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inode <span class="token operator">*</span>d_inode<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> d_iname<span class="token punctuation">[</span>DNAME_INLINE_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内核初始化的时候创建好了一个dentry slab和flip slab缓存，所有的struct dentry对象和struct file对象都将由它们进行分配。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sock_map_fd</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> file <span class="token operator">*</span>newfile<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 1.申请dentry、file内核对象</span>    newfile <span class="token operator">=</span> <span class="token function">sock_alloc_file</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>newfile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 2.关联到socket及进程</span>      <span class="token function">fd_install</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> newfile<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> fd<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">struct</span> file <span class="token operator">*</span><span class="token function">sock_alloc_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dname<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 申请dentry</span>    path<span class="token punctuation">.</span>dentry <span class="token operator">=</span> <span class="token function">d_alloc_pseudo</span><span class="token punctuation">(</span>sock_mnt<span class="token operator">-></span>mnt_sb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 申请flip</span>    file <span class="token operator">=</span> <span class="token function">alloc_file</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">,</span> FMOD_READ <span class="token operator">|</span> FMODE_WRITE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>socket_file_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在sock_alloc_file中完成内核对象的申请，其中会去进行struct dentry和struct file两个内核对象的申请。</strong>dentry对象的申请最终同样是是调用到了kmem_cache_alloc函数（对应的slab缓存dentry在内核初始化时的dcache_init中创建的），而file对象的申请最终是调用了kmem_cache_zalloc函数进行分配（对应的slab缓存flip是在内核初始化时的files_init中创建的）</p><blockquote><p>kmem_cache_alloc()和kmem_cache_zalloc()都是用于从指定的kmem_cache中分配对象的函数。它们的主要区别在于，kmem_cache_zalloc()在分配内存后，会自动将内存区域初始化为0。</p><p>具体来说：</p><ul><li>kmem_cache_alloc()：从指定的kmem_cache分配一个对象的内存空间。返回的内存空间中的内容是不确定的，也就是说，它可能包含任何数据。调用者需要自己对内存进行初始化。</li><li>kmem_cache_zalloc()：从指定的kmem_cache分配一个对象的内存空间，并自动将整个内存区域初始化为0。这意味着调用者可以直接使用返回的内存，无需再进行初始化。</li></ul><p>在一些情况下，使用kmem_cache_zalloc()可能更方便，因为它可以确保内存区域的内容被初始化为0。然而，如果你知道你会立即覆盖整个内存区域的内容，那么使用kmem_cache_alloc()可能会更高效，因为它避免了不必要的内存初始化。</p></blockquote><h5 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h5><p>调用链：</p><ul><li>SYSCALL_DEFINE3<ul><li>sock_create<ul><li>__sock_create<ul><li>sock_alloc =&gt; =&gt; sock_alloc_inode：申请socket_alloc和socket_wq</li><li>inet_create<ul><li>sk_alloc =&gt; sk_prot_alloc：申请tcp_sock</li></ul></li></ul></li></ul></li><li>sock_map_fd<ul><li>sock_alloc_file<ul><li>d_alloc_pseudo =&gt; __d_alloc：申请dentry</li><li>alloc_file =&gt; get_empty_flip：申请file</li></ul></li></ul></li></ul></li></ul><p>socket系统调用完毕之后，在内核中就申请了配套的一组内核对象。这些内核对象并不是鼓励地存在，而是互相保留着和其他内存对象的关联关系。</p><p><img src="/posts/48821/6d424f2828a1426d973ef066379d1b47.png" alt></p><p>所有网络相关的操作，包括数据接收和发送等都以这些数据结构为基础来进行的</p><h4 id="2）服务端socket创建"><a href="#2）服务端socket创建" class="headerlink" title="2）服务端socket创建"></a>2）服务端socket创建</h4><p>除了直接创建socket意外，服务端还可以通过accept函数在接受连接请求时完成相关内核对象的创建。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE</span><span class="token punctuation">(</span>accept4<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr __user <span class="token operator">*</span><span class="token punctuation">,</span> upeerp_sockaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token operator">*</span>newsock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据fd查找到监听的socket</span>    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 申请并初始化新的socket</span>    newsock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    newsock<span class="token operator">-></span>type <span class="token operator">=</span> sock<span class="token operator">-></span>type<span class="token punctuation">;</span>    newsock<span class="token operator">-></span>ops <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 申请新的file对象，并设置到新的socket上</span>    newfile <span class="token operator">=</span> <span class="token function">sock_alloc_file</span><span class="token punctuation">(</span>newsock<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 接受连接</span>    err <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">accept</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> newsock<span class="token punctuation">,</span> sock<span class="token operator">-></span>file<span class="token operator">-></span>f_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将新文件添加到当前进程的打开文件列表</span>    <span class="token function">fd_install</span><span class="token punctuation">(</span>newfd<span class="token punctuation">,</span> newfile<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到socket_alloc、file、dentry对象的分配都是相同的方式，唯一的区别是tcp_sock对象是在第三次握手的时候创建的，所以这里在接收连接的时候直接从全连接队列拿出request_sock的sock成员就可以了，无需再单独申请。</p><h3 id="四、问题解答"><a href="#四、问题解答" class="headerlink" title="四、问题解答"></a>四、问题解答</h3><ol><li>内核是如何管理内存的：内核采用SLAB的方式来管理内存，总共分为四部<ul><li>把所有的内存条和CPU进行分组，组成node</li><li>把每一个node划分成多个zone</li><li>每个zone下都用伙伴系统来管理空闲页面</li><li>提供slab分配器来管理各种内核对象</li><li>前三步时基础模块，为应用程序分配内存时的请求调页组件也能够用到，而第四步是内核专用的。每个slab缓存都是用来存储固定大小，甚至是特定的一种内核对象。这样当一个对象释放内存后，另一个同类对象可以直接使用这块内存，几乎没有任何碎片。极大地提高了分配效率，同时降低了碎片率。</li></ul></li><li>如何查看内核使用的内存信息<ul><li>通过/proc/slabinfo可以看到所有的kmem_cache。</li><li>更方便的是slatop命令，它从大到小按照占用内存进行排列。</li></ul></li><li>服务器上一条ESTABLISH状态的空连接需要消耗多少内存：假设连接上绝大部分时间都是空闲的，也就是假设没有发送缓存区和接收缓存区的开销，那么一个socket大约需要如下几个内核对象<ul><li>struct socket_alloc：大约0.62KB， slab缓存名是sock_inode_cache</li><li>struct top_sock：大约1.94KB，slab缓存名是tcp</li><li>struct dentry：大约0.19KB，slab缓存名是dentry</li><li>struct file：大约为0.25KB，slab缓存名是flip</li><li>加上slab多少会存在一点碎片无法使用，这组内核对象的大小大约是3.3KB左右。所以即使一万条连接也只需要占用33MB的内存</li><li>至于CPU开销，没有数据包的接收和处理是不需要消耗CPU的。长连接上在没有数据传输的情况下，只有极少量的保护包传输，CPU开销可以忽略不计</li></ul></li><li>机器上出现了3万多个TIME_WAIT，内存开销会不会很大<ul><li>从内存的角度来考虑，一条TIME_WAIT状态的连接仅仅是0.4KB左右的内存而已</li><li>从端口的角度来考虑，占用的端口只是针对特定服务器来说是占用了，只要下次连接的服务端不一样（IP或者端口不一样），那么这个端口仍然可以用来发起TCP连接</li><li>只有在连接同一个server的时候端口占用才能算得上是问题。如果想解决这个问题可以考虑使用tcp_max_tw_buckets来限制TIME_WAIT连接总数，或者打开tcp_tw_recycle、tcp_tw_reuse来快速回收端口，或者干脆使用长连接代替频繁的短连接。</li></ul></li></ol><p><strong>拓展阅读</strong>：</p><p><a href="https://zhuanlan.zhihu.com/p/62795773">Linux 内核 101：NUMA架构 - 知乎 (zhihu.com)</a></p><p><a href="https://www.jianshu.com/p/0607c5f62c51">浅解NUMA机制 - 简书 (jianshu.com)</a></p><p><a href="https://www.cnblogs.com/linhaostudy/p/10006723.html">Linux内存描述之内存区域zone–Linux内存管理(三) - yooooooo - 博客园 (cnblogs.com)</a></p><p><a href="https://www.dingmos.com/index.php/archives/23/#cl-2">Linux 内核 | 内存管理——Slab 分配器 - 一丁点儿 (dingmos.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/68465952">Linux中的物理内存管理 [一] - 知乎 (zhihu.com)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在应用程序里，我们使用多少内存都是自己能掌握和控制的，但是纵观Linux整台服务器，除了应用程序以外，内核也会申请和管理大量的内存。&lt;/p&gt;
&lt;h3 id=&quot;一、相关实际问题&quot;&gt;&lt;a href=&quot;#一、相关实际问题&quot; class=&quot;headerlink&quot; title=&quot;一、
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议中三次握手和四次挥手</title>
    <link href="https://joytsing.github.io/posts/42952/"/>
    <id>https://joytsing.github.io/posts/42952/</id>
    <published>2024-04-07T12:35:56.000Z</published>
    <updated>2024-04-10T09:00:22.436Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、三次握手流程"><a href="#一、三次握手流程" class="headerlink" title="一、三次握手流程"></a>一、三次握手流程</h3><p>推荐<a href="https://www.coonote.com/tcpip/tcp-three-handshakes-four-waves.html">阅读这篇文章</a>：</p><ol><li>客户端调用connect系统调用，发出第一次握手<ul><li><strong>找到套接字</strong>：创建内核对象的时候，fd会跟file对象做通过fd_install关联起来，通过进程的fd_table就可以找到对应的file，而file的private指针就指向了socket对象，所以根据fd即可找到套接字</li><li><strong>判断当前套接字的状态</strong>：只有SS_UNCONNECTED状态（刚创建的套接字就是该状态）才会继续，其他状态都会报错<ul><li>注意此处是socket的状态，而不是sock的状态</li><li>会将socket状态更改为SS_CONNECTING</li></ul></li><li><strong>更改sock状态为TCP_SYN_SENT</strong></li><li><strong>绑定端口</strong>：如果当前套接没有bind端口（端口为0则表示没有绑定），则从ip_local_port_range的某一个随机位置开始循环遍历找到合适的端口，如果查询不到则抛出Cannot assign requested address的错误</li><li><strong>申请skb加入发送队列并设置syn数据包</strong>：将SYN标志位置为1，随机生成一个序列号，并设置MSS等字段，随后将数据包发送出去<ul><li>这里直接调用的是tcp_transmit_skb，而正常发送逻辑会从tcp_sendmsg开始，其中会检查当前套接字的状态，如果不是已建立或者CLOSE_WAIT，会等待连接建立</li></ul></li><li><strong>启动重传定时器</strong>：等到一定时间后收不到服务端的反馈的时候来开启重传。首次超时时间是在TCP_TIMEOUT_INIT宏中定义的，该值在Linux3.10版本是1秒， 在一些老版本中是3秒。每次超时时间为2的指数递增（1，2，4，8，16，32）</li></ul></li><li>服务端收到SYN包之后，发出第二次握手<ul><li><strong>找到套接字</strong>：skb通过软中断不断上传到tcp协议栈，根据数据报首部的IP地址和端口号查找对应的socket对象</li><li><strong>判断当前套接字的状态</strong>：这里会进入TCP_LISTEN的处理逻辑</li><li><strong>判断连接是否已经建立</strong>：检查是否有与这个SYN包的四元组相同的连接已经存在<ul><li>如果已经存在ESTABLISHED状态的连接，则丢弃该握手包</li><li>如果已经存在SYN_RCVD状态的连接，则可能是一个重传的SYN包，这个时候会继续一下逻辑</li></ul></li><li><strong>查找半连接队列</strong>：到套接字的半连接队列中查找是否存在对应的半连接对象，因为当前是第一次握手，所以显然队列中还不存在半连接对象</li><li><strong>创建半连接对象加入队列</strong>：会先检查半连接队列和全连接队列是否已满，如果数据包没有被丢弃则创建request_sock对象，将状态设置为TCP_SYN_RCVD<ul><li>如果半连接队列满了且还没有开启syn_cookies那么将直接把握手包丢弃</li><li>如果全连接队列已满且存在young ack则同样把握手包丢弃</li></ul></li><li><strong>构造synack包并发送</strong>：将ACK和SYN标志位都置为1，随机生成一个序列号，并将确认号设置为SYN包的序列号+1，同时设置MSS等字段，最后将数据包发送出去</li><li><strong>半连接对象入队</strong>：将半连接对象request_sock加入半连接队列</li><li><strong>开启重传定时器</strong></li></ul></li><li>客户端收到SYNACK包之后，发出第三次握手<ul><li><strong>找到套接字</strong>：skb通过软中断不断上传到tcp协议栈，根据数据报首部的IP地址和端口号查找对应的socket对象</li><li><strong>判断当前套接字的状态</strong>：这里会进入TCP_SYN_SENT的处理逻辑</li><li><strong>移除重传队列中的SYN包，停止计时器</strong></li><li><strong>更改sock状态为ESTABLISHED</strong></li><li><strong>初始化TCP连接的拥塞控制算法、接收缓存和发送缓存空间等信息</strong></li><li><strong>开启keep alive保活计时器</strong></li><li><strong>唤醒等待队列的进程</strong></li><li><strong>构造ACK包进行发送</strong>：判断是否满足TCP的延迟确认（Delayed ACK）机制，如果满足则和数据包一起发送</li></ul></li><li>服务端收到ACK包之后，完成连接建立<ul><li><strong>找到套接字</strong>：skb通过软中断不断上传到tcp协议栈，根据数据报首部的IP地址和端口号查找对应的socket对象</li><li><strong>判断当前套接字的状态</strong>：这里会进入TCP_LISTEN的处理逻辑（注意不是TCP_SYN_RCVD）</li><li><strong>查找半连接队列</strong>：这次是响应第三次握手，在上一次已经创建了半连接对象放置在队列中，所以这次可以<strong>从队列中拿到半连接对象</strong></li><li><strong>创建sock对象</strong>：判断socket的全连接队列是否满了，没满则根据半连接对象创建子sock<ul><li>会将sock状态设置为ESTABLISHED，并且关联到这个request_sock</li><li>随后将request_sock其从半连接队列移除，加入到全连接队列中</li></ul></li><li><strong>唤醒等待队列的进程</strong>：如果有进程调用accept等待连接的话，则会被唤醒<ul><li>唤醒之后进程从全连接队列中拿到request_sock</li><li>之后就可以根据request_sock中保存的tcp_sock来创建socket对象</li></ul></li></ul></li></ol><h3 id="二、为什么握手是三次"><a href="#二、为什么握手是三次" class="headerlink" title="二、为什么握手是三次"></a>二、为什么握手是三次</h3><p>如果不进行最后一次握手，即服务端返回synack报文之后就完成建立的话，那么在数据包延迟到达的情况下有可能出现问题。</p><ul><li>第一次握手包延迟：假如说客户端发起的SYN数据包因为网络延迟没有到达服务端，那么这时候它就收不到服务端的SYNACK报文，那么此时它就会超时重传SYN数据包。如果这次服务端收到了并回复了SYNACK报文，那么连接就算建立成功了。而在连接建立成功并且通讯完成又释放了之后，第一次因为延迟而没有到达服务端的SYN数据包这时候到达了，这时候服务端会以为是一个新的连接到达，于是再次响应一个SYNACK报文，因为只有两次握手，所以就建立了一条本不应该存在的连接。而如果此时使用的是三次握手，那么客户端收到这条SYNACK报文后则会将其丢弃，不会完成连接的建立。</li><li>第二次握手包延迟：如果服务端收到了客户端的SYN报文，而回传SYNACK包的时候超时了，那么如果此时是两次握手，服务端直接认为连接建立成功，而客户端会以为是自己的SYN报文没有到达服务端而重传SYN数据包，那么服务端会因为已经建立连接（自己认为已经建立过了）所以丢弃重传的SYN包，所以客户端这边永远都连不上。而如果此时使用的是三次握手，那么在SYNACK包超时之后，除了客户端重发SYN包，服务端也会重发SYNACK包。那么客户端收到重发的SYNACK包之后会发出ACK包，而服务端收到重发的SYN包后会再次发出SYNACK包。这时这个新的SYNACK包到达之后会因为序列号对不上而被客户端丢弃，而服务端收到ACK包之后就完成连接的建立。建立完成之后即使延迟的SYNACK包到达了客户端，也会同样被丢弃。</li><li>第三次握手包延迟（当然只可能在三次握手时出现）：客户端发出ACK报文之后是不会期待响应的，所以此时它会直接认为连接建立。而服务端会因为收不到ACK包而重传SYNACK包，那么客户端会再次发送ACK包，如果服务端收到则完成建立。如果重试多次后一直丢失，那么服务端会认为连接建立失败而关闭连接。后续如果客户端正常的发出数据包给服务端，则会收到RST包，从而意识到连接已经被关闭。也就是说没有必要有第四次握手，如果ACK包一直丢失不能建立连接，后续发送数据的时候就可以感知到。</li></ul><p><img src="/posts/42952/7179150385446631985.png" alt></p><h3 id="三、关闭连接的情况"><a href="#三、关闭连接的情况" class="headerlink" title="三、关闭连接的情况"></a>三、关闭连接的情况</h3><p>关闭连接有以下几种可能：</p><ol><li><strong>超时</strong>：如果在设定的超时时间内没有收到期望的ACK包或其他响应，TCP连接会被关闭。这是为了防止网络中的“僵尸连接”消耗系统资源。</li><li><strong>错误或异常</strong>：如果发生了某些错误或异常，例如网络错误、对方突然断线或程序崩溃等，TCP连接也会被关闭。</li><li><strong>主动关闭</strong>：如果应用程序调用了关闭连接的函数（例如close和shutdown），TCP连接也会被关闭。</li><li><strong>RST标志</strong>：如果收到一个带有RST（Reset）标志的TCP包，TCP连接也会被立即关闭。RST包通常在发生错误或异常时被发送，例如，收到了一个不应该收到的包，或者试图打开一个不存在的连接等。</li></ol><p>如果是发生了如网络错误、断线或程序崩溃等错误或异常，那么自己这边的系统可能关闭所有的网络接口，释放所有的网络相关的内存等（取决于操作系统和协议栈的实现），而对端发送的保活数据包将接收不到ACK，重试几次后，就会进行连接的关闭，这个时候是不会进行四次挥手的。</p><p>而如果是发生以下情况，就会发送一个带有RST标志的TCP包。收到带有RST标志的包的一方会立即关闭连接，而不需要执行常规的四次挥手过程。这种情况下，连接的关闭是非正常的，因为它并没有经过正常的关闭过程就被终止了。</p><ol><li><strong>收到了一个错误的序列号的数据包</strong>：在TCP连接中，每个数据包都有一个序列号，用来保证数据包的有序接收。如果收到了一个序列号不正确的数据包（即这个数据包的序列号不在期望的序列号范围内），TCP会发送一个RST数据包来重置连接</li><li><strong>应用程序强制关闭</strong>：应用程序在正常关闭一个TCP连接时，会通过操作系统发送一个FIN（Finish）标志的数据包，这将触发TCP的正常关闭流程，也就是所谓的”四次挥手”。然而，有一种特殊的情况，那就是”强制关闭”或”紧急关闭”。在某些情况下，例如，应用程序崩溃，或者用户想要立即关闭连接，而不等待四次挥手过程完成，操作系统会发送一个RST（Reset）标志的数据包来立即关闭连接。这种情况下，操作系统并不会等待对方的确认，连接会立即关闭。可以使用SO_LINGER选项来设置一个0延迟的linger时间以实现强制关闭</li><li><strong>网络层错误或异常</strong>：在某些网络层的错误或异常情况下，例如，网络接口出错或者IP路由失败，TCP可能会发送一个RST数据包来关闭连接。</li><li><strong>TCP层错误或异常</strong>：在某些TCP层的错误或异常情况下，例如，内存不足，无法创建新的数据包，或者处理到一半的数据包被意外丢失，TCP可能会发送一个RST数据包来关闭连接。</li></ol><p>也就是以上的情况其实都不会进行四次挥手，只有当正常进行连接的关闭才会进行四次挥手的逻辑。当应用程序A决定关闭一个TCP连接时，它会调用 close() 或 shutdown() 函数，这些函数在操作系统内部会发送一个FIN（Finish）标志的TCP数据包给对端B，这就开始了所谓的四次挥手过程。</p><h3 id="四、四次挥手流程"><a href="#四、四次挥手流程" class="headerlink" title="四、四次挥手流程"></a>四、四次挥手流程</h3><ol><li><p>主动方调用close或shutdown，发起第一次挥手</p><ul><li><strong>取消文件描述符和file对象指针的关联</strong>：即后续无法再使用这个文件描述符，shutdown不会关闭fd，所以仍需要调用close来关闭文件描述符<ul><li>lose在fd被多个进程持有时不会立马关闭连接，调用close只会让引用计数-1，需要等到socket的引用计数为0才会发送FIN报文</li><li>而shutdown会直接关闭连接</li></ul></li><li><strong>判断当前套接字状态</strong>：如果是LISTEN则直接设置为close，然后释放对象，结束流程</li><li><strong>释放接收队列</strong>：如果不是LISTEN状态则循环遍历接收队列，释放队列中的skb<ul><li>如果接收队列不为空，即释放了skb，则会发送一个RST来中断连接，然后更改套接字状态并释放相关资源，结束流程</li></ul></li><li><strong>判断是否设置了SO_LINGER</strong>：如果设置了该选项并且linger时间设置为0，那么也发送RST直接中断连接<ul><li>默认是没有设置该选项的，close方法不会阻塞的，在后台进行处理</li><li>如果设置为0，则立即关闭连接，发送缓冲区有未发送的数据则直接丢弃，直接进入CLOSED</li></ul></li><li><strong>发送FIN数据包</strong>：只有没有设置SO_LINGER或者设置了非0的linger才会来到这里<ul><li><strong>更新自身状态为FIN_WAIT_1（状态机中ESTABLISH的下一位）</strong></li><li><strong>遍历发送队列，如果其中有数据包未发送就在最后一个数据包设置FIN标志位，然后将所有数据包发送出去。</strong></li><li>如果设置了SO_LINGER，则进程进入阻塞，等待linger时间，如果超时仍然没有发完则会发送RST报文。</li><li>默认没有设置linger（不会阻塞）则会检测当前socket状态。如果是FIN_WAIT1（一般来说没有阻塞直接返回就是这个状态），就会查看孤儿socket数量是不是太多了，如果是则更改为CLOSE状态并发送RST直接关闭，不是则tcp_close函数到此基本结束</li></ul></li></ul></li><li><p>服务端收到FIN包之后，发起第二次挥手</p><ul><li><strong>找到套接字，检查到套接字状态</strong>：因为当前是ESTABLISHED状态，所以进入tcp_rcv_established，并在最终检测到数据报的FIN标志位为1而进入tcp_fin函数进行处理</li><li><strong>更改套接字状态</strong>：对于ESTABLISHED状态的套接字，会将其更改为CLOSE_WAIT状态</li><li><strong>内存清理</strong>：清空乱序队列中的数据包，并且根据当前的内存压力和套接字的内存使用情况来回收一部分内存</li><li><strong>唤醒阻塞的进程</strong>：通知在recv上等待的进程有数据可读，此时读取的返回结果会是0<ul><li>此时服务端已经知道对端已经关闭连接，然后就可以编写逻辑来决定何时调用close方法</li></ul></li><li><strong>发送ACK包给客户端</strong></li></ul></li><li><p>客户端收到ACK包</p><ul><li><strong>找到套接字，检查到套接字状态</strong>：因为当前的状态是TCP_FIN_WAIT1，所以会进去一个状态处理函数tcp_rcv_state_process（如果不是LISTEN或是ESTABLISHED就会进入这个函数）</li><li><strong>更改套接字状态</strong>：将自身的状态更改为TCP_FIN_WAIT2</li><li><strong>设置定时器</strong>：TMO+2MSL或者基于RTO计算超时<ul><li>超时后会直接变迁到closed状态，然后将套接字的发送端设置为关闭</li></ul></li><li><strong>唤醒阻塞在close上的进程</strong>：针对于设置了SO_LINGER的情况，被唤醒后继续执行close后续逻辑<ul><li>检测linger2是否大于等于0（TCP层面的，用于设定孤儿套接字在FIN_WAIT2状态的生存时间，如果没有配置则默认为tcp_fin_timeout，如果大于则等待一段时间来接收对端的FIN，如果小于0则立即关闭连接，并发送RST报文</li></ul></li></ul></li><li><p>服务端继续处理，发送数据包给客户端</p><ul><li><p>服务端在知道客户端关闭连接后还可以继续发送数据包</p></li><li><p>如果客户端关闭了读通道(close会都关闭)，那么客户端收到数据包后会发送RST数据包之后服务端直接进行关闭</p><p><img src="/posts/42952/aa1363297f2045bfb85055ee100d7a42.png" alt="在这里插入图片描述"></p></li><li><p>如果客户端只是关闭了写通道(shutdown可以只关闭写)，那么数据包会照常接收并返回ACK报文</p><p><img src="/posts/42952/bf95d06b15044605b0308d0dc5710f0b.png" alt="在这里插入图片描述"></p></li></ul></li><li><p>当服务端处理完毕之后，调用close方法，发起第三次挥手</p><ul><li><strong>释放接收队列</strong>：如果有skb释放或者socket设置了SO_LINGER选项且linger时间为0，那么还是发送RST</li><li><strong>更新套接字状态</strong> ：如果不是上面两种情况则继续更新到状态机的下一位，因为当前是CLOSE_WAIT，所以更新成LAST_ACK<ul><li>CLOSE_WAIT会在保活定时器超时后强行关闭连接，用于服务端一直没有主动关闭连接而客户端已经因为超时而关闭的情况。</li></ul></li><li><strong>发送FIN包给客户端</strong></li></ul></li><li><p>客户端收到FIN包之后，发起第四次挥手</p><ul><li><strong>发送ACK数据包</strong>：同样进入tcp_fin函数，发送ack包给服务端然</li><li><strong>更改套接字状态</strong>：为当前状态是TCP_FIN_WAIT2，更改至TIME_WAIT</li><li><strong>内存释放</strong>：time_wait状态时，原socket会被destroy，然后新创建一个inet_timewait_sock，在等待2MSL之后删除。</li></ul></li><li><p>服务端收到客户端的ACK包之后，完成四次挥手：<strong>将LAST_ACK更改为CLOSED，并且释放对象</strong></p></li></ol><p>如果两边同时发送FIN，那么在FIN_WAIT_1时收到对方的FIN，会进入CLOSING，之后收到ACK变成TIME_WAIT</p><h3 id="五、为什么挥手是四次"><a href="#五、为什么挥手是四次" class="headerlink" title="五、为什么挥手是四次"></a>五、为什么挥手是四次</h3><p>不同于握手，SYN和ACK可以同时发送。FIN表示的是自己没有数据要发了，而在客户端结束发送数据的时候，不一定服务端也结束了，所以没办法将FIN包和ACK包结合在一起发送。</p><p>对于可靠连接而言，ACK包是不可以省略的，每一个方向上的数据发送都应该得到对端的确认。并且假如说节省第二次挥手的ACK包，那么因为下一个FIN的时间是不确定的，有可能很久，那么实现的时候得让FIN_WAIT_1等待一个很久的时间。如果它是因为丢包了，那么重试也会需要一个很长的时间，这会导致close的时间非常的久。如果节省最后一个ACK包，也就是说被动方发出FIN之后就关闭，主动方收到FIN之后也直接关闭。那么有可能FIN包丢失了，所以导致被动方关闭了而主动方还在等待。</p><p>而最后需要进入TIME_WAIT状态等待2MSL的原因主要有两个：</p><ol><li>保证老的重复报文在网络中消逝：如果说没有TIME_WAIT两个2MSL，而客户端和服务端又基于原本的端口建立了新的连接，那么旧连接中可能有数据包延迟，没达到最大生存时间，所以还没被丢弃，这个时候到达了新的连接，并且正好在接收窗口中，那么此时会被误以为是正常的数据包，从而导致新的连接数据错乱。序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。所以通过设置2MSL，保证新连接建立的时候，旧连接在网络中残留的数据包都已经死亡了</li><li>如果主动关闭方的ACK丢失，那么被动方会重发FIN包，以允许主动方重发ACK，那么此时如果没有TIMEWAIT，则主动方已经关闭了，无法重发ACK报文，TCP协议栈会返回 RST 报文，RST其实是出现异常的时候才发送的数据包，这对于可靠的TCP协议而言不是一个比较优雅的关闭方式。</li></ol><p>如果出现过多的TIME_WAIT，想要缩短TIME_WAIT的时间，Linux 操作系统提供了两个可以系统参数来快速回收处于 <code>TIME_WAIT</code> 状态的连接（这两个参数都是默认关闭的），分别是<code>net.ipv4.tcp_tw_reuse</code>和<code>net.ipv4.tcp_tw_recycle</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、三次握手流程&quot;&gt;&lt;a href=&quot;#一、三次握手流程&quot; class=&quot;headerlink&quot; title=&quot;一、三次握手流程&quot;&gt;&lt;/a&gt;一、三次握手流程&lt;/h3&gt;&lt;p&gt;推荐&lt;a href=&quot;https://www.coonote.com/tcpip/tcp-t
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(六)</title>
    <link href="https://joytsing.github.io/posts/11832/"/>
    <id>https://joytsing.github.io/posts/11832/</id>
    <published>2024-04-07T09:03:59.000Z</published>
    <updated>2024-04-07T12:33:14.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、相关实际问题"><a href="#一、相关实际问题" class="headerlink" title="一、相关实际问题"></a>一、相关实际问题</h3><ol><li>为什么服务端程序都需要先listen一下</li><li>半连接队列和全连接队列长度如何确定</li><li>“Cannot assign requested address”这个报错是怎么回事</li><li>一个客户端端口可以同时用在两条连接上吗</li><li>服务端半/全连接队列满了会怎么样</li><li>新连接的soket内核对象是什么时候建立的</li><li>建立一条TCP连接需要消耗多长时间</li><li>服务器负载很正常，但是CPU被打到底了时怎么回事</li></ol><h3 id="二、深入理解listen"><a href="#二、深入理解listen" class="headerlink" title="二、深入理解listen"></a>二、深入理解listen</h3><h4 id="1）listen系统调用"><a href="#1）listen系统调用" class="headerlink" title="1）listen系统调用"></a>1）listen系统调用</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE2</span><span class="token punctuation">(</span>listen<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 根据fd查找socket内核对象</span>    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取内核参数net.core.somaxconn</span>      somaxconn <span class="token operator">=</span> <span class="token function">sock_net</span><span class="token punctuation">(</span>sock<span class="token operator">-></span>sk<span class="token punctuation">)</span><span class="token operator">-></span>core<span class="token punctuation">.</span>sysctl_somaxconn<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>backlog <span class="token operator">></span> somaxconn<span class="token punctuation">)</span>        backlog <span class="token operator">=</span> somaxconn<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用协议栈注册的listen函数</span>     err <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">listen</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用户态的<a href="https://so.csdn.net/so/search?q=socket&spm=1001.2101.3001.7020">socket</a>文件描述符只是一个整数而已，内核是没有办法直接使用的，所以首先就是先<strong>根据用户传入的文件描述符来查找对应的socket内核对象</strong>。</p><p>再接着获取了<strong>系统里的net.core.somaxconn内核参数的值，和用户传入的backlog作比较后取一个最小值</strong>传入下一步。</p><p><strong>所以虽然listen允许我们传入backlog（该值和半连接队列、全连接队列都有关系），但是会受到内核参数的限制。</strong></p><p>接着通过<strong>调用sock-&gt;ops-&gt;listen进入协议栈的listen函数</strong>。</p><blockquote><ol><li>文件描述表：<strong>进程级别</strong>。一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，<strong>PCB 内部有一个文件描述符表，记录着当前进程所有可用的文件描述符</strong>，也即当前进程所有打开的文件。</li><li>打开文件表：系统级别。<strong>内核对所有打开文件维护的一个描述表格，将表格中的每一项称为打开文件句柄</strong>。它<strong>存储了一个打开文件的所有相关信息</strong>，例如当前文件的偏移量，访问模式，状态等等。</li><li>inode：系统级别。<strong>文件系统中的每个文件都有自己的i-node信息</strong>，它包含文件类型，访问权限，文件属性等等。<br><img src="/posts/11832/065d37f6d7d44a75b2424affa394ae17.png" alt></li></ol><p><img src="/posts/11832/9b38462ae8ce460cb84a1706ea9e63f5.png" alt></p><p>fdtable对应用户已打开文件表，或者说<a href="https://so.csdn.net/so/search?q=文件描述符&spm=1001.2101.3001.7020">文件描述符</a>表，是进程私有的。它的成员fd是file指针数组的指针，其中数组的索引就是文件描述符，而数组元素就是file指针，或者说已打开文件句柄。一个struct file的实例代表一个打开的文件，当一个用户进程成功打开文件时，会创建次结构体，并包含调用者应用程序的文件访问属性，例如文件数据的偏移量、访问模式和特殊标志等。此对象映射到调用者的文件描述符表，作为调用者应用程序对文件的句柄。</p><p>通常数组的第一个元素（索引为0）是进程的标准输入文件，数组的第二个元素（索引为1）是进程的标准输出文件，数组的第三个元素（索引为2）是进程的标准错误文件。</p><p>查看进程允许打开的最大文件句柄数：<code>ulimit -n</code>；设置进程能打开的最大文件句柄数：<code>ulimit -n xxx</code>。</p><p><img src="/posts/11832/72723c4182ef4e628557ad49db706a3b.png" alt></p><p>以上说法是在linux中的概念，而在windows中句柄的概念对应的是linux中文件描述符的概念，都是一个非负的整数。</p></blockquote><h4 id="2）协议栈listen"><a href="#2）协议栈listen" class="headerlink" title="2）协议栈listen"></a>2）协议栈listen</h4><p>上文提到系统调用最后会通过sock-&gt;ops-&gt;listen进入协议栈的listen函数，对于AF_INET而言，指向的是inet_listen</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_listen</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 还不是listen状态（尚未listen过）</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>old_state <span class="token operator">!=</span> TCP_LISTEN<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 开始监听</span>    err <span class="token operator">=</span> <span class="token function">inet_csk_listen_start</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置全连接队列长度</span>    sk<span class="token operator">-></span>sk_max_ack_backlog <span class="token operator">=</span> backlog<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<strong>全连接队列的长度就是执行listen调用时传入的backlog和系统参数之间较小的那个值</strong>。所以如果再线上遇到了全连接队列溢出的问题，想加大该队列的长度，那么可能需要将它们都设置得更大。</p><p>回过头来看inet_csk_listen_start函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_csk_listen_start</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> nr_table_entries<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> inet_connection_sock <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// icsk->icsk_accept_queue时接收队列</span>    <span class="token comment" spellcheck="true">// 接收队列内核对象的申请和初始化</span>    <span class="token keyword">int</span> rc <span class="token operator">=</span> <span class="token function">reqsk_queue_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>icsk<span class="token operator">-></span>icsk_accept_queue<span class="token punctuation">,</span> nr_table_entries<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数再一开始就<strong>将struct sock对象强制转换成了inet_connection_sock，名叫icsk</strong>。之所以可以强制转换是因为inet_connection_sock是包含sock的。tcp_sock、inet_connection_sock、inet_sock、sock是逐层嵌套的关系，类似面向对象里继承的概念。而对于TCP的socket来说，sock对象实际上是一个tcp_sock。因此TCP的sock对象可以强制类型转换为tcp_sock、inet_connection_sock、inet_sock来使用。即子类转换为父类。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> tcp_sock <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* inet_connection_sock has to be the first member of tcp_sock */</span>    <span class="token keyword">struct</span> inet_connection_sock inet_conn<span class="token punctuation">;</span>    u16 tcp_header_len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Bytes of tcp header to send      */</span>    u16 xmit_size_goal_segs<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Goal for segmenting output packets */</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> inet_connection_sock <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* inet_sock has to be the first member! */</span>    <span class="token keyword">struct</span> inet_sock      icsk_inet<span class="token punctuation">;</span>    <span class="token keyword">struct</span> request_sock_queue icsk_accept_queue<span class="token punctuation">;</span>    <span class="token keyword">struct</span> inet_bind_bucket   <span class="token operator">*</span>icsk_bind_hash<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> inet_sock <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* sk and pinet6 has to be the first two members of inet_sock */</span>    <span class="token keyword">struct</span> sock     sk<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> IS_ENABLED(CONFIG_IPV6)</span>    <span class="token keyword">struct</span> ipv6_pinfo   <span class="token operator">*</span>pinet6<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> socket <span class="token punctuation">{</span>    socket_state        state<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> sock     <span class="token operator">*</span>sk<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> proto_ops  <span class="token operator">*</span>ops<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>也可以由sock强制转换为tcp_sock，因为在套接字创建的时候，就是以struct tcp_sock作为大小进行分配的。也就是内核中的每个sock都是tcp_sock类型，而struct tcp_sock正好是最大的那个结构体，不会出现越界访问的情况。</p></blockquote><p>在接下来的一行reqsk_queue_alloc中实际上包含了两件重要的事情。一是接<strong>收队列数据结构的定义</strong>，二是<strong>接收队列的申请和初始化</strong>。</p><h4 id="3）接收队列定义"><a href="#3）接收队列定义" class="headerlink" title="3）接收队列定义"></a>3）接收队列定义</h4><p>icsk-&gt;icsk_accept_queue定义在inet_connection_sock下，是一个request_sock_queue类型的对象，是内核用来接收客户端请求的主要数据结构。我们平时说的全连接队列、半连接队列全都是在这个数据结构里实现的。</p><p><img src="/posts/11832/729eba138dc942e58206eaeee3a97113.png" alt></p><p>我们来看具体的代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> inet_connection_sock <span class="token punctuation">{</span>    <span class="token keyword">struct</span> inet_sock icsk_inet<span class="token punctuation">;</span>    <span class="token keyword">struct</span> request_sock_queue icsk_accept_queue<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> request_sock_queue <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 全连接队列</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>rskq_accept_head<span class="token punctuation">;</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>rskq_accept_tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 半连接队列</span>    <span class="token keyword">struct</span> listen_sock <span class="token operator">*</span>listen_opt<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> listen_sock <span class="token punctuation">{</span>    u8 max_qlen_log<span class="token punctuation">;</span>    u32 nr_table_entires<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>syn_table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于全连接队列来说，在它上面不需要进行复杂的查找工作，<strong>accept处理的时候只是先进先出地接受就好了</strong>。所以全连接队列通过rskq_accept_head和rskq_accept_tail以<strong>链表的形式来管理</strong>。</p><p>和半连接队列相关联的数据对象是listen_opt，它是listen_sock类型的。<strong>因为服务端需要在第三次握手时快速地查找出来第一次握手时留存的request_sock对象，所以其实是用了一个哈希表来管理</strong>，就是struct request_sock *syn_table[0]。max_qlen_log和nr_table_entries都和半连接队列的长度有关。</p><h4 id="4）接收队列申请和初始化"><a href="#4）接收队列申请和初始化" class="headerlink" title="4）接收队列申请和初始化"></a>4）接收队列申请和初始化</h4><p>了解了全/半连接队列数据结构后，再回到inet_csk_listen_start函数中。它<strong>调用了reqsk_queue_alloc来申请和初始化icsk_accept_queue这个接收队列</strong>。</p><p>在reqsk_queue_alloc这个函数中完成了接收队列request_sock_queue内核对象的创建和初始化。其中包括内存申请、半连接队列长度的计算、全连接队列头的初始化等等。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">reqsk_queue_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> request_sock_queue <span class="token operator">*</span>queue<span class="token punctuation">,</span> unsigend <span class="token keyword">int</span> nr_table_entries<span class="token punctuation">)</span><span class="token punctuation">{</span>    size_t lopt_size <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> listen_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> listen_sock <span class="token operator">*</span>lopt<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算半连接队列的长度</span>    nt_table_entries <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> nr_table_entries<span class="token punctuation">,</span> sysctl_max_syn_backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    nr_table_entries <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 为listen神奇对象申请内存，这里包括了半连接队列</span>    lopt_size <span class="token operator">+</span><span class="token operator">=</span> nr_table_entries <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sturct request_sock <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>lopt_size <span class="token operator">></span> PAGE_SIZE<span class="token punctuation">)</span>        lopt <span class="token operator">=</span> <span class="token function">vzalloc</span><span class="token punctuation">(</span>lopt_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    lopt <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span>lopt_size<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 全连接队列头初始化</span>    queue<span class="token operator">-></span>rskq_accept_head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 半连接队列设置</span>    lopt<span class="token operator">-></span>nr_table_entries <span class="token operator">=</span> nr_table_entries<span class="token punctuation">;</span>    queue<span class="token operator">-></span>listen_opt <span class="token operator">=</span> lopt<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开头定义了一个struct listen_sock的指针，这个listen_sock就是我们平时经常说的半连接队列。接下来计算半连接队列的长度，计算出来实际大小后进行内存的申请。最后将全连接队列呕吐设置成了NULL，将半连接队列挂到了接收队列queue上。</p><blockquote><p>半连接队列上每个元素分配的是一个指针大小，实际指向的request_sock的内存还未分配。这其实是一个哈希表，真正的半连接用的request_sock对象是在握手的过程中分配的，计算完哈希值后挂到这个哈希表上。</p></blockquote><h4 id="5）半连接队列长度计算"><a href="#5）半连接队列长度计算" class="headerlink" title="5）半连接队列长度计算"></a>5）半连接队列长度计算</h4><p>reqsk_queue_alloc函数中计算了半连接队列的长度，因为有些复杂所以没有在前面展开，这里深入一下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">reqsk_queue_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> request_sock_queue <span class="token operator">*</span>queue<span class="token punctuation">,</span> unsigend <span class="token keyword">int</span> nr_table_entries<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算半连接队列的长度</span>    nr_table_entries <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> nr_table_entries<span class="token punctuation">,</span> sysctl_max_syn_backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    nr_table_entries <span class="token operator">=</span> <span class="token function">max_t</span><span class="token punctuation">(</span>u32<span class="token punctuation">,</span> nr_table_entries<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nr_table_entries <span class="token operator">=</span> <span class="token function">roundup_pow_of_two</span><span class="token punctuation">(</span>nr_table_entries <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为了效率，不记录nr_table_entries而是记录2的N次幂等于nr_table_entries</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>kopt<span class="token operator">-></span>max_qlen_log <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> lopt<span class="token operator">-></span>max_qlen_log<span class="token punctuation">)</span> <span class="token operator">&lt;</span> nr_table_entries<span class="token punctuation">;</span> lopt<span class="token operator">-></span>max_qlen_log<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传进来的nr_table_entries在最初是用户传入的backlog和内核参数net.core.somaxconn二者之间的较小值。而在这个reqsk_queue_alloc函数里又将完成三次的对比和计算。</p><ul><li>min_t(u32, nr_table_entries, sysctl_max_syn_backlog)：和sysctl_max_syn_backlog内核对象比较，取较小值</li><li>max_t(u32, nr_table_entries, 8)：用来保证nr_table_entries不能比8小，避免传入太小的值导致无法建立连接</li><li>roundup_pow_of_two(nr_table_entries + 1)：用于上对齐到2的整数次幂</li></ul><p><strong>总的来说半连接队列的长度是min(backlog, somaxconn, tcp_max_syn_backlog)+1再向上取整到2的N次幂，但最小不能小于16。</strong></p><p>最后为了提升比较性能，内核并没有直接记录半连接队列的长度，而是采用了一种晦涩的方法，只记录其N次幂。即如果队列长度为16，则记录max_qlen_log为4，只需要直到它是为了提升性能的即可。</p><h4 id="6）小结"><a href="#6）小结" class="headerlink" title="6）小结"></a>6）小结</h4><p><strong>listen的主要工作其实就是申请和初始化接收队列，包括全连接队列和半连接队列。其中全连接队列是一个链表，而半连接队列由于需要快速地查找，所以使用的是一个哈希表。这两个队列是三次握手中很重要的两个数据结构，有了它们服务端才能正常相应来自客户端的三次握手。所以服务端都需要先调用listen才行。</strong></p><p>同时我们也知道了去内核时如何确定全连接队列和半连接队列的长度。</p><ol><li>全连接队列：min(backlog, net.core.somaxconn)</li><li>半连接队列：max(min(backlog, net.core.somaxconn, tcp_max_syn_backlog) + 1向上取整到2的幂次, 16)</li></ol><h3 id="三、深入理解connect"><a href="#三、深入理解connect" class="headerlink" title="三、深入理解connect"></a>三、深入理解connect</h3><p>客户端再发起连接的时候，创建一个socket，如何瞄准服务端调用connect就可以了，代码可以简单到只有两句。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">connect</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但这两行代码背后隐藏的技术细节却很多。</p><p><img src="/posts/11832/f96eece2281843df8f18c01b97d3d5af.png" alt></p><h4 id="1）connect调用链展开"><a href="#1）connect调用链展开" class="headerlink" title="1）connect调用链展开"></a>1）connect调用链展开</h4><p>当客户机调用connect函数的时候，进入系统调用</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>connect<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr __user <span class="token operator">*</span><span class="token punctuation">,</span> uservaddr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据用户fd查找内核中的socket对象</span>    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 进行connect</span>    err <span class="token operator">=</span> sock<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">connect</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> addlen<span class="token punctuation">,</span> sock<span class="token operator">-></span>file<span class="token operator">-></span>f_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理还是首先根据用户传入的文件描述符来查询对应的socket内核对象，如何再调用sock-&gt;ops-&gt;connect，对于AF_INET类型的socket而言，指向的是inet_stream_connect。而inet_stream_connect实际会去调用__inet_stream_connect</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__inet_stream_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> socket <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-></span>sk<span class="token punctuation">;</span>    <span class="token function">witch</span><span class="token punctuation">(</span>sock<span class="token operator">-></span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>            err <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token keyword">case</span> SS_CONNECTED<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">// 此套接口已经和对端的套接口相连接了，即连接已经建立</span>        err <span class="token operator">=</span> <span class="token operator">-</span>EISCONN<span class="token punctuation">;</span>        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token keyword">case</span> SS_CONNECTING<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">// 此套接口正在尝试连接对端的套接口，即连接正在建立中</span>            err <span class="token operator">=</span> <span class="token operator">-</span>EALREADY<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> SS_UNCONNECTED<span class="token punctuation">:</span>        err <span class="token operator">=</span> sk<span class="token operator">-></span>sk_prot<span class="token operator">-></span><span class="token function">connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> uaddr<span class="token punctuation">,</span> addr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>          sock<span class="token operator">-></span>state <span class="token operator">=</span> SS_CONNECTING<span class="token punctuation">;</span>        err <span class="token operator">=</span> <span class="token operator">-</span>EINPROGRESS<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>刚创建完毕的socket的状态就是SS_UNCONNECTED，根据switch判断会去调用sk-&gt;sk_prot-&gt;connect</strong>，对于TCP socket而言，调用的是<strong>tcp_v4_connect</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> addr_len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置socket的状态为TCP_SYN_SENT</span>    <span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_SYN_SENT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 动态选择一个端口</span>    err <span class="token operator">=</span> <span class="token function">inet_hash_connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_death_row<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 函数用来根据sk中的信息，构建一个syn报文，并将它发送出去</span>    err <span class="token operator">=</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里会<strong>把socket的状态设置为TCP_SYN_SENT，再通过inet_hash_connect来动态地选择一个可用的端口</strong>。</p><h4 id="2）选择可用端口"><a href="#2）选择可用端口" class="headerlink" title="2）选择可用端口"></a>2）选择可用端口</h4><p>找到inet_hash_connect的源码，我们来看看到底端口时如何选择出来的。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_hash_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inet_timewait_death_row <span class="token operator">*</span>death_row<span class="token punctuation">,</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">__inet_hash_connect</span><span class="token punctuation">(</span>death_row<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> <span class="token function">inet_sk_port_offset</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> __inet_check_established<span class="token punctuation">,</span> __inet_hash_nolisten<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要关注一下调用__inet_hash_connect的两个参数 ：</p><ul><li>inet_sk_port_offset(sk)：这个函数根据要链接的目的IP和端口等信息生成一个随机数</li><li>__inet_check_established：检查是否和现有ESTABLISH状态的连接冲突的时候用的函数</li></ul><p>接着进入__inet_hash_connect函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__inet_hash_connect</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 是否绑定过端口</span>    <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> snum <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>inet_num<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取本地端口配置</span>    <span class="token function">inet_get_local_port_range</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>low<span class="token punctuation">,</span> <span class="token operator">&amp;</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>        remaing <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>snum<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 遍历查找</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> remaining<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        port <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> offset<span class="token punctuation">)</span> <span class="token operator">%</span> remaining<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保证了port会在范围之间</span>        <span class="token comment" spellcheck="true">// 查看是否是保留端口，是则跳过</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">inet_is_reserverd_local_port</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 查找和遍历已经使用的端口的哈希表链</span>         head <span class="token operator">=</span> <span class="token operator">&amp;</span>hinfo<span class="token operator">-></span>bhash<span class="token punctuation">[</span><span class="token function">inet_bhashfn</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> port<span class="token punctuation">,</span> hinfo<span class="token operator">-></span>bhash_size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">inet_bind_bucket_for_each</span><span class="token punctuation">(</span>tb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>head<span class="token operator">-></span>charin<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果端口已经使用</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">net_eq</span><span class="token punctuation">(</span><span class="token function">ib_net</span><span class="token punctuation">(</span>tb<span class="token punctuation">)</span><span class="token punctuation">,</span> net<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> tb<span class="token operator">-></span>port <span class="token operator">==</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 通过check_established继续检查是否可用</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">check_established</span><span class="token punctuation">(</span>death_row<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tw<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">goto</span> ok<span class="token punctuation">;</span>         <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 未使用的话</span>        tb <span class="token operator">=</span> <span class="token function">inet_bind_bukcet_create</span><span class="token punctuation">(</span>hinfo<span class="token operator">-></span>bind_bucket_cachep<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">goto</span> ok<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个函数中首先判断了inet_sk(sk)-&gt;inet_num，<strong>如果调用过bind，那么这个函数会选择好端口并设置在inet_num上，加入没有调用过bind，那么snum为0。</strong></p><p>接着调用inet_get_local_port_range，这个函数<strong>读取的是net.ipv4.ip_local_port_range这个内核参数，来读取管理员配置的可用的端口范围</strong>。</p><blockquote><p>该参数的默认值是32768-61000，意味着端口与总可用量是61000-32768=28232个。如果觉得这个数字不够用，那么可以通过修改net.ipve4.ip_local_port_range内参参数来重新设置。</p></blockquote><p>接下来进入for循环，其中offset是通过inet_sk_port_offset(sk)计算出来的随机数（是调用__inet_hash_connect时传进来的参数）。<strong>这段循环的作用就是从某个随机数开始，把整个可用端口范围遍历一遍，直到找到可用的端口为止</strong>。具体逻辑如下</p><ol><li>从随机数+low开始<strong>选取一个端口</strong></li><li><strong>判断端口是否是保留端口</strong>，即判断端口是否在net.ipv4.ip_local_reserved_ports中（如果因为某种原因不希望某些端口被内核使用则可以写入这个参数）</li><li><strong>获取已使用端口的哈希表</strong></li><li><strong>遍历哈希表判断端口是否被使用</strong>，如果没有找到则说明可以使用，已使用过则调用check_established（具体逻辑见下部分）</li><li>找到合适的端口：通过inet_bind_bucket_create<strong>申请一个inet_bind_bucket来记录端口已经使用了，并用哈希表的形式管理起来</strong>。</li><li>找不到合适的端口：<strong>返回-EADDRNOTAVAIL</strong>，也就是我们在用户程序上看到的Cannot assign requested address</li></ol><blockquote><p>所以如果遇到这个错误，应该想到去查一下net.ipv4.ip_local_port_range中设置的可用端口的范围是不是太小了。</p></blockquote><h4 id="3）端口被使用过怎么办"><a href="#3）端口被使用过怎么办" class="headerlink" title="3）端口被使用过怎么办"></a>3）端口被使用过怎么办</h4><p>在遍历已使用端口的哈希表时，对于已被使用的端口，会去<strong>调用check_established继续检查是否可用，如果这个函数返回0，则说明端口可以继续使用</strong>。</p><blockquote><p>对于TCP连接而言，维护的是一对四元组，分别由收发双方的端口号和ip地址决定，只要四元组中任意一个元素不同，都算是两条不同的连接。所以只要现有的TCP连接中四元组不与要建立的连接的其他三个元素完全一致，该端口就仍然可以使用。</p></blockquote><p>check_established实际上会去调用__inet_check_established</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__inet_check_established</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inet_timewait_death_row <span class="token operator">*</span>death_row<span class="token punctuation">,</span>                <span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> __u16 lport<span class="token punctuation">,</span>                <span class="token keyword">struct</span> inet_timewait_sock <span class="token operator">*</span><span class="token operator">*</span>twp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找哈希桶</span>    ehash_bucket <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">inet_ehash_buket</span><span class="token punctuation">(</span>hinfo<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历看看有没有四元组一样的，一样的话就报错</span>    <span class="token function">sk_nulls_for_each</span><span class="token punctuation">(</span>sk2<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>head<span class="token operator">-></span>chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk2<span class="token operator">-></span>sk_hash <span class="token operator">!=</span> hash<span class="token punctuation">)</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">INET_MATCH</span><span class="token punctuation">(</span>sk2<span class="token punctuation">,</span> net<span class="token punctuation">,</span> acookie<span class="token punctuation">,</span> saddr<span class="token punctuation">,</span> daddr<span class="token punctuation">,</span> ports<span class="token punctuation">,</span> dif<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> not_unique<span class="token punctuation">;</span>    <span class="token punctuation">}</span>unique<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>not_uniqueue<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token operator">-</span>EADDRNOTAVAIL<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数首先找到inet_ehash_bucket（类似bhash，只不过这是所有ESTABLISH状态的socket组成的hash表），然后<strong>遍历整个哈希表，如果哈希值不相同则说明当前四元组不一致，如果哈希值相同则使用INET_MATCH进一步进行比较</strong>。如果匹配就是说明四元组完全一致，所以这个端口不可用，返回-EADDRNOTAVAIL，如果不匹配（四元组有一或以上个元素不一样）那么就返回0，表示该端口仍然可以用于建立新连接。</p><blockquote><p>INET_MATCH中除了将<strong>saddr、</strong>daddr、__ports进行了比较，还比较了一些其他项目，所以TCP连接还有五元组、七元组之类的说法。</p><p>一台客户机的最大建立的连接数并不是65535，只要有足够多的服务端，单机发出百万条连接没有任何问题。</p></blockquote><h4 id="4）发起SYN请求"><a href="#4）发起SYN请求" class="headerlink" title="4）发起SYN请求"></a>4）发起SYN请求</h4><p>找到可用的端口后，回到tcp_v4_connect，接下来会去调用tcp_connect来根据sk中的信息构建一个syn报文发送出去。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 申请并设置skb</span>    buff <span class="token operator">=</span> <span class="token function">alloc_skb_fclone</span><span class="token punctuation">(</span>MAX_TCP_HEADER <span class="token operator">+</span> <span class="token number">15</span><span class="token punctuation">,</span> sk<span class="token operator">-></span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tcp_init_nondata_skb</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> tp<span class="token operator">-></span>write_seq<span class="token operator">++</span><span class="token punctuation">,</span> TCPHDR_SYN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加到发送队列sk_write_queue</span>    <span class="token function">tcp_connect_queue_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 实际发出syn</span>    err <span class="token operator">=</span> tp<span class="token operator">-></span>fastopen_req <span class="token operator">?</span> <span class="token function">tcp_send_syn_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> sk<span class="token operator">-></span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 启动重传定时器</span>    <span class="token function">inet_csk_resetxmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">,</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_rto<span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tcp_connect一口气做了这么几件事：</p><ol><li><strong>申请一个skb，并将其设置为syn包</strong></li><li><strong>添加到发送队列上</strong></li><li><strong>调用tcp_transmit_skb将该包发出</strong>（同之前内核发送网络包的方式，传递给网络层）</li><li><strong>启动一个重传定时器，超时会重发</strong></li></ol><p><strong>该定时器的作用是等到一定时间后收不到服务端的反馈的时候来开启重传</strong>。首次超时时间是在TCP_TIMEOUT_INIT宏中定义的，该值在Linux3.10版本是1秒， 在一些老版本中是3秒。</p><blockquote><p>TCP在实现过程中，发送队列和重传队列都是sk_write_queue，这两个队列是一并处理的。</p></blockquote><h4 id="5）小结"><a href="#5）小结" class="headerlink" title="5）小结"></a>5）小结</h4><p><strong>客户端执行connect函数的时候，把本地socket状态设置成了TCP_SYN_SENT，选了一个可用的端口，接着发出SYN握手请求并启动重传定时器。</strong></p><p>在选择端口时，会随机地从ip_local_port_range指定的范围中选择一个位置开始循环遍历，找到可用端口后发出syn握手包，如果端口查找失败则抛出异常“Cannot assign requested address”。如果当前可用端口很充足，那么循环很快就可以退出。而如果ip_local_port_range中的端口快被用完了，那么这时候内核就大概率要把循环执行很多轮才能找到可用端口，<strong>这会导致connect系统调用的CPU开销上涨</strong>。</p><p><strong>而如果在connect之前使用了bind，将会使得connect系统调用时地端口选择方式无效，转而使用bind时确定的端口</strong>。即如果提前调用bind选了一个端口号，会先尝试使用该端口号，如果传入0也会自动选择一个。但默认情况下一个端口只会被使用一次，所以对于客户端角色的socket，不建议使用bind。</p><h3 id="四、完整TCP连接建立过程"><a href="#四、完整TCP连接建立过程" class="headerlink" title="四、完整TCP连接建立过程"></a>四、完整TCP连接建立过程</h3><p>在一次TCP连接建立（三次握手）的过程中，并不只是简单的状态的流转，还包括端口选择、半连接队列、syncookie、全连接队列、重传计时器等关键操作。</p><p>在三次握手的过程，服务端核心逻辑是创建socket绑定端口，listen监听，最后accept接收客户端的的请求；而客户端的核心逻辑是创建socket，然后调用connect连接服务端。</p><p>socket的创建、服务端的listen、客户端的connect在前面都已经讲解过了，那么这里从客户端connect发出syn包之后开始。客户端通过调用connect来发起连接。<strong>客户端在调用connect的时候，把本地socket状态设置成了TCP_SYN_SENT，选了一个可用的端口，接着发出SYN握手请求并启动重传定时器</strong>。</p><p><img src="/posts/11832/ba1fddf3fe0d459ab307d88650b4d73a.png" alt></p><h4 id="1）服务端响应SYN"><a href="#1）服务端响应SYN" class="headerlink" title="1）服务端响应SYN"></a>1）服务端响应SYN</h4><p>在服务端，所有的TCP包（包括客户端发来的SYN握手请求）都经过网卡、软中断进入tcp_v4_rcv。在该函数中根据网络包skb的TCP头信息中的目的IP信息查找当前处于listen状态的socket，然后继续进入tcp_v4_do_rcv处理握手过程（因为listen状态的socket不会收到的进入预处理队列。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 服务端收到第一步握手SYN或者第三步ACK都会走到这里</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_LISTEN） <span class="token punctuation">{</span>    <span class="token keyword">struct</span> sock <span class="token operator">*</span>nsk <span class="token operator">=</span> <span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nsk<span class="token punctuation">)</span>         <span class="token keyword">goto</span> discard<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nsk <span class="token operator">!=</span> sk<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_child_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> nsk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        rsk <span class="token operator">=</span> nsk<span class="token punctuation">;</span>        <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">,</span> skb<span class="token operator">-></span>len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      rsk <span class="token operator">=</span> sk<span class="token punctuation">;</span>      <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找listen socket的半连接队列</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>req <span class="token operator">=</span> <span class="token function">inet_csk_search_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> iph<span class="token operator">-></span>saddr<span class="token punctuation">,</span> iph<span class="token operator">-></span>daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">tcp_check_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在tcp_v4_do_rcv中判断当前socket是listen状态后，首先会到tcp_v4_hnd_req查看是否处于半连接队列</strong>。如果再半连接队列中没有找到对应的半连接对象，则会返回listen的socket(连接尚未创建)；如果找到了就将该半连接socket返回。服务端第一次响应SYN的时候，半连接队列自然没有对应的半连接对象，所以返回的是原listen的socket，即nsk == sk。</p><p><strong>在tcp_rcv_state_process里根据不同的socket状态进行不同的处理</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span>             <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">swich</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> TCP_LISTEN<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// 判断是否为syn握手包</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>th<span class="token operator">-></span>syn<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>icsk<span class="token operator">-></span>icsk_af_ops<span class="token operator">-></span><span class="token function">conn_request</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中conn_request是一个函数指针，指向tcp_v4_conn_request。<strong>服务端响应SYN的主要逻辑都在整个tcp_v4_conn_request里</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查看半连接队列是否满了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">inet_csk_reqsk_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    want_cookie <span class="token operator">=</span> <span class="token function">tcp_syn_flood_action</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token string">"TCP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>want_cookie<span class="token punctuation">)</span>        <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 在全连接队列满的情况下，如果有young_ack，那么直接丢弃</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inet_csk_reqsk_queue_young</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENOVERFLOWS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 分配request_sock内核对象</span>    req <span class="token operator">=</span> <span class="token function">inet_reqsk_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_request_sock_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造syn+ack包</span>    skb_synack <span class="token operator">=</span> <span class="token function">tcp_make_synack</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> req<span class="token punctuation">,</span> <span class="token function">fastopen_cookie_present</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>valid_foc<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&amp;</span>valid_foc <span class="token punctuation">:</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span>do_fastopen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 发送syn+ack响应</span>    err <span class="token operator">=</span> <span class="token function">ip_build_and_send_pkt</span><span class="token punctuation">(</span>skb_aynack<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> ireq<span class="token operator">-></span>loc_addr<span class="token punctuation">,</span> ireq<span class="token operator">-></span>rmt_addr<span class="token punctuation">,</span> ireq<span class="token operator">-></span>opt<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 添加到半连接队列，并开启计时器</span>    <span class="token function">inet_csk_reqsk_queue_hash_add</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> TCP_TIMEOUT_INIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里首先<strong>判断半连接队列是否满了</strong>，如果满了进入tcp_syn_flood_action去<strong>判断是否开启了tcp_syncookies内核参数</strong>。<strong>如果队列满且未开启tcp_syncookies，那么该握手包将被直接丢弃。</strong></p><blockquote><p>TCP Syn Cookie 是一个防止 SYN Flood 攻击的技术。当服务器接收到大量伪造的 SYN 请求时，可以消耗掉所有的连接资源，导致合法用户无法建立新的连接，这种攻击方式被称为 SYN Flood 攻击。SYN Flood 是一种 DoS（Denial of Service，服务拒绝）攻击。</p><p>这种技术的主要思想是不在服务器上为每个收到的 SYN 请求分配资源，而是通过计算一个 Cookie（实质上是一个哈希值），将这个 Cookie 作为 SYN-ACK 包的序列号发回客户端。当客户端回复 ACK 包时，服务器可以从 ACK 包的确认号中恢复出之前发送的 Cookie，从而验证这个连接请求是有效的。</p><p>这种方式可以有效抵御 SYN Flood 攻击，因为服务器不需要为每个 SYN 请求分配资源，伪造的 SYN 请求不会消耗服务器的资源。但是，SYN Cookie 技术也有一些局限性，例如它不兼容一些 TCP 的高级特性（如窗口缩放），并且在计算 Cookie 时也会消耗一些 CPU 资源</p></blockquote><p>接着<strong>判断全连接队列是否满了</strong>，因为全连接队列满也会导致握手异常，那干脆就在第一次握手的时候也判断了。<strong>如果全队列满了，且young_ack数量大于1的话，那么同样也是直接丢弃</strong>。</p><blockquote><p>young_ack是半连接队列里保存着的一个计时器，记录的是刚有SYN到达，没有被SYN_ACK重传定时器重传过SYN_ACK，同时也没有完成过三次握手的sock数量。</p><p>inet_csk_reqsk_queue_young(sk) &gt; 1这一判断，其实是在检查是否存在”年轻”的连接请求。如果存在这样的请求，而且全连接队列又已经满了，那么就会选择拒绝新的连接请求，以防止服务器过载。</p></blockquote><p>接下来是<strong>构造synack包</strong>，然后通过ip_build_and_send_pkt把它<strong>发送出去</strong>。</p><p>最后<strong>把当前的握手信息添加到半连接队列，并且启动计时器</strong>。计时器的作用是<strong>如果某个时间内还收不到客户端的第三次握手，服务端就会重传synack包</strong>。</p><blockquote><p>此时半连接队列中的request_sock的状态为SYN_RECV。等到服务器收到客户端的ACK报文，也就是三次握手完成后，request_sock 会被”升级”为一个完整的 sock 结构体，状态变为 ESTABLISHED。</p></blockquote><h4 id="2）客户端响应SYNACK"><a href="#2）客户端响应SYNACK" class="headerlink" title="2）客户端响应SYNACK"></a>2）客户端响应SYNACK</h4><p>客户端收到服务端发来的synack包的时候，由于自身状态是TCP_SYN_SENT，所以不会进入ESTABLISHED、LISTEN分支，同样进入tcp_rcv_state_process函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 服务端收到第一个SYN包</span>    <span class="token keyword">case</span> TCP_LISTEN<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 客户端第二次握手处理</span>        <span class="token keyword">case</span> TCP_SYN_SENT<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// 处理synack包</span>        queued <span class="token operator">=</span> <span class="token function">tcp_rcv_synsent_state_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> th<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tcp_rcv_synsent_state_process是客户端响应synack的主要逻辑</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tcp_rcv_synsent_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span>                 <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>tp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">tcp_ack</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> FLAG_SLOWPATH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 连接建立完成</span>    <span class="token function">tcp_finish_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_write_pending <span class="token operator">||</span>    icsk<span class="token operator">-></span>icsk_accept_queue<span class="token punctuation">.</span>rskq_defer_accept <span class="token operator">||</span>    icsk<span class="token operator">-></span>icsk_ack<span class="token punctuation">.</span>pingpong<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 延迟确认......</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">tcp_send_ack</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>tcp_ack(sk, skb, FLAG_SLOWPATH)：这行代码在收到SYN-ACK包后<strong>更新了socket的状态，包括序列号、确认号等</strong>。</p><ul><li><p>tcp_clean_rtx_queue：删除重传队列中已被确认的数据包，停止重传定时器</p><blockquote><p>在TCP协议中，当发送一个数据包时，发送方将这个数据包存储在重传队列中，并启动一个定时器。如果在定时器超时之前收到了这个数据包的确认（ACK），那么发送方就知道这个数据包已经成功地到达接收方，它就会从重传队列中删除这个数据包。否则，当定时器超时时，发送方就会重新发送这个数据包。</p><p>tcp_clean_rtx_queue函数就是处理这个重传队列的函数。它遍历重传队列，查看哪些数据包已经得到了确认，然后从重传队列中删除这些数据包。它还会计算网络的往返时间（RTT），以便于调整TCP的超时时间。</p><p>如果重传队列中的所有数据包都已经被确认，那么停止重传定时器。</p></blockquote></li></ul></li><li><p>tcp_finish_connect(sk, skb)：这行代码完成了TCP连接的建立。它<strong>将socket的状态从SYN_SENT改为ESTABLISHED，初始化TCP连接的拥塞控制算法、接收缓存和发送缓存空间等信息，开启keep alive计时器，然后唤醒等待连接完成的进程</strong>。</p><blockquote><p>Keep-alive计时器就是用于控制发送keep-alive数据包的计时器。通常，当一个TCP连接上没有任何数据包的传输时，我们就启动这个计时器。如果在计时器超时之前有新的数据包在这个连接上发送或接收，那么我们就重置计时器。如果计时器超时，那么我们就发送一个keep-alive数据包，并重新启动计时器等待响应。如果接收到了对这个数据包的响应，那么我们就知道连接仍然存在。如果在一定时间内没有收到响应，那么我们就假定连接已经断开，并将其关闭。</p></blockquote></li><li><p>满足TCP的延迟确认（Delayed ACK）机制：这种情况下，ACK包可能会和后续的数据包一起发送，以减少网络上的包的数量。</p></li><li><p>不满足延迟确认机制：立即调用tcp_send_ack(sk)，<strong>申请和构造ACK包然后发送出去</strong>。这个ACK包是对对方SYN-ACK包的确认，也是TCP三次握手的最后一步。</p></li></ol><p>即<strong>客户端响应来自服务端的synack时清除了connect时设置得重传定时器，把当前socket状态设置为ESTABLISHED，开启保活计时器然后发出第三次握手的ack确认</strong>。</p><h4 id="3）服务端响应ACK"><a href="#3）服务端响应ACK" class="headerlink" title="3）服务端响应ACK"></a>3）服务端响应ACK</h4><p>服务端响应第三次握手的ack时同样会进入tcp_v4_do_rcv。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 服务端收到第一步握手SYN或者第三步ACK都会走到这里</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_LISTEN） <span class="token punctuation">{</span>        <span class="token keyword">struct</span> sock <span class="token operator">*</span>nsk <span class="token operator">=</span> <span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nsk<span class="token punctuation">)</span>             <span class="token keyword">goto</span> discard<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nsk <span class="token operator">!=</span> sk<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_child_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> nsk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rsk <span class="token operator">=</span> nsk<span class="token punctuation">;</span>            <span class="token keyword">goto</span> reset<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于此处已经是第三次握手了，半连接队列里会存在第一次握手时留下的半连接信息，所以tcp_v4_hnd_req会在半连接队列里找到半连接request_sock对象后进入tcp_check_req</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找listen socket的半连接队列</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>req <span class="token operator">=</span> <span class="token function">inet_csk_search_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> iph<span class="token operator">-></span>saddr<span class="token punctuation">,</span> iph<span class="token operator">-></span>daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">tcp_check_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_check_req</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建子sock</span>    child <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_af_ops<span class="token operator">-></span><span class="token function">syn_recv_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 清理半连接队列</span>    <span class="token function">inet_csk_reqsk_queue_unlink</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_csk_reqsk_queue_removed</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加全连接队列</span>    <span class="token function">inet_csk_reqsk_queue_add</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数完成了以下工作：</p><ol><li><strong>判断接收队列是不是满了，没满则创建子sock（tcp_sock)</strong></li><li><strong>把request_sock从半连接队列删除</strong></li><li><strong>将request_sock添加到全连接队列链表的尾部，并与新创建的sock关联</strong></li></ol><p>因为是第三次握手所以返回了新的子sock，那么显然nsk!=sk，所以会执行<strong>tcp_child_process来为新的子sock进行一些初始化和处理工作</strong>，如设置TCP标志等，如果处理成功则会返回0。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_child_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>parent<span class="token punctuation">,</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span>child<span class="token punctuation">,</span>        <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> state <span class="token operator">=</span> child<span class="token operator">-></span>sk_state<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sock_owned_by_user</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret <span class="token operator">=</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">,</span> skb<span class="token operator">-></span>len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 进行状态处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> TCP_SYN_RECV <span class="token operator">&amp;&amp;</span> child<span class="token operator">-></span>sk_state <span class="token operator">!=</span> state<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 状态处理结束后socket的状态发生了变化</span>        <span class="token comment" spellcheck="true">// 调用sock_def_readable函数发送可读事件通告给listening socket，告知其可以进行accept系统调用</span>            parent<span class="token operator">-></span><span class="token function">sk_data_ready</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 新的socket被进行系统调用的进程锁定；因为这是新的socket，所以在tcp_v4_rcv加的锁不会起到保护新socket的作用</span>        <span class="token function">__sk_add_backlog</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 加入到后背队列</span>    <span class="token punctuation">}</span>    <span class="token function">bh_unlock_sock</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sock_put</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到其中再一次调用了tcp_rcv_state_process，然后唤醒等待队列上的进程。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> tcphdr <span class="token operator">*</span>th<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 服务端收到第一次握手的SYN包</span>    <span class="token keyword">case</span> TCP_LISTEN<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 客户端第二次握手处理</span>        <span class="token keyword">case</span> TCP_SYN_SENT<span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 服务端收到第三次握手的ACK包</span>    <span class="token keyword">case</span> TCP_SYN_RECV<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// 改变状态为连接</span>        <span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_ESTABLISHED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>服务端响应第三次握手ACK所做的工作就是把当前半连接对象删除，创建了新的sock后加入全连接队列，最后将新连接状态设置为ESTABLISHED。</strong></p><h4 id="4）服务端accept"><a href="#4）服务端accept" class="headerlink" title="4）服务端accept"></a>4）服务端accept</h4><p><strong>当服务端调用accept时主要的逻辑就是创建socket对象，然后从全连接队列中取出request_sock，将其中保存的第三次握手时创建的sock取出并与socket关联，随后释放request_sock。</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">inet_csk_accept</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 从全连接都列中获取</span>    <span class="token keyword">struct</span> request_sock_queue <span class="token operator">*</span>queue <span class="token operator">=</span> <span class="token operator">&amp;</span>icsk<span class="token operator">-></span>icsk_accept_queue<span class="token punctuation">;</span>    req <span class="token operator">=</span> <span class="token function">reqsk_queue_remove</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    newsk <span class="token operator">=</span> req<span class="token operator">-></span>sk<span class="token punctuation">;</span>    <span class="token keyword">return</span> newsk<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> request_sock <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 和其它struct request_sock对象形成链表</span>    <span class="token keyword">struct</span> request_sock        <span class="token operator">*</span>dl_next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Must be first member! */</span>    <span class="token comment" spellcheck="true">// SYN段中客户端通告的MSS</span>    u16                mss<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// SYN+ACK段已经重传的次数，初始化为0</span>    u8                retrans<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// SYN+ACK段的超时时间</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>            expires<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指向tcp_request_sock_ops,该函数集用于处理第三次握手的ACK段以及后续accept过程中struct tcp_sock对象的创建</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> request_sock_ops    <span class="token operator">*</span>rsk_ops<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 连接建立前无效，建立后指向创建的tcp_sock结构</span>    <span class="token keyword">struct</span> sock            <span class="token operator">*</span>sk<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>所以，accept的重点工作就是从已经建立好的全连接队列中取出一个返回给用户进程</strong></p><p><img src="/posts/11832/3f1980ac7a6f48858ab0a0eec4dbdb8c.png" alt></p><p>TCP连接建立的操作可以简单划分为两类：</p><ol><li>内核消耗CPU进行接收、发送或者处理，包括系统调用、软中断和上下文切换。它们的耗时基本是几微妙左右。</li><li>网络传输将包从一台机器上发出，经过各式各样的网络互联设备道到达目的及其。网络传输的耗时一般在几毫秒到几百毫秒，远超于本机CPU处理。</li></ol><p>由于网络传输耗时比双端CPU耗时要高1000倍不止，所以在正常的TCP连接建立过程中，一般堪虑网络延时即可。</p><p>一个RTT指的是包从一台服务器到另一台服务器的一个来回的延迟时间。从全局来看，TCP连接建立的网络耗时大约需要三次传输，再加上少许的双方CPU开销，总共大约比1.5倍RTT大一点点。</p><p>不过从客户端的角度来看，只要ACK包发出了，内核就认为连接建立成功，可以开始发送数据了。所以如果在客户端统计TCP连接建立耗时，只需要两次传输耗时——即比1个RTT多一点时间（从服务端视角来看也是同理）。</p><h3 id="五、异常TCP建立情况"><a href="#五、异常TCP建立情况" class="headerlink" title="五、异常TCP建立情况"></a>五、异常TCP建立情况</h3><h4 id="1）connect系统调用耗时失控"><a href="#1）connect系统调用耗时失控" class="headerlink" title="1）connect系统调用耗时失控"></a>1）connect系统调用耗时失控</h4><p>客户端在发起connect系统调用的的时候，主要工作就是端口选择。在选择的过程中有一个大循环，从ip_local_port_range的一个随机位置开始把这个范围遍历一遍，找到可用端口则退出循环。如果端口很充足，那么循环只需要执行少数几次就可以退出。但是如果端口消耗掉很多已经不充足，或者干脆就没有可用的了，那么这个循环就得执行很多遍。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_hash_connect</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">inet_get_local_range</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>low<span class="token punctuation">,</span> <span class="token operator">&amp;</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>    remaining <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> remaining<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 其中offset是一个随机数</span>    port <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> offset<span class="token punctuation">)</span> <span class="token operator">%</span> remaining<span class="token punctuation">;</span>        head <span class="token operator">=</span> <span class="token operator">&amp;</span>hinfo<span class="token operator">-></span>bhash<span class="token punctuation">[</span><span class="token function">inet_bhashfn</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> port<span class="token punctuation">,</span> hinfo<span class="token operator">-></span>bhash_size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加锁</span>    <span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 一大段端口选择逻辑，选择成功就goto ok，选择不成功就goto next_port</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    next_port<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// 解锁</span>           <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<strong>每次循环内部需要等待所以及在哈希表中执行多次的搜索。并且这里的锁是自旋锁，如果资源被占用，进程并不会挂起，而是占用CPU不断地尝试去获得锁</strong>。假设端口范围ip_local_port_range配置的是10000~30000，而且已经用尽了。那么每次当发起连接的时候，都需要把循环执行两万遍才退出。这时会涉及大量的哈希查找以及自旋锁等待开销，系统态CPU将出现大幅度上涨。</p><p>所以当connect系统调用的CPU大幅度上涨时，可以<strong>尝试修改内核常熟ipv4.ip_local_port_range多预留一些端口、改用长连接或者尽快回收TIME_WAIT等方式</strong>。</p><h4 id="2）第一次握手丢包"><a href="#2）第一次握手丢包" class="headerlink" title="2）第一次握手丢包"></a>2）第一次握手丢包</h4><p><strong>服务端在响应来自客户端的第一次握手请求的时候，会判断半连接队列和全连接队列是否溢出。如果发生溢出的，可能会直接将握手包丢弃，而不会反馈给客户端。</strong></p><h5 id="1-半连接队列满"><a href="#1-半连接队列满" class="headerlink" title="1. 半连接队列满"></a>1. 半连接队列满</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 看看半连接队列是否满了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">inet_csk_reqsk_queue_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    want_cookie <span class="token operator">=</span> <span class="token function">tcp_syn_flood_action</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token string">"TCP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>want_cookie<span class="token punctuation">)</span>        <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 看看全连接队列是否满了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>drop<span class="token punctuation">:</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENDROPS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在以上代码中<code>inet_csk_reqsk_is_full</code>如果返回true就表示半连接队列满了，另外<code>tcp_syn_flood_action</code>判断是否打开了内核参数<code>cp_syncookies</code>，如果未打开则返回false。</p><p>也就是说，<strong>如果半连接队列满了，而且没有开启tcp_syncookies，那么来自客户端的握手包将goto drop，即直接丢弃</strong>。</p><p>SYN Flood攻击就是通过耗光服务端上的半连接队列来使得正常的用户连接请求无法被响应。不过在现在的Linux内核里只要打开tcp_syncookies，半连接队列满了仍然可以保证正常握手的进行。</p><h5 id="2-全连接队列满"><a href="#2-全连接队列满" class="headerlink" title="2. 全连接队列满"></a>2. 全连接队列满</h5><p>当半连接队列判断通过以后，紧接着还由全连接队列的相关判断。如果满了服务端还是会丢弃它。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 看看半连接队列是否满了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 在全连接队列满的情况下，如果有young_ack，那么直接丢弃</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inet_csk_reqsk_queue_young</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENOVERFLOWS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sk_aceeptq_is_full</code>判断全连接队列是否满了，<code>inet_csk_reqsk_queue_young</code>判断有没有<code>young_ack</code>（未处理完的半连接请求）。<strong>如果全连接队列满且同时有<code>young_ack</code>，那么内核同样直接丢掉该SYN握手包</strong>。</p><h5 id="3-客户端发起重试"><a href="#3-客户端发起重试" class="headerlink" title="3. 客户端发起重试"></a>3. 客户端发起重试</h5><p>假设服务端发生了全/半连接队列溢出而导致的丢包，那么转换到客户端的视角来看就是SYN包没有任何响应。</p><p>因为客户端在发出握手包的时候，开启了一个重传定时器。如果收不到预期的synack，超时的逻辑就会开始执行。不过重传定时器的时间单位都是以秒来计算的，这意味着如果有握手重传发生，即使第一次重传就能成功，那接口最快响应也是一秒以后的事情了，这对接口耗时影响非常大。以下是connect系统调用关于重传的逻辑。</p><p><img src="/posts/11832/3b6012963a8e4ff49bd91356cc21bab5.png" alt></p><p>来详细看看重传的相关逻辑。客户端在connect系统调用发出SYN握手信号后就开启了重传定时器：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span>sruct sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 实际发出SYN</span>    err <span class="token operator">=</span> tp<span class="token operator">-></span>fastopen_req <span class="token operator">?</span> <span class="token function">tcp_send_syn_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span> <span class="token punctuation">:</span>       <span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> sk<span class="token operator">-></span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 启动重传定时器</span>    <span class="token function">inet_csk_reset_xmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">,</span>        <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_rto<span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其中inet_csk(sk)-&gt;icsk_rto是超时时间，该值初始化的时候被设置为TCP_TIMEOUT_INIT</strong>（1秒，在一些老版本的内核里为3秒）。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_connect_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化为TCP_TIMEOUT_INIT</span>    <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_rto <span class="token operator">=</span> TCP_TIMEOUT_INIT<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果能正常接收到服务端响应的synack，那么客户端的这个定时器会清除</strong>。这段逻辑在tcp_rearm_rto里，具体的调用顺序为tcp_rcv_state_process-&gt;tcp_rcv_synsent_state_process-&gt;tcp_ack-&gt;tcp_clean_rtx_queue-&gt;tcp_rearm_rto;</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_stream_rto</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">inet_csk_clear_xmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果服务端发生了丢包，那么定时器到时候会进入回调函数tcp_write_timer中进行重传（其实不只是握手，连接状态的超时重传也是在这里完成的）</strong>。</p><blockquote><p>其实不只是握手，连接状态的超时重传也是在这里完成的</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tcp_write_timer</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">tcp_write_timer_handler</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">tcp_write_timer_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 取出定时器类型</span>    event <span class="token operator">=</span> icsk<span class="token operator">-></span>icsk_pending<span class="token punctuation">;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">case</span> ICSK_TIME_RETRANS<span class="token punctuation">:</span>           <span class="token comment" spellcheck="true">// 清除定时器</span>        <span class="token comment" spellcheck="true">// icsk_pending用于标记一个 TCP 连接当前有哪些定时器是激活状态，是一个位掩码，每一位都对应一个特定的定时器</span>        icsk<span class="token operator">-></span>icsk_pending <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token function">tcp_retransmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里tcp_transmit_timer是重传的主要函数。在这里<strong>完成重传以及下一次定时器到期的时间设置</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_retransmit_timer</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 超过了重传次数则退出</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tcp_write_timeout</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 重传</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tcp_retransmit_skb（sk<span class="token punctuation">,</span> <span class="token function">tcp_write_queue_head</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 重传失败</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 退出前重新设置下一次的超时时间</span>out_reset_timer<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">// 计算超时时间</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sk<span class="token operator">-></span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    icsk<span class="token operator">-></span>icsk_rto <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>icsk<span class="token operator">-></span>icsk_rto <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 设置</span>    <span class="token function">inet_csk_reset_xmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">,</span> icsk<span class="token operator">-></span>icsk_rto<span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>tcp_write_timeout用来判断是否重试过多，如果是则退出重试逻辑</strong>。</p><blockquote><p>对于SYN握手包主要的判断依据是net.ipv4_tcp_syn_retries（内核参数，对于一个新建连接，内核要发送多少个SYN连接请求才决定放弃。不应该大于255,默认值是5），但其实并不是简单的对比次数，而是转化成了时间进行对比。所以如果在线上看到了实际重传次数和对应内核参数不一致也不用太奇怪。</p></blockquote><p>接着<strong>调用tcp_retransmit_skb函数重发了发送队列里的头元素</strong>。</p><p>最后再次<strong>设置下一次超时的时间，为前一次时间的两倍</strong>。</p><h5 id="4-实际抓包结果"><a href="#4-实际抓包结果" class="headerlink" title="4. 实际抓包结果"></a>4. 实际抓包结果</h5><p>客户端发出TCP第一次握手之后，在1秒以后进行了第一次握手重试。重试仍然没有响应，那么接下来一次又分别在3秒、7秒、15秒、31秒和63秒等事件共重试了六次（我的tcp_syn_retries设置为6）。</p><p>当服务端第一次握手的时候出现了半/全连接队列溢出导致的丢包，那么接口响应的时间将会很久（只进行一次重试都需要一秒的时间），用户体验会受到很大的影响。并且如果某一个时间段内有多个进程/线程卡在了和Redis或者MySQL的握手连接上，那么可能会导致线程池剩下的线程数量不足以处理服务。</p><h4 id="3）第三次握手丢包"><a href="#3）第三次握手丢包" class="headerlink" title="3）第三次握手丢包"></a>3）第三次握手丢包</h4><p>客户端在收到服务器的synack相应的时候，就认为连接建立成功了，然后会将自己的连接状态设置为ESTABLISHED，发出第三次握手请求。但服务端在第三次握手的时候还有可能有意外发生。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_hnd_req</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找listen socket的半连接队列</span>    <span class="token keyword">struct</span> request_sock <span class="token operator">*</span>req <span class="token operator">=</span> <span class="token function">inet_csk_search_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> th<span class="token operator">-></span>source<span class="token punctuation">,</span> iph<span class="token operator">-></span>saddr<span class="token punctuation">,</span> iph<span class="token operator">-></span>daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">tcp_check_req</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_check_req</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建子socket</span>    child <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-></span>icsk_af_ops<span class="token operator">-></span><span class="token function">syn_recv_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> req<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 清理半连接队列</span>    <span class="token function">inet_csk_reqsk_queue_unlink</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_csk_reqsk_queue_removed</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加全连接队列</span>    <span class="token function">inet_csk_reqsk_queue_add</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在第三次握手时，首先从半连接队列里拿到半连接对象，之后通过tcp_check_req =&gt; inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock来创建子socket</p><p>这里syn_recv_sock是一个函数指针，在ipv4中指向了tcp_v4_syn_recv_sock。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_syn_recv_sock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断全连接队列是不是满了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">goto</span> exit_overflow<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述代码可以看出，<strong>第三次握手的时候，如果服务器全连接队列满了，来自客户端的ack握手包又被直接丢弃</strong>。</p><p><strong>由于客户端在发起第三次握手之后就认为连接建立了，所以如果第三次握手失败，是由服务端来重发synack（服务端发送synack之后启动了定时器，并将该半连接对象保存在了半连接队列中）</strong>。服务端等到半连接定时器到时后，想客户端重新发起synack，客户端收到后再重新恢复第三次握手。如果这个期间服务端全连接队列一直都是满的，那么服务端重试5次（受内核参数net.ipv4.tcp_synack_retries控制）后就放弃了。</p><p>客户端在发起第三次握手之后往往就开始发送数据，其实这个时候连接还没有真的建立起来。<strong>如果第三次握手失败了，那么它发出去的数据，包括重试都将被服务端无视</strong>，知道连接真正建立成功后才行。</p><h4 id="4）握手异常总结"><a href="#4）握手异常总结" class="headerlink" title="4）握手异常总结"></a>4）握手异常总结</h4><ol><li>端口不足：导致connect系统调用的时候过多地执行自旋锁等待与哈希查找，会引起CPU开销上涨。严重的情况下会耗光CPU，影响用户逻辑的执行。<ol><li>调整ip_local_port_range来尽量加大端口范围</li><li>尽量复用连接，使用长连接来削减频繁的握手处理</li><li>开启tcp_tw_reuse和tcp_tw_recycle</li></ol></li><li>服务端在第一次握手丢包（半连接队列满且tcp_syncookies为0 || 全连接队列满且有未完成的半连接请求）：客户端不断发起syn重试</li><li>服务端在第三次握手丢包（全连接队列满）：服务端不断发起synack重试</li></ol><p>握手重试对服务端影响很大，常见的解决方法如下：</p><ol><li>打开syncookies：防止SYN Flood攻击等</li><li>加大连接队列长度：全连接是min(backlog，net.core.somaxconn)，半连接是min(backlog，somaxconn，tcp_max_syn_backlog) + 1向上取整到2的幂次（且不小于16）</li><li>尽快调用accept</li><li>尽早拒绝：例如MySQL和Redis等服务器的内核参数tcp_abort_on_overflow设置为1，如果队列满了直接reset指令发送给客户端，告诉其不要继续等待。这时候客户端会收到错误“connection reset by peer”</li><li>尽量减少TCP连接的次数</li></ol><h3 id="六、如何查看是否有连接队列溢出发生"><a href="#六、如何查看是否有连接队列溢出发生" class="headerlink" title="六、如何查看是否有连接队列溢出发生"></a>六、如何查看是否有连接队列溢出发生</h3><h4 id="1）全连接队列溢出判断"><a href="#1）全连接队列溢出判断" class="headerlink" title="1）全连接队列溢出判断"></a>1）全连接队列溢出判断</h4><p>全连接队列溢出都会记录到ListenOverflows这个MIB（管理信息库），对应SNMP统计信息中的ListenDrops这一项。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查看半连接队列是否满了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 在全连接队列满的情况下，如果有young_ack，那么直接丢弃</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inet_csk_reqsk_queue_young</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENOVERFLOWS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> drop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>drop<span class="token punctuation">:</span><span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENDROPS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> sock <span class="token operator">*</span><span class="token function">tcp_v4_syn_recv_sock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sock <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断全连接队列是不是满了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sk_acceptq_is_full</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">goto</span> exit_overflow<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>exit_overflow<span class="token punctuation">:</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENOVERFLOWS<span class="token punctuation">)</span><span class="token punctuation">;</span>exit<span class="token punctuation">:</span>    <span class="token function">NET_INC_STATS_BH</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> LINUX_MIB_LISTENDROPS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到服务端在响应第一次握手和第三次握手的时候，在全队列满了时都会调用<code>NET_INC_STATS_BH</code>来增加<code>LINUX_MIB_LISTENOVERFLOWS</code>和<code>LINUX_MIB_LISTENDROPS</code>这两个MIB。</p><p>在proc.c中，这两个MIB会被整合到SNMP统计信息。</p><p>在执行netstat-s的时候，该工具会读取SNMP统计信息并展现出来。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#watch 'netstat -s | grep overflowed'</span>    <span class="token number">198</span> times the listen queue of a socket overflowed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过netstat -s输出中的xx times the listen queue如果查看到数字有变化，则说明一定是服务端上发生了全连接队列溢出了。</p><h4 id="2）半连接队列溢出判断"><a href="#2）半连接队列溢出判断" class="headerlink" title="2）半连接队列溢出判断"></a>2）半连接队列溢出判断</h4><p>半连接队列溢出时更新的是LINUX_MIB_LISTENDROPS这个MIB，然而不只是半连接队列发生溢出的时候会增加该值，全连接队列满了该值也会增加。所以根据netstat -s查看半连接队列是否溢出是不靠谱的。</p><p>对于半连接队列是否溢出这个问题，一般直接看服务器tcp_syncookies是不是1就行了。如果该值是1，那么根本不会发生半连接溢出丢包。而如果不是1，则建议改为1。</p><p>如果因为其他原因不想打开，那么除了netstat -s，也可以同时查看listen端口上的SYN_RECV的数量，如果该数量达到了半连接队列的长度（根据内核参数和自己传递的backlog可以计算出来）则可以确定有半连接队列溢出。</p><h3 id="七、问题解答"><a href="#七、问题解答" class="headerlink" title="七、问题解答"></a>七、问题解答</h3><ol><li>为什么服务端程序都需要先listen一下<ul><li>内核在响应listen调用的时候创建了半连接、全连接两个队列，这两个队列是三次握手中很重要的数据结构，有了它吗才能正常响应客户端的三次握手。所以服务器提供服务前都需要先listen一下才行。</li></ul></li><li>半连接队列和全连接队列长度如何确定<ul><li>半连接队列：max((min(backlog, somaxconn, tcp_max_syn_backlog) + 1)向上取整到2的幂次), 16)</li><li>全连接队列：min(backlog, somaxconn)</li></ul></li><li>“Cannot assign requested address”这个报错是怎么回事<ul><li>一条TCP连接由一个四元组构成，其中目的IP和端口以及自身的IP都是在连接建立前确定了的，只有自身的端口需要动态选择出来。客户端会在connect发起的时候自动选择端口号。具体的选择就是随机地从ip_local_port_range选择一个位置开始循环判断，跳过ip_local_reserver_ports里设置的要避开的端口，然后挨个判断是否可用。如果循环完也没有找到可用端口，就会抛出这个错误。</li></ul></li><li>一个客户端端口可以同时用在两条连接上吗<ul><li>connect调用在选择端口的时候如果端口没有被用上那就是可用的，但是如果被用过也不代表这个端口就不可用。</li><li>如果用过，则会去判断是否有老的连接四元组与当前要建立的这个新连接四元组完全一致，如果不完全一致则该端口仍然可用。</li></ul></li><li>服务端半/全连接队列满了会怎么样<ul><li>服务端响应第一次握手的时候会进行半连接队列和全连接队列是否满的判断<ul><li>如果半连接队列满了且未开启tcp_syncookies，丢弃握手包</li><li>如果全连接队列满了且存在young_acck，丢弃握手包</li></ul></li><li>服务端响应第三次握手的时候会进行全连接队列是否满的判断<ul><li>如果全连接队列满了则丢弃握手包</li></ul></li></ul></li><li>新连接的soket内核对象是什么时候建立的<ul><li>内核其实在第三次握手完毕的时候就把sock对象创建好了。在用户进程调用accept的时候，直接把该对象取出来，再包装一个socket对象就返回了。</li></ul></li><li>建立一条TCP连接需要消耗多长时间<ul><li>一般网络的RTT值根据服务器物理距离的不同大约是在零点几秒、几十毫秒之间。这个时间要比CPU本地的系统调用耗时长得多。所以正常情况下，在客户端或者是服务端看来，都基本上约等于一个RTT。</li><li>如果一旦出现了丢包，无论是那种原因，需要重传定时器来接入的话，耗时就最少要一秒了。</li></ul></li><li>服务器负载很正常，但是CPU被打到底了时怎么回事<ul><li>如果在端口极其不充足的情况下，connect系统调用的内部循环需要全部执行完毕才能判断出来没有端口可用。如果要发出的连接请求特别频繁，connect就会消耗掉大量的CPU。如果要发出的连接请求特别频繁，connect就会消耗掉大量的CPU。当服务器上的进程不多，但是每个进程都在疯狂的消耗CPU，这时候就会出现CPU被消耗光，但是服务器负载却不高的情况。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、相关实际问题&quot;&gt;&lt;a href=&quot;#一、相关实际问题&quot; class=&quot;headerlink&quot; title=&quot;一、相关实际问题&quot;&gt;&lt;/a&gt;一、相关实际问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;为什么服务端程序都需要先listen一下&lt;/li&gt;
&lt;li&gt;半连接队列和全连接队
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux网络学习笔记(五)</title>
    <link href="https://joytsing.github.io/posts/36379/"/>
    <id>https://joytsing.github.io/posts/36379/</id>
    <published>2024-04-05T09:03:52.000Z</published>
    <updated>2024-04-07T12:51:38.095Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、相关实际问题"><a href="#一、相关实际问题" class="headerlink" title="一、相关实际问题"></a>一、相关实际问题</h3><ol><li>127.0.0.1本机网络IO需要经过网卡吗</li><li>数据包在内核中是什么走向，和外网发送相比流程上有什么差别</li><li>访问本机服务时，使用127.0.0.1能比本机IP（例如192.168.x.x）快吗</li></ol><h3 id="二、跨机网络通信过程"><a href="#二、跨机网络通信过程" class="headerlink" title="二、跨机网络通信过程"></a>二、跨机网络通信过程</h3><p>在开始讲述本机通信过程之前，先回顾前面的跨机网络通信。</p><h4 id="1）跨机数据发送"><a href="#1）跨机数据发送" class="headerlink" title="1）跨机数据发送"></a>1）跨机数据发送</h4><p><img src="/posts/36379/905c9a70079c41958e9b0bf745ed53af.png" alt></p><ol><li>应用层：send/sendto</li><li>系统调用：（send=&gt;）<strong>sendto</strong><ol><li><strong>构造msghdr并赋值</strong>（用户待发送数据的指针、数据长度、发送标志等）</li><li>sock_sendmsg =&gt; __sock_sendmsg_nosec =&gt; <strong>sock-&gt;ops-&gt;sendmsg</strong></li></ol></li><li>协议栈：<strong>inet_sendmsg</strong>（AF_INET协议族对socck-&gt;ops-&gt;sendmsg的实现）<ul><li>传输层<ol><li><strong>sk-&gt;sk_prot-&gt;sendmsg</strong></li><li><strong>tcp_sendmsg</strong>（tcp协议对sk-&gt;sk_prot-&gt;sendmsg的实现）：<strong>数据拷贝到发送队列的skb</strong></li><li><strong>tcp_write_xmit：拥塞控制、滑动窗口、包分段</strong></li><li><strong>tcp_transmit_skb：拷贝skb、封装TCP头、调用网络层发送</strong></li></ol></li><li>网络层<ol><li><strong>ip_queue_xmit：查找socket缓存的路由表，没有则查找路由项并缓存，为skb设置路由表，封装IP头并发送</strong></li><li>ip_local_out =&gt; __ip_local_out =&gt; nf_hook：<strong>netfilter过滤</strong></li><li>skb_dst(skb)-&gt;output(skb)：找到skb路由表的dst条目，调用output方法</li><li>ip_output：<strong>简单的统计，再次执行netfilter过滤</strong>，回调ip_finish_output</li><li>ip_finish_output：<strong>校验数据包的长度，如果大于MTU，就会执行分片</strong></li><li>ip_finish_output2：调用邻居子系统定义的方法</li></ol></li></ul></li><li>邻居子系统<ol><li>rt_nexthop：<strong>获取路由下一跳的IP信息</strong></li><li>__ipv4_neigh_lookup_noref：<strong>根据下一条IP信息在arp缓存中查找邻居项</strong></li><li>__neigh_create：<strong>创建一个邻居项，并加入邻居哈希表</strong></li><li>dst_neigh_output =&gt; neighbour-&gt;output（实际指向neigh_resolve_output）：<ol><li><strong>封装MAC头（可能会先触发arp请求）</strong></li><li>调用dev_queue_xmit发送到下层</li></ol></li></ol></li><li>网络设备子系统<ol><li><strong>dev_queue_xmit：选择发送队列，获得排队规则，存在队列则调用__dev_xmit_skb</strong></li><li>__dev_xmit_skb：根据qdisc状态执行不同逻辑</li><li>q-&gt;enqueue：<strong>入队</strong></li><li><strong>__qdisc_run：开始发送</strong></li><li><strong>qdisc_restart *<em>=&gt; sch_direct_xmit =&gt; *</em>dev_hard_start_xmit</strong>：<strong>从队列取出一个skb并发送</strong></li><li>dev-&gt;netdev_ops-&gt;ndo_start_xmit：调用驱动里的发送回调函数，将数据包传给网卡设备</li></ol></li><li>驱动程序：igb_xmit_frame<ol><li>igb_xmit_frame_ring：<strong>获取发送环形数组队列下一个可用的缓冲区，挂上skb</strong></li><li>igb_tx_map：<strong>获取下一个描述符指针，将skb数据映射到网卡可访问的内存DMA区域</strong></li></ol></li><li>硬件发送<ol><li><strong>发送完毕触发硬中断通知CPU</strong></li><li>igb_msix_ring =&gt; napi_schedule =&gt; __raise_softirq_irqoff：硬中断处理，发起软中断</li><li>net_rx_action =&gt; igb_poll：软中断处理</li><li>igb_clean_tx_irq：<strong>释放skb，清除tx_buffer，清理DMA</strong></li></ol></li></ol><h4 id="2）跨机数据接收"><a href="#2）跨机数据接收" class="headerlink" title="2）跨机数据接收"></a>2）跨机数据接收</h4><ol><li>硬件<ol><li>网卡把帧DMA到内存</li><li>发起硬中断通知CPU</li></ol></li><li>驱动程序<ol><li>igb_msix_ring =&gt; napi_schedule =&gt; __raise_softirq_irqoff：硬中断处理，发起软中断</li><li>net_rx_action =&gt; igb_poll：软中断处理</li><li>igb_clean_rx_irq：<strong>从RingBuffer取出数据包进行初步处理、检查完整性等，并将其封装为sk_buff添加到网络接收队列</strong></li></ol></li><li>网络设备子系统：netif_receive_skb<ol><li>__netif_receive_skb_core：<strong>遍历ptype_all链表处理数据包（tcp_dump抓包点），遍历ptype_base哈希表处理数据包</strong></li><li>deliver_skb：根据上述遍历到的协议，<strong>传递给对应协议处理函数进行进一步的处理</strong>。例如IP数据包（ptype_base中）则将其传递给IP协议处理模块。</li></ol></li><li>网络协议栈处理：pt_prev-&gt;func<ul><li>网络层<ol><li>ip_rcv：<strong>通过Netfilter进行进一步处理</strong>，比如网络地址转换(NAT)、防火墙过滤等操作</li><li>ip_rcv_finish =&gt; ip_local_deliver_finish：使用inet_protos<strong>拿到协议的函数地址，根据包中的协议类型选择分发</strong>。在这里skb包将会进一步被派送到更上层的协议中，UDP或TCP</li></ol></li><li>传输层<ol><li>tcp_v4_rcv：<strong>获取tcp头和ip头，拿到目的ip地址和端口，找到对应的socket</strong></li><li>tcp_v4_do_rcv =&gt; tcp_rcv_established：<strong>将接收到的数据放到socket的接收队列尾部</strong>，并<strong>调用sk_data_ready来唤醒在socket上等待的用户进程</strong></li><li>sock_def_readable =&gt;autoremove_wake_function =&gt; default_wake_function：唤醒进程</li></ol></li></ul></li><li>用户进程<ol><li>系统调用recv =&gt; sock_recvmsg ==&gt; __sock_recvmsg ==&gt; __sock_recvmsg_nosec</li><li>sock-&gt;ops-&gt;recvmsg：在AF_INET中其指向的是inet_recvmsg</li><li>inet_recvmsg =&gt; sk-&gt;sk_prot-&gt;recvmsg：在SOCK_STREAM中它的实现是tcp_recvmsg</li><li>tcp_recvmsg：<strong>遍历接收队列，如果数据量不满足则阻塞进程</strong></li><li>sk_wait_data：<strong>定义了一个等待队列项wait</strong>，在这个新的等待队列项上<strong>注册了回调函数autoremove_wake_function</strong>，并把<strong>当前进程描述符current关联到其.private成员上，让出cpu进入睡眠</strong></li><li>睡眠===</li><li><strong>唤醒后继续遍历队列接收数据</strong></li></ol></li></ol><h4 id="3）跨机网络通信汇总"><a href="#3）跨机网络通信汇总" class="headerlink" title="3）跨机网络通信汇总"></a>3）跨机网络通信汇总</h4><p><img src="/posts/36379/371fb77993524d25960f79688ee38136.png" alt></p><h3 id="三、本机发送过程"><a href="#三、本机发送过程" class="headerlink" title="三、本机发送过程"></a>三、本机发送过程</h3><p>上面主要介绍了跨机时整个网络的发送过程， 而在本机网络IO过程中，会有一些差别。主要的差异有两部分，分别是路由和驱动程序。</p><h4 id="1）网络层路由"><a href="#1）网络层路由" class="headerlink" title="1）网络层路由"></a>1）网络层路由</h4><p><img src="/posts/36379/b6ad411f22094f07ad1c3b4739525ee4.png" alt></p><p>发送数据进入协议栈到达网络层的时候，网络层入口函数是ip_queue_xmit。在网络层里会进行路由选择，路由选择完毕再设置一些IP头，进行一些Netfilter的过滤，数据包分片等操作，然后将包交给邻居子系统。</p><p>对于本机网络IO来说，特殊之处在于<strong>在local路由表中就可以找到路由项，对应的设备都是用loopback网卡，也就是常说的lo设备</strong>。</p><p>我们重新回到之前网络层查找路由项的部分代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ip_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> flowi <span class="token operator">*</span>fl<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 检查socket中是否有缓存的路由表</span>    rt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> rtable<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">__sk_dst_check</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>rt <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 没有缓存则展开查找路由项并缓存到socket中</span>    rt <span class="token operator">=</span> <span class="token function">ip_route_output_ports</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">sk_setup_caps</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-></span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1234567891011</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查找路由项的函数时ip_route_output_ports，它经过层层调用，来到关键的部分——fib_lookup</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">fib_lookup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> flowi4 <span class="token operator">*</span>flp<span class="token punctuation">,</span> <span class="token keyword">struct</span> fib_result <span class="token operator">*</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> fib_table <span class="token operator">*</span>table<span class="token punctuation">;</span>    table <span class="token operator">=</span> <span class="token function">fib_get_table</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> RT_TABLE_LOCAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">fib_table_lookup</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> flp<span class="token punctuation">,</span> res<span class="token punctuation">,</span> FIB_LOOKUP_NOREF<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 查找与给定流（由flp指定）匹配的路由项，并将查找结果存储在res中。FIB_LOOKUP_NOREF是传递给此函数的标志，用于指定查找行为的一些细节。</span>    <span class="token comment" spellcheck="true">// 查找成功返回0</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> <span class="token function">fib_get_table</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> RT_TABLE_MAIN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">fib_table_lookup</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> flp<span class="token punctuation">,</span> res<span class="token punctuation">,</span> FIB_LOOKUP_NOREF<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span>ENETUNREACH<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">12345678910111213</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在fib_lookup中将<strong>会对local和main两个路由表展开查询，并且先查询local后查询main</strong>。我们在Linux上使用ip命令可以查看到这两个路由表，这里只看local路由表（因为本机网络IO查询到整个表就结束了）</p><pre class="line-numbers language-cmd"><code class="language-cmd">#ip route list table locallocal 10.143.x.y dev eth0 proto kernel scope host src 10.143.x.ylocal 127.0.0.1 dev lo proto kernel host src 127.0.0.1123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从上述结果可以看出127.0.0.1的路由在local路由表中就能够找到。</p><blockquote><p>上面路由表中10.143.x.y dev eth0是本机的局域网IP，虽然写的是dev eth0，但是其实内核在初始化local路由表的时候，把local路由表里所有的路由项都设置为了RTN_LOCAL。所以即使本机IP不用环回地址，内核在路由项查找的时候判断类型是RTN_LOCAL，仍然会使用net-&gt;loopback_dev，也就是lo虚拟网卡。</p><p>此处可以使用tcpdump -i eht0 port 8888以及telnet 10.143.x.y 8888进行验证，telnet后tcpdump并不会收到网络请求，因为发给的是lo。</p></blockquote><p>之后fib_lookup的工作完成，返回上一层__ip_route_output_key函数继续执行。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> rtable <span class="token operator">*</span><span class="token function">ip_route_output_key</span><span class="token punctuation">(</span><span class="token keyword">struct</span> net <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> flowi4 <span class="token operator">*</span>fl4<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fib_lookup</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> fl4<span class="token punctuation">,</span> <span class="token operator">&amp;</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>type <span class="token operator">==</span> RTN_LOCAL<span class="token punctuation">)</span> <span class="token punctuation">{</span>      dev_out <span class="token operator">=</span> net<span class="token operator">-></span>loopback_dev<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token number">12345678910</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对于本机的网络请求，设备将全部使用net-&gt;loopback_dev，也就是lo虚拟网卡。接下来的网络层仍然和跨机网络IO一样（所以本机网络IO如果skb大于MTU仍然会进行分片，不过lo虚拟网卡(65535)的MTU(1500)比Ethernet大得多），最终会经过ip_finish_output，进入邻居子系统的入口函数dst_neigh_output</strong>。</p><p>在邻居子系统函数中经过处理后，进入网络设备子系统（入口函数是dev_queue_xmit）</p><h4 id="2）网络设备子系统"><a href="#2）网络设备子系统" class="headerlink" title="2）网络设备子系统"></a>2）网络设备子系统</h4><p>网络设备子系统的入口函数是dev_queue_xmit，其中会<strong>判断是否有队列</strong>。<strong>对于有队列的物理设备，该函数进行了一系列复杂的排队等处理后，才调用dev_hard_start_xmit，从这个函数在进入驱动程序igb_xmit_frame来发送</strong>。在这个过程中还可能触发软中断进行发送。</p><p>但是<strong>对于启动状态的回环设备</strong>（q-&gt;enqueue判断为false）来说就简单多了，它<strong>没有队列的问题，直接进入dev_hard_start_xmit</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dev_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    q <span class="token operator">=</span> <span class="token function">rcu_dereference_bh</span><span class="token punctuation">(</span>txq_qdisc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">-></span>enqueue<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 回环设备这里返回false</span>      rc <span class="token operator">=</span> <span class="token function">__dev_xmit_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 开始回环设备处理</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>dev<span class="token operator">-></span>flags <span class="token operator">&amp;</span> IFF_UP<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">12345678910111213</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在dev_hard_start_xmit函数中还将调用设备驱动的操作函数，对<strong>于回环设备的而言，其“设备驱动”的操作函数ops-&gt;ndo_start_xmit指向的是loopback_xmit</strong>（不同于正常网络设备的igb_xmit_frame）。</p><p><img src="/posts/36379/031af9965aea406c88692f7ca8c55793.png" alt></p><p><img src="/posts/36379/dd2484c6c34746579ffd367efb80eec7.png" alt></p><h4 id="3）驱动程序"><a href="#3）驱动程序" class="headerlink" title="3）驱动程序"></a>3）驱动程序</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> netdev_tx_t <span class="token function">loopback_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> net_device <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 剥离掉和源socket的联系</span>    <span class="token function">skb_orphan</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用netif_rx</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">netif_rx</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span> <span class="token operator">==</span> NET_RX_SUCCESS<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>loopback_xmit中首先调用skb_orphan先把skb上的socket指针去掉了，接着调用netif_tx，在该方法中最终会执行到enqueue_to_backlog。</strong></p><blockquote><p>在本机IO发送的过程中，传输层下面的skb就不需要释放了，直接给接收方传过去就行。不过传输层的skb就节约不了，还是需要频繁地申请和释放。</p></blockquote><p><img src="/posts/36379/2c95c6ac11f046adab03100275efee3e.png" alt></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">enqueue_to_backlog</span><span class="token punctuation">(</span><span class="token keyword">struct</span> sk_buff <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">int</span> cpu<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>qtail<span class="token punctuation">)</span><span class="token punctuation">{</span>    sd <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>softnet_data<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">__skb_queue_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>input_pkt_queue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">__napi_schedule</span><span class="token punctuation">(</span>sd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sd<span class="token operator">-></span>backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">12345678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>enqueue_to_backlog函数用于<strong>把要发送的skb插入softnet_data-&gt;input_pkt_queue队列</strong></p><p>具体步骤如下：</p><ol><li>sd = &amp;per_cpu(softnet_data, cpu)：获取给定 CPU 的softnet_data结构。这个结构保存了这个 CPU 的一些网络处理状态和数据，比如input_pkt_queue。</li><li>__skb_queue_tail(&amp;sd-&gt;input_pkt_queue, skb)：将数据包skb加入到input_pkt_queue队列的尾部。</li><li>__napi_schedule(sd, &amp;sd-&gt;backlog)：调度该函数来触发软中断处理这个队列。</li></ol><p>这里<strong>触发的软中断类型是NET_RX_SOFTIRQ</strong>，只有触发完软中断，发送过程才算完成了。</p><h3 id="四、本机接收过程"><a href="#四、本机接收过程" class="headerlink" title="四、本机接收过程"></a>四、本机接收过程</h3><p>发送过程触发软中断后，会进入软中断处理函数net_rx_action。</p><p><img src="/posts/36379/28e7da137a7845cbaab82ba100861be8.png" alt></p><p><strong>在跨机地网络包地接收过程中，需要经过硬中断，然后才能触发软中断。而在本机地网络IO过程中，由于并不真的过网卡，所以网卡地发送过程、硬中断就都省去了，直接从软中断开始。</strong></p><p>对于igb网卡来说，软中断中轮询调用的poll函数指向的是igb_poll函数。而对于loopback网卡来说，poll函数是process_backlog。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process_backlog</span><span class="token punctuation">(</span><span class="token keyword">struct</span> napi_struct <span class="token operator">*</span>napi<span class="token punctuation">,</span> <span class="token keyword">int</span> quota<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>skb <span class="token operator">=</span> <span class="token function">__skb_dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>process_queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">__netif_receive_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// skb_queue_splice_tail_init()函数用来将链表a(输入队列)的元素链接到链表b(处理队列)上</span>     <span class="token comment" spellcheck="true">// 形成一个新的链表b，并将原来a的头变成了空链表</span>     qlen <span class="token operator">=</span> <span class="token function">skb_queue_len</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>input_pkt_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>qlen<span class="token punctuation">)</span>        <span class="token function">skb_queue_splice_tail_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-></span>input_pkt_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sd<span class="token operator">-></span>process_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1234567891011121314</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数用于反复处理队列中的数据包，直到队列为空或者处理的数据包数量达到了指定的配额（quota）。</p><p>在内层循环中，它使用 __skb_dequeue() 函数<strong>从 process_queue 中取出一个数据包，然后使用 __netif_receive_skb() 函数处理这个数据包</strong>。</p><p>在内层循环结束后，它<strong>检查 input_pkt_queue（输入数据包队列）是否还有剩余的数据包</strong>。如果有，它<strong>使用 skb_queue_splice_tail_init() 函数将 input_pkt_queue 中的数据包移动到 process_queue 中</strong>，然后在下一次内层循环中继续处理这些数据包。</p><p><strong>__netif_receive_skb用于将数据送往协议栈，在此之后的调用过程就和跨机网络的IO又一致了</strong>：__netif_receive_skb =&gt; __netif_receive_skb_core =&gt; deliver_skb，然后再将数据送入ip_rcv中进行后续操作。</p><p><img src="/posts/36379/e492262233c94d3ca37656becc5f263b.png" alt></p><h3 id="五、问题解答"><a href="#五、问题解答" class="headerlink" title="五、问题解答"></a>五、问题解答</h3><ol><li>127.0.0.1本机网络IO需要经过网卡吗<ul><li>不需要经过网卡，即使网卡拔了也可以正常使用本机网络</li></ul></li><li>数据包在内核中是什么走向，和外网发送相比流程上有什么差别<ul><li>节约了驱动上的一些开销。发送数据不需要静茹RingBuffer的驱动队列，直接把skb传给接收协议栈。</li><li>其他组件，包括系统调用、协议栈、设备子系统都经过了，甚至驱动程序也运行了，所以还是有一定的开销的。</li><li>如果想要再本机网络IO上绕开协议栈的开销，可以动用eBPF，用eBPF的sockmap和sk redirect可以达到真正不走协议栈的目的。</li></ul></li><li>访问本机服务时，使用127.0.0.1能比本机IP（例如192.168.x.x）快吗<ul><li>本机IP和127.0.0.1没有差别，都是走的环回设备lo</li><li>这是因为内核在设置IP的时候，把所有的本机IP都初始化到了local路由表里，类型写死了是RTN_LOCAL。所以后面的路由项选择的时候发现类型是RTN_LOCAL就会选择lo设备。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、相关实际问题&quot;&gt;&lt;a href=&quot;#一、相关实际问题&quot; class=&quot;headerlink&quot; title=&quot;一、相关实际问题&quot;&gt;&lt;/a&gt;一、相关实际问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;127.0.0.1本机网络IO需要经过网卡吗&lt;/li&gt;
&lt;li&gt;数据包在内核中是
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
      <category term="源码阅读" scheme="https://JoyTsing.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
