<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="浅析Cpp中的SFINAE, joytsing blog"><meta name="description" content="Substitution Failure Is Not An Error"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>浅析Cpp中的SFINAE | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/11.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">浅析Cpp中的SFINAE</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2024-04-01</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-04-01</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 9.5k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 41 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SFINAE（Substitution Failure Is Not An Error，替换失败并非错误）一听就非常高级，什么是“替换”？这里的替换，实际上指的正是模板实例化；也就是说，当模板实例化失败时，编译器并不认为这是一个错误。这个概念晦涩难懂，因为它牵扯到编译器对模板的处理，而且很多时候不知道怎么去用（唉，语言学家），下面通过一个例子先学习下。</p><h2 id="进化之路"><a href="#进化之路" class="headerlink" title="进化之路"></a>进化之路</h2><h3 id="cpp-11"><a href="#cpp-11" class="headerlink" title="cpp 11"></a><strong>cpp 11</strong></h3><p>在正式编写代码前要介绍一个重要的库 <code>#include &lt;type_traits&gt;</code>。</p><p>该库是模板编程中最重要核心的库之一，若缺少本库就不会有如此丰富强大的泛型编程的实现。</p><p><strong>std:: enable_if&lt;&gt;</strong></p><p>此模板可以说是 SFINA 的灵魂一般的存在。</p><p>我们的目的是让模板参数符合某一种约束条件，而 enable_if 可以根据约束条件进行特定展开。根据这一特点，可以对模板的展开进行限制。具体的：</p><ul><li>如果满足约束条件，在 enable_if 中会存在等同于 T 的公开成员 <code>typedef type</code></li><li>如果不满足条件，则没有此 <code>typedef type</code></li></ul><p>std:: enable_if 可能的实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">></span>
<span class="token keyword">struct</span> enable_if <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">struct</span> enable_if<span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span> 
    <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>std:: is_xxx&lt;&gt;</strong></p><p>这是在 type_traits 中的一系列模板，这类模板可以对模板参数进行特定条件判断符合与否。</p><ul><li>若符合确定条件，则提供等于 <code>true</code> 的成员常量 <code>value</code></li><li>若不成功，则提供等于 <code>false</code> 的成员常量 <code>value</code></li></ul><blockquote><p>而对于本示例，我们可以使用<code>std::is_integral&lt;T&gt;</code>，本模板可以判断T是否为整数类型。<br>如果是整数类型，则要求展开失败，否则展开成功。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>

<span class="token keyword">namespace</span> my <span class="token punctuation">{</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 引入第二个模板参数
     * 根据第二个模板参数展开失败与否
     * 决定是否最终使用该模板
     */</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Iter<span class="token punctuation">,</span> 
        <span class="token keyword">typename</span> SFINA <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span><span class="token operator">!</span>std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span>Iter<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span>
    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当<code>my::vector&lt;Type&gt; vec0(5, val);</code>进行模板匹配时候，首先会找到<code>vector(Iter begin, Iter end)</code>并尝试展开，但该模板的第二个参数约束<code>Iter</code>不是整形类型时，才能展开成功。因此再重新寻找其他的匹配函数。</p><h3 id="cpp-14-cpp-17"><a href="#cpp-14-cpp-17" class="headerlink" title="cpp 14 ~ cpp 17"></a><strong>cpp 14 ~ cpp 17</strong></h3><p>对于每次写<code>std::is_integral&lt;T&gt;::value</code>和<code>std::enable_if&lt;B&gt;::type</code>都比较麻烦。因此 cpp 14 建议可以通过另一个简单的符号表示该内容。也就是<code>type trait variable templates</code>的概念。直到 cpp 17 才在正式标准中进行了全面的完善。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// cpp14</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token operator">></span>
<span class="token keyword">using</span> enable_if_t <span class="token operator">=</span> <span class="token keyword">typename</span> enable_if<span class="token operator">&lt;</span>B<span class="token punctuation">,</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// cpp17</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">></span>
<span class="token keyword">inline</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> is_integral_v <span class="token operator">=</span> is_integral<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此我们可以得到以下的简洁版本。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>

<span class="token keyword">namespace</span> my <span class="token punctuation">{</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 相对于cpp11更加简洁的写法
     * 同时第二个模板参数没有具体使用到，可以省略成一个匿名形式
     */</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Iter<span class="token punctuation">,</span> 
        <span class="token keyword">typename</span> <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span><span class="token operator">!</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>Iter<span class="token operator">>></span><span class="token operator">></span>
    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cpp-20"><a href="#cpp-20" class="headerlink" title="cpp 20"></a><strong>cpp 20</strong></h3><p>c++ 是一门不断发展的现代语言，在 cpp 20 中提出了概念和约束到标准中。</p><p><strong>requires</strong></p><p><code>requires</code> 是一个关键字。可以直接在模板函数中进行使用。</p><p>requires是在template和函数体之间编写，提升可代码可阅读性。</p><p>注意一点，requires 子句需要是一个初等表达式 或者 带括号的表达式。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;concepts></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>

<span class="token keyword">namespace</span> my <span class="token punctuation">{</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 使用 requires 关键字</span>
    <span class="token comment" spellcheck="true">// 直接写出约束条件</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Iter<span class="token operator">></span>
    <span class="token function">requires</span> <span class="token punctuation">(</span><span class="token operator">!</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>Iter<span class="token operator">></span><span class="token punctuation">)</span>
    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>concept</strong></p><p><code>concept</code> 是一个关键字。可以通过该关键字定义一个基于模板参数的约束条件。再将该约束条件运用到具体的模板函数中。</p><p>这样可以使约束条件和具体的模板函数进行分离，大大化简编码的复杂度。同时这个约束条件可以进行复用，再次减少了代码的冗余度。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;concepts></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>

<span class="token keyword">namespace</span> my <span class="token punctuation">{</span>

<span class="token comment" spellcheck="true">// 定义一个约束条件</span>
<span class="token comment" spellcheck="true">// 约束为不能是整形数值</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span>
concept IterType <span class="token operator">=</span> <span class="token operator">!</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>Type<span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 直接写定义的约束条件</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span>IterType Iter<span class="token operator">></span>
    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>requires 表达式</strong></p><p><code>requires 表达式</code> 是将上述的<code>concept</code>和<code>requires</code>结合使用。</p><p>requires 表达式的编写形式与函数编写非常相似，将约束条件挨个写在requires后的大括号域内。</p><p>这种展现形式简洁明了，容易扩充。能同时兼具单独使用<code>concept</code>和<code>requires</code>的优点。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;concepts></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>

<span class="token keyword">namespace</span> my <span class="token punctuation">{</span>

<span class="token comment" spellcheck="true">// requires 表达式</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span>
concept IterType <span class="token operator">=</span> requires <span class="token punctuation">{</span> 
    std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>Type<span class="token operator">></span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Type<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">vector</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> Type val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(size_t len, Type val)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 使用 requires 表达式</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span>IterType Iter<span class="token operator">></span>
    <span class="token function">vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vector(Iter begin, Iter end)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// namespace my</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>假如设计一个加法接口，可以对两个基础类型数据、两个支持加法的自定义类型数据、两个相同容器里的数据、两个相同类型的数组里的数据进行加操作，应当怎么做？这个加法接口有两个输入，返回相加后的结果，对于数组或者容器类型的数据返回的是逐个相加的结果。</p><p>根据这个要求，我们首先可以写出以下的函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
T <span class="token function">add</span><span class="token punctuation">(</span> T a<span class="token punctuation">,</span> T b <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样写会带来一个问题：当形参a和b不是相同的类型的时候，会造成匹配不上的结果</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时编译器会报错：</p><pre class="line-numbers language-cpp"><code class="language-cpp">main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">13</span><span class="token operator">:</span><span class="token number">21</span><span class="token operator">:</span> error<span class="token operator">:</span> no matching function <span class="token keyword">for</span> call to ‘<span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span><span class="token punctuation">)</span>’
  <span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>
                     <span class="token operator">^</span>
main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">4</span><span class="token operator">:</span><span class="token number">3</span><span class="token operator">:</span> note<span class="token operator">:</span> candidate<span class="token operator">:</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> T <span class="token function">add</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> T<span class="token punctuation">)</span>
 T <span class="token function">add</span><span class="token punctuation">(</span> T a<span class="token punctuation">,</span> T b <span class="token punctuation">)</span>
   <span class="token operator">^</span><span class="token operator">~</span><span class="token operator">~</span>
main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">4</span><span class="token operator">:</span><span class="token number">3</span><span class="token operator">:</span> note<span class="token operator">:</span>   <span class="token keyword">template</span> argument deduction<span class="token operator">/</span>substitution failed<span class="token operator">:</span>
main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">13</span><span class="token operator">:</span><span class="token number">21</span><span class="token operator">:</span> note<span class="token operator">:</span>   deduced conflicting types <span class="token keyword">for</span> parameter ‘T’ <span class="token punctuation">(</span>‘<span class="token keyword">int</span>’ <span class="token operator">and</span> ‘<span class="token keyword">float</span>’<span class="token punctuation">)</span>
  <span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到我们在调用add方法的时候，我们的模板函数钟的T只有一种类型，没办法推导出两种类型，编译失败。</p><p>我们接着对这个函数进行改进，让它能够支持两种类型的输入，我们想着既然一个模板参数对应一个类型，那么我们再加一个模板参数不就可以对应两个不同类型的参数了吗，答案是可以的，正当我们兴奋的想写下这个函数的时候，问题来了，返回类型怎么写？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
返回类型？<span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当两个不同类型的值相加的时候，怎么确定函数的返回类型呢，我们知道一般我们写一个float的数和int类型的数相加得到的一定是一个float数，但是在模板中输入有成千上万种可能，我们没办法写出一个具体的类型来指代。这种事情最好还是让编译器来自己决定，那就是<strong>尾置返回类型：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">decltype</span><span class="token punctuation">(</span> a <span class="token operator">+</span> b <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的auto只是一个占位符，并不是指实际的类型，真正的类型是靠<code>decltype</code>来推导出来的，<code>decltype</code>是c++11之后引入的关键词，作用是在编译期推导出括号里的表达式、变量或者类型本身的类型。这里它会自动推导出表达式( a + b )的类型，并取代前面的auto作为返回值类型。</p><p>在c++14之后，这个函数可以取消尾置返回类型，auto也具备了自动推导返回值类型的能力：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里一切都很好，我们这个模板函数可以支持两种不同类的输入，并且能够自动推导返回类型了，但是这还不够，因为对于容器类型的数据来说，我们还没办法对其进行支持，因此我们要写一个可以支持两个容器类型数据加法的重载函数模板：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>
         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// #接口实现2</span>
<span class="token punctuation">{</span>
    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，会选择接口实现2而不是接口实现1</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> c1 <span class="token punctuation">)</span> std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>val<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok; 输出 2 4 6 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，这里的Container1和Container2是模板模板参数。T1和T2是模板模板参数中的具体参数。接口实现2可以看成是对接口实现1的重载，在调用时，如果输入是两个容器类型的数据，编译器会认为接口实现2匹配的更好，从而实例化接口实现2的函数模板。</p><p>但是这样同时会带来新的问题，当我们想对两个由自定义的模板类定义的对象操作add接口的时候，会出现棘手的现象。</p><h2 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h2><p>首先，只考虑有接口实现1的情况下，我们自己定义了一个模板类，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> B<span class="token punctuation">{</span>
        <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token function">B</span><span class="token punctuation">(</span> <span class="token keyword">const</span> T b_ <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">b</span><span class="token punctuation">(</span> b_ <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

        B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> B rhs <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 加法运算符重载1</span>
        <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">B</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>
        <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> B<span class="token operator">&lt;</span>U<span class="token operator">></span> rhs <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 加法运算符重载2 </span>
        <span class="token punctuation">{</span>
                <span class="token keyword">return</span> B<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意这里让编译器去决定加法之后的模板参数类型是什么</span>
        <span class="token punctuation">}</span>

        T b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们重载了加法运算符，让它得以支持加法操作，同时我们还实现了一个加法运算符的模板函数重载，让这个类型的变量能对不同的T类型实现加法操作，譬如:</p><pre class="line-numbers language-cpp"><code class="language-cpp">B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1<span class="token punctuation">,</span> a2<span class="token punctuation">;</span>
a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，a1和a2是相同类型的数据,调用加法运算符重载1</span>
B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> a3<span class="token punctuation">;</span>
a1 <span class="token operator">+</span> a3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，a1和a3不是相同类型的数据，调用加法运算符重载2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在一个只考虑有接口实现1的版本中，我们调用add方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1<span class="token punctuation">;</span>
   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1<span class="token punctuation">;</span>
   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, a1和b1虽然是不同的类型，但是因为重载了运算符，可以做加法</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在一个既有接口实现1又有接口实现2的版本中，我们调用add方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>
         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// #接口实现2</span>
<span class="token punctuation">{</span>
    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现2上</span>

   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>
   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>
   <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error，编译器同样会匹配到接口实现2，但是B类型中没有begin,end等函数，报错</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们本来想让接口实现1只为基础类型或者支持加法的自定义类型服务，而让接口实现2为容器类型服务的。现在好了，在为自定义模板类型的变量调用接口的时候，也会匹配到接口实现2上去，与我们的预期大大不同。</p><p>这个问题的根本原因在于我们的接口实现2的形参在与实参进行匹配的时候，因为我们的自定义类型是模板类，与模板模板参数匹配的更好，这样编译器会优先决策匹配的更好的模板函数实现，而这整个过程就是有c++<strong>重载决议机制</strong>实现的。</p><p>那我们有没有办法去人为的控制这种重载呢，让最终的调用能够选择正确的匹配函数呢？答案是可以的，这就是我们要利用SFINAE机制来做的事情了，而这正是本文接下来要说的重点。</p><p>在讲SFINAE之前，我们要大致了解一下我们实现的这个add接口从定义到实例化再到最终调用编译器做了哪些事情，这有助于后面理解SFINAE机制。</p><h2 id="实例化过程"><a href="#实例化过程" class="headerlink" title="实例化过程"></a>实例化过程</h2><ol><li>两阶段命名查找(<strong>Two-Phase Name Lookup</strong>)</li></ol><p>在c++中，将各种变量、函数、模板等命名分为受限型命名(qualified name)，非受限型命名(unqualified name)，依赖型命名(dependent name)，非依赖型命名(non-dependent)几种。所谓受限型命名，指的是在作用域符(::)或者成员访问运算符(-&gt;和.)之后的名称（即属于类成员或者命名空间内的变量或者函数）。非受限型命名则是除了受限型名之外的名称。依赖型命名是指以某种方式依赖于模板参数的名称。相同的，非依赖型命名就是不属于依赖性名称的名称。</p><p>我们这里的add接口在调用的时候既没有用作用域符，也没有用成员访问运算符，因此是一个非受限型名称，同时add接口又依赖模板参数，因此也属于依赖性名称，因此可以称之为unqulified dependent name。对于这类名称，编译器在首次看到的时候会先对其进行一次查找，这时候由于模板还没有实例化，这个时候找到的只是这个add函数的“蓝图”，即我们所写的函数模板，这个阶段只能对其做基础的模板解析和语法检查，等模板经历了实参推导和替换之后，才会生成实际的函数，这时候还需要在进行一次查找以找到实例化后的函数，这个过程就是<strong>两阶段命名查找</strong>。</p><p>第一阶段的命名查找一般使用普通查找规则(Ordinary Lookup rule)，第二阶段会使用著名的<code>实参依赖</code>(Aurgument Dependent Lookup, ADL)查找规则来进行查找，具体的原理不是本文的重点，这里不再深入，有兴趣的朋友可以自己去了解。通过命名查找机制找到的实例化之后的函数会放入<strong>重载集</strong>中(Overload Set)，随后会以候选者的角色送入重载决议中进行裁决。</p><ol start="2"><li>两阶段编译检查(Two-Phase Translation)</li></ol><p>两阶段编译检查是配合两阶段命名查找的一种机制，同样以add接口为例，在第一次查找这个函数模板的时候，会对其进行解析，同时检查它的语法合法性，这时候不管类型是不是支持加法操作，编译器都不会报错，因为编译器此时还不知道模板的参数具体是什么。</p><p>在第二阶段命名查找之后，编译器已经能够找到了add模板实例化之后函数，经过重载决议之后，编译器会从这些实例化函数中选取一个最合适的重载函数作为最终要执行的函数，这时候会进行第二阶段的编译器检查，这时候检查就会更加严格，会检查函数内部的表达式是否能够成立，例如上面的例子中：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现2上</span>

   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>
   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>
   <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error，编译器同样会匹配到接口实现2，但是B类型中没有begin,end等函数，报错</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中的auto c2 = add( a2, b2 ); 就是在这个第二段编译检查阶段才报错的。</p><ol start="3"><li>模板实参推导(Template Argument Deduction, TAD)</li></ol><p>为啥需要模板实参推导这个机制呢？最主要的原因是我们想要在使用add这个模板函数的时候要像使用普通函数一样简单，虽然可以通过显示的指定模板的参数来调用，但是这种方法显得非常的繁琐。我们先举一个简单的例子来直观感受一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span> T t <span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// f&lt;int>(1); 模板参数T被推导为int</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// f&lt;double>(1.1); 模板参数T被推导为double</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// error: T cannot be duduced</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上模板实参推导涉及到许许多多的内容，会遇到诸如类型退化、左值引用传参、右值引用传参、万能引用、完美转发、可变参数等诸多情况，模板实参推导的规则非常复杂，其原理也不在本文中详细说明。</p><ol start="4"><li>模板实参替换(Template Argument Substitution, TAS)</li></ol><p>在用推导出的实参替换模板参数之后，再使用推导出来的类型替换模板参数，从而完成实例化一个函数模板的过程。</p><p>这里就要讲到本文的重点了：<strong>参数替换过程中，并不总是能够替换成功</strong>的，举个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span> T a <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 重载1</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span> T<span class="token operator">::</span>value_type a <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 重载2</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">test</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 重载2替换失败，选择重载1</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里编译器会通过命名查找机制找到重载1和重载2两种函数模板，然后模板参数T都可以被推导为int类型，但是由于int类型中没有value_type这个类型，会造成参数替换失败，此时编译器并不会立即报错，只是将其从重载集中移除，后面的重载决议也就不会再选择它，这个机制就是SFINAE。</p><p>我们利用这种机制可以<strong>实现对模板参数类型的限制</strong>，也可以通过强行<strong>禁用某些模板</strong>来实现人为的重载选择。</p><ol start="5"><li>重载决议</li></ol><p>重载决议的核心就是在重载集中找到唯一的一个与调用情况最优匹配的实现函数，如果重载决议找不到最匹配的函数，则编译器会报” no matching function for call to xxx”的错误。</p><h2 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h2><p>我们的思路是想利用SFINAE机制来让下面这个调用：</p><pre class="line-numbers language-cpp"><code class="language-cpp">B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>
B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>
<span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>排除掉接口实现2，方法是强行让编译器对这个调用在和接口实现2的函数模板进行模板实参替换的时候失败，这样重载决议中就会忽略掉这个模板实现，从而让它选择接口实现1。具体的实现需要借助标准模板库里提供的两个工具：<code>std::enable_if</code>以及<code>std::voit_t;</code></p><p>enable_if的一个可能的实现是这样的（参考cppreference）:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">></span>
<span class="token keyword">struct</span> enable_if <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">struct</span> enable_if<span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">using</span> type <span class="token operator">=</span> T<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token operator">></span>
<span class="token keyword">using</span> enable_if_t <span class="token operator">=</span> <span class="token keyword">typename</span> enable_if<span class="token operator">&lt;</span>B<span class="token punctuation">,</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// c++14：别名而已，可以少写一个type</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个元函数是一个类型萃取(Type Trait)，在模板的第一个参数B为true的时候，它的type成员会返回一个类型：如果没有第二个模板参数，返回类型是默认的void，否则，返回的是其第二个参数的类型。如果参数B为false的时候，其成员类型是未定义的，根据SFINAE机制，编译期会忽略包含该std::enable_if_t&lt;&gt;表达式的模板。说人话：</p><p>意思就是我们可以设立一个条件，当条件满足的时候，就让编译器生成这个函数实例，否则忽略它。非常方便！<strong>我们只要在我们的add接口实现2上去用这个工具判断输入的模板实参是不是容器类型就行了，如果是容器类型，那么就实例化这个函数模板，如果不是，则忽略它。</strong></p><p>那么问题就变成了怎么去判断输入类型是不是容器类型。我们可以简单的认为一个类中如果有迭代器，并且具有begin()或者end()这样的成员方法，那么这就是一个容器类型（当然并不严谨，因为stack和queue中并没有迭代器，这里只是作为一个例子，并不考虑这种情况，严谨点的也可以单独将stack和queue拎出来做特化处理即可，问题都不大）。</p><p>我们可以利用成员探测技术（Detecting Members）来让编译器在自己去探测一个类型是否具有迭代器成员和begin()成员。我们可以写出下面这种元函数代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 判断类型否是一个容器类型的元函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span>
<span class="token keyword">struct</span> is_container_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 普通版本</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 偏特化版本</span>
<span class="token keyword">struct</span> is_container_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span>
<span class="token operator">:</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::void_t也是一种利用SFINAE机制实现的元函数，它的一种可能的实现如下所示（参考cppreference）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token keyword">using</span> void_t <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它就是一个别名模板（alias template），是void类型的一个别名，但是它的模板参数是一个可变参数，这同时也是一个可变参数模板（variable template）。这个元函数的意思是它可以接收任意个类型作为模板参数，编译器会在实参替换阶段检查看你输入的每个类型能否被替换成功，如果替换失败，编译器会忽略这个模板。</p><p>回到我们这个判断类型否是一个容器类型的元函数里，如果模板参数T1和T2中含有iterator类型，并且有begin()函数，那么std::void_t中的模板参数可以被替换成功，从而void_t类型就成了void的别名，进一步的编译器会选择is_container_type这个模板类的偏特化版本。注意这里偏特化的版本继承了std::true_type这个类（这是个语法糖），这个类里面有个编译期布尔常量value，其值为true。</p><p>如果模板参数T1和T2中没有iterator类型或者没有begin()函数，那么std::void_t中模板参数会替换失败，但是由于SFINAE，编译器不会报错，此时编译器会选择is_container_type这个模板类的普通版本，这个普通版本继承了std::false_type这个类，这里类里面的编译期布尔常量value的值为false。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_container_type<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">>></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, 打印1</span>
    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_container_type<span class="token operator">&lt;</span>B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">>></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印0</span>
    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_container_type<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印0</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以把这个判断类型的元函数与std::enable_if_t结合在一起来对类型做一些限制，从而可以帮助编译器排除一些模板，选择正确的模板。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

<span class="token comment" spellcheck="true">// 判断类型否是一个容器类型的元函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span>
<span class="token keyword">struct</span> is_container_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 普通版本</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 偏特化版本</span>
<span class="token keyword">struct</span> is_container_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span>
<span class="token operator">:</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>
         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_container_type<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">>></span><span class="token operator">::</span>value<span class="token punctuation">,</span> Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> 
<span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// #接口实现2</span>
<span class="token punctuation">{</span>
    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现2上</span>

   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>
   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>
   <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，由于B类型不是容器类型，编译器会匹配到接口实现1上</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题解决！现在我们可以让B<t>这种自定义的模板类的数据在调用add接口的时候不再匹配到接口实现1上去了。这就是SFINAE机制的强大威力。</t></p><p>但是对于接口的提供者来说，这还远远不够，因为你永远不知道用户在调用这个接口的时候会传进去个什么玩意，我们必须对输入的类型做一些限制：a. 比如我们这里的接口实现1中，我们不能允许两个不支持加法操作的类型数据传进来，b. 同样在接口实现2中，我们不能允许两个异型容器进行加法操作。</p><p>针对条件a，我们仿照仿照上面的方法可以写出判断两个类型是否支持加法的元函数，针对b，我们可以写出判断两个容器类型是否是同型容器的元函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 判断两个类型是否支持加法的元函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span>
<span class="token keyword">struct</span> is_add_supported_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 如果支持加法，is_add_supported_type继承的value = 1</span>
<span class="token keyword">struct</span> is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">::</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 判断两个容器是否是相同类型容器的元函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span>
         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token operator">></span>
<span class="token keyword">struct</span> is_same_container_type
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> value <span class="token operator">=</span> std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 测试</span>
    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_add_supported_type<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印1</span>
    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">>></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, 打印0，两个容器不支持直接加</span>
    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_same_container_type<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ok, 打印1</span>
    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>is_same_container_type<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token punctuation">,</span> std<span class="token operator">::</span>list<span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ok, 打印0, vector和list不是同型容器</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里的判断两个容器是否是同型容器的元函数中用到了std::is_same_v，这个元函数属于预测型萃取，可以用来判断两个类型是否相同，其源码为：（参考cppreference）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span>
<span class="token keyword">struct</span> is_same <span class="token operator">:</span> std<span class="token operator">::</span>false_type <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">struct</span> is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token operator">:</span> std<span class="token operator">::</span>true_type <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span> <span class="token operator">></span>
<span class="token keyword">inline</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> is_same_v <span class="token operator">=</span> is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// c++ 17</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们利用上面所写的两个元函数来改进我们的接口：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 判断两个类型是否支持加法的元函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span>
<span class="token keyword">struct</span> is_add_supported_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 如果支持加法，is_add_supported_type继承的value = 1</span>
<span class="token keyword">struct</span> is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">::</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> 
<span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

<span class="token comment" spellcheck="true">// 判断类型否是一个容器类型的元函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span>
<span class="token keyword">struct</span> is_container_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 普通版本</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 偏特化版本</span>
<span class="token keyword">struct</span> is_container_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span>
<span class="token operator">:</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 判断两个容器是否是相同类型容器的元函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span>
         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token operator">></span>
<span class="token keyword">struct</span> is_same_container_type
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> value <span class="token operator">=</span> std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>
         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_container_type<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">>></span><span class="token operator">::</span>value <span class="token operator">&amp;&amp;</span> is_same_container_type<span class="token operator">&lt;</span>Container1<span class="token punctuation">,</span> Container2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> 
<span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// #接口实现2</span>
<span class="token punctuation">{</span>
    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">int</span> a0 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
   <span class="token keyword">float</span> b0 <span class="token operator">=</span> <span class="token number">20.2</span><span class="token punctuation">;</span>
   <span class="token keyword">auto</span> c0 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0<span class="token punctuation">,</span> b0 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, a0 和 b0是可加的</span>

   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现2上</span>

   B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2<span class="token punctuation">;</span>
   B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b2<span class="token punctuation">;</span>
   <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok，匹配到接口实现1上</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写到这里发现这个接口已经像那么回事了，但是还是存在问题，因为我们针对容器类型的函数模板中，使用了emplace_back这个函数，不幸的是并不是所有的容器类型里面都支持这个函数，比如std::set，std::map里面只有insert方法。我们需要根据容器类型里有没有emplace_back函数来区分处理。这时候，可以先写一个判断类型中是否有emplace_back方法的元函数，然后利用<strong>编译期if</strong>来分别做处理：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 判断类型中是否有emplace_back成员的元函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span>
<span class="token keyword">struct</span> has_emplace_back_method <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> has_emplace_back_method<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token operator">:</span> std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// # 改进后的接口实现2</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>
         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_container_type<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">>></span><span class="token operator">::</span>value <span class="token operator">&amp;&amp;</span> is_same_container_type<span class="token operator">&lt;</span>Container1<span class="token punctuation">,</span> Container2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> 
<span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// </span>
<span class="token punctuation">{</span>
    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 编译期if，由于我们事先已经约束了Container1和Container2是同型容器，因此只要判断一个就行</span>
        <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 测试</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>

    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> b2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 也可以支持了</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译期if是在c++17标准之后引入的东西，与std::enable_if其实非常类似，其原理也是利用了SFINAE机制，在某些时候甚至可以和std::enable_if互换着用。比如这里如果不用编译期if表达式的话，我们可以再写一个针对具有insert方法的容器类型的重载函数模板，通过std::enable_if来控制编译器选择哪个模板来实例化。</p><p>编译期if的好处是可以根据条件来启用或禁止某些特定语句，而不用像std::enable_if一样重新写一个模板，此外它的可读性更好一些。</p><p>当我们觉得这个函数接口已经写完了的时候，又发现了重大的问题，我们这个接口虽然对容器类型的数据很好的支持了，但是对数组却不支持，好家伙，这是万万不能行的。不过问题其实不大，我们只要对数组类型的数据整一个特化的版本就好了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N1<span class="token punctuation">,</span> <span class="token keyword">int</span> N2<span class="token operator">></span>
<span class="token keyword">struct</span> min_val <span class="token comment" spellcheck="true">// 元函数：求两个数中的最小值</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> value <span class="token operator">=</span> N1 <span class="token operator">&lt;</span> N2 <span class="token operator">?</span> N1 <span class="token operator">:</span> N2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 元函数：求两个数中的最大值</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">max_val</span><span class="token punctuation">(</span> <span class="token keyword">int</span> N1<span class="token punctuation">,</span> <span class="token keyword">int</span> N2 <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 常量表达式,C++14</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> N1 <span class="token operator">></span> N2 <span class="token operator">?</span> N1 <span class="token operator">:</span> N2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 针对数组类型的模板特化</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">int</span> N1<span class="token punctuation">,</span>
         <span class="token keyword">typename</span> T2<span class="token punctuation">,</span> <span class="token keyword">int</span> N2<span class="token operator">></span>
std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span>
<span class="token function">add</span><span class="token punctuation">(</span> <span class="token function">T1</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">T2</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span>N2<span class="token punctuation">]</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 注意这里要用static修饰要返回用结果变量，不然你返回一个临时变量的指针，运行时会出错</span>
    <span class="token keyword">static</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span><span class="token function">max_val</span><span class="token punctuation">(</span> N1<span class="token punctuation">,</span> N2 <span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> min_val<span class="token operator">&lt;</span>N1<span class="token punctuation">,</span> N2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N1<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 处理剩余的元素</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N2<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回数组退化后的指针(注意c++是不允许返回数组类型的)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>min_val和max_val是典型的值元编程技巧，可以用来在编译期间进行值计算。其中常量表达式可读性更好一些。</p><p>到这里，我们的add接口才算是写完了，现在将完整的代码贴在下面供大家参考：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> MY_ADD_H</span>
<span class="token macro property">#<span class="token directive keyword">define</span> MY_ADD_H</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span>

<span class="token comment" spellcheck="true">// 判断两个类型是否支持加法的元函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span>
<span class="token keyword">struct</span> is_add_supported_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 如果支持加法，is_add_supported_type继承的value = 1</span>
<span class="token keyword">struct</span> is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">::</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> 
<span class="token function">add</span><span class="token punctuation">(</span> T1 a<span class="token punctuation">,</span> T2 b <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// #接口实现1</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

<span class="token comment" spellcheck="true">// 判断类型否是一个容器类型的元函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span>
<span class="token keyword">struct</span> is_container_type <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 普通版本</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span> <span class="token comment" spellcheck="true">// 偏特化版本</span>
<span class="token keyword">struct</span> is_container_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span>
<span class="token operator">:</span>std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 判断两个容器是否是相同类型容器的元函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span>
         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token operator">></span>
<span class="token keyword">struct</span> is_same_container_type
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> value <span class="token operator">=</span> std<span class="token operator">::</span>is_same_v<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 判断类型中是否有emplace_back成员的元函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">>></span>
<span class="token keyword">struct</span> has_emplace_back_method <span class="token operator">:</span> std<span class="token operator">::</span>false_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> has_emplace_back_method<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token operator">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> <span class="token operator">:</span> std<span class="token operator">::</span>true_type<span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// # 改进后的接口实现2</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T1<span class="token punctuation">,</span>
         <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_container_type<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">>></span><span class="token operator">::</span>value <span class="token operator">&amp;&amp;</span> is_same_container_type<span class="token operator">&lt;</span>Container1<span class="token punctuation">,</span> Container2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">>></span> 
<span class="token function">add</span><span class="token punctuation">(</span> Container1<span class="token operator">&lt;</span>T1<span class="token operator">></span> a<span class="token punctuation">,</span> Container2<span class="token operator">&lt;</span>T2<span class="token operator">></span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// </span>
<span class="token punctuation">{</span>
    Container1<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">></span> ret<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> a_iter <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span><span class="token punctuation">,</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 编译期if，由于我们事先已经约束了Container1和Container2是同型容器，因此只要判断一个就行</span>
        <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token operator">+</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> a_iter <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> a_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>a_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的数据</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> b_iter <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b_iter <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span> has_emplace_back_method<span class="token operator">&lt;</span>Container1<span class="token operator">&lt;</span>T1<span class="token operator">>></span><span class="token operator">::</span>value <span class="token punctuation">)</span> ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> ret<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token operator">*</span>b_iter <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span> N1<span class="token punctuation">,</span> <span class="token keyword">int</span> N2<span class="token operator">></span>
<span class="token keyword">struct</span> min_val <span class="token comment" spellcheck="true">// 元函数：求两个数中的最小值</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> value <span class="token operator">=</span> N1 <span class="token operator">&lt;</span> N2 <span class="token operator">?</span> N1 <span class="token operator">:</span> N2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 元函数：求两个数中的最大值</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">max_val</span><span class="token punctuation">(</span> <span class="token keyword">int</span> N1<span class="token punctuation">,</span> <span class="token keyword">int</span> N2 <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 常量表达式,C++14</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> N1 <span class="token operator">></span> N2 <span class="token operator">?</span> N1 <span class="token operator">:</span> N2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 针对数组类型的模板特化版本</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">int</span> N1<span class="token punctuation">,</span>
         <span class="token keyword">typename</span> T2<span class="token punctuation">,</span> <span class="token keyword">int</span> N2<span class="token operator">></span>
std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>is_add_supported_type<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span>
<span class="token function">add</span><span class="token punctuation">(</span> <span class="token function">T1</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">T2</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span>N2<span class="token punctuation">]</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span>declval<span class="token operator">&lt;</span>T2<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span><span class="token function">max_val</span><span class="token punctuation">(</span> N1<span class="token punctuation">,</span> N2 <span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> min_val<span class="token operator">&lt;</span>N1<span class="token punctuation">,</span> N2<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N1<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 处理剩余的元素</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N2<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回数组退化后的指针</span>
<span class="token punctuation">}</span>

<span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"my_add.h"</span></span>

<span class="token keyword">struct</span> A
<span class="token punctuation">{</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">A</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a_ <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span> a_ <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    A <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> A<span class="token operator">&amp;</span> rhs <span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">A</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>a <span class="token operator">+</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> B
<span class="token punctuation">{</span>
        <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token function">B</span><span class="token punctuation">(</span> <span class="token keyword">const</span> T b_ <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">b</span><span class="token punctuation">(</span> b_ <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

        B <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> B rhs <span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token comment" spellcheck="true">// 加法运算符重载1</span>
        <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">B</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>
        <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span> <span class="token keyword">const</span> B<span class="token operator">&lt;</span>U<span class="token operator">></span> rhs <span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token comment" spellcheck="true">// 加法运算符重载2 </span>
        <span class="token punctuation">{</span>
                <span class="token keyword">return</span> B<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>b <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意这里让编译器去决定加法之后的模板参数类型是什么</span>
        <span class="token punctuation">}</span>

        T b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a0 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">float</span> b0 <span class="token operator">=</span> <span class="token number">2.1</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> c0 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0<span class="token punctuation">,</span> b0 <span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>c0<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印3.1</span>

    A <span class="token function">a1</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b1</span><span class="token punctuation">(</span> <span class="token number">20</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> c1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1<span class="token punctuation">,</span> b1 <span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>c1<span class="token punctuation">.</span>a<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印30</span>

    B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a2</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> B<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> <span class="token function">b2</span><span class="token punctuation">(</span> <span class="token number">22.2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> c2 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a2<span class="token punctuation">,</span> b2 <span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>c2<span class="token punctuation">.</span>b<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印30.2</span>

    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a0_vec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b0_vec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> c0_vec <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0_vec<span class="token punctuation">,</span> b0_vec <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印2, 4, 6, 4</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> c0_vec <span class="token punctuation">)</span> std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>val<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a0_set <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> b0_set <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> c0_set <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0_set<span class="token punctuation">,</span> b0_set <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印2, 4, 6, 4</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> c0_set <span class="token punctuation">)</span> std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>val<span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>

    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">a1_vec</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token function">b1_vec</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> c1_vec <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1_vec<span class="token punctuation">,</span> b1_vec <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>

    <span class="token keyword">int</span> a0_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> b0_array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> c0_array <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a0_array<span class="token punctuation">,</span> b0_array <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok, 打印2, 4, 6, 4</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>c0_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span> 

    A a1_array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    A b1_array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> c1_array <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span> a1_array<span class="token punctuation">,</span> b1_array <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上就是我们为了实现一个范型的add接口所做的全部工作，当然了可以发现template那写的一坨阅读性非常差，所以在C++20版本中添加了新的特性: concept和require，赞美20。</p></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/13357/"><div class="card-image"><img src="/medias/featureimages/23.jpg" class="responsive-img" alt="Cpp中的memory order"> <span class="card-title">Cpp中的memory order</span></div></a><div class="card-content article-content"><div class="summary block-with-text">复杂又不复杂</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-04-01 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></span></div></div><div class="card-action article-tags"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/7859/"><div class="card-image"><img src="/medias/featureimages/16.jpg" class="responsive-img" alt="深入理解Linux网络学习笔记(三)"> <span class="card-title">深入理解Linux网络学习笔记(三)</span></div></a><div class="card-content article-content"><div class="summary block-with-text">内核和用户进程协作之epoll</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-04-01 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-category">计算机网络</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="chip bg-color">计算机网络</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><span class="chip bg-color">源码阅读</span></a></div></div></div></div></article></div><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">755.5k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script></body></html>