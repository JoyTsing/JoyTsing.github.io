<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Gcc编译的背后, joytsing blog"><meta name="description" content="前言在linux下写代码时，使用gcc只需要输入gcc a.c -o a就将代码编译好了，这背后做了些什么，在学习了下一学期的《编译原理》则不难理解，一般来说高级语言程序编译的过程只需要：预处理、编译、汇编、链接。gcc在后台实际上也经历了"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>Gcc编译的背后 | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/16.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">Gcc编译的背后</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/C/" class="post-category">C</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2020-12-04</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-03-21</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 9.5k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 40 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在linux下写代码时，使用gcc只需要输入<code>gcc a.c -o a</code>就将代码编译好了，这背后做了些什么，在学习了下一学期的《编译原理》则不难理解，一般来说高级语言程序编译的过程只需要：预处理、编译、汇编、链接。gcc在后台实际上也经历了这几个过程，通过<code>-v</code>参数就可以查看它的编译细节，想要看某个具体的编译过程，则可以分别使用<code>-E</code>,<code>-S</code>,<code>-c</code>,<code>-o</code>,对应的后台工具分别为<code>cpp</code>,<code>ccl</code>,<code>as</code>,<code>ld</code>。</p><p>下面将逐步分析这几个过程以及相关的内容，比如语法检查，代码调试，汇编语言等待。</p><a id="more"></a><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>预处理过程主要是C语言编译器执行各种预处理命令，编译的基本过程(词法分析、语法分析)之前需要先对源代码中头文件的包含、宏定义的扩展、条件编译等命令先行处理，其中以<code>#define</code>,<code>#include</code>,<code>#ifdef ... #endif</code>这三类最为常见，其中<code>#define</code>除了可以单独使用来设置一些常量之外，还可以配合<code>#ifdef ... #endif</code>使用来控制代码块的编译与否，同时也可以避免同一个头文件多次包含，而<code>#include</code>则比较简单，<code>&lt;&gt;</code>或者’” “‘包含头文件即可。下面介绍几个和预处理相关的几个简单内容。</p><h3 id="打印出预处理之后的结果"><a href="#打印出预处理之后的结果" class="headerlink" title="打印出预处理之后的结果"></a>打印出预处理之后的结果</h3><p><code>$ gcc -E hello.c</code></p><p>这样可以看到源代码中各种预处理命令是如何被解释的，从而方便理解和查错。</p><h3 id="在命令行定义宏"><a href="#在命令行定义宏" class="headerlink" title="在命令行定义宏"></a>在命令行定义宏</h3><p><code>$gcc -Dmacro hello.c</code></p><p>这个等同于在文件的开头定义宏，即 <code>#define macro</code>，但是在命令行定义更灵活。例如，在源代码中有这些语句。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifdef</span> DEBUG</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this code is for debugging\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果编译时加上 <code>-DDEBUG</code> 选项，那么编译器就会把 <code>printf</code> 所在的行编译进目标代码，从而方便地跟踪该位置的某些程序状态。这样 <code>-DDEBUG</code> 就可以当作一个调试开关，编译时加上它就可以用来打印调试信息，发布时则可以通过去掉该编译选项把调试信息去掉。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>编译之前C 语言编译器会进行词法分析、语法分析，接着会把源代码翻译成中间语言，即汇编语言。如果想看到这个中间结果，可以用 <code>gcc -S</code>。需要提到的是，诸如 Shell 等解释语言也会经历一个词法分析和语法分析的阶段，不过之后并不会进行“翻译”，而是“解释”，边解释边执行。</p><p>把源代码翻译成汇编语言，实际上是编译的整个过程中的第一个阶段，之后的阶段和汇编语言的开发过程没有什么区别。这个阶段涉及到对源代码的词法分析、语法检查（通过 <code>-std</code> 指定遵循哪个标准），并根据优化 <code>（-O）</code> 要求进行翻译成汇编语言的动作。</p><h3 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h3><p>如果只是想要检查语法化可以使用<code>gcc</code>的<code>-fsyntax-only</code>选项，如果是要让代码有更好的可移植性的话则尽量少使用<code>gcc</code>的扩展特性，并结合<code>-std</code>让源代码遵循某个标准：</p><pre class="line-numbers language-c"><code class="language-c">$ cat hello<span class="token punctuation">.</span>c
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
$ gcc <span class="token operator">-</span>fsyntax<span class="token operator">-</span>only hello<span class="token punctuation">.</span>c
hello<span class="token punctuation">.</span>c<span class="token punctuation">:</span> In function ‘main’<span class="token punctuation">:</span>
hello<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span> error<span class="token punctuation">:</span> expected ‘<span class="token punctuation">;</span>’ before ‘<span class="token keyword">return</span>’
$ vim hello<span class="token punctuation">.</span>c
$ cat hello<span class="token punctuation">.</span>c
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
$ gcc <span class="token operator">-</span>std<span class="token operator">=</span>c89 <span class="token operator">-</span>pedantic<span class="token operator">-</span>errors hello<span class="token punctuation">.</span>c    #默认情况下，gcc是允许在程序中间声明变量的，但是turboc就不支持
hello<span class="token punctuation">.</span>c<span class="token punctuation">:</span> In function ‘main’<span class="token punctuation">:</span>
hello<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span> error<span class="token punctuation">:</span> ISO C90 forbids mixed declarations and code<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><p>检测语法后就是翻译，<code>gcc</code>提供了<code>-O</code>选项供不同运行平台的用户产生优化过的汇编代码。</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -o hello hello.c         <span class="token comment" spellcheck="true"># 采用默认选项，不优化</span>
$ gcc -O2 -o hello2 hello.c    <span class="token comment" spellcheck="true"># 优化等次是2</span>
$ gcc -Os -o hellos hello.c    <span class="token comment" spellcheck="true"># 优化目标代码的大小</span>
$ <span class="token function">ls</span> -S hello hello2 hellos    <span class="token comment" spellcheck="true"># 可以看到，hellos 比较小, hello2 比较大</span>
hello2  hello  hellos
$ <span class="token function">time</span> ./hello
hello, world

real    0m0.001s
user    0m0.000s
sys     0m0.000s
$ <span class="token function">time</span> ./hello2     <span class="token comment" spellcheck="true"># 可能是代码比较少的缘故，执行效率看上去不是很明显</span>
hello, world

real    0m0.001s
user    0m0.000s
sys     0m0.000s

$ <span class="token function">time</span> ./hellos     <span class="token comment" spellcheck="true"># 虽然目标代码小了，但是执行效率慢了些</span>
hello, world

real    0m0.002s
user    0m0.000s
sys     0m0.000s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="生成汇编语言程序"><a href="#生成汇编语言程序" class="headerlink" title="生成汇编语言程序"></a>生成汇编语言程序</h2><p>通过<code>-S</code>选项来查看编译出来的汇编语言程序。</p><pre class="line-numbers language-assembly"><code class="language-assembly">$ gcc -S hello.c  # 默认输出是hello.s，可自己指定，输出到屏幕`-o -`，输出到其他文件`-o file`
$ cat hello.s
cat hello.s
        .file   "hello.c"
        .section        .rodata
.LC0:
        .string "hello, world"
        .text
.globl main
        .type   main, @function
main:
        leal    4(%esp), %ecx
        andl    $-16, %esp
        pushl   -4(%ecx)
        pushl   %ebp
        movl    %esp, %ebp
        pushl   %ecx
        subl    $4, %esp
        movl    $.LC0, (%esp)
        call    puts
        movl    $0, %eax
        addl    $4, %esp
        popl    %ecx
        popl    %ebp
        leal    -4(%ecx), %esp
        ret
        .size   main, .-main
        .ident  "GCC: (GNU) 4.1.3 20070929 (prerelease) (Ubuntu 4.1.2-16ubuntu2)"
        .section        .note.GNU-stack,"",@progbits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的用的汇编的语法格式是<code>AT&amp;T</code>的格式,在使用IDE进行DEBUG的时候是可以更改的(如使用的<code>CLion</code>)</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><h3 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h3><p>汇编实际上是作为翻译为与机器代码的中间桥梁，汇编还不可以实际上运行,想要查看中间的汇编代码可以通过<code>gcc -c</code>来查看。</p><h3 id="生成目标代码"><a href="#生成目标代码" class="headerlink" title="生成目标代码"></a>生成目标代码</h3><p>下面来演示一下通过<code>gcc -c</code>和<code>as</code>来产生目标代码：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">file</span> hello.s
hello.s: ASCII assembler program text
$ gcc -c hello.s   <span class="token comment" spellcheck="true">#用gcc把汇编语言编译成目标代码</span>
$ <span class="token function">file</span> hello.o     <span class="token comment" spellcheck="true">#file命令用来查看文件类型，目标代码可重定位的(relocatable)，</span>
                   <span class="token comment" spellcheck="true">#需要通过ld进行进一步链接成可执行程序(executable)和共享库(shared)</span>
hello.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, not stripped
$ as -o hello.o hello.s        <span class="token comment" spellcheck="true">#用as把汇编语言编译成目标代码</span>
$ <span class="token function">file</span> hello.o
hello.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>gcc</code>和<code>as</code>默认产生的目标代码都是ELF格式的，这里讨论一下ELF格式的目标代码。</p><blockquote><p>什么是ELF(format of Executable and Linking Format (ELF) files)?</p><p>是UNIX系统实验室（<a href="https://baike.baidu.com/item/USL">USL</a>）作为应用程序二进制接口（Application Binary Interface，<a href="https://baike.baidu.com/item/ABI">ABI</a>）而开发和发布的，也是<a href="https://baike.baidu.com/item/Linux/27050">Linux</a>的主要可执行文件格式。</p><p>1999年，被86open项目选为<a href="https://baike.baidu.com/item/x86架构/7470217">x86架构</a>上的类<a href="https://baike.baidu.com/item/Unix操作系统">Unix操作系统</a>的二进制文件标准格式，用来取代<a href="https://baike.baidu.com/item/COFF">COFF</a>。因其可扩展性与灵活性，也可应用在其它处理器、计算机系统架构的操作系统上</p><p>ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。实际上，一个文件中不一定包含全部内容，而且它们的位置也未必如同所示这样安排，只有ELF头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。</p></blockquote><h3 id="ELF文件初次接触"><a href="#ELF文件初次接触" class="headerlink" title="ELF文件初次接触"></a>ELF文件初次接触</h3><p>目标代码此时发现不再是普通的文本格式，无法通过文本编辑器来浏览。如果想了解更多目标代码的细节，区分 <code>relocatable</code>（可重定位）、<code>executable</code>（可执行）、<code>shared libarary</code>（共享库）的不同，我们得设法了解目标代码的组织方式和相关的阅读和分析工具。下面主要介绍这部分内容。</p><blockquote><p>BFD is a package which allows applications to use the same routines(例行程序) to operate on object files whatever the object file format. A new object file format can be supported simply by creating a new BFD back end and adding it to the library.</p></blockquote><p><code>binutils</code>（GNU Binary Utilities）的很多工具都采用这个库来操作目标文件，这类工具有 <code>objdump</code>，<code>objcopy</code>，<code>nm</code>，<code>strip</code> 等（当然，我们也可以利用它。如果深入了解ELF格式，那么通过它来分析和编写 Virus 程序将会更加方便），不过另外一款非常优秀的分析工具 <code>readelf</code> 并不是基于这个库，所以也应该可以直接用 <code>elf.h</code> 头文件中定义的相关结构来操作 ELF 文件。</p><p>下面将通过这些辅助工具（主要是 <code>readelf</code> 和 <code>objdump</code>），结合 ELF 手册来分析它们。将依次介绍 ELF 文件的结构和三种不同类型 ELF 文件的区别。</p><h3 id="ELF文件的结构"><a href="#ELF文件的结构" class="headerlink" title="ELF文件的结构"></a>ELF文件的结构</h3><pre class="line-numbers language-bash"><code class="language-bash">ELF Header<span class="token punctuation">(</span>ELF文件头<span class="token punctuation">)</span>
Program Headers Table<span class="token punctuation">(</span>程序头表，实际上叫段表好一些，用于描述可执行文件和可共享库<span class="token punctuation">)</span>
Section 1
Section 2
Section 3
<span class="token punctuation">..</span>.
Section Headers Table<span class="token punctuation">(</span>节区头部表，用于链接可重定位文件成可执行文件或共享库<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于可重定位文件，程序头是可选的，而对于可执行文件和共享库文件（动态链接库），节区表则是可选的。可以分别通过 <code>readelf</code> 文件的 <code>-h</code>，<code>-l</code> 和 <code>-S</code> 参数查看 ELF 文件头（ELF Header）、程序头部表（Program Headers Table，段表）和节区表（Section Headers Table）。</p><p>文件头说明了文件的类型，大小，运行平台，节区数目等。</p><h3 id="三种不同类型ELF文件比较"><a href="#三种不同类型ELF文件比较" class="headerlink" title="三种不同类型ELF文件比较"></a>三种不同类型ELF文件比较</h3><p>先来通过文件头看看不同ELF的类型。为了说明问题，先来几段代码吧。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* myprintf.c */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">myprintf</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/* test.h -- myprintf function declaration */</span>

<span class="token macro property">#<span class="token directive keyword">ifndef</span> _TEST_H_</span>
<span class="token macro property">#<span class="token directive keyword">define</span> _TEST_H_</span>

<span class="token keyword">void</span> <span class="token function">myprintf</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token comment" spellcheck="true">/* test.c */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"test.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">myprintf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面通过这几段代码来演示通过 <code>readelf -h</code> 参数查看 ELF 的不同类型。期间将演示如何创建动态链接库（即可共享文件）、静态链接库，并比较它们的异同。</p><p>编译产生两个目标文件 <code>myprintf.o</code> 和 <code>test.o</code>，它们都是可重定位文件（REL）：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -c myprintf.c test.c
$ readelf -h test.o <span class="token operator">|</span> <span class="token function">grep</span> Type
  Type:                              REL <span class="token punctuation">(</span>Relocatable file<span class="token punctuation">)</span>
$ readelf -h myprintf.o <span class="token operator">|</span> <span class="token function">grep</span> Type
  Type:                              REL <span class="token punctuation">(</span>Relocatable file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据目标代码链接产生可执行文件，这里的文件类型是可执行的(EXEC)：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -o <span class="token function">test</span> myprintf.o test.o
$ readelf -h <span class="token function">test</span> <span class="token operator">|</span> <span class="token function">grep</span> Type
  Type:                              EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>用 <code>ar</code> 命令创建一个静态链接库，静态链接库也是可重定位文件（REL）：</p><pre class="line-numbers language-bash"><code class="language-bash">$ ar rcsv libmyprintf.a myprintf.o
$ readelf -h libmyprintf.a <span class="token operator">|</span> <span class="token function">grep</span> Type
  Type:                              REL <span class="token punctuation">(</span>Relocatable file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可见，静态链接库和可重定位文件类型一样，它们之间唯一不同是前者可以是多个可重定位文件的“集合”。</p><p>静态链接库可直接链接（只需库名，不要前面的 <code>lib</code>），也可用 <code>-l</code> 参数，<code>-L</code> 指定库搜索路径。</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -o <span class="token function">test</span> test.o -lmyprintf -L./<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译产生动态链接库，并支持 <code>major</code> 和 <code>minor</code> 版本号，动态链接库类型为 <code>DYN</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -Wall myprintf.o -shared -Wl,-soname,libmyprintf.so.0 -o libmyprintf.so.0.0
$ <span class="token function">ln</span> -sf libmyprintf.so.0.0 libmyprintf.so.0
$ <span class="token function">ln</span> -sf libmyprintf.so.0 libmyprintf.so
$ readelf -h libmyprintf.so <span class="token operator">|</span> <span class="token function">grep</span> Type
  Type:                              DYN <span class="token punctuation">(</span>Shared object file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态链接库编译时和静态链接库类似：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -o <span class="token function">test</span> test.o -lmyprintf -L./<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是执行时需要指定动态链接库的搜索路径，把 <code>LD_LIBRARY_PATH</code> 设为当前目录，指定 <code>test</code> 运行时的动态链接库搜索路径：</p><pre class="line-numbers language-bash"><code class="language-bash">$ LD_LIBRARY_PATH<span class="token operator">=</span>./ ./test
$ gcc -static -o <span class="token function">test</span> test.o -lmyprintf -L./<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在不指定 <code>-static</code> 时会优先使用动态链接库，指定时则阻止使用动态链接库，这时会把所有静态链接库文件加入到可执行文件中，使得执行文件很大，而且加载到内存以后会浪费内存空间，因此不建议这么做。</p><p>经过上面的演示基本可以看出它们之间的不同：</p><ul><li>可重定位文件本身不可以运行，仅仅是作为可执行文件、静态链接库（也是可重定位文件）、动态链接库的 “组件”。</li><li>静态链接库和动态链接库本身也不可以执行，作为可执行文件的“组件”，它们两者也不同，前者也是可重定位文件（只不过可能是多个可重定位文件的集合），并且在链接时加入到可执行文件中去。</li><li>而动态链接库在链接时，库文件本身并没有添加到可执行文件中，只是在可执行文件中加入了该库的名字等信息，以便在可执行文件运行过程中引用库中的函数时由动态链接器去查找相关函数的地址，并调用它们。</li></ul><p>从这个意义上说，动态链接库本身也具有可重定位的特征，含有可重定位的信息。对于什么是重定位？如何进行静态符号和动态符号的重定位，我们将在链接部分和后面一节中介绍。</p><h3 id="ELF主体：节区"><a href="#ELF主体：节区" class="headerlink" title="ELF主体：节区"></a>ELF主体：节区</h3><p>下面来看看 ELF 文件的主体内容：节区（Section)。</p><p>ELF 文件具有很大的灵活性，它通过文件头组织整个文件的总体结构，通过节区表 (Section Headers Table）和程序头（Program Headers Table 或者叫段表）来分别描述可重定位文件和可执行文件。但不管是哪种类型，它们都需要它们的主体，即各种节区。</p><p>在可重定位文件中，节区表描述的就是各种节区本身；而在可执行文件中，程序头描述的是由各个节区组成的段（Segment），以便程序运行时动态装载器知道如何对它们进行内存映像，从而方便程序加载和运行。</p><p>下面先来看看一些常见的节区，而关于这些节区（Section）如何通过重定位构成不同的段（Segments），以及有哪些常规的段，我们将在链接部分进一步介绍。</p><p>可以通过 <code>readelf -S</code> 查看 ELF 的节区，先来看看可重定位文件的节区信息，通过节区表来查看：</p><p>默认编译好 <code>myprintf.c</code>，将产生一个可重定位的文件 <code>myprintf.o</code>，这里通过 <code>myprintf.o</code> 的节区表查看节区信息。</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -c myprintf.c
$ readelf -S myprintf.o
There are 11 section headers, starting at offset 0xc0:

Section Headers:
  <span class="token punctuation">[</span>Nr<span class="token punctuation">]</span> Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  <span class="token punctuation">[</span> 0<span class="token punctuation">]</span>                   NULL            00000000 000000 000000 00      0   0  0
  <span class="token punctuation">[</span> 1<span class="token punctuation">]</span> .text             PROGBITS        00000000 000034 000018 00  AX  0   0  4
  <span class="token punctuation">[</span> 2<span class="token punctuation">]</span> .rel.text         REL             00000000 000334 000010 08      9   1  4
  <span class="token punctuation">[</span> 3<span class="token punctuation">]</span> .data             PROGBITS        00000000 00004c 000000 00  WA  0   0  4
  <span class="token punctuation">[</span> 4<span class="token punctuation">]</span> .bss              NOBITS          00000000 00004c 000000 00  WA  0   0  4
  <span class="token punctuation">[</span> 5<span class="token punctuation">]</span> .rodata           PROGBITS        00000000 00004c 00000e 00   A  0   0  1
  <span class="token punctuation">[</span> 6<span class="token punctuation">]</span> .comment          PROGBITS        00000000 00005a 000012 00      0   0  1
  <span class="token punctuation">[</span> 7<span class="token punctuation">]</span> .note.GNU-stack   PROGBITS        00000000 00006c 000000 00      0   0  1
  <span class="token punctuation">[</span> 8<span class="token punctuation">]</span> .shstrtab         STRTAB          00000000 00006c 000051 00      0   0  1
  <span class="token punctuation">[</span> 9<span class="token punctuation">]</span> .symtab           SYMTAB          00000000 000278 0000a0 10     10   8  4
  <span class="token punctuation">[</span>10<span class="token punctuation">]</span> .strtab           STRTAB          00000000 000318 00001a 00      0   0  1
Key to Flags:
  W <span class="token punctuation">(</span>write<span class="token punctuation">)</span>, A <span class="token punctuation">(</span>alloc<span class="token punctuation">)</span>, X <span class="token punctuation">(</span>execute<span class="token punctuation">)</span>, M <span class="token punctuation">(</span>merge<span class="token punctuation">)</span>, S <span class="token punctuation">(</span>strings<span class="token punctuation">)</span>
  I <span class="token punctuation">(</span>info<span class="token punctuation">)</span>, L <span class="token punctuation">(</span>link order<span class="token punctuation">)</span>, G <span class="token punctuation">(</span>group<span class="token punctuation">)</span>, x <span class="token punctuation">(</span>unknown<span class="token punctuation">)</span>
  O <span class="token punctuation">(</span>extra OS processing required<span class="token punctuation">)</span> o <span class="token punctuation">(</span>OS specific<span class="token punctuation">)</span>, p <span class="token punctuation">(</span>processor specific<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>objdump -d</code> 可看反编译结果，用 <code>-j</code> 选项可指定需要查看的节区：</p><pre class="line-numbers language-bash"><code class="language-bash">$ objdump -d -j .text   myprintf.o
myprintf.o:     <span class="token function">file</span> <span class="token function">format</span> elf32-i386

Disassembly of section .text:

00000000 <span class="token operator">&lt;</span>myprintf<span class="token operator">></span>:
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   83 ec 08                sub    <span class="token variable">$0x8</span>,%esp
   6:   83 ec 0c                sub    <span class="token variable">$0xc</span>,%esp
   9:   68 00 00 00 00          push   <span class="token variable">$0x0</span>
   e:   e8 fc ff ff ff          call   f <span class="token operator">&lt;</span>myprintf+0xf<span class="token operator">></span>
  13:   83 c4 10                add    <span class="token variable">$0x10</span>,%esp
  16:   c9                      leave
  17:   c3                      ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>-r</code> 选项可以看到有关重定位的信息，这里有两部分需要重定位：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -r myprintf.o

Relocation section <span class="token string">'.rel.text'</span> at offset 0x334 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0000000a  00000501 R_386_32          00000000   .rodata
0000000f  00000902 R_386_PC32        00000000   puts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>.rodata</code> 节区包含只读数据，即我们要打印的 <code>hello, world!</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .rodata myprintf.o

Hex dump of section <span class="token string">'.rodata'</span><span class="token keyword">:</span>
  0x00000000 68656c6c 6f2c2077 6f726c64 2100     hello, world<span class="token operator">!</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>没有找到 <code>.data</code> 节区, 它应该包含一些初始化的数据：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .data myprintf.o

Section <span class="token string">'.data'</span> has no data to dump.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也没有 <code>.bss</code> 节区，它应该包含一些未初始化的数据，程序默认初始为 0：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .bss       myprintf.o

Section <span class="token string">'.bss'</span> has no data to dump.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>.comment</code> 是一些注释，可以看到是是 <code>Gcc</code> 的版本信息</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .comment myprintf.o

Hex dump of section <span class="token string">'.comment'</span><span class="token keyword">:</span>
  0x00000000 00474343 3a202847 4e552920 342e312e .GCC: <span class="token punctuation">(</span>GNU<span class="token punctuation">)</span> 4.1.
  0x00000010 3200                                2.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>.note.GNU-stack</code> 这个节区也没有内容：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .note.GNU-stack myprintf.o

Section <span class="token string">'.note.GNU-stack'</span> has no data to dump.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>.shstrtab</code> 包括所有节区的名字：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .shstrtab myprintf.o

Hex dump of section <span class="token string">'.shstrtab'</span><span class="token keyword">:</span>
  0x00000000 002e7379 6d746162 002e7374 72746162 <span class="token punctuation">..</span>symtab<span class="token punctuation">..</span>strtab
  0x00000010 002e7368 73747274 6162002e 72656c2e <span class="token punctuation">..</span>shstrtab<span class="token punctuation">..</span>rel.
  0x00000020 74657874 002e6461 7461002e 62737300 text<span class="token punctuation">..</span>data<span class="token punctuation">..</span>bss.
  0x00000030 2e726f64 61746100 2e636f6d 6d656e74 .rodata<span class="token punctuation">..</span>comment
  0x00000040 002e6e6f 74652e47 4e552d73 7461636b <span class="token punctuation">..</span>note.GNU-stack
  0x00000050 00                                  <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>符号表 <code>.symtab</code> 包括所有用到的相关符号信息，如函数名、变量名，可用 <code>readelf</code> 查看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -symtab myprintf.o

Symbol table <span class="token string">'.symtab'</span> contains 10 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS myprintf.c
     2: 00000000     0 SECTION LOCAL  DEFAULT    1
     3: 00000000     0 SECTION LOCAL  DEFAULT    3
     4: 00000000     0 SECTION LOCAL  DEFAULT    4
     5: 00000000     0 SECTION LOCAL  DEFAULT    5
     6: 00000000     0 SECTION LOCAL  DEFAULT    7
     7: 00000000     0 SECTION LOCAL  DEFAULT    6
     8: 00000000    24 FUNC    GLOBAL DEFAULT    1 myprintf
     9: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND puts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串表 <code>.strtab</code> 包含用到的字符串，包括文件名、函数名、变量名等：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -x .strtab myprintf.o

Hex dump of section <span class="token string">'.strtab'</span><span class="token keyword">:</span>
  0x00000000 006d7970 72696e74 662e6300 6d797072 .myprintf.c.mypr
  0x00000010 696e7466 00707574 7300              intf.puts.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上表可以看出，对于可重定位文件，会包含这些基本节区 <code>.text</code>, <code>.rel.text</code>, <code>.data</code>, <code>.bss</code>, <code>.rodata</code>, <code>.comment</code>, <code>.note.GNU-stack</code>, <code>.shstrtab</code>, <code>.symtab</code> 和 <code>.strtab</code>。</p><h3 id="汇编语言文件中的节区表述"><a href="#汇编语言文件中的节区表述" class="headerlink" title="汇编语言文件中的节区表述"></a>汇编语言文件中的节区表述</h3><p>为了进一步理解这些节区和源代码的关系，这里来看一看 <code>myprintf.c</code> 产生的汇编代码。</p><pre class="line-numbers language-assembly"><code class="language-assembly">$ gcc -S myprintf.c
$ cat myprintf.s
        .file   "myprintf.c"
        .section        .rodata
.LC0:
        .string "hello, world!"
        .text
.globl myprintf
        .type   myprintf, @function
myprintf:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $8, %esp
        subl    $12, %esp
        pushl   $.LC0
        call    puts
        addl    $16, %esp
        leave
        ret
        .size   myprintf, .-myprintf
        .ident  "GCC: (GNU) 4.1.2"
        .section        .note.GNU-stack,"",@progbits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是不是可以从中看出可重定位文件中的那些节区和汇编语言代码之间的关系？在上面的可重定位文件，可以看到有一个可重定位的节区，即 <code>.rel.text</code>，它标记了两个需要重定位的项，<code>.rodata</code> 和 <code>puts</code>。这个节区将告诉编译器这两个信息在链接或者动态链接的过程中需要重定位， 具体如何重定位？将根据重定位项的类型，比如上面的 <code>R_386_32</code> 和 <code>R_386_PC32</code>。</p><p>到这里，对可重定位文件应该有了一个基本的了解，下面将介绍什么是可重定位，可重定位文件到底是如何被链接生成可执行文件和动态链接库的，这个过程除了进行一些符号的重定位外，还进行了哪些工作呢？</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h3><p>重定位是将符号引用与符号定义进行链接的过程。因此链接是处理可重定位文件，把它们的各种符号引用和符号定义转换为可执行文件中的合适信息（一般是虚拟内存地址）的过程。</p><p>链接又分为静态链接和动态链接，前者是程序开发阶段程序员用 <code>ld</code>（<code>gcc</code> 实际上在后台调用了 <code>ld</code>）静态链接器手动链接的过程，而动态链接则是程序运行期间系统调用动态链接器（<code>ld-linux.so</code>）自动链接的过程。</p><p>比如，如果链接到可执行文件中的是静态链接库 <code>libmyprintf.a</code>，那么 <code>.rodata</code> 节区在链接后需要被重定位到一个绝对的虚拟内存地址，以便程序运行时能够正确访问该节区中的字符串信息。而对于 <code>puts</code> 函数，因为它是动态链接库 <code>libc.so</code> 中定义的函数，所以会在程序运行时通过动态符号链接找出 <code>puts</code> 函数在内存中的地址，以便程序调用该函数。在这里主要讨论静态链接过程，动态链接过程见之后更新的章节。</p><p>静态链接过程主要是把可重定位文件依次读入，分析各个文件的文件头，进而依次读入各个文件的节区，并计算各个节区的虚拟内存位置，对一些需要重定位的符号进行处理，设定它们的虚拟内存地址等，并最终产生一个可执行文件或者是动态链接库。这个链接过程是通过 <code>ld</code> 来完成的，<code>ld</code> 在链接时使用了一个链接脚本（<code>linker script</code>），该链接脚本处理链接的具体细节。</p><p>由于静态符号链接过程非常复杂，特别是计算符号地址的过程。这里主要介绍可重定位文件中的节区（节区表描述的）和可执行文件中段（程序头描述的）的对应关系以及 <code>gcc</code> 编译时采用的一些默认链接选项。</p><h3 id="可执行文件的段：节区重排"><a href="#可执行文件的段：节区重排" class="headerlink" title="可执行文件的段：节区重排"></a>可执行文件的段：节区重排</h3><p>下面先来看看可执行文件的节区信息，通过程序头（段表）来查看，为了比较，先把 <code>test.o</code> 的节区表也列出：</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -S test.o
There are 10 section headers, starting at offset 0xb4:

Section Headers:
  <span class="token punctuation">[</span>Nr<span class="token punctuation">]</span> Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  <span class="token punctuation">[</span> 0<span class="token punctuation">]</span>                   NULL            00000000 000000 000000 00      0   0  0
  <span class="token punctuation">[</span> 1<span class="token punctuation">]</span> .text             PROGBITS        00000000 000034 000024 00  AX  0   0  4
  <span class="token punctuation">[</span> 2<span class="token punctuation">]</span> .rel.text         REL             00000000 0002ec 000008 08      8   1  4
  <span class="token punctuation">[</span> 3<span class="token punctuation">]</span> .data             PROGBITS        00000000 000058 000000 00  WA  0   0  4
  <span class="token punctuation">[</span> 4<span class="token punctuation">]</span> .bss              NOBITS          00000000 000058 000000 00  WA  0   0  4
  <span class="token punctuation">[</span> 5<span class="token punctuation">]</span> .comment          PROGBITS        00000000 000058 000012 00      0   0  1
  <span class="token punctuation">[</span> 6<span class="token punctuation">]</span> .note.GNU-stack   PROGBITS        00000000 00006a 000000 00      0   0  1
  <span class="token punctuation">[</span> 7<span class="token punctuation">]</span> .shstrtab         STRTAB          00000000 00006a 000049 00      0   0  1
  <span class="token punctuation">[</span> 8<span class="token punctuation">]</span> .symtab           SYMTAB          00000000 000244 000090 10      9   7  4
  <span class="token punctuation">[</span> 9<span class="token punctuation">]</span> .strtab           STRTAB          00000000 0002d4 000016 00      0   0  1
Key to Flags:
  W <span class="token punctuation">(</span>write<span class="token punctuation">)</span>, A <span class="token punctuation">(</span>alloc<span class="token punctuation">)</span>, X <span class="token punctuation">(</span>execute<span class="token punctuation">)</span>, M <span class="token punctuation">(</span>merge<span class="token punctuation">)</span>, S <span class="token punctuation">(</span>strings<span class="token punctuation">)</span>
  I <span class="token punctuation">(</span>info<span class="token punctuation">)</span>, L <span class="token punctuation">(</span>link order<span class="token punctuation">)</span>, G <span class="token punctuation">(</span>group<span class="token punctuation">)</span>, x <span class="token punctuation">(</span>unknown<span class="token punctuation">)</span>
  O <span class="token punctuation">(</span>extra OS processing required<span class="token punctuation">)</span> o <span class="token punctuation">(</span>OS specific<span class="token punctuation">)</span>, p <span class="token punctuation">(</span>processor specific<span class="token punctuation">)</span>
$ gcc -o <span class="token function">test</span> test.o myprintf.o
$ readelf -l <span class="token function">test</span>

Elf <span class="token function">file</span> <span class="token function">type</span> is EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span>
Entry point 0x80482b0
There are 7 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4
  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1
      <span class="token punctuation">[</span>Requesting program interpreter: /lib/ld-linux.so.2<span class="token punctuation">]</span>
  LOAD           0x000000 0x08048000 0x08048000 0x0047c 0x0047c R E 0x1000
  LOAD           0x00047c 0x0804947c 0x0804947c 0x00104 0x00108 RW  0x1000
  DYNAMIC        0x000490 0x08049490 0x08049490 0x000c8 0x000c8 RW  0x4
  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4

 Section to Segment mapping:
  Segment Sections<span class="token punctuation">..</span>.
   00
   01     .interp
   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r
          .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame
   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss
   04     .dynamic
   05     .note.ABI-tag
   06<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可发现，<code>test</code> 和 <code>test.o</code>，<code>myprintf.o</code> 相比，多了很多节区，如 <code>.interp</code> 和 <code>.init</code> 等。另外，上表也给出了可执行文件的如下几个段（Segment）：</p><ul><li><code>PHDR</code>: 给出了程序表自身的大小和位置，不能出现一次以上。</li><li><code>INTERP</code>: 因为程序中调用了 <code>puts</code>（在动态链接库中定义），使用了动态链接库，因此需要动态装载器／链接器（<code>ld-linux.so</code>）</li><li><code>LOAD</code>: 包括程序的指令，<code>.text</code> 等节区都映射在该段，只读（R）</li><li><code>LOAD</code>: 包括程序的数据，<code>.data</code>,<code>.bss</code> 等节区都映射在该段，可读写（RW）</li><li><code>DYNAMIC</code>: 动态链接相关的信息，比如包含有引用的动态链接库名字等信息</li><li><code>NOTE</code>: 给出一些附加信息的位置和大小</li><li><code>GNU_STACK</code>: 这里为空，应该是和GNU相关的一些信息</li></ul><p>这里的段可能包括之前的一个或者多个节区，也就是说经过链接之后原来的节区被重排了，并映射到了不同的段，这些段将告诉系统应该如何把它加载到内存中。</p><h3 id="链接背后的故事"><a href="#链接背后的故事" class="headerlink" title="链接背后的故事"></a>链接背后的故事</h3><p>从上表中，通过比较可执行文件 <code>test</code> 中拥有的节区和可重定位文件（<code>test.o</code> 和 <code>myprintf.o</code>）中拥有的节区后发现，链接之后多了一些之前没有的节区，这些新的节区来自哪里？它们的作用是什么呢？先来通过 <code>gcc -v</code> 看看它的后台链接过程。</p><p>把可重定位文件链接成可执行文件：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -v -o <span class="token function">test</span> test.o myprintf.o
Reading specs from /usr/lib/gcc/i486-slackware-linux/4.1.2/specs
Target: i486-slackware-linux
Configured with: <span class="token punctuation">..</span>/gcc-4.1.2/configure --prefix<span class="token operator">=</span>/usr --enable-shared
--enable-languages<span class="token operator">=</span>ada,c,c++,fortran,java,objc --enable-threads<span class="token operator">=</span>posix
--enable-__cxa_atexit --disable-checking --with-gnu-ld --verbose
--with-arch<span class="token operator">=</span>i486 --target<span class="token operator">=</span>i486-slackware-linux --host<span class="token operator">=</span>i486-slackware-linux
Thread model: posix
gcc version 4.1.2
 /usr/libexec/gcc/i486-slackware-linux/4.1.2/collect2 --eh-frame-hdr -m
elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o <span class="token function">test</span>
/usr/lib/gcc/i486-slackware-linux/4.1.2/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/crt1.o
/usr/lib/gcc/i486-slackware-linux/4.1.2/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/crti.o
/usr/lib/gcc/i486-slackware-linux/4.1.2/crtbegin.o
-L/usr/lib/gcc/i486-slackware-linux/4.1.2
-L/usr/lib/gcc/i486-slackware-linux/4.1.2
-L/usr/lib/gcc/i486-slackware-linux/4.1.2/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/i486-slackware-linux/lib
-L/usr/lib/gcc/i486-slackware-linux/4.1.2/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span> test.o myprintf.o -lgcc
--as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed
/usr/lib/gcc/i486-slackware-linux/4.1.2/crtend.o
/usr/lib/gcc/i486-slackware-linux/4.1.2/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/crtn.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述演示看出，<code>gcc</code> 在链接了我们自己的目标文件 <code>test.o</code> 和 <code>myprintf.o</code> 之外，还链接了 <code>crt1.o</code>，<code>crtbegin.o</code> 等额外的目标文件，难道那些新的节区就来自这些文件？</p><h3 id="用-ld-完成链接过程"><a href="#用-ld-完成链接过程" class="headerlink" title="用 ld 完成链接过程"></a>用 ld 完成链接过程</h3><p>另外 <code>gcc</code> 在进行了相关配置（<code>./configure</code>）后，调用了 <code>collect2</code>，却并没有调用 <code>ld</code>，通过查找 <code>gcc</code> 文档中和 <code>collect2</code> 相关的部分发现 <code>collect2</code> 在后台实际上还是去寻找 <code>ld</code> 命令的。为了理解 <code>gcc</code> 默认链接的后台细节，这里直接把 <code>collect2</code> 替换成 <code>ld</code>，并把一些路径换成绝对路径或者简化，得到如下的 <code>ld</code> 命令以及执行的效果。</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld --eh-frame-hdr \
-m elf_i386 \
-dynamic-linker /lib/ld-linux.so.2 \
-o <span class="token function">test</span> \
/usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-slackware-linux/4.1.2/crtbegin.o \
test.o myprintf.o \
-L/usr/lib/gcc/i486-slackware-linux/4.1.2 -L/usr/i486-slackware-linux/lib -L/usr/lib/ \
-lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed \
/usr/lib/gcc/i486-slackware-linux/4.1.2/crtend.o /usr/lib/crtn.o
$ ./test
hello, world<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不出所料，它完美地运行了。下面通过 <code>ld</code> 的手册（<code>man ld</code>）来分析一下这几个参数：</p><ul><li><p><code>--eh-frame-hdr</code></p><p>要求创建一个 <code>.eh_frame_hdr</code> 节区(貌似目标文件test中并没有这个节区，所以不关心它)。</p></li><li><p><code>-m elf_i386</code></p><p>这里指定不同平台上的链接脚本，可以通过 <code>--verbose</code> 命令查看脚本的具体内容，如 <code>ld -m elf_i386 --verbose</code>，它实际上被存放在一个文件中（<code>/usr/lib/ldscripts</code> 目录下），我们可以去修改这个脚本，具体如何做？请参考 <code>ld</code> 的手册。在后面我们将简要提到链接脚本中是如何预定义变量的，以及这些预定义变量如何在我们的程序中使用。需要提到的是，如果不是交叉编译，那么无须指定该选项。</p></li><li><p>-dynamic-linker /lib/ld-linux.so.2</p><p>指定动态装载器/链接器，即程序中的 <code>INTERP</code> 段中的内容。动态装载器/链接器负责链接有可共享库的可执行文件的装载和动态符号链接。</p></li><li><p>-o test</p><p>指定输出文件，即可执行文件名的名字</p></li><li><p>/usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-slackware-linux/4.1.2/crtbegin.o</p><p>链接到 <code>test</code> 文件开头的一些内容，这里实际上就包含了 <code>.init</code> 等节区。<code>.init</code> 节区包含一些可执行代码，在 <code>main</code> 函数之前被调用，以便进行一些初始化操作，在 C++ 中完成构造函数功能。</p></li><li><p>test.o myprintf.o</p><p>链接我们自己的可重定位文件</p></li><li><p><code>-L/usr/lib/gcc/i486-slackware-linux/4.1.2 -L/usr/i486-slackware-linux/lib -L/usr/lib/ \ -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed</code></p><p>链接 <code>libgcc</code> 库和 <code>libc</code> 库，后者定义有我们需要的 <code>puts</code> 函数</p></li><li><p>/usr/lib/gcc/i486-slackware-linux/4.1.2/crtend.o /usr/lib/crtn.o</p><p>链接到 <code>test</code> 文件末尾的一些内容，这里实际上包含了 <code>.fini</code> 等节区。<code>.fini</code> 节区包含了一些可执行代码，在程序退出时被执行，作一些清理工作，在 C++ 中完成析构造函数功能。我们往往可以通过 <code>atexit</code> 来注册那些需要在程序退出时才执行的函数。</p></li></ul><h3 id="C-构造与析构：crtbegin-o和crtend-o"><a href="#C-构造与析构：crtbegin-o和crtend-o" class="headerlink" title="C++构造与析构：crtbegin.o和crtend.o"></a>C++构造与析构：crtbegin.o和crtend.o</h3><p>对于 <code>crtbegin.o</code> 和 <code>crtend.o</code> 这两个文件，貌似完全是用来支持 C++ 的构造和析构工作的，所以可以不链接到我们的可执行文件中，链接时把它们去掉看看，</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o <span class="token function">test</span> \
  /usr/lib/crt1.o /usr/lib/crti.o test.o myprintf.o \
  -L/usr/lib -lc /usr/lib/crtn.o    <span class="token comment" spellcheck="true">#后面发现不用链接libgcc，也不用--eh-frame-hdr参数</span>
$ readelf -l <span class="token function">test</span>

Elf <span class="token function">file</span> <span class="token function">type</span> is EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span>
Entry point 0x80482b0
There are 7 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4
  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1
      <span class="token punctuation">[</span>Requesting program interpreter: /lib/ld-linux.so.2<span class="token punctuation">]</span>
  LOAD           0x000000 0x08048000 0x08048000 0x003ea 0x003ea R E 0x1000
  LOAD           0x0003ec 0x080493ec 0x080493ec 0x000e8 0x000e8 RW  0x1000
  DYNAMIC        0x0003ec 0x080493ec 0x080493ec 0x000c8 0x000c8 RW  0x4
  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4

 Section to Segment mapping:
  Segment Sections<span class="token punctuation">..</span>.
   00
   01     .interp
   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r
          .rel.dyn .rel.plt .init .plt .text .fini .rodata
   03     .dynamic .got .got.plt .data
   04     .dynamic
   05     .note.ABI-tag
   06
$ ./test
hello, world<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完全可以工作，而且发现 <code>.ctors</code>（保存着程序中全局构造函数的指针数组）, <code>.dtors</code>（保存着程序中全局析构函数的指针数组）,<code>.jcr</code>（未知）,<code>.eh_frame</code> 节区都没有了，所以 <code>crtbegin.o</code> 和 <code>crtend.o</code> 应该包含了这些节区。</p><h3 id="初始化与退出清理：crti-o-和-crtn-o"><a href="#初始化与退出清理：crti-o-和-crtn-o" class="headerlink" title="初始化与退出清理：crti.o 和 crtn.o"></a>初始化与退出清理：crti.o 和 crtn.o</h3><p>而对于另外两个文件 <code>crti.o</code> 和 <code>crtn.o</code>，通过 <code>readelf -S</code> 查看后发现它们都有 <code>.init</code> 和 <code>.fini</code> 节区，如果我们不需要让程序进行一些初始化和清理工作呢？是不是就可以不链接这个两个文件？试试看。</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld  -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o <span class="token function">test</span> \
      /usr/lib/crt1.o test.o myprintf.o -L/usr/lib/ -lc
/usr/lib/libc_nonshared.a<span class="token punctuation">(</span>elf-init.oS<span class="token punctuation">)</span>: In <span class="token keyword">function</span> `__libc_csu_init<span class="token string">':
(.text+0x25): undefined reference to `_init'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>貌似不行，竟然有人调用了 <code>__libc_csu_init</code> 函数，而这个函数引用了 <code>_init</code>。这两个符号都在哪里呢？</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -s /usr/lib/crt1.o <span class="token operator">|</span> <span class="token function">grep</span> __libc_csu_init
    18: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND __libc_csu_init
$ readelf -s /usr/lib/crti.o <span class="token operator">|</span> <span class="token function">grep</span> _init
    17: 00000000     0 FUNC    GLOBAL DEFAULT    5 _init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>竟然是 <code>crt1.o</code> 调用了 <code>__libc_csu_init</code> 函数，而该函数却引用了我们没有链接的 <code>crti.o</code> 文件中定义的 <code>_init</code> 符号。这样的话不链接 <code>crti.o</code> 和 <code>crtn.o</code> 文件，不用 <code>crt1.o</code> ，看看 <code>gcc</code> 额外链接进去的最后一个文件 <code>crt1.o</code> 到底干什么</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld  -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o \
      <span class="token function">test</span> test.o myprintf.o -L/usr/lib/ -lc
ld: warning: cannot <span class="token function">find</span> entry symbol _start<span class="token punctuation">;</span> defaulting to 00000000080481a4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样却说没有找到入口符号 <code>_start</code>，难道 <code>crt1.o</code> 中定义了这个符号？不过它给默认设置了一个地址，只是个警告，说明 <code>test</code> 已经生成，不管怎样先运行看看再说。</p><pre class="line-numbers language-bash"><code class="language-bash">$ ./test
hello, world<span class="token operator">!</span>
Segmentation fault<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>貌似程序运行完了，不过结束时冒出个段错误？可能是程序结束时有问题，用 <code>gdb</code> 调试看看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -g -c test.c myprintf.c <span class="token comment" spellcheck="true">#产生目标代码, 非交叉编译，不指定-m也可链接，所以下面可去掉-m</span>
$ ld -dynamic-linker /lib/ld-linux.so.2 -o <span class="token function">test</span> \
     test.o myprintf.o -L/usr/lib -lc
ld: warning: cannot <span class="token function">find</span> entry symbol _start<span class="token punctuation">;</span> defaulting to 00000000080481d8
$ ./test
hello, world<span class="token operator">!</span>
Segmentation fault
$ gdb -q ./test
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l
1       <span class="token comment" spellcheck="true">#include "test.h"</span>
2
3       int main<span class="token punctuation">(</span><span class="token punctuation">)</span>
4       <span class="token punctuation">{</span>
5               myprintf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
6               <span class="token keyword">return</span> 0<span class="token punctuation">;</span>
7       <span class="token punctuation">}</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> 7      <span class="token comment" spellcheck="true">#在程序的末尾设置一个断点</span>
Breakpoint 1 at 0x80481bf: <span class="token function">file</span> test.c, line 7.
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> r            <span class="token comment" spellcheck="true">#程序都快结束了都没问题，怎么会到最后出个问题呢？</span>
Starting program: /mnt/hda8/Temp/c/program/test
hello, world<span class="token operator">!</span>

Breakpoint 1, main <span class="token punctuation">(</span><span class="token punctuation">)</span> at test.c:7
7       <span class="token punctuation">}</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n        <span class="token comment" spellcheck="true">#单步执行看看，怎么下面一条指令是0x00000001，肯定是程序退出以后出了问题</span>
0x00000001 <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n        <span class="token comment" spellcheck="true">#诶，当然找不到边了，都跑到0x00000001了</span>
Cannot <span class="token function">find</span> bounds of current <span class="token keyword">function</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x00000001 <span class="token keyword">in</span> ?? <span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原来是这么回事，估计是 <code>return 0</code> 返回之后出问题了，看看它的汇编去。</p><pre class="line-numbers language-assembly"><code class="language-assembly">$ gcc -S test.c #产生汇编代码
$ cat test.s
...
        call    myprintf
        movl    $0, %eax
        addl    $4, %esp
        popl    %ecx
        popl    %ebp
        leal    -4(%ecx), %esp
        ret
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后面就这么几条指令，难不成 <code>ret</code> 返回有问题，不让它 <code>ret</code> 返回，把 <code>return</code> 改成 <code>_exit</code> 直接进入内核退出。</p><pre class="line-numbers language-bash"><code class="language-bash">$ vim test.c
$ <span class="token function">cat</span> test.c    <span class="token comment" spellcheck="true">#就把return语句修改成_exit了。</span>
<span class="token comment" spellcheck="true">#include "test.h"</span>
<span class="token comment" spellcheck="true">#include &lt;unistd.h> /* _exit */</span>

int main<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    myprintf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _exit<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
$ gcc -g -c test.c myprintf.c
$ ld -dynamic-linker /lib/ld-linux.so.2 -o <span class="token function">test</span> test.o myprintf.o -L/usr/lib -lc
ld: warning: cannot <span class="token function">find</span> entry symbol _start<span class="token punctuation">;</span> defaulting to 00000000080481d8
$ ./test    <span class="token comment" spellcheck="true">#竟然好了，再看看汇编有什么不同</span>
hello, world<span class="token operator">!</span>
$ gcc -S test.c
$ <span class="token function">cat</span> test.s    <span class="token comment" spellcheck="true">#貌似就把ret指令替换成了_exit函数调用，直接进入内核，让内核处理了，那为什么ret有问题呢？</span>
<span class="token punctuation">..</span>.
        call    myprintf
        subl    <span class="token variable">$12</span>, %esp
        pushl   <span class="token variable">$0</span>
        call    _exit
<span class="token punctuation">..</span>.
$ gdb -q ./test    <span class="token comment" spellcheck="true">#把代码改回去（改成return 0;），再调试看看调用main函数返回时的下一条指令地址eip</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l
warning: Source <span class="token function">file</span> is <span class="token function">more</span> recent than executable.
1       <span class="token comment" spellcheck="true">#include "test.h"</span>
2
3       int main<span class="token punctuation">(</span><span class="token punctuation">)</span>
4       <span class="token punctuation">{</span>
5               myprintf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
6               <span class="token keyword">return</span> 0<span class="token punctuation">;</span>
7       <span class="token punctuation">}</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> 5
Breakpoint 1 at 0x80481b5: <span class="token function">file</span> test.c, line 5.
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> 7
Breakpoint 2 at 0x80481bc: <span class="token function">file</span> test.c, line 7.
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> r
Starting program: /mnt/hda8/Temp/c/program/test

Breakpoint 1, main <span class="token punctuation">(</span><span class="token punctuation">)</span> at test.c:5
5               myprintf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x/8x <span class="token variable">$esp</span>
0xbf929510:     0xbf92953c      0x080481a4      0x00000000      0xb7eea84f
0xbf929520:     0xbf92953c      0xbf929534      0x00000000      0x00000001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现 <code>0x00000001</code> 刚好是之前调试时看到的程序返回后的位置，即 <code>eip</code>，说明程序在初始化时，这个 <code>eip</code> 就是错误的。为什么呢？因为根本没有链接进初始化的代码，而是在编译器自己给我们，初始化了程序入口即 <code>00000000080481d8</code>，也就是说，没有人调用 <code>main</code>，<code>main</code> 不知道返回哪里去，所以，我们直接让 <code>main</code> 结束时进入内核调用 <code>_exit</code> 而退出则不会有问题。</p><p>通过上面的演示和解释发现只要把return语句修改为 <code>_exit</code> 语句，程序即使不链接任何额外的目标代码都可以正常运行（原因是不链接那些额外的文件时相当于没有进行初始化操作，如果在程序的最后执行 <code>ret</code> 汇编指令，程序将无法获得正确的 <code>eip</code>，从而无法进行后续的动作）。但是为什么会有“找不到 <code>_start</code> 符号”的警告呢？通过 <code>readelf -s</code> 查看 <code>crt1.o</code> 发现里头有这个符号，并且 <code>crt1.o</code> 引用了 <code>main</code> 这个符号，是不是意味着会从 <code>_start</code> 进入 <code>main</code> 呢？是不是程序入口是 <code>_start</code>，而并非 <code>main</code> 呢？</p><h3 id="C-语言程序真正的入口"><a href="#C-语言程序真正的入口" class="headerlink" title="C 语言程序真正的入口"></a>C 语言程序真正的入口</h3><p>先来看看刚才提到的链接器的默认链接脚本（<code>ld -m elf_386 --verbose</code>），它告诉我们程序的入口（entry）是 <code>_start</code>，而一个可执行文件必须有一个入口地址才能运行，所以这就是说明了为什么 <code>ld</code> 一定要提示我们 “_start找不到”，找不到以后就给默认设置了一个地址。</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld --verbose  <span class="token operator">|</span> <span class="token function">grep</span> ^ENTRY    <span class="token comment" spellcheck="true">#非交叉编译，可不用-m参数；ld默认找_start入口，并不是main</span>
ENTRY<span class="token punctuation">(</span>_start<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原来是这样，程序的入口（entry）竟然不是 <code>main</code> 函数，而是 <code>_start</code>。那干脆把汇编里头的 <code>main</code> 给改掉算了，看行不行？</p><p>先生成汇编 <code>test.s</code>：</p><pre class="line-numbers language-c"><code class="language-c">$ cat test<span class="token punctuation">.</span>c
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"test.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>     </span><span class="token comment" spellcheck="true">/* _exit */</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">myprintf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
$ gcc <span class="token operator">-</span>S test<span class="token punctuation">.</span>c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后把汇编中的 <code>main</code> 改为 <code>_start</code>，即改程序入口为 <code>_start</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sed</span> -i -e <span class="token string">"s#main#_start#g"</span> test.s
$ gcc -c test.s myprintf.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>重新链接，发现果然没问题了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld -dynamic-linker /lib/ld-linux.so.2 -o <span class="token function">test</span> test.o myprintf.o -L/usr/lib/ -lc
$ ./test
hello, world<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>_start</code> 竟然是真正的程序入口，那在有 <code>main</code> 的情况下呢？为什么在 <code>_start</code> 之后能够找到 <code>main</code> 呢？这个看看 alert7 大叔的<a href="http://blog.chinaunix.net/uid-21471835-id-441223.html">Before main 分析</a>吧，这里不再深入介绍。</p><p>总之呢，通过修改程序的 <code>return</code> 语句为 <code>_exit(0)</code> 和修改程序的入口为 <code>_start</code>，我们的代码不链接 <code>gcc</code> 默认链接的那些额外的文件同样可以工作得很好。并且打破了一个学习 C 语言以来的常识：<code>main</code> 函数作为程序的主函数，是程序的入口，实际上则不然。</p><h3 id="链接脚本初次接触"><a href="#链接脚本初次接触" class="headerlink" title="链接脚本初次接触"></a>链接脚本初次接触</h3><p>再补充一点内容，在 <code>ld</code> 的链接脚本中，有一个特别的关键字 <code>PROVIDE</code>，由这个关键字定义的符号是 <code>ld</code> 的预定义字符，我们可以在 C 语言函数中扩展它们后直接使用。这些特别的符号可以通过下面的方法获取，</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld --verbose <span class="token operator">|</span> <span class="token function">grep</span> PROVIDE <span class="token operator">|</span> <span class="token function">grep</span> -v HIDDEN
  PROVIDE <span class="token punctuation">(</span>__executable_start <span class="token operator">=</span> 0x08048000<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">.</span> <span class="token operator">=</span> 0x08048000 + SIZEOF_HEADERS<span class="token punctuation">;</span>
  PROVIDE <span class="token punctuation">(</span>__etext <span class="token operator">=</span> .<span class="token punctuation">)</span><span class="token punctuation">;</span>
  PROVIDE <span class="token punctuation">(</span>_etext <span class="token operator">=</span> .<span class="token punctuation">)</span><span class="token punctuation">;</span>
  PROVIDE <span class="token punctuation">(</span>etext <span class="token operator">=</span> .<span class="token punctuation">)</span><span class="token punctuation">;</span>
  _edata <span class="token operator">=</span> <span class="token keyword">.</span><span class="token punctuation">;</span> PROVIDE <span class="token punctuation">(</span>edata <span class="token operator">=</span> .<span class="token punctuation">)</span><span class="token punctuation">;</span>
  _end <span class="token operator">=</span> <span class="token keyword">.</span><span class="token punctuation">;</span> PROVIDE <span class="token punctuation">(</span>end <span class="token operator">=</span> .<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里面有几个我们比较关心的，第一个是程序的入口地址 <code>__executable_start</code>，另外三个是 <code>etext</code>，<code>edata</code>，<code>end</code>，分别对应程序的代码段（text）、初始化数据（data）和未初始化的数据（bss）（可参考<code>man etext</code>），如何引用这些变量呢？看看这个例子。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* predefinevalue.c */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">extern</span> <span class="token keyword">int</span> __executable_start<span class="token punctuation">,</span> etext<span class="token punctuation">,</span> edata<span class="token punctuation">,</span> end<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"program entry: 0x%x \n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>__executable_start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"etext address(text segment): 0x%x \n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>etext<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"edata address(initilized data): 0x%x \n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>edata<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"end address(uninitilized data): 0x%x \n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，程序链接过程的一些细节都介绍得差不多了。在后续中将主要介绍 ELF 文件的动态符号链接过程。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.ibm.com/developerworks/cn/linux/l-assembly/index.html">Linux 汇编语言开发指南</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/hardware/ppc/assembly/index.html">PowerPC 汇编</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/l-powasm1.html">用于 Power 体系结构的汇编语言</a></li><li><a href="http://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/index.html">Linux 中 x86 的内联汇编</a></li><li>Linux Assembly HOWTO</li><li>Linux Assembly Language Programming</li><li>Guide to Assembly Language Programming in Linux</li><li><a href="http://www.luv.asn.au/overheads/compile.html">An beginners guide to compiling programs under Linux</a></li><li><a href="http://gcc.gnu.org/onlinedocs/gcc-4.2.2/gcc/">gcc manual</a></li><li><a href="http://efrw01.frascati.enea.it/Software/Unix/IstrFTU/cern-cnl-2001-003-25-link.html">A Quick Tour of Compiling, Linking, Loading, and Handling Libraries on Unix</a></li><li><a href="http://www.ibm.com/developerworks/cn/aix/library/au-unixtools.html">Unix 目标文件初探</a></li><li><a href="http://www.xfocus.net/articles/200109/269.html">Before main()分析</a></li><li><a href="http://www.linuxforums.org/forum/linux-kernel/51790-process-viewing-its-own-proc-pid-map-information.html">A Process Viewing Its Own /proc//map Information</a></li><li>UNIX 环境高级编程</li><li>Linux Kernel Primer</li><li><a href="http://www.linuxforums.org/misc/understanding_elf_using_readelf_and_objdump.html">Understanding ELF using readelf and objdump</a></li><li><a href="http://netwinder.osuosl.org/users/p/patb/public_html/elf_relocs.html">Study of ELF loading and relocs</a></li><li>ELF file format and ABI<ul><li><a href="http://refspecs.linuxbase.org/elf/elf.pdf">[1]</a></li><li><a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt">[2]</a></li></ul></li><li>TN05.ELF.Format.Summary.pdf</li><li><a href="http://www.xfocus.net/articles/200105/174.html">ELF文件格式(中文)</a></li><li>关于 GCC 方面的论文，请查看历年的会议论文集<ul><li><a href="http://www.gccsummit.org/2005/2005-GCC-Summit-Proceedings.pdf">2005</a></li><li><a href="http://www.gccsummit.org/2006/2006-GCC-Summit-Proceedings.pdf">2006</a></li></ul></li><li><a href="http://www.faqs.org/docs/Linux-HOWTO/GCC-HOWTO.html">The Linux GCC HOW TO</a></li><li><a href="http://linux.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/elf.html">ELF: From The Programmer’s Perspective</a></li><li><a href="http://www.xxlinux.com/linux/article/development/soft/20070424/8267.html">C/C++ 程序编译步骤详解</a></li><li><a href="http://c-faq-chn.sourceforge.net/ccfaq/index.html">C 语言常见问题集</a></li><li><a href="http://elfhack.whitecell.org/mydocs/use_bfd.txt">使用 BFD 操作 ELF</a></li><li><a href="http://sourceware.org/binutils/docs/bfd/index.html">bfd document</a></li><li><a href="http://blog.chinaunix.net/u/19881/showart_215242.html">UNIX/LINUX 平台可执行文件格式分析</a></li><li><a href="http://www.tinylab.org/linux-assembly-language-quick-start/">Linux 汇编语言快速上手：4大架构一块学</a></li><li>GNU binutils 小结</li></ul></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/10533/"><div class="card-image"><img src="/medias/featureimages/20.jpg" class="responsive-img" alt="记录博客的一次更新"> <span class="card-title">记录博客的一次更新</span></div></a><div class="card-content article-content"><div class="summary block-with-text">记录一次博客的更新已经很久没有写博客了，上一次写博客还是在半年前因为课程要求做读书笔记才记的，这半年来发生了很多事情，我的想法与之前也发生了很大的变化，希望能够从现在开始认认真真读几本书，好好写一下博客，记录一下自己的生活，最后希望自己能够</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-05 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%9D%82%E8%AE%B0/" class="post-category">杂记</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E7%AB%99%E7%82%B9%E7%9B%B8%E5%85%B3/"><span class="chip bg-color">站点相关</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/64955/"><div class="card-image"><img src="/medias/featureimages/18.jpg" class="responsive-img" alt="Linux学习笔记(十)"> <span class="card-title">Linux学习笔记(十)</span></div></a><div class="card-content article-content"><div class="summary block-with-text">df,du与归档压缩等df与dudf显示可用空间，-h用常见的格式显示出大小 du统计文件或者目录的磁盘使用情况，用得比较少。 这些命令通常是在要扩容和挂载时候才使用，配合fdisk -l和lvextend来使用。 tartar 命令</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-11 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Linux/" class="post-category">Linux</a></span></div></div><div class="card-action article-tags"><a href="/tags/Linux/"><span class="chip bg-color">Linux</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0!==window.getSelection&&((""+(n=window.getSelection())).length<Number.parseInt("120")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: JoyTsing<br />文章作者: JoyTsing<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者joytsing所有，请任何形式的转载都请注明出处并在文章评论区处告知。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)))})</script><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">842k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script></body></html>