<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoyTsing</title>
  
  <subtitle>[object Object]</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://joytsing.github.io/"/>
  <updated>2024-03-04T07:26:23.057Z</updated>
  <id>https://joytsing.github.io/</id>
  
  <author>
    <name>JoyTsing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过折叠表达式简化返回值检测</title>
    <link href="https://joytsing.github.io/posts/33498/"/>
    <id>https://joytsing.github.io/posts/33498/</id>
    <published>2024-03-04T07:14:44.000Z</published>
    <updated>2024-03-04T07:26:23.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="返回值检查"><a href="#返回值检查" class="headerlink" title="返回值检查"></a>返回值检查</h2><p>比如在启动服务器或者客户端的时候编写init函数， 此时需要依次去config目录加载对应的配置，log的配置等等，在这个时候如果一行行写的话就会有如下代码：</p><pre class="line-numbers language-c++"><code class="language-c++">error_t result{};result = check1(…);if (result != error_t::ok) {  return result;}result = check2(…);if (result != error_t::ok) {  return result;}result = check3(…);if (result != error_t::ok) {  return result;}result = check4(…);if (result != error_t::ok) {  return result;}return error_t::ok;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽说也可以但是终归是比较丑陋，如果应用折叠表达式的话可以写成如下形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">return</span> <span class="token function">checked_exec</span><span class="token punctuation">(</span>  error_t<span class="token operator">::</span>ok<span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check1</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check2</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check3</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">check4</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的check_exec可以写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> R<span class="token punctuation">,</span>          <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Fn<span class="token operator">></span>R <span class="token function">checked_exec</span><span class="token punctuation">(</span><span class="token keyword">const</span> R<span class="token operator">&amp;</span> expected<span class="token punctuation">,</span>               Fn<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> fn<span class="token punctuation">)</span><span class="token punctuation">{</span>  R result <span class="token operator">=</span> expected<span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>result <span class="token operator">=</span> forward<span class="token operator">&lt;</span>Fn<span class="token operator">></span><span class="token punctuation">(</span>             fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> expected<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，前提是不传入参数，传入参数不同的话就需要额外编写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;返回值检查&quot;&gt;&lt;a href=&quot;#返回值检查&quot; class=&quot;headerlink&quot; title=&quot;返回值检查&quot;&gt;&lt;/a&gt;返回值检查&lt;/h2&gt;&lt;p&gt;比如在启动服务器或者客户端的时候编写init函数， 此时需要依次去config目录加载对应的配置，log的配置等等，
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>vscode CMake Tools 传递命令行参数</title>
    <link href="https://joytsing.github.io/posts/61384/"/>
    <id>https://joytsing.github.io/posts/61384/</id>
    <published>2024-01-20T15:03:02.000Z</published>
    <updated>2024-01-20T15:17:21.433Z</updated>
    
    <content type="html"><![CDATA[<p>vscode调试C++程序时，有时需要给程序传递命令行参数。这么说，如果是用F5去运行的话那么则是另外一套配置配置方法，但现在最近已经习惯了CMake一套工具链，同时懒得跳到命令行里面去打make或者运行脚本。这种时候，通常做法是配置<code>launch.json</code>文件中要调试程序的<code>args</code>字段。但是设置<code>tasks.json</code>和<code>launch.json</code>的方式不如使用CMake Tools插件调试运行程序方便。CMake Tools插件调试运行程序可以在多个cmake的target中切换，省去了写那些配置的繁琐步骤。</p><p><img src="/posts/61384/image-20240120230905008.png" alt></p><h2 id="1-设置方法-设置-cmake-debugConfig-的-args字段"><a href="#1-设置方法-设置-cmake-debugConfig-的-args字段" class="headerlink" title="1. 设置方法: 设置 cmake.debugConfig 的 args字段"></a>1. 设置方法: 设置 cmake.debugConfig 的 args字段</h2><p>注意要是去设置<code>Workspace</code>的<code>settings.json</code>,因为每个项目需要的设置的命令行参数不一样。</p><p>如果设置<code>User</code>的<code>settings.json</code>会对其他项目产生影响。</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"cmake.debugConfig"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"arg1"</span><span class="token punctuation">,</span> <span class="token string">"arg2"</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里只配置了<code>cmake.debugConfig</code>中的<code>args</code>字段，其他字段省去了，因为我们当前只需要设置命令行参数。</p><p>虽然名字叫<code>debugConfig</code>，这里传递的命令行参数在<code>Release</code>和<code>Debug</code>模式下都是有效的。</p><h2 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h2><p>假设<code>main.cpp</code>需要用到命令行参数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> argc <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后直接创建一个.vscode文件夹，创建一个settings.json文件，把上面1中提到的内容加进去就好了。</p><p><img src="/posts/61384/image-20240120230941833.png" alt></p><p>这样用CMake一套就能直接带参数调试或者运行了，同理，想要配置clangd的话也是直接去settings设置就好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vscode调试C++程序时，有时需要给程序传递命令行参数。这么说，如果是用F5去运行的话那么则是另外一套配置配置方法，但现在最近已经习惯了CMake一套工具链，同时懒得跳到命令行里面去打make或者运行脚本。这种时候，通常做法是配置&lt;code&gt;launch.json&lt;/c
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="Tool" scheme="https://JoyTsing.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>贵安，元旦快乐</title>
    <link href="https://joytsing.github.io/posts/53667/"/>
    <id>https://joytsing.github.io/posts/53667/</id>
    <published>2024-01-01T16:54:05.000Z</published>
    <updated>2024-01-01T16:58:55.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="元旦快乐"><a href="#元旦快乐" class="headerlink" title="元旦快乐"></a>元旦快乐</h2><p>2024年伊始，很久没有更新新的博文了，先给大家祝贺一下。在这里顺便说一下本站接下来的计划吧：</p><p>因为这个blog是我大二时候一时兴起搭的，大部分插件什么的也是那会弄的，现在发现已经有很多不能用了，可能之后会有一次大的迭代或者重构吧。毕竟前端这东西还是迭代太快了，这才4年hexo的结构就已经变了个样了，插件统计什么的我估计之前都是靠着缓存在工作，clean之后直接罢工了（笑。</p><p>希望新的一年多多努力，好好奋斗，多读点书（不管是什么样的），做一些有意义的工作，别的想说的都融在那两首歌里面了，愿意听就去听吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;元旦快乐&quot;&gt;&lt;a href=&quot;#元旦快乐&quot; class=&quot;headerlink&quot; title=&quot;元旦快乐&quot;&gt;&lt;/a&gt;元旦快乐&lt;/h2&gt;&lt;p&gt;2024年伊始，很久没有更新新的博文了，先给大家祝贺一下。在这里顺便说一下本站接下来的计划吧：&lt;/p&gt;
&lt;p&gt;因为这个blo
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux下多Clang工具链的踩坑</title>
    <link href="https://joytsing.github.io/posts/19689/"/>
    <id>https://joytsing.github.io/posts/19689/</id>
    <published>2023-12-21T11:21:21.000Z</published>
    <updated>2023-12-21T11:55:43.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>故事是从C++ 17标准说起，在写线程池异步执行的时候发现居然没法使用move移动，然后怀疑到了clang头上，因为发现当我使用C++17标准下的<code>std::invoke_result</code>时直接报错是没有这个函数实现，说明clang版本有点旧了(加上我需要C++20的实现)，然后就开始研究起来clang的更新。</p><p><img src="/posts/19689/2.png" alt></p><h2 id="第一个坑"><a href="#第一个坑" class="headerlink" title="第一个坑"></a>第一个坑</h2><p>首先，因为需要做cmu15445 2023spring的project，在我的环境下安装了全套clang-14的tool-chain，那么问题来了，首先，你直接apt install只能安装到14的版本，其次，如果能安装了，但我需要使用最新的C++标准，但我又想保留老的tool chain怎么办？（可以试一试，如果直接安装的话会把老的版本卸载了）</p><p>首先是安装：我先找到了llvm官网的安装脚本，但又存在一个问题，通过这个安装脚本下载的话速度太慢（是的挂梯子也不行），后来翻找发现果然国内有对应的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/llvm-apt/">镜像源</a>。那么怎么做，长话短说，直接通过脚本安装的话会卸载，这里是手动启用了一部分，即首先信任来自 <a href="https://apt.llvm.org/">llvm</a> 的 PGP 公钥。然后先手动安装clang-17以及clang++-17（或许还有别的，但这两个是肯定有的），在手动安装的情况下因为指定了版本号，所以是不会冲突的（clang-14与clang-17），最重要的部分安装好后通过先前的脚本将完整的tool-chain下载下来（即clang-tidy-17等等）。</p><p>到目前为止没结束，因为还需管理多版本clang，需要通过<code>update-alternatives</code>选择对应版本号，具体怎么用直接搜索该命令就好，最后应该把这3个软件版本设成最新的：clang、clang++、clangd。那么目前多版本算是好了。</p><h2 id="第二个坑"><a href="#第二个坑" class="headerlink" title="第二个坑"></a>第二个坑</h2><p>那么怎么使用多版本呢？如果你不是命令行档（即干啥都坚持在命令行cmake），想要自己多个选择的话，那么此时你打开vscode对应的项目会出现下面的问题<img src="/posts/19689/1.png" alt></p><p>原因很显然，因为我们将对应的默认clang版本更改了，但是理论上说，在vscode上选择对应工具链会切换成对应的版本号，那么为什么？我花了大量时间在.vscode和插件的配置上，但实际上这些都是没用的。上图是我已经正常配置过了的版本，如果你之前使用的话，那么你会发现clang 14和clang17这两个地方的编译器的链接是完全相同的。</p><p>出现这个情况的原因在上文中已经说了，因为我们使用的<code>update-alternatives</code>，做的实际上是帮助我们创建对应的软链接，即：对于<code>clang</code> ，如果我在<code>update-alternatives</code>中把clang版本中的14设为高优先级那么clang链接的就是14，设置的是17就是17。我们需要做的是更改tool chain对应找的工具，也就是不再要之前的软链接（曾经是对的，但不会自动更改）。</p><p><img src="/posts/19689/3.png" alt></p><p>当时思路是正确了，那么怎么更改？在扫描tool chain的时候我注意到他会去一个目录下加载，于是去那个目录：</p><p><img src="/posts/19689/4.png" alt></p><p>把对应的clang14和clang17的tool-chain加上版本号即可，这时候vscode的cmake tool chain也设置好了。以后如果是多环境也是这样即可。</p><h2 id="别的坑"><a href="#别的坑" class="headerlink" title="别的坑"></a>别的坑</h2><p>其实实际上踩的坑不止这些，包括但不限于把公钥全删了导致apt报错等等，但最后终于把vscode下c++的clangd更新，不再给我那些C++17语法报错，总的来说还是指的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;故事是从C++ 17标准说起，在写线程池异步执行的时候发现居然没法使用move移动，然后怀疑到了clang头上，因为发现当我使用C++17标
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>内存分配函数malloc的原理及实现</title>
    <link href="https://joytsing.github.io/posts/8649/"/>
    <id>https://joytsing.github.io/posts/8649/</id>
    <published>2023-12-19T15:41:01.000Z</published>
    <updated>2024-01-01T16:46:29.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是malloc"><a href="#1-什么是malloc" class="headerlink" title="1 什么是malloc"></a>1 什么是malloc</h2><p>在实现malloc之前，先要相对正式地对malloc做一个定义。</p><p>根据标准C库函数的定义，malloc具有如下原型：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：</p><ul><li>malloc分配的内存大小<strong>至少</strong>为size参数所指定的字节数</li><li>malloc的返回值是一个指针，指向一段可用内存的起始地址</li><li>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</li><li>malloc应该尽快完成内存分配并返回（不能使用<a href="http://en.wikipedia.org/wiki/NP-hard">NP-hard</a>的内存分配算法）</li><li>实现malloc时应同时实现内存大小调整和内存释放函数（即realloc和free）</li></ul><p>对于malloc更多的说明可以在命令行中键入以下命令查看：</p><pre><code>man malloc</code></pre><h2 id="2-预备知识"><a href="#2-预备知识" class="headerlink" title="2 预备知识"></a>2 预备知识</h2><p>在实现malloc之前，需要先解释一些Linux系统内存相关的知识。</p><h3 id="2-1-Linux内存管理"><a href="#2-1-Linux内存管理" class="headerlink" title="2.1 Linux内存管理"></a>2.1 Linux内存管理</h3><h4 id="2-1-1-虚拟内存地址与物理内存地址"><a href="#2-1-1-虚拟内存地址与物理内存地址" class="headerlink" title="2.1.1 虚拟内存地址与物理内存地址"></a>2.1.1 虚拟内存地址与物理内存地址</h4><p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时，都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片$2^N$字节的内存，其中$N$是机器位数。例如在64位CPU和64位操作系统下，每个进程的虚拟地址空间为$2^{64}$Byte。</p><p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p><p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫<a href="http://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>（Memory Management Unit）的硬件完成。</p><h4 id="2-1-2-页与地址构成"><a href="#2-1-2-页与地址构成" class="headerlink" title="2.1.2 页与地址构成"></a>2.1.2 页与地址构成</h4><p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p><p>所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：</p><p><img src="https://pic4.zhimg.com/80/v2-b37992424628f32bc5e8245b689a31df_720w.webp" alt="img"></p><p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内偏移都是用低12位表示，而剩下的高地址表示页号。</p><p>MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构<a href="http://en.wikipedia.org/wiki/Page_table">页表</a>来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a>等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。</p><p><img src="https://pic3.zhimg.com/80/v2-15d430b30f223794b85ce6f54a95006e_720w.webp" alt="img"></p><h4 id="2-1-3-内存页与磁盘页"><a href="#2-1-3-内存页与磁盘页" class="headerlink" title="2.1.3 内存页与磁盘页"></a>2.1.3 内存页与磁盘页</h4><p>我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。</p><p>最后附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程（<a href="http://en.wikipedia.org/wiki/Page_table">图片来源页</a>）。</p><p><img src="https://pic3.zhimg.com/80/v2-5bb7bf5a484d6185e9d5a06a20408da6_720w.webp" alt="img"></p><h3 id="2-2-Linux进程级内存管理"><a href="#2-2-Linux进程级内存管理" class="headerlink" title="2.2 Linux进程级内存管理"></a>2.2 Linux进程级内存管理</h3><h4 id="2-2-1-内存排布"><a href="#2-2-1-内存排布" class="headerlink" title="2.2.1 内存排布"></a>2.2.1 内存排布</h4><p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p><p>以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p><p>根据<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt">Linux内核相关文档</a>描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：</p><p><img src="https://pic3.zhimg.com/80/v2-c9969fd8e48b5dcdd813de6d0756434a_720w.webp" alt="img"></p><p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p><ul><li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li><li>Data：这里存放的是初始化过的全局变量</li><li>BSS：这里存放的是未初始化的全局变量</li><li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li><li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li><li>Stack：这是栈区域，自高地址向低地址增长</li></ul><p>下面我们主要关注Heap区域的操作。对整个Linux内存排布有兴趣的同学可以参考其它资料。</p><h4 id="2-2-2-Heap内存模型"><a href="#2-2-2-Heap内存模型" class="headerlink" title="2.2.2 Heap内存模型"></a>2.2.2 Heap内存模型</h4><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p><p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：</p><p><img src="https://pic2.zhimg.com/80/v2-9bd8544cccfc3709a2139a6121aeab31_720w.webp" alt="img"></p><p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p><h4 id="2-2-3-brk与sbrk"><a href="#2-2-3-brk与sbrk" class="headerlink" title="2.2.3 brk与sbrk"></a>2.2.3 brk与sbrk</h4><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：</p><pre><code>int brk(void *addr);void *sbrk(intptr_t increment);</code></pre><p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p><p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p><p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</p><h4 id="2-2-4-资源限制与rlimit"><a href="#2-2-4-资源限制与rlimit" class="headerlink" title="2.2.4 资源限制与rlimit"></a>2.2.4 资源限制与rlimit</h4><p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> rlimit <span class="token operator">*</span>limit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> rlimit <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> rlimit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getrlimit</span><span class="token punctuation">(</span>RLIMIT_AS<span class="token punctuation">,</span> limit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"soft limit: %ld, hard limit: %ld\n"</span><span class="token punctuation">,</span> limit<span class="token operator">-></span>rlim_cur<span class="token punctuation">,</span> limit<span class="token operator">-></span>rlim_max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中rlimit是一个结构体：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> rlimit <span class="token punctuation">{</span>    rlim_t rlim_cur<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Soft limit */</span>    rlim_t rlim_max<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Hard limit (ceiling for rlim_cur) */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p><h2 id="3-实现malloc"><a href="#3-实现malloc" class="headerlink" title="3 实现malloc"></a>3 实现malloc</h2><h3 id="3-1-玩具实现"><a href="#3-1-玩具实现" class="headerlink" title="3.1 玩具实现"></a>3.1 玩具实现</h3><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 一个玩具malloc */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p><h3 id="3-2-正式实现"><a href="#3-2-正式实现" class="headerlink" title="3.2 正式实现"></a>3.2 正式实现</h3><p>下面严肃点讨论malloc的实现方案。</p><h4 id="3-2-1-数据结构"><a href="#3-2-1-数据结构" class="headerlink" title="3.2.1 数据结构"></a>3.2.1 数据结构</h4><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p><p>可以用如下结构体定义一个block：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> s_block <span class="token operator">*</span>t_block<span class="token punctuation">;</span><span class="token keyword">struct</span> s_block <span class="token punctuation">{</span>    size_t size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 数据区大小 */</span>    t_block next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 指向下个块的指针 */</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 是否是空闲块 */</span>    <span class="token keyword">int</span> padding<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 填充4字节，保证meta块长度为8的倍数 */</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-7f5b5dcb606608867c9d03cc908bcfa1_720w.webp" alt="img"></p><h4 id="3-2-2-寻找合适的block"><a href="#3-2-2-寻找合适的block" class="headerlink" title="3.2.2 寻找合适的block"></a>3.2.2 寻找合适的block</h4><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p><ul><li><strong>First fit</strong>：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块</li><li><strong>Best fit</strong>：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</li></ul><p>两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。</p><pre><code>/* First fit */t_block find_block(t_block *last, size_t size) {    t_block b = first_block;    while(b &amp;&amp; !(b-&gt;free &amp;&amp; b-&gt;size &gt;= size)) {        *last = b;        b = b-&gt;next;    }    return b;}</code></pre><p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到这返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新block使用的，具体会在接下来的一节用到。</p><h4 id="3-2-3-开辟新的block"><a href="#3-2-3-开辟新的block" class="headerlink" title="3.2.3 开辟新的block"></a>3.2.3 开辟新的block</h4><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> BLOCK_SIZE 24 </span><span class="token comment" spellcheck="true">/* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */</span>t_block <span class="token function">extend_heap</span><span class="token punctuation">(</span>t_block last<span class="token punctuation">,</span> size_t s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t_block b<span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sbrk</span><span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">+</span> s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>size <span class="token operator">=</span> s<span class="token punctuation">;</span>    b<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span>        last<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token punctuation">;</span>    b<span class="token operator">-></span>free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-4-分裂block"><a href="#3-2-4-分裂block" class="headerlink" title="3.2.4 分裂block"></a>3.2.4 分裂block</h4><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：</p><p><img src="https://pic4.zhimg.com/80/v2-bd539864955725b96751f9b23b8ca293_720w.webp" alt="img"></p><p>实现代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">split_block</span><span class="token punctuation">(</span>t_block b<span class="token punctuation">,</span> size_t s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t_block new<span class="token punctuation">;</span>    new <span class="token operator">=</span> b<span class="token operator">-></span>data <span class="token operator">+</span> s<span class="token punctuation">;</span>    new<span class="token operator">-></span>size <span class="token operator">=</span> b<span class="token operator">-></span>size <span class="token operator">-</span> s <span class="token operator">-</span> BLOCK_SIZE <span class="token punctuation">;</span>    new<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token punctuation">;</span>    new<span class="token operator">-></span>free <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    b<span class="token operator">-></span>size <span class="token operator">=</span> s<span class="token punctuation">;</span>    b<span class="token operator">-></span>next <span class="token operator">=</span> new<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-5-malloc的实现"><a href="#3-2-5-malloc的实现" class="headerlink" title="3.2.5 malloc的实现"></a>3.2.5 malloc的实现</h4><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p><p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：</p><pre class="line-numbers language-c"><code class="language-c">size_t <span class="token function">align8</span><span class="token punctuation">(</span>size_t s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">&amp;</span> <span class="token number">0x7</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">define</span> BLOCK_SIZE 24</span><span class="token keyword">void</span> <span class="token operator">*</span>first_block<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* other functions... */</span><span class="token keyword">void</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t_block b<span class="token punctuation">,</span> last<span class="token punctuation">;</span>    size_t s<span class="token punctuation">;</span>    <span class="token operator">/</span> 对齐地址 <span class="token operator">/</span>    s <span class="token operator">=</span> <span class="token function">align8</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>first_block<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">/</span> 查找合适的block <span class="token operator">/</span>        last <span class="token operator">=</span> first_block<span class="token punctuation">;</span>        b <span class="token operator">=</span> <span class="token function">find_block</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>last<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">/</span> 如果可以，则分裂 <span class="token operator">/</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">-</span> s<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token punctuation">(</span> BLOCK_SIZE <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">split_block</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>            b<span class="token operator">-></span>free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token operator">/</span> 没有合适的block，开辟一个新的 <span class="token operator">*</span><span class="token operator">/</span>        b <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>last<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    b <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    first_block <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> b<span class="token operator">-></span>data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-6-calloc的实现"><a href="#3-2-6-calloc的实现" class="headerlink" title="3.2.6 calloc的实现"></a>3.2.6 calloc的实现</h4><p>有了malloc，实现calloc只要两步：</p><ol><li>malloc一段内存</li><li>将数据区内容置为0</li></ol><p>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">calloc</span><span class="token punctuation">(</span>size_t number<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    size_t <span class="token operator">*</span>new<span class="token punctuation">;</span>    size_t s8<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    new <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>number <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>new<span class="token punctuation">)</span> <span class="token punctuation">{</span>        s8 <span class="token operator">=</span> <span class="token function">align8</span><span class="token punctuation">(</span>number <span class="token operator">*</span> size<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s8<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            new<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> new<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-7-free的实现"><a href="#3-2-7-free的实现" class="headerlink" title="3.2.7 free的实现"></a>3.2.7 free的实现</h4><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p><ol><li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li><li>如何解决碎片问题</li></ol><p>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</p><ul><li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li><li>这个地址确实是之前通过我们自己的malloc分配的</li></ul><p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p><p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> s_block <span class="token operator">*</span>t_block<span class="token punctuation">;</span><span class="token keyword">struct</span> s_block <span class="token punctuation">{</span>    size_t size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 数据区大小 */</span>    t_block next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 指向下个块的指针 */</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 是否是空闲块 */</span>    <span class="token keyword">int</span> padding<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 填充4字节，保证meta块长度为8的倍数 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Magic pointer，指向data */</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们定义检查地址合法性的函数：</p><pre class="line-numbers language-c"><code class="language-c">t_block <span class="token function">get_block</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>      tmp <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> tmp <span class="token operator">-</span><span class="token operator">=</span> BLOCK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">valid_addr</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>first_block<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">></span> first_block <span class="token operator">&amp;&amp;</span> p <span class="token operator">&lt;</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> p <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token function">get_block</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>ptr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p><p>一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> s_block <span class="token operator">*</span>t_block<span class="token punctuation">;</span><span class="token keyword">struct</span> s_block <span class="token punctuation">{</span>    size_t size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 数据区大小 */</span>    t_block prev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 指向上个块的指针 */</span>    t_block next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 指向下个块的指针 */</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 是否是空闲块 */</span>    <span class="token keyword">int</span> padding<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 填充4字节，保证meta块长度为8的倍数 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Magic pointer，指向data */</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>合并方法如下：</p><pre class="line-numbers language-c"><code class="language-c">t_block <span class="token function">fusion</span><span class="token punctuation">(</span>t_block b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>next<span class="token operator">-></span>free<span class="token punctuation">)</span> <span class="token punctuation">{</span>        b<span class="token operator">-></span>size <span class="token operator">+</span><span class="token operator">=</span> BLOCK_SIZE <span class="token operator">+</span> b<span class="token operator">-></span>next<span class="token operator">-></span>size<span class="token punctuation">;</span>        b<span class="token operator">-></span>next <span class="token operator">=</span> b<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>next<span class="token punctuation">)</span>            b<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t_block b<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">valid_addr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        b <span class="token operator">=</span> <span class="token function">get_block</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token operator">-></span>free <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>prev <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>prev<span class="token operator">-></span>free<span class="token punctuation">)</span>            b <span class="token operator">=</span> <span class="token function">fusion</span><span class="token punctuation">(</span>b<span class="token operator">-></span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>next<span class="token punctuation">)</span>            <span class="token function">fusion</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>prev<span class="token punctuation">)</span>                b<span class="token operator">-></span>prev<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                first_block <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token function">brk</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-8-realloc的实现"><a href="#3-2-8-realloc的实现" class="headerlink" title="3.2.8 realloc的实现"></a>3.2.8 realloc的实现</h4><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">copy_block</span><span class="token punctuation">(</span>t_block src<span class="token punctuation">,</span> t_block dst<span class="token punctuation">)</span> <span class="token punctuation">{</span>    size_t <span class="token operator">*</span>sdata<span class="token punctuation">,</span> <span class="token operator">*</span>ddata<span class="token punctuation">;</span>    size_t i<span class="token punctuation">;</span>    sdata <span class="token operator">=</span> src<span class="token operator">-></span>ptr<span class="token punctuation">;</span>    ddata <span class="token operator">=</span> dst<span class="token operator">-></span>ptr<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> src<span class="token operator">-></span>size <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> dst<span class="token operator">-></span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        ddata<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sdata<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p><ul><li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li><li>如果新的size变小了，考虑split</li><li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li></ul><p>下面是realloc的实现：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    size_t s<span class="token punctuation">;</span>    t_block b<span class="token punctuation">,</span> new<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>newp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">/* 根据标准库文档，当p传入NULL时，相当于调用malloc */</span>        <span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">valid_addr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s <span class="token operator">=</span> <span class="token function">align8</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        b <span class="token operator">=</span> <span class="token function">get_block</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">>=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">-</span> s <span class="token operator">>=</span> <span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">split_block</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 看是否可进行合并 */</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> b<span class="token operator">-></span>next<span class="token operator">-></span>free                    <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">+</span> BLOCK_SIZE <span class="token operator">+</span> b<span class="token operator">-></span>next<span class="token operator">-></span>size<span class="token punctuation">)</span> <span class="token operator">>=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">fusion</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">-></span>size <span class="token operator">-</span> s <span class="token operator">>=</span> <span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token function">split_block</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/* 新malloc */</span>                newp <span class="token operator">=</span> <span class="token function">malloc</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newp<span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                new <span class="token operator">=</span> <span class="token function">get_block</span><span class="token punctuation">(</span>newp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">copy_block</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> new<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">(</span>newp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-遗留问题和优化"><a href="#3-3-遗留问题和优化" class="headerlink" title="3.3 遗留问题和优化"></a>3.3 遗留问题和优化</h3><p>以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p><ul><li>同时兼容32位和64位系统</li><li>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效</li><li>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度</li><li>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是malloc&quot;&gt;&lt;a href=&quot;#1-什么是malloc&quot; class=&quot;headerlink&quot; title=&quot;1 什么是malloc&quot;&gt;&lt;/a&gt;1 什么是malloc&lt;/h2&gt;&lt;p&gt;在实现malloc之前，先要相对正式地对malloc做一个定义。&lt;/
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Effective Cpp：条款 &amp; 实践</title>
    <link href="https://joytsing.github.io/posts/22113/"/>
    <id>https://joytsing.github.io/posts/22113/</id>
    <published>2023-12-16T12:23:38.000Z</published>
    <updated>2023-12-16T12:26:10.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章：让自己习惯-C"><a href="#第一章：让自己习惯-C" class="headerlink" title="第一章：让自己习惯 C++"></a>第一章：让自己习惯 C++</h2><h3 id="条款-1：视-C-为一个语言联邦"><a href="#条款-1：视-C-为一个语言联邦" class="headerlink" title="条款 1：视 C++ 为一个语言联邦"></a>条款 1：视 C++ 为一个语言联邦</h3><p>C++ 拥有多种不同的编程范式，而这些范式集成在一个语言中，使得 C++ 是一门即灵活又复杂的语言：</p><ol><li>传统的面向过程 C：区块，语句，预处理器，内置数据类型，数组，指针。</li><li>面向对象的 C with Classes：类，封装，继承，多态，动态绑定。</li><li>模板编程 Template C++ 和堪称黑魔法的模板元编程（TMP）。</li><li>C++ 标准库 STL。</li></ol><p>C++ 高效编程守则视情况而变化，程序设计没有银弹。</p><h3 id="条款-2：尽量以-const-enum-inline-替换-define"><a href="#条款-2：尽量以-const-enum-inline-替换-define" class="headerlink" title="条款 2：尽量以 const, enum, inline 替换 #define"></a>条款 2：尽量以 const, enum, inline 替换 #define</h3><p>在原书写成时 C++11 中的<code>constexpr</code>还未诞生，现在一般认为应当用<code>constexpr</code>定义编译期常量来替代大部分的<code>#define</code>宏常量定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> ASPECT_RATIO 1.653</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> aspect_ratio <span class="token operator">=</span> <span class="token number">1.653</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们也可以将编译期常量定义为类的静态成员：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GamePlayer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">auto</span> numTurns <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>enum</code>可以用于替代整型的常量，并且在模板元编程中应用广泛（见条款 48）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GamePlayer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span> numTurns <span class="token operator">=</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>大部分<code>#define</code>宏常量应当用内联模板函数替代：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">CallWithMax</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，宏和函数的行为本身并不完全一致，宏只是简单的替换，并不涉及传参和复制。</p><h3 id="条款-3：尽可能使用-const"><a href="#条款-3：尽可能使用-const" class="headerlink" title="条款 3：尽可能使用 const"></a>条款 3：尽可能使用 const</h3><p>若你想让一个常量只读，那你应该明确说出它是const常量，对于指针来说，更是如此：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">char</span> greeting<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 指针可修改，数据可修改</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 指针可修改，数据不可修改</span><span class="token keyword">char</span> <span class="token keyword">const</span><span class="token operator">*</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 指针可修改，数据不可修改</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 指针不可修改，数据可修改</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> greeting<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指针不可修改，数据不可修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 STL 迭代器，分清使用<code>const</code>还是<code>const_iterator</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator iter <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 迭代器不可修改，数据可修改</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator iter <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 迭代器可修改，数据不可修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>面对函数声明时，如果你不想让一个函数的结果被无意义地当作左值，请使用const返回值：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>const成员函数：</strong></p><p>const成员函数允许我们操控const对象，这在传递常引用时显得尤为重要：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t position<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// const对象使用的重载</span>        <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t position<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// non-const对象使用的重载</span>        <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string text<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，const和non-const对象都有其各自的重载版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">const</span> Textblock<span class="token operator">&amp;</span> ctb<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ctb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 调用 const TextBlock::operator[]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译器对待const对象的态度通常是 bitwise constness，而我们在编写程序时通常采用 logical constness，这就意味着，在确保客户端不会察觉的情况下，我们认为const对象中的某些成员变量应当是允许被改变的，使用关键字<code>mutable</code>来标记这些成员变量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CTextBlock</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    std<span class="token operator">::</span>size_t <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">char</span><span class="token operator">*</span> pText<span class="token punctuation">;</span>    <span class="token keyword">mutable</span> std<span class="token operator">::</span>size_t textLength<span class="token punctuation">;</span>    <span class="token keyword">mutable</span> <span class="token keyword">bool</span> lengthIsValid<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>size_t CTextBlock<span class="token operator">::</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lengthIsValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        textLength <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span>pText<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 可以修改mutable成员变量</span>        lengthIsValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 可以修改mutable成员变量</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> textLength<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在重载const和non-const成员函数时，需要尽可能避免书写重复的内容，这促使我们去进行常量性转除。在大部分情况下，我们应当避免转型的出现，但在此处为了减少重复代码，转型是适当的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t position<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 假设这里有非常多的代码</span>        <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t position<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> TextBlock<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string text<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，反向做法：令const版本调用non-const版本以避免重复——并不被建议，一般而言const版本的限制比non-const版本的限制更多，因此这样做会带来风险。</p><h3 id="条款-4：确定对象在使用前已被初始化"><a href="#条款-4：确定对象在使用前已被初始化" class="headerlink" title="条款 4：确定对象在使用前已被初始化"></a>条款 4：确定对象在使用前已被初始化</h3><p>无初值对象在 C/C++ 中广泛存在，因此这一条款就尤为重要。在定义完一个对象后需要尽快为它赋初值：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> text <span class="token operator">=</span> <span class="token string">"A C-style string"</span><span class="token punctuation">;</span><span class="token keyword">double</span> d<span class="token punctuation">;</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于类中的成员变量而言，我们有两种建议的方法完成初始化工作，一种是直接在定义处赋初值（since C++11）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CTextBlock</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>size_t textLength<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> lengthIsValid<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种是使用构造函数成员初始化列表：</p><pre class="line-numbers language-cpp"><code class="language-cpp">ABEntry<span class="token operator">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> address<span class="token punctuation">,</span>                 <span class="token keyword">const</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">></span><span class="token operator">&amp;</span> phones<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">theAddress</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">thePhones</span><span class="token punctuation">(</span>phones<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">numTimesConsulted</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员初始化列表也可以留空用来执行默认构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">ABEntry<span class="token operator">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">theAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">thePhones</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">numTimesConsulted</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，类中成员的初始化具有次序性，而这次序与成员变量的声明次序一致，与成员初始化列表的次序无关。</p><blockquote><p>类中成员的初始化是可选的，但是引用类型必须初始化。</p></blockquote><p><strong>静态对象的初始化：</strong></p><p>C++ 对于定义于不同编译单元内的全局静态对象的初始化相对次序并无明确定义，因此，以下代码可能会出现使用未初始化静态对象的情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// File 1</span><span class="token keyword">extern</span> FileSystem tfs<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// File 2</span><span class="token keyword">class</span> <span class="token class-name">Directory</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Directory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        FileSystem disk <span class="token operator">=</span> tfs<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Directory tempDir<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面这个例子中，你无法确保位于不同编译单元内的<code>tfs</code>一定在<code>tempDir</code>之前初始化完成。</p><p>这个问题的一个有效解决方案是采用 <strong>Meyers’ singleton</strong>，将全局静态对象转化为局部静态对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp">FileSystem<span class="token operator">&amp;</span> <span class="token function">tfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> FileSystem fs<span class="token punctuation">;</span>    <span class="token keyword">return</span> fs<span class="token punctuation">;</span><span class="token punctuation">}</span>Directory<span class="token operator">&amp;</span> <span class="token function">tempDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> Directory td<span class="token punctuation">;</span>    <span class="token keyword">return</span> td<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个手法的基础在于：C++ 保证，函数内的局部静态对象会在<strong>该函数被调用期间</strong>和<strong>首次遇上该对象之定义式</strong>时被初始化。</p><p>当然，这种做法对于多线程来说并不具有优势，最好还是在单线程启动阶段手动调用函数完成初始化。</p><h2 id="第二章：构造-析构-赋值运算"><a href="#第二章：构造-析构-赋值运算" class="headerlink" title="第二章：构造/析构/赋值运算"></a>第二章：构造/析构/赋值运算</h2><h3 id="条款-5：了解-C-默默编写并调用哪些函数"><a href="#条款-5：了解-C-默默编写并调用哪些函数" class="headerlink" title="条款 5：了解 C++ 默默编写并调用哪些函数"></a>条款 5：了解 C++ 默默编写并调用哪些函数</h3><p>C++ 中的空类并不是真正意义上的空类，编译器会为它预留以下内容：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Empty</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>                           <span class="token comment" spellcheck="true">// 默认构造函数（没有任何构造函数时）</span>    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>               <span class="token comment" spellcheck="true">// 拷贝构造函数</span>    <span class="token function">Empty</span><span class="token punctuation">(</span>Empty<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 移动构造函数 (since C++11)</span>    <span class="token operator">~</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>                          <span class="token comment" spellcheck="true">// 析构函数</span>    Empty<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 拷贝赋值运算符</span>    Empty<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Empty<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// 移动赋值运算符 (since C++11)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>唯有当这些函数被调用时，它们才会真正被编译器创建出来，下面代码将造成上述每一个函数被创建：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Empty e1<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 默认构造函数 &amp; 析构函数</span>Empty <span class="token function">e2</span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 拷贝构造函数</span>Empty e3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 移动构造函数 (since C++11)</span>e2 <span class="token operator">=</span> e1<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 拷贝赋值运算符</span>e3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 移动赋值运算符 (since C++11)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，拷贝赋值运算符只有在允许存在时才会自动创建，比如以下情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">NamedObject</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string<span class="token operator">&amp;</span> nameValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在该类中，我们有一个string引用类型，然而引用无法指向不同对象，因此编译器会拒绝为该类创建一个默认的拷贝赋值运算符。</p><p>除此之外，以下情形也会导致拷贝赋值运算符不会自动创建：</p><ol><li>类中含有const成员。</li><li>基类中含有private的拷贝赋值运算符。</li></ol><h3 id="条款-6：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-6：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 6：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 6：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>原书中使用的做法是将不想使用的函数声明为private，但在 C++11 后我们有了更好的做法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Uncopyable</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    Uncopyable<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-7：为多态基类声明虚析构函数"><a href="#条款-7：为多态基类声明虚析构函数" class="headerlink" title="条款 7：为多态基类声明虚析构函数"></a>条款 7：为多态基类声明虚析构函数</h3><p>当派生类对象经由一个基类指针被删除，而该基类指针带着一个非虚析构函数，其结果是未定义的，可能会无法完全销毁派生类的成员，造成内存泄漏。消除这个问题的方法就是对基类使用虚析构函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你不想让一个类成为基类，那么在类中声明虚函数是是一个坏主意，因为额外存储的虚表指针会使类的体积变大。</p><blockquote><p>只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用virtual关键字声明，都自动成为虚析构函数。</p></blockquote><p>虚析构函数的运作方式是，最深层派生的那个类的析构函数最先被调用，然后是其上的基类的析构函数被依次调用。</p><p>如果你想将基类作为抽象类使用，但手头上又没有别的虚函数，那么将它的析构函数设为纯虚函数是一个不错的想法。考虑以下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但若此时从该基类中派生出新的类，会发生报错，这是因为编译器无法找到基类的析构函数的实现。因此，即使是纯虚析构函数，也需要一个函数体：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Base<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者以下写法也被允许：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-8：别让异常逃离析构函数"><a href="#条款-8：别让异常逃离析构函数" class="headerlink" title="条款 8：别让异常逃离析构函数"></a>条款 8：别让异常逃离析构函数</h3><p>在析构函数中吐出异常并不被禁止，但为了程序的可靠性，应当极力避免这种行为。</p><p>为了实现 RAII，我们通常会将对象的销毁方法封装在析构函数中，如下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">DBConn</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 该函数可能会抛出异常</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    DBConnection db<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但这样我们就需要在析构函数中完成对异常的处理，以下是几种常见的做法：</p><p>第一种：杀死程序：</p><pre class="line-numbers language-cpp"><code class="language-cpp">DBConn<span class="token operator">::</span><span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span> db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 记录运行日志，以便调试</span>        std<span class="token operator">::</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种：直接吞下异常不做处理，但这种做法不被建议。</p><p>第三种：重新设计接口，将异常的处理交给客户端完成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">DBConn</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        closed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>closed<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 处理异常</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    DBConnection db<span class="token punctuation">;</span>    <span class="token keyword">bool</span> closed<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个新设计的接口中，我们提供了<code>close</code>函数供客户手动调用，这样客户也可以根据自己的意愿处理异常；若客户忘记手动调用，析构函数才会自动调用<code>close</code>函数。</p><p>当一个操作可能会抛出需要客户处理的异常时，将其暴露在普通函数而非析构函数中是一个更好的选择。</p><h3 id="条款-9：绝不在构造和析构过程中调用虚函数"><a href="#条款-9：绝不在构造和析构过程中调用虚函数" class="headerlink" title="条款 9：绝不在构造和析构过程中调用虚函数"></a>条款 9：绝不在构造和析构过程中调用虚函数</h3><p>在创建派生类对象时，基类的构造函数永远会早于派生类的构造函数被调用，而基类的析构函数永远会晚于派生类的析构函数被调用。</p><p>在派生类对象的基类构造和析构期间，对象的类型是基类而非派生类，因此此时调用虚函数会被编译器解析至基类的虚函数版本，通常不会得到我们想要的结果。</p><p>间接调用虚函数是一个比较难以发现的危险行为，需要尽量避免：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">LogTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">LogTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 此处间接调用了虚函数！</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要基类在构造时就得知派生类的构造信息，推荐的做法是在派生类的构造函数中将必要的信息向上传递给基类的构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> logInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">LogTransaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> logInfo<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Transaction<span class="token operator">::</span><span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> logInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">LogTransaction</span><span class="token punctuation">(</span>logInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 更改为了非虚函数调用</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">BuyTransaction</span> <span class="token operator">:</span> <span class="token keyword">public</span> Transaction <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">BuyTransaction</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token function">CreateLogString</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将信息传递给基类构造函数</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>string <span class="token function">CreateLogString</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意此处的<code>CreateLogString</code>是一个静态成员函数，这是很重要的，因为静态成员函数可以确保不会使用未完成初始化的成员变量。</p><h3 id="条款-10：令-operator-返回一个指向-this-的引用"><a href="#条款-10：令-operator-返回一个指向-this-的引用" class="headerlink" title="条款 10：令 operator= 返回一个指向 *this 的引用"></a>条款 10：令 operator= 返回一个指向 *this 的引用</h3><p>虽然并不强制执行此条款，但为了实现连锁赋值，大部分时候应该这样做：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这个条款适用于</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                    <span class="token comment" spellcheck="true">// +=, -=, *= 等等运算符</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// 即使参数类型不是 Widget&amp; 也适用</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-11：在-operator-中处理“自我赋值”"><a href="#条款-11：在-operator-中处理“自我赋值”" class="headerlink" title="条款 11：在 operator= 中处理“自我赋值”"></a>条款 11：在 operator= 中处理“自我赋值”</h3><p>自我赋值是合法的操作，但在一些情况下可能会导致意外的错误，例如在复制堆上的资源时：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span> pRes<span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">// 删除当前持有的资源</span>    pRes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Resource</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pRes<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 复制传入的资源</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但若<code>rhs</code>和<code>*this</code>指向的是相同的对象，就会导致访问到已删除的数据。</p><p>最简单的解决方法是在执行后续语句前先进行<strong>证同测试（Identity test）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 若是自我赋值，则不做任何事</span>    <span class="token keyword">delete</span> pRes<span class="token punctuation">;</span>    pRes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Resource</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pRes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个常见的做法是只关注异常安全性，而不关注是否自我赋值：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Resource<span class="token operator">*</span> pOrigin <span class="token operator">=</span> pRes<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 先记住原来的pRes指针</span>    pRes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Resource</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pRes<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 复制传入的资源</span>    <span class="token keyword">delete</span> pOrigin<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 删除原来的资源</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仅仅是适当安排语句的顺序，就可以做到使整个过程具有异常安全性。</p><p>还有一种取巧的做法是使用 copy and swap 技术，这种技术聪明地利用了栈空间会自动释放的特性，这样就可以通过析构函数来实现资源的释放：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Widget <span class="token function">temp</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述做法还可以写得更加巧妙，就是利用按值传参，自动调用构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-12：复制对象时勿忘其每一个成分"><a href="#条款-12：复制对象时勿忘其每一个成分" class="headerlink" title="条款 12：复制对象时勿忘其每一个成分"></a>条款 12：复制对象时勿忘其每一个成分</h3><p>这个条款正如其字面意思，当你决定手动实现拷贝构造函数或拷贝赋值运算符时，忘记复制任何一个成员都可能会导致意外的错误。</p><p>当使用继承时，继承自基类的成员往往容易忘记在派生类中完成复制，如果你的基类拥有拷贝构造函数和拷贝赋值运算符，应该记得调用它们：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PriorityCustomer</span> <span class="token operator">:</span> <span class="token keyword">public</span> Customer <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">PriorityCustomer</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    PriorityCustomer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> priority<span class="token punctuation">;</span><span class="token punctuation">}</span>PriorityCustomer<span class="token operator">::</span><span class="token function">PriorityCustomer</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">Customer</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">// 调用基类的拷贝构造函数</span>      <span class="token function">priority</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>PriorityCustomer<span class="token operator">::</span>PriorityCustomer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Customer<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 调用基类的拷贝赋值运算符</span>    priority <span class="token operator">=</span> rhs<span class="token punctuation">.</span>priority<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，不要尝试在拷贝构造函数中调用拷贝赋值运算符，或在拷贝赋值运算符的实现中调用拷贝构造函数，一个在初始化时，一个在初始化后，它们的功用是不同的。</p><h2 id="第三章：资源管理"><a href="#第三章：资源管理" class="headerlink" title="第三章：资源管理"></a>第三章：资源管理</h2><h3 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h3><p>对于传统的堆资源管理，我们需要使用成对的<code>new</code>和<code>delete</code>，这样若忘记<code>delete</code>就会造成内存泄露。因此，我们应尽可能以对象管理资源，并采用RAII（Resource Acquisition Is Initialize，资源取得时机便是初始化时机），让析构函数负责资源的释放。</p><p>原书此处关于智能指针的内容已经过时，在 C++11 中，通过专一所有权来管理RAII对象可以使用<code>std::unique_ptr</code>，通过引用计数来管理RAII对象可以使用<code>std::shared_ptr</code>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Investment* CreateInvestment();</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pUniqueInv1</span><span class="token punctuation">(</span><span class="token function">CreateInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pUniqueInv2</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>pUniqueInv1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转移资源所有权</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pSharedInv1</span><span class="token punctuation">(</span><span class="token function">CreateInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pSharedInv2</span><span class="token punctuation">(</span>pSharedInv1<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 引用计数+1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>智能指针默认会自动delete所持有的对象，我们也可以为智能指针指定所管理对象的释放方式（删除器deleter）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// void GetRidOfInvestment(Investment*) {}</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>GetRidOfInvestment<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">pUniqueInv</span><span class="token punctuation">(</span><span class="token function">CreateInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GetRidOfInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pSharedInv</span><span class="token punctuation">(</span><span class="token function">CreateInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GetRidOfInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-14：在资源管理类中小心拷贝行为"><a href="#条款-14：在资源管理类中小心拷贝行为" class="headerlink" title="条款 14：在资源管理类中小心拷贝行为"></a>条款 14：在资源管理类中小心拷贝行为</h3><p>我们应该永远保持这样的思考：当一个RAII对象被复制，会发生什么事？</p><p><strong>选择一：禁止复制</strong></p><p>许多时候允许RAII对象被复制并不合理，如果确是如此，那么就该明确禁止复制行为，条款 6 已经阐述了怎么做这件事。</p><p><strong>选择二：对底层资源祭出“引用计数法”</strong></p><p>正如<code>std::shared_ptr</code>所做的那样，每一次复制对象就使引用计数+1，每一个对象离开定义域就调用析构函数使引用计数-1，直到引用计数为0就彻底销毁资源。</p><p><strong>选择三：复制底层资源</strong></p><p>在复制对象的同时复制底层资源的行为又被称作<strong>深拷贝（Deep copying）</strong>，例如在一个对象中有一个指针，那么在复制这个对象时就不能只复制指针，也要复制指针所指向的数据。</p><p><strong>选择四：转移底层资源的所有权</strong></p><p>和<code>std::unique_ptr</code>的行为类似，永远保持只有一个对象拥有对资源的管理权，当需要复制对象时转移资源的管理权。</p><h3 id="条款-15：在资源管理类中提供对原始资源的访问"><a href="#条款-15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15：在资源管理类中提供对原始资源的访问"></a>条款 15：在资源管理类中提供对原始资源的访问</h3><p>和所有的智能指针一样，STL 中的智能指针也提供了对原始资源的隐式访问和显式访问：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Investment<span class="token operator">*</span> pRaw <span class="token operator">=</span> pSharedInv<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 显式访问原始资源</span>Investment raw <span class="token operator">=</span> <span class="token operator">*</span>pSharedInv<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 隐式访问原始资源</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当我们在设计自己的资源管理类时，也要考虑在提供对原始资源的访问时，是使用显式访问还是隐式访问的方法，还是两者皆可。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Font</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    FontHandle <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> handle<span class="token punctuation">;</span> <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 显式转换函数</span>    <span class="token keyword">operator</span> <span class="token function">FontHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> handle<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 隐式转换函数</span><span class="token keyword">private</span><span class="token operator">:</span>    FontHandle handle<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般而言显式转换比较安全，但隐式转换对客户比较方便。</p><h3 id="条款-16：成对使用-new-和-delete-时要采用相同形式"><a href="#条款-16：成对使用-new-和-delete-时要采用相同形式" class="headerlink" title="条款 16：成对使用 new 和 delete 时要采用相同形式"></a>条款 16：成对使用 new 和 delete 时要采用相同形式</h3><p>使用<code>new</code>来分配单一对象，使用<code>new[]</code>来分配对象数组，必须明确它们的行为并不一致，分配对象数组时会额外在内存中记录“数组大小”，而使用<code>delete[]</code>会根据记录的数组大小多次调用析构函数，使用<code>delete</code>则仅仅只会调用一次析构函数。对于单一对象使用<code>delete[]</code>其结果也是未定义的，程序可能会读取若干内存并将其错误地解释为数组大小。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span><span class="token keyword">delete</span> object<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，使用<code>typedef</code>定义数组类型会带来额外的风险：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>string AddressLines<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>std<span class="token operator">::</span>string<span class="token operator">*</span> pal <span class="token operator">=</span> <span class="token keyword">new</span> AddressLines<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// pal 是一个对象数组，而非单一对象</span><span class="token keyword">delete</span> pal<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// 行为未定义</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pal<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-17：以独立语句将-newed-对象置入智能指针"><a href="#条款-17：以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款 17：以独立语句将 newed 对象置入智能指针"></a>条款 17：以独立语句将 newed 对象置入智能指针</h3><p>原书此处所讲已过时，现在更好的做法是使用<code>std::make_unique</code>和<code>std::make_shared</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> pUniqueInv <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Investment<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// since C++14</span><span class="token keyword">auto</span> pSharedInv <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Investment<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// since C++11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="第四章：设计与声明"><a href="#第四章：设计与声明" class="headerlink" title="第四章：设计与声明"></a>第四章：设计与声明</h2><h3 id="条款-18：让接口容易被正确使用，不易被误用"><a href="#条款-18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款 18：让接口容易被正确使用，不易被误用"></a>条款 18：让接口容易被正确使用，不易被误用</h3><ol><li>好的接口很容易被正确使用，不易被误用。你应在在你的所有接口中努力达成这些性质。</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li><li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 三个参数类型相同的函数容易造成误用</span>Data<span class="token operator">::</span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 通过适当定义新的类型加以限制，降低误用的可能性</span>Data<span class="token operator">::</span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token keyword">const</span> Month<span class="token operator">&amp;</span> m<span class="token punctuation">,</span> <span class="token keyword">const</span> Day<span class="token operator">&amp;</span> d<span class="token punctuation">,</span> <span class="token keyword">const</span> Year<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>尽量使用智能指针，避免跨DLL的 new 和 delete，使用智能指针自定义删除器来解除互斥锁（mutexes）。</li></ol><h3 id="条款-19：设计-class-犹如设计-type"><a href="#条款-19：设计-class-犹如设计-type" class="headerlink" title="条款 19：设计 class 犹如设计 type"></a>条款 19：设计 class 犹如设计 type</h3><p>几乎在设计每一个 class 时，都要面对如下问题：</p><p><strong>新 type 对象应该如何被创建和销毁？</strong> 这会影响到类中构造函数、析构函数、内存分配和释放函数（<code>operator new</code>，<code>operator new[]</code>，<code>operator delete</code>，<code>operator delete[]</code>）的设计。</p><p><strong>对象的初始化和赋值该有什么样的差别？</strong> 这会影响到构造函数和拷贝赋值运算之间行为的差异。</p><p><strong>新 type 的对象如果被按值传递，意味着什么？</strong> 这会影响到拷贝构造函数的实现。</p><p><strong>什么是新 type 的合法值？</strong> 你的类中的成员函数必须对类中成员变量的值进行检查，如果不合法就要尽快解决或明确地抛出异常。</p><p><strong>你的新 type 需要配合某个继承图系吗？</strong> 你的类是否受到基类设计地束缚，是否拥有该覆写地虚函数，是否允许被继承（若不想要被继承，应该声明为<code>final</code>）。</p><p><strong>什么样的运算符和函数对此新 type 而言是合理的？</strong> 这会影响到你将为你的类声明哪些函数和重载哪些运算符。</p><p><strong>什么样的标准函数应该被驳回？</strong> 这会影响到你将哪些标准函数声明为<code>= delete</code>。</p><p><strong>谁该取用新 type 的成员？</strong> 这会影响到你将类中哪些成员设为 public，private 或 protected，也将影响到友元类和友元函数的设置。</p><p><strong>什么是新 type 的“未声明接口”？</strong> 为未声明接口提供效率、异常安全性以及资源运用上的保证，并在实现代码中加上相应的约束条件。</p><p><strong>你的新 type 有多么一般化？</strong> 如果你想要一系列新 type 家族，应该优先考虑模板类。</p><h3 id="条款-20：宁以按常引用传参替换按值传参"><a href="#条款-20：宁以按常引用传参替换按值传参" class="headerlink" title="条款 20：宁以按常引用传参替换按值传参"></a>条款 20：宁以按常引用传参替换按值传参</h3><p>当使用按值传参时，程序会调用对象的拷贝构造函数构建一个在函数内作用的局部对象，这个过程的开销可能会较为昂贵。对于任何用户自定义类型，使用按常引用传参是较为推荐的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ValidateStudent</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为没有任何新对象被创建，这种传参方式不会调用任何构造函数或析构函数，所以效率比按值传参高得多。</p><p>使用按引用传参也可以避免<strong>对象切片（Object slicing）</strong> 的问题，参考以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    std<span class="token operator">::</span>string <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">WindowWithScrollBars</span> <span class="token operator">:</span> <span class="token keyword">public</span> Window <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处一个<code>WindowWithScrollBars</code>类继承自<code>Window</code>基类。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PrintNameAndDisplay</span><span class="token punctuation">(</span>Window w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 按值传参，会发生对象切片</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此处在传参时，调用了基类<code>Window</code>的拷贝构造函数而非派生类的拷贝构造函数，因此在函数种使用的是一个<code>Window</code>对象，调用虚函数时也只能调用到基类的虚函数<code>Window::Display</code>。</p><p>由于按引用传递不会创建新对象，这个问题就能得到避免：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PrintNameAndDisplay</span><span class="token punctuation">(</span><span class="token keyword">const</span> Window<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 参数不会被切片</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也并非永远都使用按引用传参，对于内置类型、STL的迭代器和函数对象，我们认为使用按值传参是比较合适的。</p><h3 id="条款-21：必须返回对象时，别妄想返回其引用"><a href="#条款-21：必须返回对象时，别妄想返回其引用" class="headerlink" title="条款 21：必须返回对象时，别妄想返回其引用"></a>条款 21：必须返回对象时，别妄想返回其引用</h3><p>返回一个指向函数内部局部变量的引用是严重的错误，因为局部变量在离开函数时就被销毁了，除此之外，返回一个指向局部静态变量的引用也是不被推荐的。</p><p>尽管返回对象会调用拷贝构造函数产生开销，但这开销比起出错而言微不足道。</p><h3 id="条款-22：将成员变量声明为-private"><a href="#条款-22：将成员变量声明为-private" class="headerlink" title="条款 22：将成员变量声明为 private"></a>条款 22：将成员变量声明为 private</h3><p>出于对封装性的考虑，应该尽可能地隐藏类中的成员变量，并通过对外暴露函数接口来实现对成员变量的访问：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">AccessLevels</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">GetReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> readOnly<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">SetReadWrite</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> readWrite <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">GetReadWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> readWrite<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">SetWriteOnly</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> writeOnly <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> noAccess<span class="token punctuation">;</span>    <span class="token keyword">int</span> readOnly<span class="token punctuation">;</span>    <span class="token keyword">int</span> readWrite<span class="token punctuation">;</span>    <span class="token keyword">int</span> writeOnly<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过为成员变量提供 getter 和 setter 函数，我们就能避免客户做出写入只读变量或读取只写变量这样不被允许的操作。</p><p>将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性。例如这可使得在成员变量被读或写时轻松通知其它对象，可以验证类的约束条件以及函数的提前和事后状态，可以在多线程环境中执行同步控制……</p><p><code>protected</code>和<code>public</code>一样，都不该被优先考虑。假设我们有一个public成员变量，最终取消了它，那么所有使用它的客户代码都将被破坏；假设我们有一个protected成员变量，最终取消了它，那么所有使用它的派生类都将被破坏。</p><p>综合以上讨论，在类中应当将成员变量优先声明为 private。</p><h3 id="条款-23：宁以非成员、非友元函数替换成员函数"><a href="#条款-23：宁以非成员、非友元函数替换成员函数" class="headerlink" title="条款 23：宁以非成员、非友元函数替换成员函数"></a>条款 23：宁以非成员、非友元函数替换成员函数</h3><p>假设有这样一个类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">WebBrowser</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">ClearCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">ClearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">RemoveCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要一次性调用这三个函数，那么需要额外提供一个新的函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">ClearEverything</span><span class="token punctuation">(</span>WebBrowser<span class="token operator">&amp;</span> wb<span class="token punctuation">)</span> <span class="token punctuation">{</span>    wb<span class="token punctuation">.</span><span class="token function">ClearCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wb<span class="token punctuation">.</span><span class="token function">ClearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wb<span class="token punctuation">.</span><span class="token function">RemoveCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，虽然成员函数和非成员函数都可以完成我们的目标，但此处更建议使用非成员函数，这是为了遵守一个原则：<strong>越少的代码可以访问数据，数据的封装性就越强</strong>。此处的<code>ClearEverything</code>函数仅仅是调用了<code>WebBrowser</code>的三个public成员函数，而并没有使用到<code>WebBrowser</code>内部的private成员，因此没有必要让其也拥有访问类中private成员的能力。</p><p>这个原则对于友元函数也是相同的，因为友元函数和成员函数拥有相同的权力，所以在能使用非成员函数完成任务的情况下，就不要使用友元函数和成员函数。</p><p>如果你觉得一个全局函数并不自然，也可以考虑将<code>ClearEverything</code>函数放在工具类中充当静态成员函数，或与<code>WebBrowser</code>放在同一个命名空间中：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> WebBrowserStuff <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">WebBrowser</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">ClearEverything</span><span class="token punctuation">(</span>WebBrowser<span class="token operator">&amp;</span> wb<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-24：若所有参数皆需类型转换，请为此采用非成员函数"><a href="#条款-24：若所有参数皆需类型转换，请为此采用非成员函数" class="headerlink" title="条款 24：若所有参数皆需类型转换，请为此采用非成员函数"></a>条款 24：若所有参数皆需类型转换，请为此采用非成员函数</h3><p>现在我们手头上拥有一个<code>Rational</code>类，并且它可以和<code>int</code>隐式转换：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我们需要重载乘法运算符来实现<code>Rational</code>对象之间的乘法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将运算符重载放在类中是行得通的，至少对于<code>Rational</code>对象来说是如此。但当我们考虑混合运算时，就会出现一个问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Rational <span class="token function">oneEight</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rational <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rational result <span class="token operator">=</span> oneHalf <span class="token operator">/</span> oneEight<span class="token punctuation">;</span>result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确</span>result <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> oneHalf<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如将乘法运算符写成函数形式，错误的原因就一目了然了：</p><pre class="line-numbers language-cpp"><code class="language-cpp">result <span class="token operator">=</span> oneHalf<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确</span>result <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span>oneHalf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在调用<code>operator*</code>时，<code>int</code>类型的变量会隐式转换为<code>Rational</code>对象，因此用<code>Rational</code>对象乘以<code>int</code>对象是合法的，但反过来则不是如此。</p><p>所以，为了避免这个错误，我们应当将运算符重载放在类外，作为非成员函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="条款-25：考虑写出一个不抛异常的swap函数"><a href="#条款-25：考虑写出一个不抛异常的swap函数" class="headerlink" title="条款 25：考虑写出一个不抛异常的swap函数"></a>条款 25：考虑写出一个不抛异常的swap函数</h3><p>由于<code>std::swap</code>函数在 C++11 后改为了用<code>std::move</code>实现，因此几乎已经没有性能的缺陷，也不再有像原书中所说的为自定义类型去自己实现的必要。不过原书中透露的思想还是值得一学的。</p><p>如果想为自定义类型实现自己的swap方法，可以考虑使用模板全特化，并且这种做法是被 STL 允许的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>pImpl<span class="token punctuation">,</span> other<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    WidgetImpl<span class="token operator">*</span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>    <span class="token keyword">void</span> swap<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> Widget<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，由于外部函数并不能直接访问<code>Widget</code>的private成员变量，因此我们先是在类中定义了一个 public 成员函数，再由<code>std::swap</code>去调用这个成员函数。</p><p>然而若<code>Widget</code>和<code>WidgetImpl</code>是类模板，情况就没有这么简单了，因为 C++ 不支持函数模板偏特化，所以只能使用重载的方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但很抱歉，这种做法是被 STL 禁止的，因为这是在试图向 STL 中添加新的内容，所以我们只能退而求其次，在其它命名空间中定义新的swap函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> WidgetStuff <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token number">3</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> Widget<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们希望在对自定义对象进行操作时找到正确的swap函数重载版本，这时候如果再写成<code>std::swap</code>，就会强制使用 STL 中的swap函数，无法满足我们的需求，因此需要改写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span><span class="token function">swap</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，C++ 名称查找法则能保证我们优先使用的是自定义的swap函数而非 STL 中的swap函数。</p><blockquote><p>C++ 名称查找法则：编译器会从使用名字的地方开始向上查找，由内向外查找各级作用域（命名空间）直到全局作用域（命名空间），找到同名的声明即停止，若最终没找到则报错。 函数匹配优先级：普通函数 &gt; 特化函数 &gt; 模板函数</p></blockquote><h2 id="第五章：实现"><a href="#第五章：实现" class="headerlink" title="第五章：实现"></a>第五章：实现</h2><h3 id="条款-26：尽可能延后变量定义式出现的时间"><a href="#条款-26：尽可能延后变量定义式出现的时间" class="headerlink" title="条款 26：尽可能延后变量定义式出现的时间"></a>条款 26：尽可能延后变量定义式出现的时间</h3><p>当变量定义出现时，程序需要承受其构造成本；当变量离开其作用域时，程序需要承受其析构成本。因此，避免不必要的变量定义，以及延后变量定义式直到你确实需要它。</p><p>延后变量定义式还有一个意义，即“默认构造+赋值”效率低于“直接构造”：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 效率低</span>std<span class="token operator">::</span>string encrypted<span class="token punctuation">;</span>encrypted <span class="token operator">=</span> password<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 效率高</span>std<span class="token operator">::</span>string <span class="token function">encrypted</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于循环中变量的定义，我们一般有两种做法：</p><p>A. 定义于循环外，在循环中赋值：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    w <span class="token operator">=</span> 取决于 i 的某个值<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法产生的开销：1 个构造函数 + 1 个析构函数 + n 个赋值操作</p><p>B. 定义于循环内：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Widget <span class="token function">w</span><span class="token punctuation">(</span>取决于 i 的某个值<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法产生的开销：n 个构造函数 + n 个析构函数</p><p>由于做法A会将变量的作用域扩大，因此除非知道该变量的赋值成本比“构造+析构”成本低，或者对这段程序的效率要求非常高，否则建议使用做法B。</p><h3 id="条款-27：少做转型动作"><a href="#条款-27：少做转型动作" class="headerlink" title="条款 27：少做转型动作"></a>条款 27：少做转型动作</h3><p>C 式转型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">(</span>T<span class="token punctuation">)</span>expression<span class="token function">T</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>C++ 式转型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const_cast</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>const_cast</code>用于常量性转除，这也是唯一一个有这个能力的 C++ 式转型。</li><li><code>dynamic_cast</code>用于安全地向下转型，这也是唯一一个 C 式转型无法代替的转型操作，它会执行对继承体系的检查，因此会带来额外的开销。只有拥有虚函数的基类指针能进行<code>dynamic_cast</code>。</li><li><code>reinterpret_cast</code>用于在任意两个类型间进行低级转型，执行该转型可能会带来风险，也可能不具备移植性。</li><li><code>static_cast</code>用于进行强制隐式转换，也是最常用的转型操作，可以将内置数据类型互相转换，也可以将<code>void*</code>和typed指针，基类指针和派生类指针互相转换。</li></ul><p>尽量在 C++ 程序中使用 C++ 式转型，因为 C++ 式转型操作功能更明确，可以避免不必要的错误。</p><p>唯一使用 C 式转型的时机可能是在调用 explicit 构造函数时：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">DoSomeWork</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">DoSomeWork</span><span class="token punctuation">(</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等价于 DoSomeWork(static_cast&lt;Widget>(15));</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，转型并非什么都没有做，而是可能会更改数据的底层表述，或者为指针附加偏移值，这和具体平台有关，因此不要妄图去揣测转型后对象的具体布局方式。</p><p>避免对<code>*this</code>进行转型，参考以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SpecialWindow</span> <span class="token operator">:</span> <span class="token keyword">public</span> Window <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Window<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码试图通过转型<code>*this</code>来调用基类的虚函数，然而这是严重错误的，这样做会得到一个新的<code>Window</code>副本并在该副本上调用函数，而非在原本的对象上调用函数。</p><p>正确的做法如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SpecialWindow</span> <span class="token operator">:</span> <span class="token keyword">public</span> Window <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Window<span class="token operator">::</span><span class="token function">OnResize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你想知道一个基类指针是否指向一个派生类对象时，你需要用到<code>dynamic_cast</code>，如果不满足，则会产生报错。但是对于继承体系的检查可能是非常慢的，所以在注重效率的程序中应当避免使用<code>dynamic_cast</code>，改用<code>static_cast</code>或别的代替方法。</p><h3 id="条款-28：避免返回-handles-指向对象的内部成分"><a href="#条款-28：避免返回-handles-指向对象的内部成分" class="headerlink" title="条款 28：避免返回 handles 指向对象的内部成分"></a>条款 28：避免返回 handles 指向对象的内部成分</h3><p>考虑以下<code>Rectangle</code>类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> RectData <span class="token punctuation">{</span>    Point ulhc<span class="token punctuation">;</span>    Point lrhc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Point<span class="token operator">&amp;</span> <span class="token function">UpperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>ulhc<span class="token punctuation">;</span> <span class="token punctuation">}</span>    Point<span class="token operator">&amp;</span> <span class="token function">LowerRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>lrhc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>RectData<span class="token operator">></span> pData<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码看起来没有任何问题，但其实是在做自我矛盾的事情：我们通过const成员函数返回了一个指向成员变量的引用，这使得成员变量可以在外部被修改，而这是违反 logical constness 的原则的。换句话说，你<strong>绝对不应该令成员函数返回一个指针指向“访问级别较低”的成员函数</strong>。</p><p>改成返回常引用可以避免对成员变量的修改：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> <span class="token function">UpperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>ulhc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> <span class="token function">LowerRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>lrhc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是这样依然会带来一个称作 <strong>dangling handles（空悬句柄）</strong> 的问题，当对象不复存在时，你将无法通过引用获取到返回的数据。</p><p>采用最保守的做法，返回一个成员变量的副本：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Point <span class="token function">UpperLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>ulhc<span class="token punctuation">;</span> <span class="token punctuation">}</span>Point <span class="token function">LowerRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pData<span class="token operator">-</span><span class="token operator">></span>lrhc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>避免返回 handles（包括引用、指针、迭代器）指向对象内部。遵循这个条款可增加封装性，使得const成员函数的行为符合常量性，并将发生 “空悬句柄” 的可能性降到最低。</p><h3 id="条款-29：为“异常安全”而努力是值得的"><a href="#条款-29：为“异常安全”而努力是值得的" class="headerlink" title="条款 29：为“异常安全”而努力是值得的"></a>条款 29：为“异常安全”而努力是值得的</h3><p>异常安全函数提供以下三个保证之一：</p><p><strong>基本承诺：</strong> 如果异常被抛出，程序内的任何事物仍然保持在有效状态下，没有任何对象或数据结构会因此败坏，所有对象都处于一种内部前后一致的状态，然而程序的真实状态是不可知的，也就是说客户需要额外检查程序处于哪种状态并作出对应的处理。</p><p><strong>强烈保证：</strong> 如果异常被抛出，程序状态完全不改变，换句话说，程序会回复到“调用函数之前”的状态。</p><p><strong>不抛掷（nothrow）保证：</strong> 承诺绝不抛出异常，因为程序总是能完成原先承诺的功能。作用于内置类型身上的所有操作都提供 nothrow 保证。</p><p>原书中实现 nothrow 的方法是<code>throw()</code>，不过这套异常规范在 C++11 中已经被弃用，取而代之的是<code>noexcept</code>关键字：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，使用<code>noexcept</code>并不代表函数绝对不会抛出异常，而是在抛出异常时，将代表出现严重错误，会有意想不到的函数被调用（可以通过<code>set_unexpected</code>设置），接着程序会直接崩溃。</p><p>当异常被抛出时，带有异常安全性的函数会：</p><ol><li>不泄漏任何资源。</li><li>不允许数据败坏。</li></ol><p>考虑以下<code>PrettyMenu</code>的<code>ChangeBackground</code>函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PrettyMenu</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">ChangeBackground</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    Mutex mutex<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 互斥锁</span>    Image<span class="token operator">*</span> bgImage<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 目前的背景图像</span>    <span class="token keyword">int</span> imageChanges<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 背景图像被改变的次数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> PrettyMenu<span class="token operator">::</span><span class="token function">ChangeBackground</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> bgImage<span class="token punctuation">;</span>    <span class="token operator">++</span>imageChanges<span class="token punctuation">;</span>    bgImage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Image</span><span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显这个函数不满足我们所说的具有异常安全性的任何一个条件，若在函数中抛出异常，<code>mutex</code>会发生资源泄漏，<code>bgImage</code>和<code>imageChanges</code>也会发生数据败坏。</p><p>通过以对象管理资源，使用智能指针和调换代码顺序，我们能将其变成一个具有强烈保证的异常安全函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> PrettyMenu<span class="token operator">::</span><span class="token function">ChangeBackground</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Lock <span class="token function">m1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    bgImage<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Image<span class="token operator">></span><span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>imageChanges<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个常用于提供强烈保证的方法是我们所提到过的 copy and swap，为你打算修改的对象做出一份副本，对副本执行修改，并在所有修改都成功执行后，用一个不会抛出异常的swap方法将原件和副本交换：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> PMImpl <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Image<span class="token operator">></span> bgImage<span class="token punctuation">;</span>    <span class="token keyword">int</span> imageChanges<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">PrettyMenu</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    Mutex mutex<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>PMImpl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> PrettyMenu<span class="token operator">::</span><span class="token function">ChangeBackground</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token operator">&amp;</span> imgSrc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Lock <span class="token function">m1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> pNew <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>PMImpl<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取副本</span>    pNew<span class="token operator">-</span><span class="token operator">></span>bgImage<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Image<span class="token operator">></span><span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>pNew<span class="token operator">-</span><span class="token operator">></span>imageChanges<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>pImpl<span class="token punctuation">,</span> pNew<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当一个函数调用其它函数时，函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的“异常安全保证”中的最弱者。</p><p>强烈保证并非永远都是可实现的，特别是当函数在操控非局部对象时，这时就只能退而求其次选择不那么美好的基本承诺，并将该决定写入文档，让其他人维护时不至于毫无心理准备。</p><h3 id="条款-30：透彻了解-inlining-的里里外外"><a href="#条款-30：透彻了解-inlining-的里里外外" class="headerlink" title="条款 30：透彻了解 inlining 的里里外外"></a>条款 30：透彻了解 inlining 的里里外外</h3><p>将函数声明为内联一共有两种方法，一种是为其显式指定<code>inline</code>关键字，另一种是直接将成员函数的定义式写在类中，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> <span class="token function">Age</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> theAge<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 隐式声明为 inline</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> theAge<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>inline</code>诞生之初，它被当作是一种对编译器的优化建议，即将“对此函数的每一个调用”都以函数本体替换之。但在编译器的具体实现中，该行为完全被优化等级所控制，与函数是否内联无关。</p><p>在现在的 C++ 标准中，<code>inline</code>作为优化建议的含义已经被完全抛弃，取而代之的是“允许函数在不同编译单元中多重定义”，使得可以在头文件中直接给出函数的实现。</p><p>在 C++17 中，引入了一个新的<code>inline</code>用法，使静态成员变量可以在类中直接定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> theAge <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// since C++17</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-31：将文件间的编译依存关系降至最低"><a href="#条款-31：将文件间的编译依存关系降至最低" class="headerlink" title="条款 31：将文件间的编译依存关系降至最低"></a>条款 31：将文件间的编译依存关系降至最低</h3><p>C++ 坚持将类的实现细节放置于类的定义式中，这就意味着，即使你只改变类的实现而不改变类的接口，在构建程序时依然需要重新编译。这个问题的根源出在编译器必须在编译期间知道对象的大小，如果看不到类的定义式，就没有办法为对象分配内存。也就是说，C++ 并没有把“将接口从实现中分离”这件事做得很好。</p><p><strong>用“声明的依存性”替换“定义的依存性”：</strong></p><p>我们可以玩一个“将对象实现细目隐藏于一个指针背后”的游戏，称作 <strong>pimpl idiom（pimpl 是 pointer to implemention 的缩写）</strong>：将原来的一个类分割为两个类，一个只提供接口，另一个负责实现该接口，称作<strong>句柄类（handle class）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// person.hpp 负责声明类</span><span class="token keyword">class</span> <span class="token class-name">PersonImpl</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>PersonImpl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// person.cpp 负责实现类</span><span class="token keyword">class</span> <span class="token class-name">PersonImpl</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> data<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Person<span class="token operator">::</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pImpl <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>PersonImpl<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> Person<span class="token operator">::</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> pImpl<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，假如我们要修改<code>Person</code>的private成员，就只需要修改<code>PersonImpl</code>中的内容，而<code>PersonImpl</code>的具体实现是被隐藏起来的，对它的任何修改都不会使得<code>Person</code>客户端重新编译，真正实现了“类的接口和实现分离”。</p><p><strong>如果使用对象引用或对象指针可以完成任务，就不要使用对象本身：</strong></p><p>你可以只靠一个类型声明式就定义出指向该类型的引用和指针；但如果定义某类型的对象，就需要用到该类型的定义式。</p><p><strong>如果能够，尽量以类声明式替换类定义式：</strong></p><p>当你在声明一个函数而它用到某个类时，你不需要该类的定义；但当你触及到该函数的定义式后，就必须也知道类的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 类的声明式</span>Date <span class="token function">Today</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ClearAppointments</span><span class="token punctuation">(</span>Data d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此处并不需要得知类的定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>为声明式和定义式提供不同的头文件：</strong></p><p>为了避免频繁地添加声明，我们应该为所有要用的类声明提供一个头文件，这种做法对 template 也适用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"datefwd.h"</span>            </span><span class="token comment" spellcheck="true">// 这个头文件内声明 class Date</span>Date <span class="token function">Today</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ClearAppointments</span><span class="token punctuation">(</span>Data d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此处的头文件命名方式<code>&quot;datefwd.h&quot;</code>取自标准库中的<code>&lt;iosfwd&gt;</code>。</p><p>上面我们讲述了接口与实现分离的其中一个方法——提供句柄类，另一个方法就是将句柄类定义为抽象基类，称作<strong>接口类（interface class）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了将<code>Person</code>对象实际创建出来，我们一般采用工厂模式。可以尝试在类中塞入一个静态成员函数<code>Create</code>用于创建对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但此时<code>Create</code>函数还无法使用，需要在派生类中给出<code>Person</code>类中的函数的具体实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">RealPerson</span> <span class="token operator">:</span> <span class="token keyword">public</span> Person <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">RealPerson</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">RealPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> data<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成<code>Create</code>函数的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">></span> Person<span class="token operator">::</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>RealPerson<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>毫无疑问的是，句柄类和接口类都需要额外的开销：句柄类需要通过 pimpl 取得对象数据，增加一层间接访问、指针大小和动态分配内存带来的开销；而接口类会增加存储虚表指针和实现虚函数跳转带来的开销。</p><p>而当这些开销过于重大以至于类之间的耦合度在相形之下不成为关键时，就以具象类（concrete class）替换句柄类和接口类。</p><h2 id="第六章：继承与面向对象设计"><a href="#第六章：继承与面向对象设计" class="headerlink" title="第六章：继承与面向对象设计"></a>第六章：继承与面向对象设计</h2><h3 id="条款-32：确定你的public继承塑模出-is-a-关系"><a href="#条款-32：确定你的public继承塑模出-is-a-关系" class="headerlink" title="条款 32：确定你的public继承塑模出 is-a 关系"></a>条款 32：确定你的public继承塑模出 is-a 关系</h3><p>“public继承”意味着 is-a，所谓 is-a，就是指适用于基类身上的每一件事情一定也适用于继承类身上，因为我们可以认为每一个派生类对象也都是一个基类对象。</p><p>这看似很自然，但在面对自然语言的表述时，往往会产生歧义。</p><p>考虑<code>Bird</code>类和<code>Penguin</code>类的继承关系：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Penguin</span> <span class="token operator">:</span> <span class="token keyword">public</span> Bird <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Penguin</code>类会获得来自<code>Bird</code>类的飞行方法，这就造成了误解，因为企鹅恰恰是不会飞的鸟类。一种解决方法是当调用<code>Penguin</code>类中的<code>Fly</code>函数时，抛出一个运行期错误，但这种做法通常不够直观；另一个解决方法是使用双继承，区分会飞和不会飞的鸟类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">FlyingBird</span> <span class="token operator">:</span> <span class="token keyword">public</span> Bird <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Penguin</span> <span class="token operator">:</span> <span class="token keyword">public</span> FlyingBird <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但若要处理鸟类的多钟不同属性时，双继承模式就不太管用了，因此我们总是说程序设计没有银弹。</p><p>另一个常见的例子是用<code>Square</code>类继承自<code>Rectangle</code>类，从几何学的角度来讲这很自然，然而正方形的长宽是相等的，矩形却不是如此，因此<code>Square</code>类和<code>Rectangle</code>类也无法满足严格的 is-a 关系。</p><h3 id="条款-33：避免遮掩继承而来的名称"><a href="#条款-33：避免遮掩继承而来的名称" class="headerlink" title="条款 33：避免遮掩继承而来的名称"></a>条款 33：避免遮掩继承而来的名称</h3><p>之前我们了解过 C++ 名称查找法则，这在继承体系中也是类似的，当我们在派生类中使用到一个名字时，编译器会优先查找派生类覆盖的作用域，如果没找到，再去查找基类的作用域，最后再查找全局作用域。</p><p>考虑以下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样会导致派生类无法使用来自基类的重载函数，因为派生类中的名称<code>mf</code>掩盖了来自基类的名称<code>mf</code>。</p><p>对于名称掩盖问题的一种方法是使用<code>using</code>关键字：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token operator">::</span>mf<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>using</code>关键字会将基类中所有使用到名称<code>mf</code>的函数全部包含在派生类中，包括其重载版本。</p><p>若有时我们不想要一个函数的全部版本，只想要单一版本（特别是在private继承时），可以考虑使用<strong>转发函数（forwarding function）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Base<span class="token operator">::</span><span class="token function">mf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-34：区分接口继承和实现继承"><a href="#条款-34：区分接口继承和实现继承" class="headerlink" title="条款 34：区分接口继承和实现继承"></a>条款 34：区分接口继承和实现继承</h3><ol><li>接口继承和实现继承不一样。在public继承下，派生类总是继承基类的接口。</li><li>声明一个纯虚函数的目的，是为了让派生类只继承函数接口。</li><li>声明简朴的非纯虚函数的目的，是让派生类继承该函数的接口和缺省实现。</li><li>声明非虚函数的目的，是为了令派生类继承函数的接口及一份强制性实现。</li></ol><p>通常而言，我们不会为纯虚函数提供具体实现，然而这样做是被允许的，并且用于替代简朴的非纯虚函数，提供更平常更安全的缺省实现。</p><p>用非纯虚函数提供缺省的默认实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Airplane</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 缺省实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Model</span> <span class="token operator">:</span> <span class="token keyword">public</span> Airplane <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是最简朴的做法，但是这样做会带来的问题是，由于不强制对虚函数的覆写，在定义新的派生类时可能会忘记进行覆写，导致错误地使用了缺省实现。</p><p>使用纯虚函数并提供默认实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Airplane</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">DefaultFly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 缺省实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Model</span> <span class="token operator">:</span> <span class="token keyword">public</span> Airplane <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        <span class="token function">DefaultFly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述写法可以替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Airplane</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> Airplane<span class="token operator">::</span><span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 缺省实现</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Model</span> <span class="token operator">:</span> <span class="token keyword">public</span> Airplane <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override <span class="token punctuation">{</span>        Airplane<span class="token operator">::</span><span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-35：考虑虚函数以外的其它选择"><a href="#条款-35：考虑虚函数以外的其它选择" class="headerlink" title="条款 35：考虑虚函数以外的其它选择"></a>条款 35：考虑虚函数以外的其它选择</h3><p><strong>藉由非虚接口手法实现 template method：</strong></p><p><strong>非虚接口（non-virtual interface，NVI）</strong> 设计手法的核心就是用一个非虚函数作为 wrapper，将虚函数隐藏在封装之下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">HealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 做一些前置工作</span>        <span class="token keyword">int</span> retVal <span class="token operator">=</span> <span class="token function">DoHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 做一些后置工作</span>        <span class="token keyword">return</span> retVal<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">DoHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 缺省算法</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NVI手法的一个优点就是在 wrapper 中做一些前置和后置工作，确保得以在一个虚函数被调用之前设定好适当场景，并在调用结束之后清理场景。如果你让客户直接调用虚函数，就没有任何好办法可以做这些事。</p><p>NVI手法允许派生类重新定义虚函数，从而赋予它们“如何实现机能”的控制能力，但基类保留诉说“函数何时被调用”的权利。</p><p>在NVI手法中虚函数除了可以是private，也可以是protected，例如要求在派生类的虚函数实现内调用其基类的对应虚函数时，就必须得这么做。</p><p><strong>藉由函数指针实现 Strategy 模式：</strong></p><p>参考以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">DefaultHealthCalc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 缺省算法</span><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> HealthCalcFunc <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义函数指针类型</span>    <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalcFunc hcf <span class="token operator">=</span> DefaultHealthCalc<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span>hcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">HealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    HealthCalcFunc healthFunc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同一个人物类型的不同实体可以有不同的健康计算函数，并且该计算函数可以在运行期变更。</p><p>这间接表明健康计算函数不再是<code>GameCharacter</code>继承体系内的成员函数，它也无权使用非public成员。为了填补这个缺陷，我们唯一的做法是弱化类的封装，引入友元或提供public访问函数。</p><p><strong>藉由 std::function 完成 Strategy 模式</strong></p><p><code>std::function</code>是 C++11 中引入的函数包装器，使用它能提供比函数指针更强的灵活度：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">DefaultHealthCalc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 缺省算法</span><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> HealthCalcFunc <span class="token operator">=</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义函数包装器类型</span>    <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalcFunc hcf <span class="token operator">=</span> DefaultHealthCalc<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span>hcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">HealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    HealthCalcFunc healthFunc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来并没有很大的改变，但当我们需要时，<code>std::function</code>就能展现出惊人的弹性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 使用返回值不同的函数</span><span class="token keyword">short</span> <span class="token function">CalcHealth</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>GameCharacter <span class="token function">chara1</span><span class="token punctuation">(</span>CalcHealth<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用函数对象（仿函数）</span><span class="token keyword">struct</span> HealthCalculator <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>GameCharacter <span class="token function">chara2</span><span class="token punctuation">(</span><span class="token function">HealthCalculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用某个成员函数</span><span class="token keyword">class</span> <span class="token class-name">GameLevel</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">float</span> <span class="token function">Health</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>GameLevel currentLevel<span class="token punctuation">;</span>GameCharacter <span class="token function">chara2</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>GameLevel<span class="token operator">::</span>Health<span class="token punctuation">,</span> currentLevel<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>古典的 Strategy 模式：</strong></p><p>在古典的 Strategy 模式中，我们并非直接利用函数指针（或包装器）调用函数，而是内含一个指针指向来自<code>HealthCalcFunc</code>继承体系的对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">HealthCalcFunc</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">Calc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span> gc<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>HealthCalcFunc defaultHealthCalc<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalcFunc<span class="token operator">*</span> phcf <span class="token operator">=</span> <span class="token operator">&amp;</span>defaultHealthCalc<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">pHealthCalc</span><span class="token punctuation">(</span>phcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">HealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> pHealthCalc<span class="token operator">-</span><span class="token operator">></span><span class="token function">Calc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    HealthCalcFunc<span class="token operator">*</span> pHealthCalc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个设计模式的好处在于足够容易辨认，想要添加新的计算函数也只需要为<code>HealthCalcFunc</code>基类添加一个派生类即可。</p><h3 id="条款-36：绝不重新定义继承而来的非虚函数"><a href="#条款-36：绝不重新定义继承而来的非虚函数" class="headerlink" title="条款 36：绝不重新定义继承而来的非虚函数"></a>条款 36：绝不重新定义继承而来的非虚函数</h3><p>非虚函数和虚函数具有本质上的不同：非虚函数执行的是静态绑定（statically bound，又称前期绑定，early binding），由对象类型本身（称之静态类型）决定要调用的函数；而虚函数执行的是动态绑定（dynamically bound，又称后期绑定，late binding），决定因素不在对象本身，而在于“指向该对象之指针”当初的声明类型（称之动态类型）。</p><p>前面我们已经说过，public继承意味着 is-a 关系，而在基类中声明一个非虚函数将会为该类建立起一种不变性（invariant），凌驾其特异性（specialization）。而若在派生类中重新定义该非虚函数，则会使人开始质疑是否该使用public继承的形式；如果必须使用，则又打破了基类“不变性凌驾特异性”的性质，就此产生了设计上的矛盾。</p><p>综上所述，在任何情况下都不该重新定义一个继承而来的非虚函数。</p><h3 id="条款-37：绝不重新定义继承而来的缺省参数值"><a href="#条款-37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款 37：绝不重新定义继承而来的缺省参数值"></a>条款 37：绝不重新定义继承而来的缺省参数值</h3><p>在条款 36 中我们已经否定了重新定义非虚函数的可能性，因此此处我们只讨论带有缺省参数值的虚函数。</p><p>虚函数是动态绑定而来，意思是调用一个虚函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。但与之不同的是，<strong>缺省参数值却是静态绑定</strong>，意思是你可能会在“调用一个定义于派生类的虚函数”的同时，却使用基类为它所指定的缺省参数值。考虑以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShapeColor</span> <span class="token punctuation">{</span> Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>ShapeColor color <span class="token operator">=</span> ShapeColor<span class="token operator">::</span>Red<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>ShapeColor color <span class="token operator">=</span> ShapeColor<span class="token operator">::</span>Green<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>ShapeColor color<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时若对派生类对象调用<code>Draw</code>函数，则会发现：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Shape<span class="token operator">*</span> pr <span class="token operator">=</span> <span class="token keyword">new</span> Rectangle<span class="token punctuation">;</span>Shape<span class="token operator">*</span> pc <span class="token operator">=</span> <span class="token keyword">new</span> Circle<span class="token punctuation">;</span>pr<span class="token operator">-</span><span class="token operator">></span><span class="token function">Draw</span><span class="token punctuation">(</span>Shape<span class="token operator">::</span>ShapeColor<span class="token operator">::</span>Green<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用 Rectangle::Draw(Shape::Green)</span>pr<span class="token operator">-</span><span class="token operator">></span><span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 调用 Rectangle::Draw(Shape::Red)</span>pc<span class="token operator">-</span><span class="token operator">></span><span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 调用 Rectangle::Draw(Shape::Red)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就迫使我们在指定虚函数时使用相同的缺省参数值，为了避免不必要的麻烦和错误，可以考虑条款 35 中列出的虚函数的替代设计，例如NVI手法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ShapeColor</span> <span class="token punctuation">{</span> Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>ShapeColor color <span class="token operator">=</span> ShapeColor<span class="token operator">::</span>Red<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token function">DoDraw</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">DoDraw</span><span class="token punctuation">(</span>ShapeColor color<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token operator">:</span> <span class="token keyword">public</span> Shape <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">DoDraw</span><span class="token punctuation">(</span>ShapeColor color<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-38：通过复合塑模出-has-a-或“根据某物实现出”"><a href="#条款-38：通过复合塑模出-has-a-或“根据某物实现出”" class="headerlink" title="条款 38：通过复合塑模出 has-a 或“根据某物实现出”"></a>条款 38：通过复合塑模出 has-a 或“根据某物实现出”</h3><p>所谓<strong>复合（composition）</strong>，指的是某种类型的对象内含它种类型的对象。复合通常意味着 <strong>has-a</strong> 或<strong>根据某物实现出（is-implemented-in-terms-of）</strong> 的关系，当复合发生于应用域（application domain）内的对象之间，表现出 has-a 的关系；当它发生于实现域（implementation domain）内则是表现出“根据某物实现出”的关系。</p><p>下面是一个 has-a 关系的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Address</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">PhoneNumber</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 合成成分物（composed object）</span>    Address address<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 同上</span>    PhoneNumber voiceNumber<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 同上</span>    PhoneNumber faxNumber<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 同上</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是一个“根据某物实现出”关系的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 将 list 应用于 Set</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Set</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">member</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">></span> rep<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 用来表述 Set 的数据</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-39：明智而审慎地使用private继承"><a href="#条款-39：明智而审慎地使用private继承" class="headerlink" title="条款 39：明智而审慎地使用private继承"></a>条款 39：明智而审慎地使用private继承</h3><p>private继承的特点：</p><ol><li>如果类之间是private继承关系，那么编译器不会自动将一个派生类对象转换为一个基类对象。</li><li>由private继承来的所有成员，在派生类中都会变为private属性，换句话说，private继承只继承实现，不继承接口。</li></ol><p>private继承的意义是“根据某物实现出”，如果你读过条款 38，就会发现private继承和复合具有相同的意义，事实上也确实如此，绝大部分private继承的使用场合都可以被“public继承+复合”完美解决：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Timer</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token keyword">int</span> tickFrequency<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">private</span> Timer <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">WidgetTimer</span> <span class="token operator">:</span> <span class="token keyword">public</span> Timer <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">OnTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    WidgetTimer timer<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用后者比前者好的原因有以下几点：</p><ol><li>private继承无法阻止派生类重新定义虚函数，但若使用public继承定义<code>WidgetTimer</code>类并复合在<code>Widget</code>类中，就能防止在<code>Widget</code>类中重新定义虚函数。</li><li>可以仅提供<code>WidgetTimer</code>类的声明，并将<code>WidgetTimer</code>类的具体定义移至实现文件中，从而降低<code>Widget</code>的编译依存性。</li></ol><p>然而private继承并非完全一无是处，一个适用于它的极端情况是<strong>空白基类最优化（empty base optimization，EBO）</strong>，参考以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Empty</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">HoldsAnInt</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    Empty e<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个没有非静态成员变量、虚函数的类，看似不需要任何存储空间，但实际上 C++ 规定凡是独立对象都必须有非零大小，因此此处<code>sizeof(HoldsAnInt)</code>必然大于<code>sizeof(int)</code>，通常会多出一字节大小，但有时考虑到内存对齐之类的要求，可能会多出更多的空间。</p><p>使用private继承可以避免产生额外存储空间，将上面的代码替代为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">HoldsAnInt</span> <span class="token operator">:</span> <span class="token keyword">private</span> Empty <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-40：明智而审慎地使用多重继承"><a href="#条款-40：明智而审慎地使用多重继承" class="headerlink" title="条款 40：明智而审慎地使用多重继承"></a>条款 40：明智而审慎地使用多重继承</h3><p>多重继承是一个可能会造成很多歧义和误解的设计，因此反对它的声音此起彼伏，下面我们来接触几个使用多重继承的场景。</p><p>最先需要认清的一件事是，程序有可能从一个以上的基类继承相同名称，那会导致较多的歧义机会：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BorrowableItem</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">CheckOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ElectronicGadget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">CheckOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MP3Player</span> <span class="token operator">:</span> <span class="token keyword">public</span> BorrowableItem<span class="token punctuation">,</span> <span class="token keyword">public</span> ElectronicGadget <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MP3Player mp<span class="token punctuation">;</span>mp<span class="token punctuation">.</span><span class="token function">CheckOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// MP3Player::CheckOut 不明确！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果真遇到这种情况，必须明确地指出要调用哪一个基类中的函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">mp<span class="token punctuation">.</span>BorrowableItem<span class="token operator">::</span><span class="token function">CheckOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用 BorrowableItem::CheckOut</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用多重继承时，我们可能会遇到要命的“菱形继承”：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">File</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">InputFile</span> <span class="token operator">:</span> <span class="token keyword">public</span> File <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">OutputFile</span> <span class="token operator">:</span> <span class="token keyword">public</span> File <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">IOFile</span> <span class="token operator">:</span> <span class="token keyword">public</span> InputFile<span class="token punctuation">,</span> <span class="token keyword">public</span> OutputFile <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候必须面对这样一个问题：是否打算让基类内的成员变量经由每一条路径被复制？如果不想要这样，应当使用虚继承，指出其愿意共享基类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">File</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">InputFile</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> File <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">OutputFile</span> <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> File <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">IOFile</span> <span class="token operator">:</span> <span class="token keyword">public</span> InputFile<span class="token punctuation">,</span> <span class="token keyword">public</span> OutputFile <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而由于虚继承会在派生类中额外存储信息来确认成员来自于哪个基类，虚继承通常会付出更多空间和速度的代价，并且由于虚基类的初始化责任是由继承体系中最底层的派生类负责，就导致了虚基类必须认知其虚基类并且承担虚基类的初始化责任。因此我们应当遵循以下两个建议：</p><ol><li>非必要不使用虚继承。</li><li>如果必须使用虚继承，尽可能避免在虚基类中放置数据。</li></ol><p>多重继承可用于结合public继承和private继承，public继承用于提供接口，private继承用于提供实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// IPerson 类指出要实现的接口</span><span class="token keyword">class</span> <span class="token class-name">IPerson</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">IPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">BirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">DatabaseID</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// PersonInfo 类有若干已实现的函数</span><span class="token comment" spellcheck="true">// 可用以实现 IPerson 接口</span><span class="token keyword">class</span> <span class="token class-name">PersonInfo</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">PersonInfo</span><span class="token punctuation">(</span>DatabaseID pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">PersonInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">TheName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">TheBirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ValueDelimOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ValueDelimClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// CPerson 类使用多重继承</span><span class="token keyword">class</span> <span class="token class-name">CPerson</span><span class="token operator">:</span> <span class="token keyword">public</span> IPerson<span class="token punctuation">,</span> <span class="token keyword">private</span> PersonInfo <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">CPerson</span><span class="token punctuation">(</span>DatabaseID pid<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">PersonInfo</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 实现必要的 IPerson 成员函数</span>        <span class="token keyword">return</span> PersonInfo<span class="token operator">::</span><span class="token function">TheName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token keyword">virtual</span> std<span class="token operator">::</span>string <span class="token function">BirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 实现必要的 IPerson 成员函数</span>        <span class="token keyword">return</span> PersonInfo<span class="token operator">::</span><span class="token function">TheBirthDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 重新定义继承而来的虚函数</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ValueDelimOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ValueDelimClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第七章：模板与泛型编程"><a href="#第七章：模板与泛型编程" class="headerlink" title="第七章：模板与泛型编程"></a>第七章：模板与泛型编程</h2><h3 id="条款-41：了解隐式接口和编译期多态"><a href="#条款-41：了解隐式接口和编译期多态" class="headerlink" title="条款 41：了解隐式接口和编译期多态"></a>条款 41：了解隐式接口和编译期多态</h3><p>类与模板都支持接口和多态。对于类而言接口是显式的，以函数签名为中心，多态则是通过虚函数发生于运行期；而对模板参数而言，接口是隐式的，奠基于有效表达式，多态则是通过模板具现化和函数重载解析（function overloading resolution）发生于编译期。</p><p>考虑以下例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">DoProcessing</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> w <span class="token operator">!=</span> someNastyWidget<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中，<code>T</code>类型的隐式接口要求：</p><ol><li>提供一个名为<code>size</code>的成员函数，该函数的返回值可与<code>int</code>（10 的类型）执行<code>operator&gt;</code>，或经过隐式转换后可执行<code>operator&gt;</code>。</li><li>必须支持一个<code>operator!=</code>函数，接受<code>T</code>类型和<code>someNastyWidget</code>的类型，或其隐式转换后得到的类型。</li></ol><blockquote><p>此处没有考虑<code>operator&amp;&amp;</code>被重载的可能性。</p></blockquote><p>加诸于模板参数身上的隐式接口，就像加诸于类对象身上的显式接口“一样真实”，两者都在编译期完成检查，你无法在模板中使用“不支持模板所要求之隐式接口”的对象（代码无法通过编译）。</p><h3 id="条款-42：了解-typename-的双重含义"><a href="#条款-42：了解-typename-的双重含义" class="headerlink" title="条款 42：了解 typename 的双重含义"></a>条款 42：了解 typename 的双重含义</h3><p>在模板声明式中，使用<code>class</code>和<code>typename</code>关键字并没有什么不同，但在模板内部，<code>typename</code>拥有更多的一重含义。</p><p>为了方便解释，我们首先需要引入一个模板相关的概念：模板内出现的名称如果相依于某个模板参数，我们称之为<strong>从属名称（dependent names）</strong>；如果从属名称在类内呈嵌套状，我们称之为<strong>嵌套从属名称（nested dependent name）</strong>；如果一个名称并不倚赖任何模板参数的名称，我们称之为<strong>非从属名称（non-dependent names）</strong>。</p><p>考虑以下模板代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> C<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">Print2nd</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        C<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>iter<span class="token punctuation">;</span>        <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码看起来没有任何问题，但实际编译时却会报错，这一切的罪魁祸首便是<code>C::const_iterator</code>。此处的<code>C::const_iterator</code>是一个指向某类型的<strong>嵌套从属类型名称（nested dependent type name）</strong>，而嵌套从属名称可能会导致解析困难，因为在编译器知道<code>C</code>是什么之前，没有任何办法知道<code>C::const_iterator</code>是否为一个类型，这就导致出现了歧义状态，而 C++ 默认假设嵌套从属名称不是类型名称。</p><p>显式指明嵌套从属类型名称的方法就是将<code>typename</code>关键字作为其前缀词：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typename</span> C<span class="token operator">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样地，若嵌套从属名称出现在模板函数声明部分，也需要显式地指明是否为类型名称：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> C<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">Print2nd</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">typename</span> C<span class="token operator">::</span>iterator iter<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这一规则的例外是，<code>typename</code>不可以出现在基类列表内的嵌套从属类型名称之前，也不可以在成员初始化列表中作为基类的修饰符：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>Nested <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 基类列表中不允许使用 typename</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>        <span class="token operator">:</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">Nested</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 成员初始化列表中不允许使用 typename</span>        <span class="token keyword">typename</span> Base<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>Nested temp<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在类型名称过于复杂时，可以使用<code>using</code>或<code>typedef</code>来进行简化：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> value_type <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token operator">::</span>value_type<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="条款-43：学习处理模板化基类内的名称"><a href="#条款-43：学习处理模板化基类内的名称" class="headerlink" title="条款 43：学习处理模板化基类内的名称"></a>条款 43：学习处理模板化基类内的名称</h3><p>在模板编程中，模板类的继承并不像普通类那么自然，考虑以下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MsgInfo</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Company<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">MsgSender</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">SendClear</span><span class="token punctuation">(</span><span class="token keyword">const</span> MsgInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Company<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">LoggingMsgSender</span> <span class="token operator">:</span> <span class="token keyword">public</span> MsgSender<span class="token operator">&lt;</span>Company<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">SendClearMsg</span><span class="token punctuation">(</span><span class="token keyword">const</span> MsgInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">SendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用基类函数，这段代码无法通过编译</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，由于直到模板类被真正实例化之前，编译器并不知道<code>MsgSender&lt;Company&gt;</code>具体长什么样，有可能它是一个全特化的版本，而在这个版本中不存在<code>SendClear</code>函数。由于 C++ 的设计策略是宁愿较早进行诊断，所以编译器会拒绝承认在基类中存在一个<code>SendClear</code>函数。</p><p>为了解决这个问题，我们需要令 C++“进入模板基类观察”的行为生效，有三种办法达成这个目标：</p><p>第一种：在基类函数调用动作之前加上<code>this-&gt;</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">SendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二种：使用<code>using</code>声明式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> MsgSender<span class="token operator">&lt;</span>Company<span class="token operator">></span><span class="token operator">::</span>SendClear<span class="token punctuation">;</span><span class="token function">SendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第三种：明白指出被调用的函数位于基类内：</p><pre class="line-numbers language-cpp"><code class="language-cpp">MsgSender<span class="token operator">&lt;</span>Company<span class="token operator">></span><span class="token operator">::</span><span class="token function">SendClear</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三种做法是最不令人满意的，如果被调用的是虚函数，上述的明确资格修饰（explicit qualification）会使“虚函数绑定行为”失效。</p><h3 id="条款-44：将与参数无关的代码抽离模板"><a href="#条款-44：将与参数无关的代码抽离模板" class="headerlink" title="条款 44：将与参数无关的代码抽离模板"></a>条款 44：将与参数无关的代码抽离模板</h3><p>模板可以节省时间和避免代码重复，编译器会为填入的每个不同模板参数具现化出一份对应的代码，但长此以外，可能会造成代码膨胀（code bloat），生成浮夸的二进制目标码。</p><p>基于<strong>共性和变性分析（commonality and variability analysis）</strong> 的方法，我们需要分析模板中重复使用的部分，将其抽离出模板，以减轻模板具现化带来的代码量。</p><ul><li>因非类型模板参数而造成的代码膨胀，往往可以消除，做法是以函数参数或类成员变量替换模板参数。</li><li>因类型模板参数而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表述的具现类型共享实现代码。</li></ul><p>参考以下矩阵类的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token operator">></span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrixBase</span> <span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Invert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t matrixSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token operator">></span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span> <span class="token operator">:</span> <span class="token keyword">private</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// private 继承实现，见条款 39</span>    <span class="token keyword">using</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>Invert<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 避免掩盖基类函数，见条款 33</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">Invert</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">// 调用模板基类函数，见条款 43</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Invert</code>并不是我们唯一要使用的矩阵操作函数，而且每次都往基类传递矩阵尺寸显得太过繁琐，我们可以考虑将数据放在派生类中，在基类中储存指针和矩阵尺寸。修改代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrixBase</span> <span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token function">SquareMatrixBase</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t n<span class="token punctuation">,</span> T<span class="token operator">*</span> pMem<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">size</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pData</span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">SetDataPtr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> pData <span class="token operator">=</span> ptr<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>size_t size<span class="token punctuation">;</span>    T<span class="token operator">*</span> pData<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span> <span class="token operator">:</span> <span class="token keyword">private</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">SquareMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> data<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>array<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token operator">></span> data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而这种做法并非永远能取得优势，硬是绑着矩阵尺寸的那个版本，有可能生成比共享版本更佳的代码。例如在尺寸专属版中，尺寸是个编译期常量，因此可以在编译期藉由常量的广传达到最优化；而在共享版本中，不同大小的矩阵只拥有单一版本的函数，可减少可执行文件大小，也就因此降低程序的 working set（在“虚内存环境”下执行的进程所使用的一组内存页），并强化指令高速缓存区内的引用集中化（locality of reference），这些都可能使程序执行得更快速。究竟哪个版本更佳，只能经由具体的测试后决定。</p><p>同样地，上面的代码也使用到了牺牲封装性的<code>protected</code>，可能会导致资源管理上的混乱和复杂，考虑到这些，也许一点点模板代码的重复并非不可接受。</p><h3 id="条款-45：运用成员函数模板接受所有兼容类型"><a href="#条款-45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款 45：运用成员函数模板接受所有兼容类型"></a>条款 45：运用成员函数模板接受所有兼容类型</h3><p>C++ 视模板类的不同具现体为完全不同的的类型，但在泛型编程中，我们可能需要一个模板类的不同具现体能够相互类型转换。</p><p>考虑设计一个智能指针类，而智能指针需要支持不同类型指针之间的隐式转换（如果可以的话），以及普通指针到智能指针的显式转换。很显然，我们需要的是模板拷贝构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SmartPtr</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">heldPtr</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>    <span class="token keyword">explicit</span> <span class="token function">SmartPtr</span><span class="token punctuation">(</span>U<span class="token operator">*</span> p<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">heldPtr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> heldPtr<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    T<span class="token operator">*</span> heldPtr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>get</code>获取原始指针，并将在原始指针之间进行类型转换本身提供了一种保障，如果原始指针之间不能隐式转换，那么其对应的智能指针之间的隐式转换会造成编译错误。</p><p>模板构造函数并不会阻止编译器暗自生成默认的构造函数，所以如果你想要控制拷贝构造的方方面面，你必须同时声明泛化拷贝构造函数和普通拷贝构造函数，相同规则也适用于赋值运算符：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 拷贝构造函数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Y<span class="token operator">></span>    <span class="token function">shared_ptr</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 泛化拷贝构造函数</span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>shared_ptr <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 拷贝赋值运算符</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Y<span class="token operator">></span>    shared_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Y<span class="token operator">></span> <span class="token keyword">const</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 泛化拷贝赋值运算符</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-46：需要类型转换时请为模板定义非成员函数"><a href="#条款-46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款 46：需要类型转换时请为模板定义非成员函数"></a>条款 46：需要类型转换时请为模板定义非成员函数</h3><p>该条款与条款 24 一脉相承，还是使用原先的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 无法通过编译！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述失败启示我们：模板实参在推导过程中，从不将隐式类型转换纳入考虑。虽然以<code>oneHalf</code>推导出<code>Rational&lt;int&gt;</code>类型是可行的，但是试图将<code>int</code>类型隐式转换为<code>Rational&lt;T&gt;</code>是绝对会失败的。</p><p>由于模板类并不依赖模板实参推导，所以编译器总能够在<code>Rational&lt;T&gt;</code>具现化时得知<code>T</code>，因此我们可以使用友元声明式在模板类内指涉特定函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在模板类内，模板名称可被用来作为“模板及其参数”的简略表达形式，因此下面的写法也是一样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当对象<code>oneHalf</code>被声明为一个<code>Rational&lt;int&gt;</code>时，<code>Rational&lt;int&gt;</code>类于是被具现化出来，而作为过程的一部分，友元函数<code>operator*</code>也就被自动声明出来，其为一个普通函数而非模板函数，因此在接受参数时可以正常执行隐式转换。</p><p>为了使程序能正常链接，我们需要为其提供对应的定义式，最简单有效的方法就是直接合并至声明式处：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于定义在类内的函数都会暗自成为内联函数，为了降低内联带来的冲击，可以使<code>operator*</code>调用类外的辅助模板函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">DoMultiply</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">Denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">DoMultiply</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-47：请使用-traits-classes-表现类型信息"><a href="#条款-47：请使用-traits-classes-表现类型信息" class="headerlink" title="条款 47：请使用 traits classes 表现类型信息"></a>条款 47：请使用 traits classes 表现类型信息</h3><p>traits classes 可以使我们在编译期就能获取某些类型信息，它被广泛运用于 C++ 标准库中。traits 并不是 C++ 关键字或一个预先定义好的构件：它们是一种技术，也是 C++ 程序员所共同遵守的协议，并要求对用户自定义类型和内置类型表现得一样好。</p><p>设计并实现一个 trait class 的步骤如下：</p><ol><li>确认若干你希望将来可取得的类型相关信息。</li><li>为该类型选择一个名称。</li><li>提供一个模板和一组特化版本，内含你希望支持的类型相关信息。</li></ol><p>以迭代器为例，标准库中拥有多种不同的迭代器种类，它们各自拥有不同的功用和限制：</p><ol><li><code>input_iterator_tag</code>：单向输入迭代器，只能向前移动，一次一步，客户只可读取它所指的东西。</li><li><code>output_iterator_tag</code>：单向输出迭代器，只能向前移动，一次一步，客户只可写入它所指的东西。</li><li><code>forward_iterator_tag</code>：单向访问迭代器，只能向前移动，一次一步，读写均允许。</li><li><code>bidirectional_iterator_tag</code>：双向访问迭代器，去除了只能向前移动的限制。</li><li><code>random_access_iterator_tag</code>：随机访问迭代器，没有一次一步的限制，允许随意移动，可以执行“迭代器算术”。</li></ol><p>标准库为这些迭代器种类提供的卷标结构体（tag struct）的继承关系如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> input_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> output_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> forward_iterator_tag <span class="token operator">:</span> input_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> bidirectional_iterator_tag <span class="token operator">:</span> forward_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> random_access_iterator_tag <span class="token operator">:</span> bidirectional_iterator_tag <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将<code>iterator_category</code>作为迭代器种类的名称，嵌入容器的迭代器中，并且确认使用适当的卷标结构体：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">deque</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">iterator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">using</span> iterator_category <span class="token operator">=</span> random_access_iterator<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">list</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">iterator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">using</span> iterator_category <span class="token operator">=</span> bidirectional_iterator<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了做到类型的 traits 信息可以在类型自身之外获得，标准技术是把它放进一个模板及其一个或多个特化版本中。这样的模板在标准库中有若干个，其中针对迭代器的是<code>iterator_traits</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">IterT</span><span class="token operator">></span><span class="token keyword">struct</span> iterator_traits <span class="token punctuation">{</span>    <span class="token keyword">using</span> iterator_category <span class="token operator">=</span> IterT<span class="token operator">::</span>iterator_category<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了支持指针迭代器，<code>iterator_traits</code>特别针对指针类型提供一个偏特化版本，而指针的类型和随机访问迭代器类似，所以可以写出如下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">IterT</span><span class="token operator">></span><span class="token keyword">struct</span> iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">*</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> iterator_category <span class="token operator">=</span> random_access_iterator_tag<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们需要为不同的迭代器种类应用不同的代码时，traits classes 就派上用场了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token punctuation">)</span>        <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token operator">::</span>random_access_iterator_tag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但这些代码实际上是错误的，我们希望类型的判断能在编译期完成。<code>iterator_category</code>是在编译期决定的，然而<code>if</code>却是在运行期运作的，无法达成我们的目标。</p><p>在 C++17 之前，解决这个问题的主流做法是利用函数重载（也是原书中介绍的做法）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">doAdvance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">,</span> std<span class="token operator">::</span>random_access_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>   <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">doAdvance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">,</span> std<span class="token operator">::</span>bidirectional_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">doAdvance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">,</span> std<span class="token operator">::</span>input_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">out_of_range</span><span class="token punctuation">(</span><span class="token string">"Negative distance"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 单向迭代器不允许负距离</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">doAdvance</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> d<span class="token punctuation">,</span> std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token operator">::</span><span class="token function">iterator_category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++17 之后，我们有了更简单有效的做法——使用<code>if constexpr</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> IterT<span class="token punctuation">,</span> <span class="token keyword">typename</span> DisT<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">Advance</span><span class="token punctuation">(</span>IterT<span class="token operator">&amp;</span> iter<span class="token punctuation">,</span> DisT d<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token operator">::</span>iterator_category<span class="token punctuation">)</span>        <span class="token operator">==</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>std<span class="token operator">::</span>random_access_iterator_tag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-48：认识模板元编程"><a href="#条款-48：认识模板元编程" class="headerlink" title="条款 48：认识模板元编程"></a>条款 48：认识模板元编程</h3><p>模板元编程（Template metaprogramming，TMP）是编写基于模板的 C++ 程序并执行于编译期的过程，它并不是刻意被设计出来的，而是当初 C++ 引入模板带来的副产品，事实证明模板元编程具有强大的作用，并且现在已经成为 C++ 标准的一部分。实际上，在条款 47 中编写 traits classes 时，我们就已经在进行模板元编程了。</p><p>由于模板元程序执行于 C++ 编译期，因此可以将一些工作从运行期转移至编译期，这可以帮助我们在编译期时发现一些原本要在运行期时才能察觉的错误，以及得到较小的可执行文件、较短的运行期、较少的内存需求。当然，副作用就是会使编译时间变长。</p><p>模板元编程已被证明是“图灵完备”的，并且以“函数式语言”的形式发挥作用，因此在模板元编程中没有真正意义上的循环，所有循环效果只能藉由递归实现，而递归在模板元编程中是由 <strong>“递归模板具现化（recursive template instantiation）”</strong> 实现的。</p><p>常用于引入模板元编程的例子是在编译期计算阶乘：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> n<span class="token operator">></span>            <span class="token comment" spellcheck="true">// Factorial&lt;n> = n * Factorial&lt;n-1></span><span class="token keyword">struct</span> Factorial <span class="token punctuation">{</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span> value <span class="token operator">=</span> n <span class="token operator">*</span> Factorial<span class="token operator">&lt;</span>n<span class="token number">-1</span><span class="token operator">></span><span class="token operator">::</span>value <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">struct</span> Factorial<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 处理特殊情况：Factorial&lt;0> = 1</span>    <span class="token keyword">enum</span> <span class="token punctuation">{</span> value <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Factorial<span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板元编程很酷，但对其进行调试可能是灾难性的，因此在实际应用中并不常见。我们可能会在下面几种情形中见到它的出场：</p><ol><li>确保量度单位正确。</li><li>优化矩阵计算。</li><li>可以生成客户定制之设计模式（custom design pattern）实现品。</li></ol><h2 id="第八章：定制-new-和-delete"><a href="#第八章：定制-new-和-delete" class="headerlink" title="第八章：定制 new 和 delete"></a>第八章：定制 new 和 delete</h2><h3 id="条款-49：了解-new-handler-的行为"><a href="#条款-49：了解-new-handler-的行为" class="headerlink" title="条款 49：了解 new-handler 的行为"></a>条款 49：了解 new-handler 的行为</h3><p>当<code>operator new</code>无法满足某一内存分配需求时，会不断调用一个客户指定的错误处理函数，即所谓的 <strong>new-handler</strong>，直到找到足够内存为止，调用声明于<code>&lt;new&gt;</code>中的<code>set_new_handler</code>可以指定这个函数。<code>new_handler</code>和<code>set_new_handler</code>的定义如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>    <span class="token keyword">using</span> new_handler <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>new_handler<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回值为原来持有的 new-handler</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一个设计良好的 new-handler 函数必须做以下事情之一：</p><p><strong>让更多的内存可被使用：</strong> 可以让程序一开始执行就分配一大块内存，而后当 new-handler 第一次被调用，将它们释还给程序使用，造成<code>operator new</code>的下一次内存分配动作可能成功。</p><p><strong>安装另一个 new-handler：</strong> 如果目前这个 new-handler 无法取得更多内存，可以调换为另一个可以完成目标的 new-handler（令 new-handler 修改“会影响 new-handler 行为”的静态或全局数据）。</p><p><strong>卸除 new-handler：</strong> 将<code>nullptr</code>传给<code>set_new_handler</code>，这样会使<code>operator new</code>在内存分配不成功时抛出异常。</p><p><strong>抛出 bad_alloc（或派生自 bad_alloc）的异常：</strong> 这样的异常不会被<code>operator new</code>捕捉，因此会被传播到内存分配处。</p><p><strong>不返回：</strong> 通常调用<code>std::abort</code>或<code>std::exit</code>。</p><p>有的时候我们或许会希望在为不同的类分配对象时，使用不同的方式处理内存分配失败情况。这时候使用静态成员是不错的选择：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler currentHandler<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 做和 std::set_new_handler 相同的事情</span>std<span class="token operator">::</span>new_handler Widget<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>new_handler oldHandler <span class="token operator">=</span> currentHandler<span class="token punctuation">;</span>    currentHandler <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> oldHandler<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> globalHandler <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 切换至 Widget 的专属 new-handler</span>    <span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 分配内存或抛出异常</span>    std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 切换回全局的 new-handler</span>    <span class="token keyword">return</span> globalHandler<span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>new_handler Widget<span class="token operator">::</span>currentHandler <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Widget</code>的客户应该类似这样使用其 new-handling：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">OutOfMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Widget<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>OutOfMem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pw1 <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 若分配失败，则调用 OutOfMem</span>Widget<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pw2 <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 若分配失败，则抛出异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现这一方案的代码并不因类的不同而不同，因此对这些代码加以复用是合理的构想。一个简单的做法是建立起一个“mixin”风格的基类，让其派生类继承它们所需的<code>set_new_handler</code>和<code>operator new</code>，并且使用模板确保每一个派生类获得一个实体互异的<code>currentHandler</code>成员变量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">NewHandlerSupport</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// “mixin”风格的基类</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                         <span class="token comment" spellcheck="true">// 其它的 operator new 版本，见条款 52</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler currentHandler<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>std<span class="token operator">::</span>new_handler NewHandlerSupport<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>new_handler oldHandler <span class="token operator">=</span> currentHandler<span class="token punctuation">;</span>    currentHandler <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> oldHandler<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span><span class="token operator">*</span> NewHandlerSupport<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> globalHandler <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> globalHandler<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>std<span class="token operator">::</span>new_handler NewHandlerSupport<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>currentHandler <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">public</span> NewHandlerSupport<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                         <span class="token comment" spellcheck="true">// 不必再声明 set_new_handler 和 operator new</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意此处的模板参数<code>T</code>并没有真正被当成类型使用，而仅仅是用来区分不同的派生类，使得模板机制为每个派生类具现化出一份对应的<code>currentHandler</code>。</p><p>这个做法用到了所谓的 <strong>CRTP（curious recurring template pattern，奇异递归模板模式）</strong> ，除了在上述设计模式中用到之外，它也被用于实现<strong>静态多态</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">></span> <span class="token keyword">struct</span> Base <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">Implementation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 在基类中暴露接口</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Derived <span class="token operator">:</span> Base<span class="token operator">&lt;</span>Derived<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">Implementation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                  <span class="token comment" spellcheck="true">// 在派生类中提供实现</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了会调用 new-handler 的<code>operator new</code>以外，C++ 还保留了传统的“分配失败便返回空指针”的<code>operator new</code>，称为 nothrow new，通过<code>std::nothrow</code>对象来使用它：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">*</span> pw1 <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 如果分配失败，抛出 bad_alloc</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pw1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 这个测试一定失败</span>Widget<span class="token operator">*</span> pw2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>nothrow<span class="token punctuation">)</span> Widget<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果分配失败，返回空指针</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pw2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 这个测试可能成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nothrow new 对异常的强制保证性并不高，使用它只能保证<code>operator new</code>不抛出异常，而无法保证像<code>new (std::nothrow) Widget</code>这样的表达式不会导致异常，因此实际上并没有使用 nothrow new 的必要。</p><h3 id="条款-50：了解-new-和-delete-的合理替换时机"><a href="#条款-50：了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50：了解 new 和 delete 的合理替换时机"></a>条款 50：了解 new 和 delete 的合理替换时机</h3><p>以下是常见的替换默认<code>operator new</code>和<code>operator delete</code>的理由：</p><p><strong>用来检测运用上的错误：</strong> 如果将“new 所得内存”delete 掉却不幸失败，会导致内存泄漏；如果在“new 所得内存”身上多次 delete 则会导致未定义行为。如果令<code>operator new</code>持有一串动态分配所得地址，而<code>operator delete</code>将地址从中移除，就很容易检测出上述错误用法。此外各式各样的编程错误可能导致 <strong>“overruns”（写入点在分配区块尾端之后）</strong> 和 <strong>“underruns”（写入点在分配区块起点之前）</strong>，以额外空间放置特定的 byte pattern 签名，检查签名是否原封不动就可以检测此类错误，下面给出了一个这样的范例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> signature <span class="token operator">=</span> <span class="token number">0xDEADBEEF</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 调试“魔数”</span><span class="token keyword">using</span> Byte <span class="token operator">=</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>    size_t realSize <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 分配额外空间以塞入两个签名</span>    <span class="token keyword">void</span><span class="token operator">*</span> pMem <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>realSize<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 调用 malloc 取得内存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pMem<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将签名写入内存的起点和尾端</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> signature<span class="token punctuation">;</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Byte<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span> <span class="token operator">+</span> realSize <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> signature<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Byte<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回指针指向第一个签名后的内存位置</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上这段代码不能保证内存对齐，并且有许多地方不遵守 C++ 规范，我们将在条款 51 中进行详细讨论。</p><p><strong>为了收集使用上的统计数据：</strong> 定制 new 和 delete 动态内存的相关信息：分配区块的大小分布，寿命分布，FIFO（先进先出）、LIFO（后进先出）或随机次序的倾向性，不同的分配/归还形态，使用的最大动态分配量等等。</p><p><strong>为了增加分配和归还的速度：</strong> 泛用型分配器往往（虽然并非总是）比定制型分配器慢，特别是当定制型分配器专门针对某特定类型之对象设计时。类专属的分配器可以做到“区块尺寸固定”，例如 Boost 提供的 Pool 程序库。又例如，编译器所带的内存管理器是线程安全的，但如果你的程序是单线程的，你也可以考虑写一个不线程安全的分配器来提高速度。当然，这需要你对程序进行分析，并确认程序瓶颈的确发生在那些内存函数身上。</p><p><strong>为了降低缺省内存管理器带来的空间额外开销：</strong> 泛用型分配器往往（虽然并非总是）还比定制型分配器使用更多内存，那是因为它们常常在每一个分配区块身上招引某些额外开销。针对小型对象而开发的分配器（例如 Boost 的 Pool 程序库）本质上消除了这样的额外开销。</p><p><strong>为了弥补缺省分配器中的非最佳内存对齐（suboptimal alignment）：</strong> 许多计算机体系架构要求特定的类型必须放在特定的内存地址上，如果没有奉行这个约束条件，可能导致运行期硬件异常，或者访问速度变低。<code>std::max_align_t</code>用来返回当前平台的最大默认内存对齐类型，对于<code>malloc</code>分配的内存，其对齐和<code>max_align_t</code>类型的对齐大小应当是一致的，但若对<code>malloc</code>返回的指针进行偏移，就没有办法保证内存对齐。</p><p>在 C++11 中，提供了以下内存对齐相关方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// alignas 用于指定栈上数据的内存对齐要求</span><span class="token keyword">struct</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> testStruct <span class="token punctuation">{</span> <span class="token keyword">double</span> data<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// alignof 和 std::alignment_of 用于得到给定类型的内存对齐要求</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>std<span class="token operator">::</span>max_align_t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>alignment_of<span class="token operator">&lt;</span>std<span class="token operator">::</span>max_align_t<span class="token operator">></span><span class="token operator">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// std::align 用于在一大块内存中获取一个符合指定内存要求的地址</span><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"memory alignment"</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> buffer<span class="token punctuation">;</span>std<span class="token operator">::</span>size_t space <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>std<span class="token operator">::</span><span class="token function">align</span><span class="token punctuation">(</span><span class="token keyword">alignof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> space<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++17 后，可以使用<code>std::align_val_t</code>来重载需求额外内存对齐的<code>operator new</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t count<span class="token punctuation">,</span> std<span class="token operator">::</span>align_val_t al<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>为了将相关对象成簇集中：</strong> 如果你知道特定的某个数据结构往往被一起使用，而你又希望在处理这些数据时将“内存页错误（page faults）”的频率降至最低，那么可以考虑为此数据结构创建一个堆，将它们成簇集中在尽可能少的内存页上。一般可以使用 placement new 达成这个目标（见条款 52）。</p><p><strong>为了获得非传统的行为：</strong> 有时候你会希望<code>operator new</code>和<code>operator delete</code>做编译器版不会做的事情，例如分配和归还共享内存（shared memory），而这些事情只能被 C API 完成，则可以将 C API 封在 C++ 的外壳里，写在定制的 new 和 delete 中。</p><h3 id="条款-51：编写-new-和-delete-时需固守常规"><a href="#条款-51：编写-new-和-delete-时需固守常规" class="headerlink" title="条款 51：编写 new 和 delete 时需固守常规"></a>条款 51：编写 new 和 delete 时需固守常规</h3><p>我们在条款 49 中已经提到过一些<code>operator new</code>的规矩，比如内存不足时必须不断调用 new-handler，如果无法供应客户申请的内存，就抛出<code>std::bad_alloc</code>异常。C++ 还有一个奇怪的规定，即使客户需求为0字节，<code>operator new</code>也得返回一个合法的指针，这种看似诡异的行为其实是为了简化语言其他部分。</p><p>根据这些规约，我们可以写出非成员函数版本的<code>operator new</code>代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 处理0字节申请</span>        size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 将其视为1字节申请</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 如果分配成功</span>            <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指针指向分配得到的内存</span>        <span class="token comment" spellcheck="true">// 如果分配失败，调用目前的 new-handler</span>        <span class="token keyword">auto</span> globalHandler <span class="token operator">=</span> <span class="token function">get_new_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// since C++11</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>globalHandler<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>globalHandler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">bad_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>operator new</code>的成员函数版本一般只会分配大小刚好为类的大小的内存空间，但是情况并不总是如此，比如假设我们没有为派生类声明其自己的<code>operator new</code>，那么派生类会从基类继承<code>operator new</code>，这就导致派生类可以使用其基类的 new 分配方式，但派生类和基类的大小很多时候是不同的。</p><p>处理此情况的最佳做法是将“内存申请量错误”的调用行为改为采用标准的<code>operator new</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> Base<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转交给标准的 operator new 进行处理</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意在<code>operator new</code>的成员函数版本中我们也不需要检测分配的大小是否为0了，因为在条款 39 中我们提到过，非附属对象必须有非零大小，所以<code>sizeof(Base)</code>无论如何也不能为0。</p><p>如果你打算实现<code>operator new[]</code>，即所谓的 array new，那么你唯一要做的一件事就是分配一块未加工的原始内存，因为你无法对 array 之内迄今尚未存在的元素对象做任何事情，实际上你甚至无法计算这个 array 将含有多少元素对象。</p><p><code>operator delete</code>的规约更加简单，你需要记住的唯一一件事情就是 C++ 保证 <strong>“删除空指针永远安全”</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> rawMemory<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rawMemory <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 归还 rawMemory 所指的内存</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>operator delete</code>的成员函数版本要多做的唯一一件事就是将大小有误的删除行为转交给标准的<code>operator delete</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Base<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> rawMemory<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rawMemory <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>rawMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转交给标准的 operator delete 进行处理</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归还 rawMemory 所指的内存</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果即将被删除的对象派生自某个基类而后者缺少虚析构函数，那么 C++ 传给<code>operator delete</code>的<code>size</code>大小可能不正确，这或许是“为多态基类声明虚析构函数”的一个足够的理由，能作为对条款 7 的补充。</p><h3 id="条款-52：写了-placement-new-也要写-placement-delete"><a href="#条款-52：写了-placement-new-也要写-placement-delete" class="headerlink" title="条款 52：写了 placement new 也要写 placement delete"></a>条款 52：写了 placement new 也要写 placement delete</h3><p>placement new 最初的含义指的是“接受一个指针指向对象该被构造之处”的<code>operator new</code>版本，它在标准库中的用途广泛，其中之一是负责在 vector 的未使用空间上创建对象，它的声明如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们此处要讨论的是广义上的 placement new，即带有附加参数的<code>operator new</code>，例如下面这种：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cerr<span class="token punctuation">)</span> Widget<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当我们在使用 new 表达式创建对象时，共有两个函数被调用：一个是用以分配内存的<code>operator new</code>，一个是对象的构造函数。假设第一个函数调用成功，而第二个函数却抛出异常，那么会由 C++ runtime 调用<code>operator delete</code>，归还已经分配好的内存。</p><p>这一切的前提是 C++ runtime 能够找到<code>operator new</code>对应的<code>operator delete</code>，如果我们使用的是自定义的 placement new，而没有为其准备对应的 placement delete 的话，就无法避免发生内存泄漏。因此，合格的代码应该是这样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// placement new</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// delete 时调用的正常 operator delete</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// placement delete</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个要注意的问题是，由于成员函数的名称会掩盖其外部作用域中的相同名称（见条款 33），所以提供 placement new 会导致无法使用正常版本的<code>operator new</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> Base<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 无法通过编译！</span><span class="token keyword">auto</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cerr<span class="token punctuation">)</span> Base<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样道理，派生类中的<code>operator new</code>会掩盖全局版本和继承而得的<code>operator new</code>版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>clog<span class="token punctuation">)</span> Derived<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 无法通过编译！</span><span class="token keyword">auto</span> pd <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免名称遮掩问题，需要确保以下形式的<code>operator new</code>对于定制类型仍然可用，除非你的意图就是阻止客户使用它们：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token operator">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// normal new</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// placement new</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// nothrow new</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个最简单的实现方式是，准备一个基类，内含所有正常形式的 new 和 delete：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">StadardNewDeleteForms</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// normal new/delete</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// placement new/delete</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// nothrow new/delete</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>nothrow_t<span class="token operator">&amp;</span> nt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>nt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>凡是想以自定义形式扩充标准形式的客户，可以利用继承和<code>using</code>声明式（见条款 33）取得标准形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token operator">:</span> <span class="token keyword">public</span> StandardNewDeleteForms<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> StandardNewDeleteForms<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> StandardNewDeleteForms<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token function">detele</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t size<span class="token punctuation">,</span> std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> logStream<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第九章：杂项讨论"><a href="#第九章：杂项讨论" class="headerlink" title="第九章：杂项讨论"></a>第九章：杂项讨论</h2><h3 id="条款-53：不要轻忽编译器的警告"><a href="#条款-53：不要轻忽编译器的警告" class="headerlink" title="条款 53：不要轻忽编译器的警告"></a>条款 53：不要轻忽编译器的警告</h3><ol><li>严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取“无任何警告”的荣誉。</li><li>不要过度依赖编译器的警告能力，因为不同的编译器对待事情的态度不同。一旦移植到另一个编译器上，你原本依赖的警告信息可能会消失。</li></ol><h3 id="条款-54：让自己熟悉包括-TR1-在内的标准程序库"><a href="#条款-54：让自己熟悉包括-TR1-在内的标准程序库" class="headerlink" title="条款 54：让自己熟悉包括 TR1 在内的标准程序库"></a>条款 54：让自己熟悉包括 TR1 在内的标准程序库</h3><p>如今 TR1 草案已完全融入 C++ 标准当中，没有再过多了解 TR1 标准库的必要。</p><h3 id="条款-55：让自己熟悉-Boost"><a href="#条款-55：让自己熟悉-Boost" class="headerlink" title="条款 55：让自己熟悉 Boost"></a>条款 55：让自己熟悉 Boost</h3><p>Boost 是若干个程序库的集合，并且当中的许多库已经被 C++ 吸纳为标准库的一部分。不过在现在的 Modern C++ 时代，是否该在项目中使用 Boost 仍然有一定的争议，一些 Boost 组件并无法做到像 C++ 标准库那样高性能，零开销抽象，但毫无疑问的是，Boost 的参考价值是无法忽视的，你可以在 Boost 中找到许多非常值得学习和借鉴的实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章：让自己习惯-C&quot;&gt;&lt;a href=&quot;#第一章：让自己习惯-C&quot; class=&quot;headerlink&quot; title=&quot;第一章：让自己习惯 C++&quot;&gt;&lt;/a&gt;第一章：让自己习惯 C++&lt;/h2&gt;&lt;h3 id=&quot;条款-1：视-C-为一个语言联邦&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中RAII和智能指针</title>
    <link href="https://joytsing.github.io/posts/57427/"/>
    <id>https://joytsing.github.io/posts/57427/</id>
    <published>2023-12-14T07:39:36.000Z</published>
    <updated>2023-12-14T14:45:37.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概-述"><a href="#概-述" class="headerlink" title="概 述"></a>概 述</h2><h3 id="RAII-Resource-Acquisition-Is-Initialization"><a href="#RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="RAII (Resource Acquisition Is Initialization)"></a><strong>RAII (Resource Acquisition Is Initialization)</strong></h3><p>RAII 要求，资源的有效期与持有资源的对象的生命期严格绑定，即由对象的构造函数完成资源的分配（获取），同时由析构函数，完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题。</p><h3 id="C-三-五法则"><a href="#C-三-五法则" class="headerlink" title="C++三/五法则"></a><strong>C++三/五法则</strong></h3><ul><li>当定义一个类时，我们显式地或隐式地指定了此类型的对象在拷贝、赋值和销毁时做什么。一个类通过定义三种特殊的成员函数来控制这些操作，分别是拷贝构造函数、赋值运算符和析构函数。</li><li><strong>拷贝构造函数，定义了当用同类型的另一个对象初始化新对象时做什么；赋值运算符，定义了将一个对象赋予同类型的另一个对象时做什么；析构函数，定义了此类型的对象销毁时做什么。我们将这些操作称为拷贝控制操作</strong>。</li><li>由于拷贝控制操作是由三个特殊的成员函数来完成的，所以我们称此为“C++三法则”。在较新的C++11标准中，为了支持移动语义，又增加了<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>，这样共有五个特殊的成员函数，所以又称为“C++五法则”。也就是说，“三法则”是针对较旧的C++98 标准说的，“五法则” 是针对较新的C++11标准说的。为了统一称呼，后来人们干把它叫做“C++ 三/五法则”。</li></ul><p>RAII ， 如果没有解构函数，在每个带有返回的分支，都要手动释放所有之前的资源；与Java Python 等自动垃圾回收语言不同（由gc延时回收），C++结构函数是显示的，当进程离开了函数作用域自动销毁之前的资源，不含糊。这样做，有好处也有坏处，对于高性能计算，利大于弊。</p><h3 id="RAII，异常安全（exception-safe）"><a href="#RAII，异常安全（exception-safe）" class="headerlink" title="RAII，异常安全（exception-safe）"></a>RAII，异常安全（exception-safe）</h3><p>C++ 标准保证了当异常发生时，会调用已创建对象的解构函数，因此 C++中不需要 finally 语句。</p><pre class="line-numbers language-java"><code class="language-java">connection c <span class="token operator">=</span> driver<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>   c<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如Java语句，需要在 finally 里显示 close资源，而 C++可以在 catch异常同时，自动释放资源。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>ofstream <span class="token function">fout</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fout <span class="token operator">&lt;&lt;</span> <span class="token string">"in\n"</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fout <span class="token operator">&lt;&lt;</span> <span class="token string">"out\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>exception <span class="token keyword">const</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"catch"</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编译器自动生成的函数：全家桶"><a href="#编译器自动生成的函数：全家桶" class="headerlink" title="编译器自动生成的函数：全家桶"></a><strong>编译器自动生成的函数：全家桶</strong></h2><p>除了 <strong>拷贝构造</strong>和 <strong>拷贝赋值</strong>，编译器会自动生成特殊函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> C <span class="token punctuation">{</span>    <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 默认构造函数</span>    <span class="token function">C</span><span class="token punctuation">(</span>C <span class="token keyword">const</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 拷贝构造函数</span>    <span class="token function">C</span><span class="token punctuation">(</span>C <span class="token operator">&amp;&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 移动构造函数 (C++11 引入)</span>    C <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>C <span class="token keyword">const</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拷贝赋值函数</span>    C <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>C <span class="token operator">&amp;&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 移动赋值函数 (C++11 引入)</span>    <span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 解构函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在其他面向对象语言中是看不到这些底层的函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">Pig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 拷贝构造</span><span class="token function">Pig</span><span class="token punctuation">(</span>Pig <span class="token keyword">const</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">m_name</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_name<span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">m_weight</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_weight<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 移动构造</span><span class="token function">Pig</span><span class="token punctuation">(</span>Pig <span class="token operator">&amp;&amp;</span>other<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">m_name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_name<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">m_weight</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_weight<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 拷贝赋值</span>Pig <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Pig <span class="token keyword">const</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    m_name <span class="token operator">=</span> other<span class="token punctuation">.</span>m_name<span class="token punctuation">;</span>    m_weight <span class="token operator">=</span> other<span class="token punctuation">.</span>m_weight<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 移动赋值</span>Pig <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Pig <span class="token operator">&amp;&amp;</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    m_name <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_name<span class="token punctuation">)</span><span class="token punctuation">;</span>    m_weight <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_weight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">Pig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++规定，除了智能指针，都是用深拷贝。以上这些函数都是编译器默认生成的。</p><h3 id="三五法则深入理解"><a href="#三五法则深入理解" class="headerlink" title="三五法则深入理解"></a>三五法则深入理解</h3><p><img src="https://pic4.zhimg.com/v2-666b134737e695bee046025df65e381b_r.jpg" alt></p><p>从一个例子出发。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> Vector <span class="token punctuation">{</span>    size_t m_size<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>m_data<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    Vector(size_t n) {    // 构造函数 - 对象初始化时调用</span><span class="token comment" spellcheck="true">//        m_size = n;</span><span class="token comment" spellcheck="true">//        m_data = (int *)malloc(n * sizeof(int));</span><span class="token comment" spellcheck="true">//    }</span>    <span class="token function">Vector</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token function">m_size</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_data</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 解构函数 - 对象销毁时调用</span>        <span class="token function">free</span><span class="token punctuation">(</span>m_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> m_size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        m_size <span class="token operator">=</span> size<span class="token punctuation">;</span>        m_data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>m_data<span class="token punctuation">,</span> m_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t index<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当 v[index] 时调用</span>        <span class="token keyword">return</span> m_data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Vector <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">+</span><span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>Vector类 并没有定义拷贝构造函数，编译器实际会发生拷贝构造，发生一次浅拷贝。如果我们使用拷贝操作，会发生什么问题吗？</p><p><img src="https://pic3.zhimg.com/80/v2-2af21508834624d5214285b0418c7192_720w.webp" alt></p><pre class="line-numbers language-text"><code class="language-text">41行     Vector v2 = v1; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在执行以上语句时，编译器默认是会发生一次浅拷贝，那么在退出main函数时候，v1.m_data 会被释放两次（析构v1 v2，就会发生两次对 v1.m_data的释放；更危险的是，如果v1被释放，而v2还在被使用，空指针出现）</p><p>– 这就是为什么，一个类定义了 <strong>解构函数，</strong> 还要定义或删除 <strong>拷贝构造函数</strong> 和 <strong>拷贝赋值函数</strong> 的原因。</p><ul><li>两种解决办法：</li></ul><p>① 直接禁止用户拷贝这个类的对象，让用户拷贝时，报错</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">Vector</span><span class="token punctuation">(</span>Vector <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://pic4.zhimg.com/80/v2-91861b16bf3b362d7650bd32183da6f3_720w.webp" alt></p><p>② 我们自己实现一下拷贝构造函数，通过深拷贝，解决指针双重释放的问题。– 如果要用浅拷贝，那涉及到 <strong>智能指针</strong>。</p><p><img src="https://pic1.zhimg.com/80/v2-80ca3e62c5cc9a96612d9fa4cfe10764_720w.webp" alt></p><p>这样保证了 任何单次操作前后，对象都处于正确状态（存在或者删除），从而避免程序读到空悬指针。这就是保证了面向对象的 “封装：不变性”。</p><p>无论，size()/resize()这样的get/set模式，还是深拷贝，都是为了满足 “封装： 不变性” – 也就是ACID中的C（consistency）。一次对象的操作，要么完成，要么不完成，要保证 对象始终处于正确的状态。</p><h3 id="拷贝赋值函数"><a href="#拷贝赋值函数" class="headerlink" title="拷贝赋值函数"></a>拷贝赋值函数</h3><p>同理，如果使用了拷贝赋值，也需要定义拷贝赋值函数。</p><p><img src="https://pic1.zhimg.com/80/v2-37fdd4f26dbee98666227602895a5f58_720w.webp" alt></p><p>以上方式，先销毁，再通过 placement new，在原有this指针上构造。为了提高性能，推荐使用，realloc，从而就地利用现有m_data，避免重新分配。</p><p><img src="https://pic4.zhimg.com/80/v2-c03216e982a84dd1123035865f2aa763_720w.webp" alt></p><p>m_data显然，本来就有一段内存，那么通过 realloc 可以方便在原有的指针地址上扩展内存，避免了一次销毁在分配操作。</p><h3 id="移动构造函数-amp-移动赋值函数"><a href="#移动构造函数-amp-移动赋值函数" class="headerlink" title="移动构造函数 &amp; 移动赋值函数"></a>移动构造函数 &amp; 移动赋值函数</h3><p><img src="https://pic4.zhimg.com/80/v2-06d734b391ec5af5320b2ff777f842ff_720w.webp" alt></p><ul><li>std::move</li></ul><p>调用 std::move，V1 接管了V2的这块内存的所有权。</p><p>而拷贝赋值的 复杂度为 O(n)，因为分配了两块内存，v1 = v2 完成的是深拷贝。</p><p>以上两个操作，都不会产生二次free。</p><ul><li>std::swap</li></ul><p>另外还有 通过 std::swap 完成两块内存内容的交换。</p><p><img src="https://pic3.zhimg.com/80/v2-9c74e7f4751238aefa8f15f3973de46a_720w.webp" alt></p><ul><li>隐式发生 Move的情况</li></ul><p>① return v2 // C++规定，return 的对象不会再使用，自然等价于 std::move 语义。</p><ul><li>显式发生 拷贝的情况</li></ul><p>① return std::as_const(v2) // 显式拷贝</p><p>② v1 = v2 // 默认拷贝</p><p><img src="https://pic2.zhimg.com/80/v2-f0385bfdf4e88fdfb80b63f596a5a301_720w.webp" alt></p><p>自定义移动构造、移动赋值，可以提高执行效率。</p><p><img src="https://pic4.zhimg.com/80/v2-c3ff25be1b7a8b0cfb1107dd130b8727_720w.webp" alt></p><p>因为移动后，销毁了原对象，不存在两次free的情况，移动是浅移动。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><strong>unique_ptr</strong></h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a><strong>含义</strong></h3><p>对象释放，保证释放之前和之后，对象都处于正常状态。这样，不会出现 野指针(空悬指针)。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在解构函数中，会自动调用 delete p 释放 p。对比 C++ 98 古老的释放对象的方法。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 之后要设null，不然可能会被再利用。</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而 unique_ptr 只需要 即可提前释放对象。– 体现了封装：一致性。</p><pre class="line-numbers language-cpp"><code class="language-cpp">p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等价于 p.reset();</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="浅拷贝问题"><a href="#浅拷贝问题" class="headerlink" title="浅拷贝问题"></a>浅拷贝问题</h3><p>以下代码，unique_ptr 是删除了拷贝函数的，调用类的成员函数会报错。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> C <span class="token punctuation">{</span>    <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 调用时，发生了浅拷贝</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//报错</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 unique_ptr 删除了 拷贝构造函数，不能被拷贝。宁可编译器出错，不在运行时出错。按照三五法则，unique_ptr 自定义了解构函数，所以它必须删除拷贝构造函数。unique_ptr 采用的是上文提到的第一种方法，来避免 double free的情况。</p><ul><li>那么如何解决这个问题，解决方法</li></ul><p>可以这样修改，从 unique_ptr 获取 原始指针</p><ul><li><strong>case 1</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>C <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从p中 get出原始指针，并不是要夺取资源的占有权，只是调用p的成员函数，并没有接管对象生命周期。</span>    <span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种情况，我们只是对 p做了一些事情，并不是需要获取p 的控制权，此时只需要指针的 get() 出一个原始指针，并没有修改它什么时候释放这件事。还可以这样，把 p 指针 move到全局变量。（不推荐）</p><ul><li><strong>case 2</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">>></span> objlist<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 把指针放到一个全局列表，那么 p的生命周期将变得和 objlist一样长。所以需要接管p的生命周期。</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    objlist<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 进一步移动到 objlist</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  不为空</span>    <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过移动构造函数，转移指针控制器</span>    p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  为空</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但移交了p 的控制权，就不能再访问 p 这个地址了。如果还想对 移交后的指针p，调用成员函数等操作，可以这样操作（不推荐，都这样做了还用什么unique_ptr）</p><ul><li><strong>case 3</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    C <span class="token operator">*</span>raw_p <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先把原始指针拷贝一份</span>    <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 转移p 控制权给 objlist </span>    <span class="token comment" spellcheck="true">// 但需要注意，要保证 raw_p的存在时间不能超过 p的生命周期，否则 会出现危险的空悬指针。</span>    <span class="token comment" spellcheck="true">//objlist.clear();</span>    raw_p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic2.zhimg.com/80/v2-b7c7fbfbb20e00f81ebb1ad056a41165_720w.webp" alt></p><p>raw_p 返回错误值。报错分析如下图，</p><p><img src="/posts/57427/1.jpg" alt></p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><strong>shared_ptr</strong></h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>下面的例子说明了 shared_ptr 的使用特点，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">struct</span> C <span class="token punctuation">{</span>     <span class="token keyword">int</span> m_number<span class="token punctuation">;</span>    <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"分配内存!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m_number <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>       <span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"释放内存!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m_number <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2333333</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">void</span> <span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"我的数字是 %d!\n"</span><span class="token punctuation">,</span> m_number<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">>></span> objlist<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    objlist<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这里用移动可以更高效，但不必须</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引用计数初始化为1</span>    <span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// shared_ptr 允许拷贝！和当前指针共享所有权，引用计数加1</span>    <span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 多次也没问题~ 多个 shared_ptr 会共享所有权，引用计数加1</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正常执行，p 指向的地址本来就没有改变</span>    objlist<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 刚刚 p 移交给 func 的生命周期结束了！引用计数减2</span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正常执行，因为引用计数还剩1，不会被释放</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 到这里最后一个引用 p 也被释放，p 指向的对象才终于释放</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>unique_ptr</strong> 解决了重复释放的方式是禁止拷贝，这样虽然效率高，但导致使用困难，容易出错；</p><p>相比之下，牺牲效率换来自由度的 <strong>shared_ptr</strong> 允许拷贝，他解决重复释放的方式是通过<strong>引用计数</strong>；</p><p>1、当初始化一个 shared_ptr时，计数初始化为 1</p><p>2、shared_ptr 被拷贝一次，计数加 1</p><p>3、shared_ptr 被解构一次，计数减 1， 减到 0 则自动销毁他指向的对象，比如 main函数 return</p><p>从而保证要还有引用存在，就不会解构对象。</p><ul><li>总结下 两种指针的特点，</li></ul><p>1&gt; unique_ptr 容易保证原子性，shared_ptr 需要硬件指令保证原子性，效率没有 unique_ptr 高；</p><p>2&gt; shared_ptr 方便，但还有循环引用问题，接着往下看。</p><h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><ul><li>一个 使用 shared_ptr 的 <strong>Bad Case</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">struct</span> C <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_child<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> parent <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> child <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 建立相互引用</span>    parent<span class="token operator">-</span><span class="token operator">></span>m_child <span class="token operator">=</span> child<span class="token punctuation">;</span>    child<span class="token operator">-</span><span class="token operator">></span>m_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// parent 不会被释放，child 还指向它</span>    child <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// child  不会被释放，parent 还指向它</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 完了，直到main函数退出，这两块内存都没有被释放。</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面实例的目的，通常 释放 parent时候，希望 child也同时被释放，但是因为产生了循环引用，导致内存泄漏。</p><p>总结一下：</p><p>动态指针 shared_ptr，可以适当减少使用者的出错概率，因为他的行为类似 GC语言的引用计数机制，但也有以下问题：</p><p>1、shared_ptr 需要维护一个 atomic 的引用计数器，效率会降低，需要额外维护一块管理内存，访问实际对象需要二级指针，而且 deleter 使用了<strong>类型擦除技术</strong>；</p><p>2、另外，全部使用 shared_ptr，可能会出现循环引用的问题，导致内存泄漏，那么要使用不影响计数的原始指针，或者 <strong>weak_ptr</strong> 来避免这个问题。</p><blockquote><p>c语言有特定方法解决循环引用，c++需要改造如下: 使用 weak_ptr</p></blockquote><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a><strong>weak_ptr</strong></h2><h3 id="讲解-weak-ptr-概念"><a href="#讲解-weak-ptr-概念" class="headerlink" title="讲解 weak_ptr 概念"></a>讲解 weak_ptr 概念</h3><ul><li>case 1</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">>></span> objlist<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    objlist<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 进一步移动到 objlist</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引用数初始化为 1</span>    p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>    std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> weak_p <span class="token operator">=</span> p<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 创建一个不影响计数器的弱引用</span>    p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>    <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 控制权转移，p 变为 null， 引用计数不变!</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>weak_p<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// here</span>        weak_p<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正常执行，p 的生命周期仍然被 objlist 延续</span>    <span class="token punctuation">}</span>    objlist<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 刚刚 p移交给 objlist的生命周期结束，引用数-1 变0</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>weak_p<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 因为 shared_ptr 指向的对象，已经释放，弱引用会失败。</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// here</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        weak_p<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">do_sth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 不会执行到这.</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里最后一个弱引用 weak_p 也被释放，他指向的管理块 被释放。</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解决方案1"><a href="#解决方案1" class="headerlink" title="# 解决方案1"></a># 解决方案1</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">struct</span> C <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_child<span class="token punctuation">;</span>    std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> parent <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> child <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 建立相互引用</span>    parent<span class="token operator">-</span><span class="token operator">></span>m_child <span class="token operator">=</span> child<span class="token punctuation">;</span>    child<span class="token operator">-</span><span class="token operator">></span>m_parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    child <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不影响 shared_ptr 计数，弱引用 weak_ptr</p><p>有时候，我们希望维护一个 shared_ptr 的弱引用 weak_ptr, 即 弱引用的拷贝与 解构不影响其引用计数器。</p><p>之后，有需要时，可以再通过 lock() 随时产生一个新的 shared_ptr 作为强引用，但不lock的时候，不影响计数。</p><blockquote><p>lock(): creates a shared_ptr that manages the referenced object</p></blockquote><p>如果失效了(计数器归零), 则 expired() 会返回 true，并且 lock() 会返回nullptr</p><p><strong>可以把 C * 理解为 unique_ptr 的弱引用，weak_ptr 理解为 shared_ptr 的弱引用。但 weak_ptr 能提供 失效检测，更安全。</strong></p><p>shared_ptr 管理的对象生命周期，取决于所有引用中，最长寿的哪一个；</p><p>unique_ptr 管理的对象生命周期长度，取决于他所属的唯一一个引用的寿命。</p><h3 id="智能指针-做为类的成员变量"><a href="#智能指针-做为类的成员变量" class="headerlink" title="# 智能指针 做为类的成员变量"></a># 智能指针 做为类的成员变量</h3><p>可以在类中使用智能指针作为成员变量，需要根据所有权情况，判断使用哪一种智能指针</p><p>1、<strong>unique_ptr</strong>: 当该对象仅仅属于我时，比如 父对象中指向子对象的指针；</p><p>2、<strong>原始指针</strong>: 当该对象不属于我，但他释放前，我必然被释放。比如：子对象中指向父对象的指针；– unique_ptr 和 原始指针 一起使用。</p><p>3、<strong>shared_ptr</strong>: 当该对象由多个对象共享，或虽然该对象仅属于我，但有使用weak_ptr的需要</p><p>4、<strong>weak_ptr</strong>: 当该对象不属于我，且他释放后，我仍可能不被释放时。比如：指向窗口中上一次被点击的元素。</p><p>5、shared_ptr 和 weak_ptr 一起使用。即使 weak_ptr 指向的原指针已失效， expired可以判断出，而不会造成报错。这一点，强于原始指针对 unique_ptr 的弱引用。</p><p><strong>综上 ，初学者 更推荐 shared_ptr 和 weak_ptr的组合，而不是 unique_ptr 和 原始指针的组合。</strong></p><h3 id="解决方案2"><a href="#解决方案2" class="headerlink" title="# 解决方案2"></a># 解决方案2</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">struct</span> C <span class="token punctuation">{</span>     std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>C<span class="token operator">></span> m_child<span class="token punctuation">;</span>    C <span class="token operator">*</span>m_parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> parent <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> child <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 建立相互引用：</span>    parent<span class="token operator">-</span><span class="token operator">></span>m_child <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 移交 child 的所属权给 parent</span>    child<span class="token operator">-</span><span class="token operator">></span>m_parent <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// parent 会被释放。因为 child 指向他的是原始指针</span>    <span class="token comment" spellcheck="true">// 此时 child 也已经被释放了，因为 child 完全隶属于 parent</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>刚才提到的 unique_ptr 的应用场景，“当该对象仅仅属于我时”。既然都是用了原始指针（假设它释放前我必然被释放），因而我们完全可以把 m_child 变成一个标志着 “完全所有权”的 unique_ptr 。</p><p>这样 也不需要， shared_ptr 维护原子计数器的开销。</p><blockquote><p>C++ 中所有的拷贝都是深拷贝，除了 shared_ptr 和 weak_ptr 是浅拷贝，而 unique_ptr 禁止拷贝。</p></blockquote><h2 id="三五法则"><a href="#三五法则" class="headerlink" title="三五法则"></a>三五法则</h2><h3 id="安全和不安全的类型"><a href="#安全和不安全的类型" class="headerlink" title="安全和不安全的类型"></a>安全和不安全的类型</h3><p>① 以下类型是安全的：</p><ul><li>int id; // 基础类型</li><li>std::vector<int> arr; // STL容器 自动调用 vector的深拷贝</int></li><li>std::shared_ptr<Object> child; // 智能指针，它是浅拷贝，引用了计数，也不会出错。除非有循环引用需要 weak_ptr配合</Object></li><li>Object *parent; // 原始指针，前提是从 unique_ptr里 .get() 出来的弱引用，才是合理的</li></ul><p>② 以下对象时不安全的：</p><ul><li>char *ptr; // 原始指针，如果是通过 malloc/free 或者 new/delete 分配的， 需要自己去删除拷贝，或者定义拷贝。</li><li>GLint tex; // 是基础类型 int，但对应的某种资源。实际和 malloc/free函数一样是分配释放资源函数。</li><li>std::vector&lt;Object *&gt; obj; // STL容器，但存储了不安全的对象。 最好，通过深拷贝，或者禁止拷贝来避免 double free 的问题。</li></ul><h3 id="那么什么样的类定义是安全的呢"><a href="#那么什么样的类定义是安全的呢" class="headerlink" title="那么什么样的类定义是安全的呢"></a>那么什么样的类定义是安全的呢</h3><ul><li>如果你的类所有成员，都是安全类型。那么五大函数都不需要声明 (或声明为 = default)，你的类自动就是安全的；</li></ul><p>那么举一个安全的结构体定义</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Mesh <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// points</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>math<span class="token operator">::</span>vec3f<span class="token operator">></span> vert<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// corners</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint32_t<span class="token operator">></span> loop<span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>math<span class="token operator">::</span>vec2f<span class="token operator">></span> loop_uv<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// faces</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint32_t<span class="token operator">></span> poly<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>最好的判断方式，如果你不需自定义解构函数，便可不担心安全问题，<strong>因为通常自定义解构函数</strong>，意味着你的类成员里，包含不安全的类型。</li></ul><p>管理资源的类，先删除它的拷贝构造和拷贝赋值函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">Shader</span><span class="token punctuation">(</span>Shader <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>Shader <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Shader <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>既然，标准库已经提供了 shared_ptr，直接用 shared_ptr<Shader> 来管理。</Shader></p><h3 id="对于数据结构"><a href="#对于数据结构" class="headerlink" title="对于数据结构"></a>对于数据结构</h3><p>如果可以（它的构造函数使用 malloc()），自己定义拷贝和移动函数。</p><p><img src="https://pic4.zhimg.com/80/v2-5070fdad816a798edfcdda5afbaf2707_720w.webp" alt></p><h3 id="如何避免不必要的拷贝：常引用"><a href="#如何避免不必要的拷贝：常引用" class="headerlink" title="如何避免不必要的拷贝：常引用"></a>如何避免不必要的拷贝：常引用</h3><p>函数的参数声明为值类型，此时，实际调用了类的拷贝构造函数。产生了一次不必要的拷贝。那么替换成 const &amp;，常引用，从而传递了一个指针，避免了拷贝。</p><h3 id="函数参数类型优化规则：-按引用还是按值？"><a href="#函数参数类型优化规则：-按引用还是按值？" class="headerlink" title="函数参数类型优化规则： 按引用还是按值？"></a>函数参数类型优化规则： 按引用还是按值？</h3><pre class="line-numbers language-text"><code class="language-text">① 如果参数是基础类型（int、float） 则按值传递；       float  squareRoot(float val);② 如果是原始指针（int*、Object*）则按值传递；       void doSomethingWith(Object *ptr);③ 如果是 容器类型（vector、string）则按常引用传递；       int sumArray(std::vector<int> const &arr);④ 如果容器不大 （tuple<int, int>）按值传递；       glm::vec3 calculate(glm::vec3 pos);⑤ 如果智能指针（shared_ptr）且需要生命周期控制权，则按值传递；用户自己调用 std::move()       void addObject(std::shared_ptr<Object> obj);⑥ 如果是智能指针，但不需要生命周期，则通过 .get() 获取原始指针后，按值传递；       void modifyObject(Object *obj);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>只有数据容器、自定义的可拷贝的类，使用常引用的方法。</li></ul><h3 id="避免不必要的隐式拷贝"><a href="#避免不必要的隐式拷贝" class="headerlink" title="避免不必要的隐式拷贝"></a>避免不必要的隐式拷贝</h3><p>我们 可以将拷贝构造函数声明为 explicit (明确的)，这样隐式拷贝会出错，从而发现不必要的拷贝。</p><p><img src="https://pic2.zhimg.com/80/v2-20424e22ed1a52d441d087e172255fd5_720w.webp" alt></p><h2 id="语言管理资源"><a href="#语言管理资源" class="headerlink" title="语言管理资源"></a>语言管理资源</h2><p>为什么很多面向对象的语言，比如Java，都没有构造函数全家桶的概念呢？</p><ul><li>因为，他们的业务需求大都是面向资源的，比如操作数据库，发送http请求等等。</li><li>这些业务往往都是和“资源”在打交道，从而，基本上都是删除了拷贝函数的那一类，解决这类需求，几乎总是在用 shared_ptr<GLShader> 的模式，于是 Java和Python 干脆简化：一切非基础类型的对象都是 <strong>浅拷贝</strong>，使用引用计数，同时再通过 <strong>垃圾回收机制</strong> 自动管理。</GLShader></li></ul><p>因此，以<strong>系统级编程、算法数据结构、高性能计算</strong> 为主要业务的C++，才发展出了这些思想，并将 <strong>拷贝、移动、指针、可变性、多线程</strong> 等概念作为 <strong>语言基础元素</strong> 而存在。这些在我们的业务中非常重要，所以不可替代。</p><h2 id="扩展关键词"><a href="#扩展关键词" class="headerlink" title="扩展关键词"></a>扩展关键词</h2><p>1、P-IMPL 的模式</p><p>2、虚函数和纯虚函数</p><p>3、拷贝如何作为虚函数</p><p>4、std::unique_ptr::release()</p><p>5、std::enable_shared_from_this</p><p>6、dynamic_cast</p><p>7、std::dynamic_pointer_cast</p><p>8、运算符重载</p><p>9、右值引用 &amp;&amp;</p><p>10、std::shared_ptr<void> 和 std::any // 可以接受任何一个对象指针，和c的void *像，但可以管理生命周期，std::any 深拷贝版本的 shared_ptr<void></void></void></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概-述&quot;&gt;&lt;a href=&quot;#概-述&quot; class=&quot;headerlink&quot; title=&quot;概 述&quot;&gt;&lt;/a&gt;概 述&lt;/h2&gt;&lt;h3 id=&quot;RAII-Resource-Acquisition-Is-Initialization&quot;&gt;&lt;a href=&quot;#RAII-R
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Effective STL-STL使用经验</title>
    <link href="https://joytsing.github.io/posts/15264/"/>
    <id>https://joytsing.github.io/posts/15264/</id>
    <published>2023-12-12T02:41:15.000Z</published>
    <updated>2023-12-14T07:44:24.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于接口和实现分离的原则，了解STL的接口和STL的实现。</p><h2 id="第-1-条：慎重选择容器类型"><a href="#第-1-条：慎重选择容器类型" class="headerlink" title="第 1 条：慎重选择容器类型"></a><strong>第 1 条：慎重选择容器类型</strong></h2><ul><li>标准 STL 序列容器：vector、string、deque、list。</li><li>标准 STL 关联容器：set、multiset、map、multimap（注：unordered_set、unordered_map 在 C++11 的时候也被引入标准库）。</li><li>非标准序列容器：slist：是一个单向链表，rope 本质上是一个”重型“string。</li><li>非标准的关联容器：hash_set、hash_multiset、hash_map、hash_multimap。</li></ul><p>如何区分以上序列容器还是关联容器，《ESTL》提供了一种分类方法：基于连续内存容器和基于节点的容器分类。</p><p><strong>连续内存容器</strong> ：把它的元素存放在一块或多块（动态分配）内存中，每块内存中存有多个元素，当有新元素插入或已有的元素被删除时，统一内存块的元素需要向前或向后移动。以便给新元素让出空间，或者填充被删除元素所留下的空隙，这种移动影响效率和异常安全性。</p><p><strong>基于节点的容器</strong>：每一个（动态分配）的内存块中只存放一个元素。容器中元素的插入或删除只影响到指向节点的指针，而不影响节点本身的内容，所以当有插入或删除操作时候，元素的值不需要移动。</p><ul><li><strong>是否需要在容器的任意位置插入新元素？</strong> 如果需要，就选择序列容器否则选择关联容器。</li><li><strong>是否关心容器中元素是排序的？</strong> 如果不关心则哈希容器是一个可行选择方案；否则你要避免哈希容器。</li><li><strong>需要哪种类型的迭代器？</strong> 如果必须是随机访问迭代器，则对容器的选择就限定为vector、deque和string。如果要求使用双向迭代器，则避免使用slist和哈希容器。</li><li><strong>当发生元素的插入和删除操作时候，避免移动容器中原来的元素是否重要？</strong> 如果是就要避免选择序列容器。</li><li><strong>容器中数据布局是否需要和C保持兼容？</strong> 如果是是只能选择 vector。</li><li><strong>元素的查找速度是否是关键的考虑因素？</strong> 如果是考虑哈希容器。</li><li><strong>如果容器内部使用引用计数技术是否介意？</strong> 如果是则避免使用string因为许多string的实现都是用了引用计数。如果需要表示某种字符串的方法，可以使用vector方法。</li><li><strong>对插入和删除操作，需要事务语义么</strong> 在插入和操作失败的时需要回滚的能力么？如果需要就有使用基于节点的容器，如果需要对多个元素插入操作需要事务，则可以选择list。因为在标准容器中，只有list提供了多个元素的事务语义。但注意：事务语义对编写异常安全代码很重要但同时付出性能上代价。</li><li><strong>需要使用迭代器、指针和引用变为无效的次数最少么</strong> 如果是就需要使用基于节点的容器，因为这类对容器的插入和删除从来不会使用迭代器和指针和引用无效；而对连续内存的容器的插入和删除一般会对指向该容器的迭代器和指针、引用变为无效。</li><li><strong>如果在容器上使用swap使得迭代器失效了会在意吗</strong> 如果在意那么避免使用 string，因为 string 是唯一在STL中 swap 操作过程中导致迭代器、指针和引用无效唯一的容器。</li><li><strong>如果序列容器迭代器是随机访问，而且只要没有删除操作发生，且插入操作只发生容器末尾，则指向数据的指针和引用就不会变为无效，这样容器是否考虑</strong> 这是一种很特殊的情况，如果是则 deque 满足你的需求，deque 是唯一的迭代器可能会变为无效和指针和引用不会变为无效的 STL 标准容器。</li></ul><h2 id="第-2-条：不要试图编写独立于容器类型的代码"><a href="#第-2-条：不要试图编写独立于容器类型的代码" class="headerlink" title="第 2 条：不要试图编写独立于容器类型的代码"></a><strong>第 2 条：不要试图编写独立于容器类型的代码</strong></h2><p>STL 是以泛化原则为基础的：</p><ul><li>数组被泛化为”以其包含的对象的类型为参数“的容器；</li><li>函数被泛化为”以其使用的迭代器的类型为参数“的算法；</li><li>指针被泛化为”以其指向的对象的类型为参数“的迭代器；</li><li>容器被泛化为”序列式和关联式“容器。</li></ul><p>试图编写对序列式容器和关联式容器都适用的代码几乎是毫无意义的。面对实际情况，不同容器是不同的，它们有非常明显的优缺点，不同的适用场景适合选择不同的容器。</p><h2 id="第-3-条：确保容器中的对象拷贝正确而高效"><a href="#第-3-条：确保容器中的对象拷贝正确而高效" class="headerlink" title="第 3 条：确保容器中的对象拷贝正确而高效"></a><strong>第 3 条：确保容器中的对象拷贝正确而高效</strong></h2><p>当(通过如 insert 或 push_back 之类的操作)向容器中加入对象时，存入容器的是你所指定的对象的拷贝。</p><p>当(通过如front或back之类的操作)从容器中取出一个对象时，你所得到的是容器中所保存的对象的拷贝。</p><p><strong>进去的是拷贝，出来的也是拷贝(copy in, copy out)。这就是 STL 的工作方式。</strong></p><p>一旦一个对象被保存到容器中，它经常会进一步被拷贝。当对 vector、string 或 deque 进行元素的插入或删除操作时，现有元素的位置通常会被移动(拷贝)。如果你使用下列任何操作—-排序算法，next_permutation 或previous_permutation, remove、unique 或类似的操作，rotate 或 reverse,等等—-那么对象将会被移动(拷贝)。没错，拷贝对象是 STL 的工作方式。</p><p>在存在继承关系的基础下，拷贝动作会导致剥离，也就是说，如果你创建了一个存放基类对象的容器，却向其中插入派生类的对象，那么在派生类对象(通过基类的拷贝构造函数)被拷贝进容器时，它所特有的部分(即派生类中的信息)将会丢失。<strong>剥离问题</strong>意味着向基类对象的容器中插入派生类对象<strong>几乎总是错误的</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SpecialWidget</span><span class="token operator">:</span> <span class="token keyword">public</span> Widget <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget<span class="token operator">></span> vw<span class="token punctuation">;</span>  SpecialWidget sw<span class="token punctuation">;</span>  vw<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>sw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//sw作为基类对象被拷贝进vw，它的派生类特有的部分在拷贝的时候被丢弃了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使拷贝动作高效、正确，并防止剥离问题发生的一个简单办法是使容器包含指针而不是对象。比如使用 <code>std::vector&lt;Widget*&gt; vw</code>; 而非上述操作。</p><h2 id="第-4-条：调用-empty-而不是检查-size-是否为-0"><a href="#第-4-条：调用-empty-而不是检查-size-是否为-0" class="headerlink" title="第 4 条：调用 empty 而不是检查 size() 是否为 0"></a><strong>第 4 条：调用 empty 而不是检查 size() 是否为 0</strong></h2><pre class="line-numbers language-text"><code class="language-text">//对任意 c 容器，下面的代码本质上等价的if (c.size() == 0) {}if (c.empty()) {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那既然如此，为何建议使用 empty 优先级于 size()，原因在于：empty 对所有的标准容器都是常数时间操作，而对一些 list 实现，size 函数耗费线性时间。（比如 list 容器的 splice 函数）。</p><h2 id="第-5-条：区间成员函数优先于与之对应的单元素成员函数"><a href="#第-5-条：区间成员函数优先于与之对应的单元素成员函数" class="headerlink" title="第 5 条：区间成员函数优先于与之对应的单元素成员函数"></a><strong>第 5 条：区间成员函数优先于与之对应的单元素成员函数</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget5</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget5<span class="token operator">></span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">;</span> v1<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 推荐</span> v1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget5<span class="token operator">></span><span class="token operator">::</span>const_iterator ci <span class="token operator">=</span> v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> ci <span class="token operator">!=</span> v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>ci<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 不推荐</span>   v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span> v1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 效率不如assign</span> v1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> v2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对copy的调用可以被替换为利用区间的insert版本</span> <span class="token keyword">const</span> <span class="token keyword">int</span> numValues <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token keyword">int</span> data<span class="token punctuation">[</span>numValues<span class="token punctuation">]</span><span class="token punctuation">;</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> data <span class="token operator">+</span> numValues<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 推荐，使用区间成员函数insert</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator <span class="token function">insertLoc</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numValues<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>   insertLoc <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>insertLoc<span class="token punctuation">,</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不推荐，使用单元素成员函数</span>   <span class="token operator">++</span>insertLoc<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>区间成员函数是指这样的一类成员函数，它们像 STL 算法一样，使用两个迭代器参数来确定该成员操作所执行的区间。如果不使用区间成员函数就得写一个显示的循环。</p><p>优点在于：</p><ul><li>C++ 标准要求区间insert 函数把现有容器中元素直接移动到它们最终的位置上，即只需要付出每个元素移动一次的代价。</li><li>明智地使用区间插入而不是单元素重复插入会提高程序的性能问题，比如对于vector来说如果内存已满再插入新元素会触发两倍扩容，区间插入不必多次重新分配内存。</li><li>区间成员函数减少代码量，形成更易懂的代码，增强软件长期可维护性。</li></ul><p>那么，都有哪些区间成员函数？</p><ul><li>区间创建函数、insert、erase、assign等</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">container<span class="token operator">::</span><span class="token function">container</span><span class="token punctuation">(</span>InputIterator begin<span class="token punctuation">,</span> InputIterator end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//区间</span><span class="token keyword">void</span> container<span class="token operator">::</span><span class="token function">container</span><span class="token punctuation">(</span>iterator position<span class="token punctuation">,</span> InputIterator begin<span class="token punctuation">,</span> InputIterator end<span class="token punctuation">)</span><span class="token punctuation">;</span>iterator container<span class="token operator">::</span><span class="token function">erase</span><span class="token punctuation">(</span>iterator begin<span class="token punctuation">,</span> iterator end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> container<span class="token operator">::</span><span class="token function">erase</span><span class="token punctuation">(</span>iterator begin<span class="token punctuation">,</span> iterator end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> container<span class="token operator">::</span><span class="token function">assign</span><span class="token punctuation">(</span>iterator begin<span class="token punctuation">,</span> iterator end<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第-6-条：当心-C-编译器最烦人的分析机制"><a href="#第-6-条：当心-C-编译器最烦人的分析机制" class="headerlink" title="第 6 条：当心 C++ 编译器最烦人的分析机制"></a><strong>第 6 条：当心 C++ 编译器最烦人的分析机制</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 注意：围绕参数名的括号(比如对f2中d)与独立的括号的区别：围绕参数名的括号被忽略，而独立的括号则表明参数</span><span class="token comment" spellcheck="true">// 列表的存在：它们说明存在一个函数指针参数</span><span class="token keyword">int</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明了一个带double参数并返回int的函数</span><span class="token keyword">int</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 同上，d两边的括号被忽略,可以给参数名加上圆括号</span><span class="token keyword">int</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 同上，参数名被忽略</span><span class="token keyword">int</span> <span class="token function">g1</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 参数是一个指向不带任何参数的函数的指针，该函数返回double值；g1以指向函数的指针为参数</span><span class="token keyword">int</span> <span class="token function">g2</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token function">pf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 同上，pf为隐式指针</span><span class="token keyword">int</span> <span class="token function">g3</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 同上，省去参数名</span><span class="token keyword">int</span> <span class="token function">test_item_6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 把一个存有整数(int)的文件ints.dat拷贝到一个list中</span> std<span class="token operator">::</span>ifstream <span class="token function">dataFile</span><span class="token punctuation">(</span><span class="token string">"ints.dat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">data1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>dataFile<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 小心，结果不会是你所想象的那样</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">data2</span><span class="token punctuation">(</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>dataFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确，注意list构造函数的第一个参数两边的括号</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dataBegin</span><span class="token punctuation">(</span>dataFile<span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dataEnd<span class="token punctuation">;</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">data3</span><span class="token punctuation">(</span>dataBegin<span class="token punctuation">,</span> dataEnd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用命名的迭代器对象与通常的STL程序风格相违背，但你或许觉得为了使代码对所有编译器都没有二义性，并且使维护代码的人理解起来更容易，这一代价是值得的。</p><h2 id="第-7-条：如果容器中包含了通过-new-操作创建的指针，切记在容器对象析构前将指针-delete-掉"><a href="#第-7-条：如果容器中包含了通过-new-操作创建的指针，切记在容器对象析构前将指针-delete-掉" class="headerlink" title="第 7 条：如果容器中包含了通过 new 操作创建的指针，切记在容器对象析构前将指针 delete 掉"></a><strong>第 7 条：如果容器中包含了通过 new 操作创建的指针，切记在容器对象析构前将指针 delete 掉</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget7</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> DeleteObject <span class="token punctuation">{</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">const</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget7<span class="token operator">*</span><span class="token operator">></span> vwp1<span class="token punctuation">,</span> vwp2<span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  vwp1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget7<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果在后面自己不delete，使用vwp在这里发生了Widget7的泄露</span>  vwp2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget7<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget7<span class="token operator">*</span><span class="token operator">></span><span class="token operator">::</span>iterator i <span class="token operator">=</span> vwp1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> vwp1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">delete</span> <span class="token operator">*</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 能行，但不是异常安全的</span> <span class="token punctuation">}</span> <span class="token function">for_each</span><span class="token punctuation">(</span>vwp2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vwp2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DeleteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确，类型安全，但仍不是异常安全的</span> <span class="token keyword">typedef</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget7<span class="token operator">></span> SPW<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SPW"指向Widget7的shared_ptr"</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>SPW<span class="token operator">></span> vwp3<span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  vwp3<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">SPW</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget7<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从Widget7创建SPW,然后对它进行一次push_back使用vwp3,这里不会有Widget7泄露，即使有异常被抛出</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>STL 容器很智能，但没有智能到知道是否该删除自己所包含的指针的程度。当你使用指针的容器，而其中的指针应该被删除时，为了避免资源泄漏，你必须或者用引用计数形式的智能指针对象(比如std::shared_ptr)代替指针，或者当容器被析构时手工删除其中的每个指针。</p><h2 id="第-8-条：切勿创建包含-auto-ptr-的容器对象"><a href="#第-8-条：切勿创建包含-auto-ptr-的容器对象" class="headerlink" title="第 8 条：切勿创建包含 auto_ptr 的容器对象"></a><strong>第 8 条：切勿创建包含 auto_ptr 的容器对象</strong></h2><p>auto_ptr 的容器(简称COAP) 是被禁止的。当你拷贝一个 auto_ptr 时，它所指向的对象的所有权被移交到拷入的 auto_ptr 上，而它自身被置为 NULL。如果你的目标是包含智能指针的容器，这并不意味着你要倒霉，包含智能指针的容器是没有问题的。但 auto_ptr 非智能指针。</p><h2 id="第-9-条：慎重选择删除元素的方法"><a href="#第-9-条：慎重选择删除元素的方法" class="headerlink" title="第 9 条：慎重选择删除元素的方法"></a><strong>第 9 条：慎重选择删除元素的方法</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">badValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 返回x是否为"坏值"</span><span class="token keyword">int</span> <span class="token function">test_item_9</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 删除c中所有值为1963的元素</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> c1<span class="token punctuation">;</span> c1<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1963</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当c1是vector, string或deque时，erase-remove习惯用法是删除特定值的元素的最好办法</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> c2<span class="token punctuation">;</span> c2<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">1963</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当c2是list时，remove成员函数是删除特定值的元素的最好办法</span> std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> c3<span class="token punctuation">;</span> c3<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">1963</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当c3是标准关联容器时，erase成员函数是删除特定值元素的最好办法</span> <span class="token comment" spellcheck="true">// 删除判别式(predicate)返回true的每一个对象</span> c1<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">remove_if</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> badValue<span class="token punctuation">)</span><span class="token punctuation">,</span> c1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当c1是vector, string或deque时，这是删除使badValue返回true的对象的最好办法</span> c2<span class="token punctuation">.</span><span class="token function">remove_if</span><span class="token punctuation">(</span>badValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当c2是list时，这是删除使badValue返回true的对象的最好办法</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator i <span class="token operator">=</span> c3<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> c3<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">badValue</span><span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> c3<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对坏值，把当前的i传给erase，递增i是副作用</span>  <span class="token keyword">else</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 对好值，则简单的递增i</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 每次元素被删除时，都向一个日志(log)文件中写一条信息</span> std<span class="token operator">::</span>ofstream logFile<span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator i <span class="token operator">=</span> c3<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> c3<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">badValue</span><span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   logFile <span class="token operator">&lt;&lt;</span> <span class="token string">"Erasing "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>i <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 写日志文件</span>   c3<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对坏值，把当前的i传给erase，递增i是副作用</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 对好值，则简单第递增i</span> <span class="token punctuation">}</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator i <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> c1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">badValue</span><span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   logFile <span class="token operator">&lt;&lt;</span> <span class="token string">"Erasing "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>i <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>   i <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 把erase的返回值赋给i，使i的值保持有效</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token operator">++</span>i<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下：</p><ul><li>要删除容器中有特定值的所有对象：如果容器是 vector，string 或deque，则使用 erase-remove 习惯用法；如果容器是list，则使用 list::remove；如果容器是一个标准关联容器，则使用它的 erase 成员函数。</li><li>要删除容器中满足特定判别式(条件)的所有对象：如果容器是vector， string或deque，则使用erase-remove_if习惯用法；如果容器是list，则使用list::remove_if；如果容器是一个标准关联容器，则使用remove_copy_if和swap，或者写一个循环来遍历容器中的元素，记住当把迭代器传给erase时，要对它进行后缀递增。</li><li>要在循环内做某些(除了删除对象之外的)操作：如果容器是一个标准序列容器，则写一个循环来遍历容器中的元素，记住每次调用erase时，要用它的返回值更新迭代器；如果容器是一个标准关联容器，则写一个循环来遍历容器中的元素，记住当把迭代器传给erase时，要对迭代器做后缀递增。</li></ul><h2 id="第-10-条：了解分配子-allocator-的约定和限制"><a href="#第-10-条：了解分配子-allocator-的约定和限制" class="headerlink" title="第 10 条：了解分配子(allocator)的约定和限制"></a><strong>第 10 条：了解分配子(allocator)的约定和限制</strong></h2><p>编写自定义的分配子，需要注意：</p><ul><li>你的分配子是一个模板，模板参数T代表你为它分配内存的对象的类型。</li><li>提供类型定义 pointer 和 reference，但是始终让 pointer 为T指针，reference为T&amp;。</li><li>千万别让你的分配子拥有随对象而不同的状态(per-object state)。通常，分配子不应该有非静态的数据成员。*</li><li>记住，传给分配子的 allocate 成员函数的是那些要求内存的对象的个数，而不是所需的字节数。同时要记住，这些函数返回T*指针(通过pointer类型定义)，即使尚未有T对象被构造出来。</li><li>一定要提供嵌套的 rebind 模板，因为标准容器依赖该模板。</li></ul><h2 id="第-11-条：理解并自定义分配子的合理用法"><a href="#第-11-条：理解并自定义分配子的合理用法" class="headerlink" title="第 11 条：理解并自定义分配子的合理用法"></a><strong>第 11 条：理解并自定义分配子的合理用法</strong></h2><p>看一段代码</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">mallocShared</span><span class="token punctuation">(</span>size_t bytesNeed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>bytesNeed<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">freeShared</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">SharedMemoryAllocator</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> T<span class="token operator">*</span> pointer<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//pointer是个类型定义，它实际上总是T*</span>    <span class="token keyword">typedef</span> size_t size_type<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//通常情况下，size_type 是 size_t 的一个类型定义</span>    <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>    pointer <span class="token function">allocate</span><span class="token punctuation">(</span>size_type numObj<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> localHint <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>pointer<span class="token operator">></span><span class="token punctuation">(</span><span class="token function">mallocShared</span><span class="token punctuation">(</span>numObj <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span>pointer ptrToMemory<span class="token punctuation">,</span> size_type numObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">freeShared</span><span class="token punctuation">(</span>ptrToMemory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span> <span class="token keyword">struct</span> rebind <span class="token punctuation">{</span>  <span class="token keyword">typedef</span> std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>U<span class="token operator">></span> other<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_11</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">typedef</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> SharedMemoryAllocator<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span> SharedDoubleVec<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// v所分配的用来容纳其元素的内存将来自共享内存</span> <span class="token comment" spellcheck="true">// 而v自己----包括它所有的数据成员----几乎肯定不会位于共享内存中，v只是普通的基于栈(stack)的对象，所以，像所有基于栈的对象一样，它将会被运行时系统放在任意可能的位置上。这个位置几乎肯定不是共享内存</span> SharedDoubleVec v<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个vector,其元素位于共享内存中</span> <span class="token comment" spellcheck="true">// 为了把v的内容和v自身都放到共享内存中，需要这样做</span> <span class="token keyword">void</span><span class="token operator">*</span> pVectorMemory <span class="token operator">=</span> <span class="token function">mallocShared</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SharedDoubleVec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 为SharedDoubleVec对象分配足够的内存</span> SharedDoubleVec<span class="token operator">*</span> pv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>pVectorMemory<span class="token punctuation">)</span>SharedDoubleVec<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用"placement new"在内存中创建一个SharedDoubleVec对象</span> <span class="token comment" spellcheck="true">// ... // 使用对象(通过pv)</span> pv<span class="token operator">-</span><span class="token operator">></span><span class="token operator">~</span><span class="token function">SharedDoubleVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 析构共享内存中的对象</span> <span class="token function">freeShared</span><span class="token punctuation">(</span>pVectorMemory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 释放最初分配的那一块共享内存</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遵守同一类型的分配子必须是等价的这一限制要求。</p><h2 id="第-12-条：切勿对-STL-容器的线程安全性有不切实际的依赖"><a href="#第-12-条：切勿对-STL-容器的线程安全性有不切实际的依赖" class="headerlink" title="第 12 条：切勿对 STL 容器的线程安全性有不切实际的依赖"></a><strong>第 12 条：切勿对 STL 容器的线程安全性有不切实际的依赖</strong></h2><p>对一个 STL 实现，你最多只能期望：</p><ul><li>多个线程读取是安全的。</li><li>多个线程对不同的容器做写入操作是安全的</li></ul><p>考虑当一个库视图实现完全的容器线程安全性时可能采取的方式：</p><ul><li>对容器成员函数的每次调用，都锁住容器直到调用结束</li><li>在容器所返回的每个迭代器的生存期结束前，都锁住容器</li><li>对作用于容器的每个算法，都锁住该该容器，直到容器结束</li></ul><p>当涉及到STL容器和线程安全性时，你可以指望一个STL库允许多个线程同时读一个容器，以及多个线程对不同的容器做写入操作。你不能指望STL库会把你从手工同步控制中解脱出来，而且你不能依赖于任何线程支持。</p><p>例如</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> g_v<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        g_v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第-13-条：vector和string优先于动态分配的数组"><a href="#第-13-条：vector和string优先于动态分配的数组" class="headerlink" title="第 13 条：vector和string优先于动态分配的数组"></a><strong>第 13 条：vector和string优先于动态分配的数组</strong></h2><p>如果使用动态的分配数组，那么可能需要做更多的工作，为了减轻负担，使用 vector 和 string 。</p><h2 id="第-14-条：使用-reserve-来避免不必要的重新分配"><a href="#第-14-条：使用-reserve-来避免不必要的重新分配" class="headerlink" title="第 14 条：使用 reserve 来避免不必要的重新分配"></a><strong>第 14 条：使用 reserve 来避免不必要的重新分配</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_14</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果不使用reserve,下面的循环在进行过程中将导致2到10次重新分配;加上reserve，则在循环过程中,将不会再发生重新分配</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 vector 和 string，增长过程是这样来实现的：每当需要更多空间时，就调用与 realloc类似的操作。这一类似于 realloc 的操作分为四部分：</p><ul><li>分配一块大小为当前容量的某个倍数的新内存。在大多数实现中，vector 和 string 的容量每次以 2 的倍数增长，即，每当容器需要扩张时，它们的容量即加倍。</li><li>把容器的所有元素从旧的内存拷贝到新的内存中。</li><li>析构掉就内存中的对象。</li><li>释放旧内存。</li></ul><p>reserve 函数能使你把重新分配的次数减少到最低程度，从而避免了重新分配和指针/迭代器/引用失效带来的开销。避免重新分配的关键在于，尽早地使用 reserve ，把容器的容量设为足够大的值，最好是在容器刚被构造出来之后就使用reserve。</p><p>通常有两种方式来使用reserve以避免不必要的重新分配。 第一种方式是，若能确切知道或大致预计容器中最终会有多少元素，则此时可以使用reserve。第二种方式是，先预留足够大的空间(根据你的需要而定)，然后，当把所有数据都加入以后，再去除多余的容量。</p><h2 id="第-15-条：注意-string-实现的多样性"><a href="#第-15-条：注意-string-实现的多样性" class="headerlink" title="第 15 条：注意 string 实现的多样性"></a><strong>第 15 条：注意 string 实现的多样性</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_15</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"string size: %d, char* size: %d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>string 的值可能会被引用计数，也可能不会。很多实现在默认情况下会使用引用计数，但它们通常提供了关闭默认选择的方法，往往是通过预处理宏来做到这一点。</li><li>string 对象大小的范围可以是一个 char* 指针大小的 1 倍到 7 倍。</li><li>创建一个新的字符串值可能需要零次、一次或两次动态分配内存。</li><li>string 对象可能共享，也可能不共享其大小和容量信息。</li><li>string 可能支持，也可能不支持针对单个对象的分配子。</li><li>不同的实现对字符内存的最小分配单位有不同的策略。</li></ul><h2 id="第-16-条：了解如何把-vector-和-string-数据传给旧的-API"><a href="#第-16-条：了解如何把-vector-和-string-数据传给旧的-API" class="headerlink" title="第 16 条：了解如何把 vector 和 string 数据传给旧的 API"></a><strong>第 16 条：了解如何把 vector 和 string 数据传给旧的 API</strong></h2><p>C++ 标准要求 vector 中的元素存储在连续的内存中，就像数组一样。string 中的数据不一定存储在连续的内存中，而且 string 的内部表示不一定是以空字符结尾的。</p><h2 id="第-17-条：使用”swap技巧”除去多余的容量"><a href="#第-17-条：使用”swap技巧”除去多余的容量" class="headerlink" title="第 17 条：使用”swap技巧”除去多余的容量"></a><strong>第 17 条：使用”swap技巧”除去多余的容量</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Contestant</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_17</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 从contestants矢量中除去多余的容量</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Contestant<span class="token operator">></span> contestants<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ... // 让contestants变大，然后删除它的大部分元素</span> <span class="token comment" spellcheck="true">// vector&lt;Contestant>(contestants)创建一个临时矢量，vector的拷贝构造函数只为所拷贝的元素分配所需要的内存</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Contestant<span class="token operator">></span><span class="token punctuation">(</span>contestants<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>contestants<span class="token punctuation">)</span><span class="token punctuation">;</span> contestants<span class="token punctuation">.</span><span class="token function">shrink_to_fit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// C++11</span> std<span class="token operator">::</span>string s<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ... // 让s变大，然后删除它的大部分字符</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> s<span class="token punctuation">.</span><span class="token function">shrink_to_fit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// C++11</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Contestant<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>contestants<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 清除contestants并把它的容量变为最小</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 清除s并把它的容量变为最小</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对 vector 或 string 进行 shrink-to-fit 操作时，考虑”swap”技巧。C++11 中增加了shrink_to_fit 成员函数。</p><p>swap 技巧的一种变化形式可以用来清除一个容器，并使其容量变为该实现下的最下值。</p><p>在做 swap 的时候，不仅两个容器的内容被交换，同时它们的迭代器、指针和引用也将被交换(string除外)。在 swap 发生后，原先指向某容器中元素的迭代器、指针和引用依然有效，并指向同样的元素—-但是，这些元素已经在另一个容器中了。</p><h2 id="第-18-条：-避免使用-vector-lt-bool-gt-类型"><a href="#第-18-条：-避免使用-vector-lt-bool-gt-类型" class="headerlink" title="第 18 条： 避免使用 vector &lt; bool&gt; 类型"></a><strong>第 18 条： 避免使用 vector &lt; bool&gt; 类型</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_18</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> v<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: cannot convert 'std::vector&lt;bool>::reference* {aka std::_Bit_reference}' to 'bool*' in initialization</span> <span class="token comment" spellcheck="true">//bool* pb = &amp;v[0]; // 不能被编译，原因：vector&lt;bool>是一个假的容器，它并不真的储存bool，相反，为了节省空间，它储存的是bool的紧凑表示</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>作为一个 STL 容器，vector 只有两点不对。首先，它不是一个 STL 容器；其次，它并不存储bool。除此以外，一切正常。</p><p>在一个典型的实现中，储存在 ”vector” 中的每个 ”bool” 仅占一个二进制位，一个 8 位的字节可容纳 8 个 ”bool”。在内部，vector 使用了与位域 (bit field)一样的思想，来表示它所存储的那些bool，实际上它只是假装存储了这些 bool。</p><p>位域与 bool 相似，它只能表示两个可能的值，但是在 bool 和看似 bool 的位域之间有一个很重要的区别：你可以创建一个指向 bool 的指针，而指向单个位的指针则是不允许的。指向单个位的引用也是被禁止的。</p><p>当你需要 vector时，标准库提供了两种选择，可以满足绝大多数情况下的需求。</p><ul><li>第一种是 deque。deque 几乎提供了 vector 所提供的一切(没有reserve和capacity)，但deque 是一个 STL 容器，而且它确实存储 bool。当然 deque 中元素的内存不是连续的，所以你不能把 deque 中的数据传递给一个期望 bool 数组的 C API。</li><li>第二种可以替代 vector 的选择是 bitset。bitset 不是 STL 容器，但它是标准 C++ 库的一部分。与 STL 容器不同的是，它的大小(即元素的个数)在编译时就确定了，所以它不支持插入和删除元素。</li></ul><h2 id="第-19-条：理解相等-equality-和等价-equivalence-的区别"><a href="#第-19-条：理解相等-equality-和等价-equivalence-的区别" class="headerlink" title="第 19 条：理解相等(equality)和等价(equivalence)的区别"></a><strong>第 19 条：理解相等(equality)和等价(equivalence)的区别</strong></h2><p>相等的概念是基于 operator== 的。等价关系是以”在已排序的区间中对象值的相对顺序”为基础的。标准关联容器是基于等价而不是相等。</p><p>标准关联容器总是保持排列顺序的，所以每个容器必须有一个比较函数(默认为 less )来决定保持怎样的顺序。等价的定义正是通过该比较函数而确定的，因此，标准关联容器的使用者要为所使用的每个容器指定一个比较函数(用来决定如何排序)。</p><p>如果该关联容器使用相等来决定两个对象是否有相同的值，那么每个关联容器除了用于排序的比较函数外，还需要另一个比较函数来决定两个值是否相等。(默认情况下，该比较函数应该是 equal_to，但 equal_to 从来没有被用作 STL 的默认比较函数。当 STL 中需要相等判断时，一般的惯例是直接调用 operator ==)。</p><h2 id="第-20-条：为包含指针的关联容器指定比较类型"><a href="#第-20-条：为包含指针的关联容器指定比较类型" class="headerlink" title="第 20 条：为包含指针的关联容器指定比较类型"></a><strong>第 20 条：为包含指针的关联容器指定比较类型</strong></h2><p>每当你要创建包含指针的关联容器时，一定要记住，容器将会按照指针的值进行排序。绝大多数情况下，这不会是你所希望的，所以你几乎肯定要创建自己的函数子类作为该容器的比较类型(comparison type)。</p><p>如果你有一个包含智能指针或迭代器的容器，那么你也要考虑为它指定一个比较类型。对指针的解决方案同样也适用于那些类似指针的对象。就像DereferenceLess适合作为包含T*的关联容器的比较类型一样，对于容器中包含了指向T对象的迭代器或智能指针的情形，DereferenceLess也同样可用作比较类型。</p><h2 id="第-21-条：总是让比较函数在等值情况下返回-false"><a href="#第-21-条：总是让比较函数在等值情况下返回-false" class="headerlink" title="第 21 条：总是让比较函数在等值情况下返回 false"></a><strong>第 21 条：总是让比较函数在等值情况下返回 false</strong></h2><p>实际踩坑简化版</p><p>背景：现在我们有一个排序的结构体，假设数据经过召回、过滤等一系列操作后，得到最终的候选集，需要根据相应的策略，进行排序，最终返回 top k 结果</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> DataItem <span class="token punctuation">{</span>  std<span class="token operator">::</span>string data_id<span class="token punctuation">;</span>  <span class="token keyword">int</span> priority<span class="token punctuation">;</span>  <span class="token keyword">int</span> score<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先根据 priority 值判断，最终根据 score 值是否相等返回。</p><p>线上代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">DataSort</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>DataItem<span class="token operator">></span> <span class="token operator">&amp;</span>data_items<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>data_items<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data_items<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> DataItem <span class="token operator">&amp;</span>item1<span class="token punctuation">,</span> <span class="token keyword">const</span> DataItem <span class="token operator">&amp;</span>item2<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>item1<span class="token punctuation">.</span>priority <span class="token operator">&lt;</span> item2<span class="token punctuation">.</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>item1<span class="token punctuation">.</span>priority <span class="token operator">></span> item2<span class="token punctuation">.</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> item1<span class="token punctuation">.</span>score <span class="token operator">>=</span> item2<span class="token punctuation">.</span>score<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试环境构造测试 case，符合预期，上线。但不久问题就出现了，上线不久后，程序直接 coredump，然后自动重启把 core 文件拉到本地调试或者编译成 debug 版，线上问题复现，原因就是因为 DataSort 导致，但是在 DataSort 中，就一个简单的排序，sort 不可能出现崩溃，唯一的原因，就是 lambda 函数实现有问题。重新修改 lambda 函数，把最后一句 return item1.score &gt;= item2.score 改成 return false 执行，运行正常</p><p>打开 Google，输入 std::sort coredump，看到了一句话</p><blockquote><p>❝ Having a non-circular relationship is called non-transitivity for the &lt; operator. It’s not too hard to realise that if your relationships are circular then you won’t be getting reasonable results. In fact there is a very strict set of rules that a data type and its comparators must abide by in order to get correct results from C++ STL algorithms, that is 「strict weak ordering」. ❞</p></blockquote><p>从上面的意思看，在 STL 中，对于 sort 函数中的排序算法，需要遵循严格弱序(strict weak ordering)的原则。</p><p>上面概念，总结下就是，存在两个变量x和y：</p><ul><li>x &gt; y 等同于 y &lt; x</li><li>x == y 等同于 !(x &lt; y) &amp;&amp; !(x &gt; y)</li></ul><p>对于 std::sort()，当容器里面元素的个数大于 <em>S</em>threshold 的枚举常量值时，会使用快速排序，在 STL 中这个值的默认值是16</p><p>调试跟踪定位发现 sort 的函数调用链最终会调用 __unguarded_partition， 我们看下 __unguarded_partition 函数的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _RandomAccessIterator<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Tp<span class="token punctuation">,</span> <span class="token keyword">typename</span> _Compare<span class="token operator">></span>     _RandomAccessIterator     <span class="token function">__unguarded_partition</span><span class="token punctuation">(</span>_RandomAccessIterator __first<span class="token punctuation">,</span>               _RandomAccessIterator __last<span class="token punctuation">,</span>               _Tp __pivot<span class="token punctuation">,</span> _Compare __comp<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">__comp</span><span class="token punctuation">(</span><span class="token operator">*</span>__first<span class="token punctuation">,</span> __pivot<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token operator">++</span>__first<span class="token punctuation">;</span>       <span class="token operator">--</span>__last<span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">__comp</span><span class="token punctuation">(</span>__pivot<span class="token punctuation">,</span> <span class="token operator">*</span>__last<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token operator">--</span>__last<span class="token punctuation">;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>__first <span class="token operator">&lt;</span> __last<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> __first<span class="token punctuation">;</span>       std<span class="token operator">::</span><span class="token function">iter_swap</span><span class="token punctuation">(</span>__first<span class="token punctuation">,</span> __last<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token operator">++</span>__first<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面代码中，有下面一段：</p><pre class="line-numbers language-text"><code class="language-text">while (__comp(*__first, __pivot))         ++__first;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，<strong>first 为迭代器，</strong>pivot 为中间值，<strong>comp 为传入的比较函数。 如果传入的 vector 中，按照之前的写法 &gt;= 元素完全相等的情况下那么 __comp 比较函数一直是 true，那么后面 ++</strong>first，最终就会使得迭代器失效，从而导致 coredump。 至此，分析完毕，请记住，STL sort 自定义比较函数，总是对相同值的比较返回 false。</p><h2 id="第-22-条：切勿直接修改-set-或-multiset-中的键"><a href="#第-22-条：切勿直接修改-set-或-multiset-中的键" class="headerlink" title="第 22 条：切勿直接修改 set 或 multiset 中的键"></a><strong>第 22 条：切勿直接修改 set 或 multiset 中的键</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_22</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> m<span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"xxx"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//m.begin()->first = 10; // build error, map的键不能修改</span> std<span class="token operator">::</span>multimap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> mm<span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"yyy"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//mm.begin()->first = 10; // build error, multimap的键同样不能修改</span> std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//*(s.begin()) = 10; // build error, set的键不能修改</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 强制类型转换</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token operator">*</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>像所有的标准关联容器一样，set 和 multiset 按照一定的顺序来存放自己的元素，而这些容器的正确行为也是建立在其元素保持有序的基础之上的。如果你把关联容器中的一个元素的值改变了(比如把10改为1000)，那么，新的值可能不在正确的位置上，这将会打破容器的有序性。</p><p>对于 map 和 multimap 尤其简单，因为如果有程序试图改变这些容器中的键，它将不能通过编译。这是因为，对于一个 map&lt;K, V&gt;或 multimap&lt;K, V&gt; 类型的对象，其中的元素类型是 pair&lt;const K, V&gt;。因为键的类型是 const K，所以它不能被修改。(如果利用 const_cast，你或许可以修改它。)</p><p>对于 set 或 multiset 类型的对象，容器中元素的类型是 T，而不是 const T。注：不通过强制类型转换并不能改变 set 或 multiset 中的元素。</p><h2 id="第-23-条：考虑用排序的vector替代关联容器"><a href="#第-23-条：考虑用排序的vector替代关联容器" class="headerlink" title="第 23 条：考虑用排序的vector替代关联容器"></a><strong>第 23 条：考虑用排序的vector替代关联容器</strong></h2><p>这个建议的前提是：</p><ul><li>创建一个新的数据结构，并插入大量元素，在这个阶段，几乎所有的操作都是插入和删除操作。很少或几乎没有查找操作。</li><li>查找阶段：查询该数据结构找到特点的信息，在这个阶段，几乎所有的操作都是查找很少或几乎没有删除。</li><li>重组阶段：改变数据结构的内容。</li></ul><p>这种方式使用其数据结构的应用程序来说，排序的 vector 可能比管理容器提供了更好的性能。</p><h2 id="第-24-条：当效率至关重要的时候，请在-map-operator-和-map-insert-之间作慎重选择"><a href="#第-24-条：当效率至关重要的时候，请在-map-operator-和-map-insert-之间作慎重选择" class="headerlink" title="第 24 条：当效率至关重要的时候，请在 map::operator[] 和 map::insert 之间作慎重选择"></a><strong>第 24 条：当效率至关重要的时候，请在 map::operator[] 和 map::insert 之间作慎重选择</strong></h2><h3 id="当做“添加”操作时，insert-效率比-operator-更高"><a href="#当做“添加”操作时，insert-效率比-operator-更高" class="headerlink" title="当做“添加”操作时，insert 效率比 operator[] 更高"></a><strong>当做“添加”操作时，insert 效率比 operator[] 更高</strong></h3><p>map::operator[] 工作原理：operator[] 返回一个引用，它指向与 k 相关联的值对象。然后 v 被赋给了该引用所指向的对象。如果键 k 已经有了相关联的值，则该值被更新。如果 k 还没有在映射表中，那就没有 operator[] 可以指向的值对象，这种情况下，它使用值类型的默认构造函数创建一个新的对象，然后 operator[] 就能返回一个指向该新对象的引用。</p><p>看一个样例：</p><pre class="line-numbers language-text"><code class="language-text">std::map<int, Widget> m;m[1] = 5.13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>表达式 m[1] 是 m.operator 的缩写形式，所以这是对 map::operator[] 的调用。该函数必须返回一个指向 Widget 的引用，因为 m 所映射的值对象类型是 Widget。这时候 m 中什么也没有，所以键 1 没有多余的值对象。因此，operator[]默认构造了一个 Widget，作为 1 相关联的值，然后返回一个指向 Widget 的引用，最后，这个 Widget 赋值为 5.13</p><p>而如果直接用</p><pre class="line-numbers language-text"><code class="language-text">m.insert(Widget::value_type(1,5.13))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样直接用我们所需的值构造了一个 Widget 比 ”先默认构造一个 Widget在赋值“ 效率更高。</p><p>与之相比，通常节省了三个函数调用：一个用于创建默认构造的临时 Widget 对象，一个用以析构该临时对象，一个是调用 Widget 的赋值操作符。</p><h3 id="当做“更新”操作时，operator-效率比-insert-更高"><a href="#当做“更新”操作时，operator-效率比-insert-更高" class="headerlink" title="当做“更新”操作时，operator[] 效率比 insert 更高"></a><strong>当做“更新”操作时，operator[] 效率比 insert 更高</strong></h3><p>原因在于 insert 调用需要一个 Widget::value_type 类型的参数（pair&lt;int,Widget&gt;），所以当我们调用 insert 时候，必须构造和析构一个该类型的对象，这样付出一个 pair 构造函数和一个 pair 析构函数的代价。而这又会导致 Widget 的构造和析构，因为 pair&lt;int,Widget&gt; 本身包含了一个 Widget 对象，而 operator[] 不使用 pair 对象，所以它不会构造和析构任何 pair 和 Widget</p><h2 id="第-25-条：熟悉非标准的散列容器"><a href="#第-25-条：熟悉非标准的散列容器" class="headerlink" title="第 25 条：熟悉非标准的散列容器"></a><strong>第 25 条：熟悉非标准的散列容器</strong></h2><p>C++11 中新增了四种关联容器，使用哈希函数组织的，即 unordered_map、unordered_multimap、unordered_set、unordered_multiset。</p><ul><li>set：集合。底层为红黑树，元素有序，不重复；multiset：底层为红黑树，元素有序，可重复</li><li>map：底层为红黑树，键有序，不重复；multimap：底层为红黑树，键有序，可重复</li><li>unordered_set：底层为哈希表，无序，不重复；unordered_multiset：底层为哈希表，无序，可重复</li><li>unordered_map：底层为哈希表，无序，不重复；unordered_multiap：底层为哈希表，无序，可重复</li></ul><h2 id="第-26-条：iterator-优先于-const-iterator、reverse-iterator-以及-const-reverse-iterator"><a href="#第-26-条：iterator-优先于-const-iterator、reverse-iterator-以及-const-reverse-iterator" class="headerlink" title="第 26 条：iterator 优先于 const_iterator、reverse_iterator 以及 const_reverse_iterator"></a><strong>第 26 条：iterator 优先于 const_iterator、reverse_iterator 以及 const_reverse_iterator</strong></h2><p>STL 中的所有标准容器都提供了 4 种迭代器类型。</p><p>对容器类 container 而言，iterator 类型的功效相当于 T<em>，而 const_iterator 则相当于 const T</em>。对一个 iterator 或者 const_iterator 进行递增则可以移动到容器中的下一个元素，通过这种方式可以从容器的头部一直遍历到尾部。reverse_iterator 与 const_reverse_iterator 同样分别对应于 T<em>和const T</em>，所不同的是，对这两个迭代器进行递增的效果是由容器的尾部反向遍历到容器头部。</p><p>注意：vector::insert，对于 C++98 中，第一个参数均为 iterator；而对于 C++11中，第一个参数均为 const_iterator。vector::erase 的情况也是这样。</p><h2 id="第-27-条：-使用-distance-和-advance-将容器的-const-iterator-转换成-iterator"><a href="#第-27-条：-使用-distance-和-advance-将容器的-const-iterator-转换成-iterator" class="headerlink" title="第 27 条： 使用 distance 和 advance 将容器的 const_iterator 转换成 iterator"></a><strong>第 27 条： 使用 distance 和 advance 将容器的 const_iterator 转换成 iterator</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_27</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">typedef</span> std<span class="token operator">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IntDeque<span class="token punctuation">;</span> <span class="token keyword">typedef</span> IntDeque<span class="token operator">::</span>iterator Iter<span class="token punctuation">;</span> <span class="token keyword">typedef</span> IntDeque<span class="token operator">::</span>const_iterator ConstIter<span class="token punctuation">;</span> IntDeque <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ConstIter ci<span class="token punctuation">;</span> ci <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使ci指向d</span> Iter <span class="token function">i</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> std<span class="token operator">::</span>distance<span class="token operator">&lt;</span>ConstIter<span class="token operator">></span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> ci<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::distance 用以取得两个迭代器(它们指向同一个容器)之间的距离；std::advance 则用于将一个迭代器移动指定的距离。</p><h2 id="第-28-条：正确理解由-reverse-iterator-的-base-成员函数所产生的-iterator-的用法"><a href="#第-28-条：正确理解由-reverse-iterator-的-base-成员函数所产生的-iterator-的用法" class="headerlink" title="第 28 条：正确理解由 reverse_iterator 的 base() 成员函数所产生的 iterator 的用法"></a><strong>第 28 条：正确理解由 reverse_iterator 的 base() 成员函数所产生的 iterator 的用法</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_28</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>reverse_iterator ri <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使ri指向3</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator <span class="token function">i</span><span class="token punctuation">(</span>ri<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span> v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"value: %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 2 3 99 4 5</span> v<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> ri <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">++</span>ri<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"value: %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 2 4 5</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要在一个reverse_iterator ri指定的位置上插入新元素，则只需在ri.base()位置处插入元素即可。对于插入操作而言，ri和ri.base()是等价的，ri.base()是真正与ri对应的iterator。 如果要在一个reverse_iterator ri指定的位置上删除一个元素，则需要在ri.base()前面的位置上执行删除操作。对于删除操作而言，ri和ri.base()是不等价的，ri.base()不是与ri对应的iterator。</p><h2 id="第-29-条：对于逐个字符的输入请考虑使用-istreambuf-iterator"><a href="#第-29-条：对于逐个字符的输入请考虑使用-istreambuf-iterator" class="headerlink" title="第 29 条：对于逐个字符的输入请考虑使用 istreambuf_iterator"></a><strong>第 29 条：对于逐个字符的输入请考虑使用 istreambuf_iterator</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_29</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 把一个文本文件的内容拷贝到一个string对象中</span> std<span class="token operator">::</span>ifstream <span class="token function">inputFile</span><span class="token punctuation">(</span><span class="token string">"interestingData.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> inputFile<span class="token punctuation">.</span><span class="token function">unsetf</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ios<span class="token operator">::</span>skipws<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 禁止忽略inputFile中的空格</span> std<span class="token operator">::</span>string <span class="token function">fileData</span><span class="token punctuation">(</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span>inputFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 速度慢</span> std<span class="token operator">::</span>string <span class="token function">fileData2</span><span class="token punctuation">(</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istreambuf_iterator<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span>inputFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>istreambuf_iterator<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 速度快</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::istream_iterator对象使用operator&gt;&gt;从输入流中读取单个字符，而std::istreambuf_iterator则直接从流的缓冲区中读取下一个字符。std::istreambuf_iterator不会跳过任何字符，它只是简单地取回流缓冲区中的下一个字符，而不管它们是什么字符，因此用不着清除输入流的skipws标志。</p><h2 id="第-30-条：确保目标区间足够大"><a href="#第-30-条：确保目标区间足够大" class="headerlink" title="第 30 条：确保目标区间足够大"></a><strong>第 30 条：确保目标区间足够大</strong></h2><p>需求1：希望像 transform 这样的算法把结果以新元素的形式插入到容器末尾开始。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">transmogrify</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">test_item_30</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> values<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> results<span class="token punctuation">;</span> results<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>results<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可避免内存的重新分配</span> <span class="token comment" spellcheck="true">//std::transform(values.cbegin(), values.cend(), results.end(), transmogrify); // 错误，segmentation fault</span> std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">,</span> transmogrify<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确 {2,4,6}</span> <span class="token comment" spellcheck="true">// 在内部，std::back_inserter返回的迭代器将使得push_back被调用，所以back_inserter可适用于所有提供了push_back方法的容器</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> results2<span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">front_inserter</span><span class="token punctuation">(</span>results2<span class="token punctuation">)</span><span class="token punctuation">,</span> transmogrify<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// std::front_inserter在内部利用了push_front，所以front_inserter仅适用于那些提供了push_front成员函数的容器</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需求2：假设希望 transform 这样的算法覆盖容器中已有的元素，那么就需要确保 result 已有的元素至少和 values 的元素一样多。否则，就必须使用 resize 来保证这一点</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> values<span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> results<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//...</span><span class="token keyword">if</span> <span class="token punctuation">(</span>results<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> results<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//确保size一样大</span><span class="token punctuation">}</span>std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>results<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fun<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//覆盖 results 中前 values.size() 的元素</span>或者，也可以先清空 results 然后按照普通的方式使用一个插入行迭代器results<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>results<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">,</span> fun<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//覆盖 results 中前 values.size() 的元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论何时，如果所使用的算法需要指定一个目标区间，那么必须确保目标区间足够大，或者确保它会随着算法的运行而增大。要在算法执行过程中增大目标区间，请使用插入型迭代器，比如ostream_iterator或者由back_inserter、front_inserter和inserter返回的迭代器。</p><h2 id="第-31-条：了解各种与排序有关的选择"><a href="#第-31-条：了解各种与排序有关的选择" class="headerlink" title="第 31 条：了解各种与排序有关的选择"></a><strong>第 31 条：了解各种与排序有关的选择</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">qualityCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>lhs <span class="token operator">&lt;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">bool</span> <span class="token function">hasAcceptableQuality</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 判断w的质量值是否为2或者更好</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">test_item_31</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">vec</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">partial_sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> qualityCompare<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将质量最好的20个元素顺序放在vec的前20个位置上</span> std<span class="token operator">::</span><span class="token function">nth_element</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">19</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> qualityCompare<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将最好的20个元素放在vec的前部，但并不关心它们的具体排列顺序</span> <span class="token comment" spellcheck="true">// std::partia_sort和std::nth_element在效果上唯一不同之处在于：partial_sort对位置1--20中的元素进行了排序，而</span> <span class="token comment" spellcheck="true">// nth_element没有对它们进行排序。然而，这两个算法都将质量最好的20个vec放到了矢量的前部</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">::</span>iterator <span class="token function">begin</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">::</span>iterator <span class="token function">end</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">::</span>iterator goalPosition<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于定位感兴趣的元素</span> <span class="token comment" spellcheck="true">// 找到具有中间质量级别的string</span> goalPosition <span class="token operator">=</span> begin <span class="token operator">+</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果全排序的话，待查找的string应该位于中间</span> std<span class="token operator">::</span><span class="token function">nth_element</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> goalPosition<span class="token punctuation">,</span> end<span class="token punctuation">,</span> qualityCompare<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 找到vec的中间质量值</span> <span class="token comment" spellcheck="true">// 现在goalPosition所指的元素具有中间质量</span> <span class="token comment" spellcheck="true">// 找到区间中具有75%质量的元素</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">::</span>size_type goalOffset <span class="token operator">=</span> <span class="token number">0.25</span> <span class="token operator">*</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 找出如果全排序的话，待查找的string离起始处有多远</span> std<span class="token operator">::</span><span class="token function">nth_element</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> begin <span class="token operator">+</span> goalOffset<span class="token punctuation">,</span> end<span class="token punctuation">,</span> qualityCompare<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 找到75%处的质量值 </span> <span class="token comment" spellcheck="true">// 将满足hasAcceptableQuality的所有元素移到前部，然后返回一个迭代器，指向第一个不满足条件的string</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">::</span>iterator goodEnd <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">partition</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hasAcceptableQuality<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>std::nth_element：用于排序一个区间，它使得位置n上的元素正好是全排序情况下的第n个元素。而且，当nth_element返回的时候，所有按全排序规则(即sort的结果)排在位置n之前的元素也都被排在位置n之前，而所有按全排序规则排在位置n之后的元素则都被排在位置n之后。</li><li>std::partial_sort和std::nth_element在排列等价元素的时候，有它们自己的做法，你无法控制它们的行为。</li><li>std::partial_sort、std::nth_element和std::sort都属于非稳定的排序算法，但是有一个名为std::stable_sort的算法可以提供稳定排序特性。</li><li>std::nth_element除了可以用来找到排名在前的n个元素以外，它还可以用来找到一个区间的中间值，或者找到某个特定百分比上的值。</li><li>std::partition：可以把所有满足某个特定条件的元素放在区间的前部。</li></ul><p>总结排序选择：</p><ul><li>如果需要对 vector、string、deque 或者数组中的元素执行一次完全排序，那么可以使用sort或者stable_sort。</li><li>如果有一个 vector、string、deque 或者数组，并且只需要对等价性最前面的n个元素进行排序，那么可以使用partial_sort。</li><li>如果有一个 vector、string、deque 或者数组，并且需要找到第n个位置上的元素，或者，需要找到等价性前面的n个元素但又不必对这n个元素进行排序，那么，nth_element正是你所需要的函数。</li><li>如果需要将一个标准序列容器中的元素按照是否满足某个特定的条件区分开来，那么，partition 和 stable_partition 可能正是你所需要的。</li><li>如果你的数据在一个 list，那么你仍然可以直接调用 partition 和 stable_partition 算法；你可以用 list::sort 来替代 sort 和 stable_sort 算法。但是，如果你需要获得 partial_sort 或 nth_element 算法的效果，那么，你可以有一些间接的途径来完成这项任务。</li></ul><h2 id="第-32-条：如果确实需要删除元素，则需要在-remove-这一类算法之后调用-erase"><a href="#第-32-条：如果确实需要删除元素，则需要在-remove-这一类算法之后调用-erase" class="headerlink" title="第 32 条：如果确实需要删除元素，则需要在 remove 这一类算法之后调用 erase"></a><strong>第 32 条：如果确实需要删除元素，则需要在 remove 这一类算法之后调用 erase</strong></h2><p>记住一句话：remove 不是真正意义上的删除，因为它做不到。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_32</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"v.size: %d\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出10</span> v<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 删除所有值等于99的元素</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"v.size: %d\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 仍然输出10, remove不是真正意义上的删除，因为它做不到</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 真正删除所有值等于99的元素 </span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>remove 的原理：移动了区间中的元素，将 “不用被删除”的元素在v.begin()和newEnd之间，“需要被删除”的元素在newEnd和v.end()之间。它返回的迭代器是指向最后一个“不用被删除”的元素之后的元素。这个返回值相当于该区间“新的逻辑结尾”。</p><p>remove 的声明：</p><pre class="line-numbers language-text"><code class="language-text">template<class ForwardIterator, class T>ForwardIterator remove(ForwardIterator first, ForwardIterator last, const T& value);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>根本就不接受容器作为参数，所以并不知道这些元素被存放在哪个容器中，删除区间中的 1 元素。</p><p><img src="https://pic3.zhimg.com/80/v2-c9523e9292df36bab6d6e01792c381ce_720w.webp" alt></p><p>std::remove并不接受容器作为参数，所以remove并不知道这些元素被存放在哪个容器中。并且，remove也不可能推断出是什么容器，因为无法从迭代器推知对应的容器类型。因为从容器中删除元素的唯一方法是调用该容器的成员函数，而remove并不知道它操作的元素所在的容器，所以remove不可能从容器中删除元素。</p><p>std::list的remove成员函数是STL中唯一一个名为remove并且确实删除了容器中元素的函数。</p><p>std::remove并不是唯一一个适用于这种情形的算法，其它还有两个属于”remove类”的算法：remove_if和unique。如同list::remove会真正删除元素(并且比使用erase-remove习惯用法更为高效)一样，std::list::unique也会真正删除元素(而且比使用erase-unique更为高效)。</p><h2 id="第-33-条：对包含指针的容器使用-remove-这一类算法时要特别小心"><a href="#第-33-条：对包含指针的容器使用-remove-这一类算法时要特别小心" class="headerlink" title="第 33 条：对包含指针的容器使用 remove 这一类算法时要特别小心"></a><strong>第 33 条：对包含指针的容器使用 remove 这一类算法时要特别小心</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget33</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">bool</span> <span class="token function">isRemove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果 pwidget 是一个未被验证的 Widget33 则删除该指针，并置位空</span><span class="token keyword">void</span> <span class="token function">delAndNullifyUnremove</span><span class="token punctuation">(</span>Widget33<span class="token operator">*</span><span class="token operator">&amp;</span> pWidget<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pWidget<span class="token operator">-</span><span class="token operator">></span><span class="token function">isRemove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">delete</span> pWidget<span class="token punctuation">;</span>  pWidget <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">test_item_33</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget33<span class="token operator">*</span><span class="token operator">></span> v<span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget33<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 删除那些指向未被验证过的Widget33对象的指针，会资源泄露</span> v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">remove_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">not1</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">mem_fun</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Widget33<span class="token operator">::</span>isCertified<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 一种可以消除资源泄露的做法</span> <span class="token comment" spellcheck="true">// 将所有指向未被验证的Widget33对象的指针删除并置成空</span> std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> delAndNullifyUnremove<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 删除v中的空指针，必须将0转换成一个指针，这样C++才能正确推断出remove的第三个参数类型</span> v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget33<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用智能指针可防止资源泄露</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget33<span class="token operator">>></span> v2<span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> v2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Widget33<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 下面语句需要编译器必须能够把智能指针类型std::shared&lt;Widget33>隐式转换为对应的内置指针类型Widget33*才能通过编译</span> <span class="token comment" spellcheck="true">//v2.erase(std::remove_if(v2.begin(), v2.end(), std::not1(std::mem_fun(&amp;Widget33::isCertified))), v2.end());</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当容器中存放的是指向动态分配的对象的指针的时候，应该避免使用remove和类似的算法(remove_if和unique)。 如果容器中存放的不是普通指针，而是具有引用计数功能的智能指针，那么就可以直接使用erase-remove的习惯用法。</p><h2 id="第-34-条：了解哪些算法要求使用排序的区间作为参数"><a href="#第-34-条：了解哪些算法要求使用排序的区间作为参数" class="headerlink" title="第 34 条：了解哪些算法要求使用排序的区间作为参数"></a><strong>第 34 条：了解哪些算法要求使用排序的区间作为参数</strong></h2><p>并非所有的算法都可以应用于任何区间。举例来说，remove算法要求单向迭代器并且要求可以通过这些迭代器向容器中的对象赋值。所以，它不能用于由输入迭代器指定的区间，也不适用于map或multimap，同样不适用于某些set和multiset的实现。同样地，很多排序算法要求随机访问迭代器，所以对于list的元素不可能调用这些算法。有些算法要求排序的区间，即区间中的值是排过序的。有些算法既可以与排序的区间一起工作，也可以与未排序的区间一起工作，但是当它们作用在排序的区间上时，算法会更加有效。</p><p>要求排序区间的STL算法：binaray_search、lower_bound、upper_bound、equal_range、set_union、set_intersection、set_difference、set_symmetric_difference、merge、inplace_merge、includes。</p><p>unique、unique_copy并不一定要求排序的区间，但通常情况下会与排序区间一起使用。</p><h2 id="第-35-条：通过-mismatch-或-lexicographical-compare-实现简单的忽略大小写的字符串比较"><a href="#第-35-条：通过-mismatch-或-lexicographical-compare-实现简单的忽略大小写的字符串比较" class="headerlink" title="第 35 条：通过 mismatch 或 lexicographical_compare 实现简单的忽略大小写的字符串比较"></a><strong>第 35 条：通过 mismatch 或 lexicographical_compare 实现简单的忽略大小写的字符串比较</strong></h2><p>std::lexicographical_compare是strcmp的一个泛化版本。不过，strcmp只能与字符数组一起工作，而lexicographical_compare则可以与任何类型的值的区间一起工作。而且，strcmp总是通过比较两个字符来判断它们的关系相等、小于还是大于，而lexicographical_compare则可以接受一个判别式，由该判别式来决定两个值是否满足一个用户自定义的准则。</p><p>strcmp通常是被优化过的，它们在字符串的处理上一般要比通用算法mismatch和lexicographical_compare快。</p><h2 id="第-36-条-理解copy-if算法的正确实现"><a href="#第-36-条-理解copy-if算法的正确实现" class="headerlink" title="第 36 条: 理解copy_if算法的正确实现"></a><strong>第 36 条: 理解copy_if算法的正确实现</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_item_36</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v1<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">v2</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">copy_if</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v2<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">distance</span><span class="token punctuation">(</span>v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> v <span class="token operator">:</span> v2<span class="token punctuation">)</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"%d\n"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 3 5</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 中增加了 std::copy_if 函数。拷贝带条件判断的算法。</p><h2 id="第-37-条-使用accumulate或者for-each进行区间统计"><a href="#第-37-条-使用accumulate或者for-each进行区间统计" class="headerlink" title="第 37 条: 使用accumulate或者for_each进行区间统计"></a><strong>第 37 条: 使用accumulate或者for_each进行区间统计</strong></h2><p>std::accumulate有两种形式：第一种形式有两个迭代器和一个初始值，它返回该初始值加上由迭代器标识的区间中的值的总和。</p><p>std::accumulate只要求输入迭代器，所以你可以使用std::istream_iterator和std::istreambuf_iterator。</p><p>std::accumulate的第二种形式带一个初始值和一个任意的统计函数。</p><p>std::for_each是另一个可被用来统计区间的算法，而且它不受accumulate的那些限制。如同accumulate一样，for_each也带两个参数：一个是区间，另一个是函数(通常是函数对象)—-对区间中的每个元素都要调用这个函数，但是，传给for_each的这个函数只接收一个实参(即当前的区间元素)。for_each执行完毕后会返回它的函数。(实际上，它返回的是这个函数的一份拷贝。)重要的是，传给for_each的函数(以及后来返回的函数)可以有副作用。</p><p>std::for_each和std::accumulate在两个方面有所不同：首先，名字accumulate暗示着这个算法将会计算出一个区间的统计信息。而for_each听起来就好像是对一个区间的每个元素做一个操作。用for_each来统计一个区间是合法的，但是不如accumulate来得清晰。其次，accumulate直接返回我们所要的统计结果，而for_each却返回一个函数对象，我们必须从这个函数对象中提取出我们所要的统计信息。在C++中，这意味着我们必须在函数子类中 加入一个成员函数，以便获得我们想要的统计信息。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 接受当前的长度总和值和新的字符串，然后返回更新之后的总和值</span>std<span class="token operator">::</span>string<span class="token operator">::</span>size_type <span class="token function">stringLengthSum</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">::</span>size_type sumSoFar<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> sumSoFar <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> Point <span class="token punctuation">{</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">double</span> initX<span class="token punctuation">,</span> <span class="token keyword">double</span> initY<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>initX<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>initY<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">PointAverage</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>unary_function<span class="token operator">&lt;</span>Point<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">PointAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">xSum</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">ySum</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">numPoints</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token operator">++</span>numPoints<span class="token punctuation">;</span>  xSum <span class="token operator">+</span><span class="token operator">=</span> p<span class="token punctuation">.</span>x<span class="token punctuation">;</span>  ySum <span class="token operator">+</span><span class="token operator">=</span> p<span class="token punctuation">.</span>y<span class="token punctuation">;</span> <span class="token punctuation">}</span> Point <span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">Point</span><span class="token punctuation">(</span>xSum <span class="token operator">/</span> numPoints<span class="token punctuation">,</span> ySum <span class="token operator">/</span> numPoints<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span> size_t numPoints<span class="token punctuation">;</span> <span class="token keyword">double</span> xSum<span class="token punctuation">,</span> ySum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_37</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> v<span class="token punctuation">{</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">2.2f</span><span class="token punctuation">,</span> <span class="token number">3.3f</span><span class="token punctuation">,</span> <span class="token number">4.5f</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">double</span> sum <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意：初始值被指定为0.0,而不是简单的0</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"vaule: %f\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 11.000000</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"sum of the ints: %d\n"</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输入非整数值结束,如字母</span> std<span class="token operator">::</span>set<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> ss<span class="token punctuation">{</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"cde"</span><span class="token punctuation">,</span> <span class="token string">"xyzw"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 计算一个容器中字符串的长度总和</span> std<span class="token operator">::</span>string<span class="token operator">::</span>size_type lengthSum <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>ss<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ss<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">::</span>size_type<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stringLengthSum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"length sum: %d\n"</span><span class="token punctuation">,</span> lengthSum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10</span> <span class="token comment" spellcheck="true">// 计算一个区间中数值的乘积</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span> vf<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">.</span>f<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">.</span>f<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">.</span>f<span class="token punctuation">,</span> <span class="token number">1.5f</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">float</span> product <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>vf<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vf<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span>f<span class="token punctuation">,</span> std<span class="token operator">::</span>multiplies<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"product: %f\n"</span><span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 9.000000</span> <span class="token comment" spellcheck="true">// 计算出一个区间中所有点的平均值</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>Point<span class="token operator">></span> lp<span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> Point avg <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>lp<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lp<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PointAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第-38-条-遵循按值传递的原则来设计函数子类"><a href="#第-38-条-遵循按值传递的原则来设计函数子类" class="headerlink" title="第 38 条: 遵循按值传递的原则来设计函数子类"></a><strong>第 38 条: 遵循按值传递的原则来设计函数子类</strong></h2><p>无论是C还是C++，都不允许将一个函数作为参数传递给另一个函数，相反，你必须传递函数指针。C和C++的标准库函数都遵循这一规则：函数指针是按值传递的。</p><h2 id="第-39-条-确保判别式是”纯函数”"><a href="#第-39-条-确保判别式是”纯函数”" class="headerlink" title="第 39 条: 确保判别式是”纯函数”"></a><strong>第 39 条: 确保判别式是”纯函数”</strong></h2><p>一个判别式(predicate)是一个返回值为bool类型(或者可以隐式地转换为bool类型)的函数。在STL中，判别式有着广泛的用途。标准关联容器的比较函数就是判别式；对于像find_if以及各种与排序有关的算法，判别式往往也被作为参数来传递。</p><h2 id="第-40-条-若一个类是函数子，则应使它可配接"><a href="#第-40-条-若一个类是函数子，则应使它可配接" class="headerlink" title="第 40 条: 若一个类是函数子，则应使它可配接"></a><strong>第 40 条: 若一个类是函数子，则应使它可配接</strong></h2><h2 id="第-41-条-理解ptr-fun、men-fun和mem-fun-ref的来由"><a href="#第-41-条-理解ptr-fun、men-fun和mem-fun-ref的来由" class="headerlink" title="第 41 条: 理解ptr_fun、men_fun和mem_fun_ref的来由"></a><strong>第 41 条: 理解ptr_fun、men_fun和mem_fun_ref的来由</strong></h2><p>std::ptr_fun：将函数指针转换为函数对象。</p><p>std::mem_fun：将成员函数转换为函数对象(指针版本)。</p><p>std::mem_fun_ref：将成员函数转换为函数对象(引用版本)。</p><h2 id="第-42-条-确保less与operator-lt-具有相同的语义"><a href="#第-42-条-确保less与operator-lt-具有相同的语义" class="headerlink" title="第 42 条: 确保less与operator&lt;具有相同的语义"></a><strong>第 42 条: 确保less与operator&lt;具有相同的语义</strong></h2><p>应该尽量避免修改less的行为，因为这样做很可能会误导其他的程序员。如果你使用了less，无论是显式地或是隐式地，你都需要确保它与operator&lt;具有相同的意义。如果你希望以一种特殊的方式来排序对象，那么最好创建一个特殊的函数子类，它的名字不能是less。</p><h2 id="第-43-条-算法调用优先于手写的循环"><a href="#第-43-条-算法调用优先于手写的循环" class="headerlink" title="第 43 条: 算法调用优先于手写的循环"></a><strong>第 43 条: 算法调用优先于手写的循环</strong></h2><p>理由：</p><ul><li>效率：算法通常比程序员自己写的循环效率更高。</li><li>正确性：自己写循环比使用算法更容易出错。</li><li>可维护性：使用算法的代码通常比手写循环的代码更加简洁明了。</li></ul><p>如果你要做的工作与一个算法所实现的功能很相近，那么用算法调用更好。但是如果你的循环很简单，而若使用算法来实现的话，却要求混合使用绑定器和配接器或者要求一个单独的函数子类，那么，可能使用手写的循环更好。最后，如果你在循环中要做的工作很多，而且又很复杂，则最好使用算法调用。</p><h2 id="第-44-条-容器的成员函数优先于同名的算法"><a href="#第-44-条-容器的成员函数优先于同名的算法" class="headerlink" title="第 44 条: 容器的成员函数优先于同名的算法"></a><strong>第 44 条: 容器的成员函数优先于同名的算法</strong></h2><p>有些STL容器提供了一些与算法同名的成员函数。比如，关联容器提供了count、find、lower_bound、upper_bound和equal_range，而list则提供了remove、remove_if、unique、sort、merge和reverse。大多数情况下，你应该使用这些成员函数，而不是相应的STL算法。这里有两个理由：第一，成员函数往往速度快；第二，成员函数通常与容器(特别是关联容器)结合得更加紧密，这是算法所不能比的。原因在于，算法和成员函数虽然有同样的名称，但是它们所做的事情往往不完全相同。</p><h2 id="第-45-条-正确区分count、find、binary-search、lower-bound、upper-bound和equal-range"><a href="#第-45-条-正确区分count、find、binary-search、lower-bound、upper-bound和equal-range" class="headerlink" title="第 45 条: 正确区分count、find、binary_search、lower_bound、upper_bound和equal_range"></a><strong>第 45 条: 正确区分count、find、binary_search、lower_bound、upper_bound和equal_range</strong></h2><p>如果区间是排序的，那么通过binary_search、lower_bound、upper_bound和equal_range，你可以获得更快的查找速度(通常是对数时间的效率)。 如果迭代器并没有指定一个排序的区间，那么你的选择范围将局限于count、count_if、find以及find_if，而这些算法仅能提供线性时间的效率。</p><h2 id="第-46-条-考虑使用函数对象而不是函数作为STL算法的参数"><a href="#第-46-条-考虑使用函数对象而不是函数作为STL算法的参数" class="headerlink" title="第 46 条: 考虑使用函数对象而不是函数作为STL算法的参数"></a><strong>第 46 条: 考虑使用函数对象而不是函数作为STL算法的参数</strong></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> StringSize <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>unary_function<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">::</span>size_type<span class="token operator">></span> <span class="token punctuation">{</span> std<span class="token operator">::</span>string<span class="token operator">::</span>size_type <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">test_item_46</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>set<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> s<span class="token punctuation">{</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"cde"</span><span class="token punctuation">,</span> <span class="token string">"xyzw"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>ostream_iterator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">::</span>size_type<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">mem_fun_ref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>std<span class="token operator">::</span>string<span class="token operator">::</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3 3 4，普通函数</span> std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>ostream_iterator<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">::</span>size_type<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">StringSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3 3 4, 函数对象</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C/C++中并不能真正地将一个函数作为参数传递给另一个函数。如果我们试图将一个函数作为参数进行传递，则编译器会隐式地将它转换成一个指向该函数的指针，并将该指针传递过去。函数指针参数抑制了内联机制。</p><h2 id="第-47-条-避免产生”直写型”-write-only-的代码"><a href="#第-47-条-避免产生”直写型”-write-only-的代码" class="headerlink" title="第 47 条: 避免产生”直写型”(write-only)的代码"></a><strong>第 47 条: 避免产生”直写型”(write-only)的代码</strong></h2><p>当你编写代码的时候，它看似非常直接和简捷，因为它是由某些基本想法(比如，erase-remove习惯用法加上在find中使用reverse_interator的概念)自然而形成的。然而，阅读代码的人却很难将最终的语句还原成它所依据的思路，这就是”直写型的代码”叫法的来历：虽然很容易编写，但是难以阅读和理解。一段代码是否是”直写型”取决于其读者的知识水平。</p><h2 id="第-48-条-总是包含-include-正确的头文件"><a href="#第-48-条-总是包含-include-正确的头文件" class="headerlink" title="第 48 条: 总是包含(#include)正确的头文件"></a><strong>第 48 条: 总是包含(#include)正确的头文件</strong></h2><p>C++标准与C的标准有所不同，它没有规定标准库中的头文件之间的相互包含关系。</p><p>总结每个与STL有关的标准头文件中所包含的内容：</p><p>(1). 几乎所有的标准STL容器都被声明在与之同名的头文件中，比如vector被声明在<vector>中，list被声明在<list>中，等等。但是set和map是个例外，<set>中声明了set和multiset，<map>中声明了map和multimap。</map></set></list></vector></p><p>(2). 除了4个STL算法以外，其它所有的算法都被声明在<algorithm>中，这4个算法是accumulate、inner_product、adjacent_difference和partial_sum，它们被声明在<numeric>头文件中。</numeric></algorithm></p><p>(3). 特殊类型的迭代器，包括istream_iterator和istreambuf_iterator，被声明在<iterator>中。</iterator></p><p>(4). 标准的函数子(比如less)和函数子配接器(比如not1、bind2nd)被声明在头文件<functional>中。</functional></p><p>任何时候如果你使用了某个头文件中的一个STL组件，那么你就一定要提供对应的#include指令，即使你正在使用的STL平台允许你省略#include指令，你也要将它们包含到你的代码中。当你需要将代码移植到其它平台上的时候，移植的压力就会减轻。</p><h2 id="第-49-条-学会分析与STL相关的编译器诊断信息"><a href="#第-49-条-学会分析与STL相关的编译器诊断信息" class="headerlink" title="第 49 条: 学会分析与STL相关的编译器诊断信息"></a><strong>第 49 条: 学会分析与STL相关的编译器诊断信息</strong></h2><p>一些技巧：</p><ul><li>vector和string的迭代器通常就是指针，所以当错误地使用了iterator的时候，编译器的诊断信息中可能会引用到指针类型。例如，如果源代码中引用了vector::iterator，那么编译器的诊断信息中极有可能就会提及double*指针。</li><li>如果诊断信息中提到了back_insert_iterator、front_insert_iterator或者insert_iterator，则几乎总是意味着你错误地调用了back_inserter、front_inserter或者inserter。如果你并没有直接调用这些函数，则一定是你所调用的某个函数直接或者间接地调用了这些函数。</li><li>类似地，如果诊断信息中提到了binder1st或者binder2nd，那么你可能是错误地使用了bind1st和bind2nd。</li><li>输出迭代器(如ostream_iterator、ostreambuf_iterator以及那些由back_inserter、front_inserter、front_inserter和inserter函数返回的迭代器)在赋值操作符内部完成其输出或者插入工作，所以，如果在使用这些迭代器的时候犯了错误，那么你所看到的错误消息中可能会提到与赋值操作符有关的内容。</li><li>如果你得到的错误消息来源于某一个STL算法的内部实现(例如，引起错误的源代码在中)，那也许是你在调用算法的时候使用了错误的类型。例如，你可能使用了不恰当的迭代器类型。</li><li>如果你正在使用一个很常见的STL组件，比如vector、string或者for_each算法，但是从错误消息来看，编译器好像对此一无所知，那么可能是你没有包含相应的头文件。</li></ul><h2 id="第-50-条-熟悉与-STL-相关的-Web-站点"><a href="#第-50-条-熟悉与-STL-相关的-Web-站点" class="headerlink" title="第 50 条: 熟悉与 STL 相关的 Web 站点"></a><strong>第 50 条: 熟悉与 STL 相关的 Web 站点</strong></h2><p><a href="https://link.zhihu.com/?target=http%3A//www.cplusplus.com/">http://www.cplusplus.com/</a> 尤其是其中的 Reference(<a href="https://link.zhihu.com/?target=http%3A//www.cplusplus.com/reference/">http://www.cplusplus.com/reference/</a>)</p><p>如果 有时 cplusplus 网站打不开，此时也可参考cppreference：<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp">https://en.cppreference.com/w/c</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;基于接口和实现分离的原则，了解STL的接口和STL的实现。&lt;/p&gt;
&lt;h2 id=&quot;第-1-条：慎重选择容器类型&quot;&gt;&lt;a href=&quot;#第-
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Cpp Core Guidelines</title>
    <link href="https://joytsing.github.io/posts/8961/"/>
    <id>https://joytsing.github.io/posts/8961/</id>
    <published>2023-12-05T07:39:23.000Z</published>
    <updated>2023-12-14T07:43:53.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章实际上是<a href="https://zhuanlan.zhihu.com/p/662592729">C++ Core Guidelines</a>解析的转载加上一些自己的理解(相当于自己集合一些觉得精华的内容放在自己blog上),废话少说。开始挖坑！</p><p>C++ Core Guidelines 由 16 个主要部分组成：</p><ul><li>简介</li><li>理念</li><li>接口</li><li>函数</li><li>类和类的层次结构</li><li>枚举</li><li>资源管理</li><li>表达式和语句</li><li>性能</li><li>并发性</li><li>错误处理</li><li>常量和不变性</li><li>模板和泛型编程</li><li>C 风格编程</li><li>源文件</li></ul><h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><p>理念性规则概览：理念性规则强调一般性，因此，无法进行检查。不过，理念性规则为下面的具体规则提供了理论依据。一共有 13 条理念性规则。可以简单理解为一般情况下的编码规范。</p><h3 id="P-1-在代码中直接表达思想"><a href="#P-1-在代码中直接表达思想" class="headerlink" title="P.1 在代码中直接表达思想"></a>P.1 在代码中直接表达思想</h3><p>编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。 而代码中所表达的东西是带有 明确的语义 的，并且（原则上）是可以由编译器和其他工具进行检验的。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Month <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 好</span>    <span class="token keyword">int</span> <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 不好</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个 <code>month</code> 比第二个，有更多的信息，以 <code>const</code> 修饰，代表不会修改当前的日期，返回类型 <code>Month</code> 也非常明确。</p><blockquote><p>成员函数修饰 <code>const</code> 是为什么，能做什么。只是默认，不修改当前类的数据成员就要加 <code>const</code>，明确语义，增加可读性。 <strong>但不够正确，也远不止如此</strong>。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> Month <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    Month m<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">;</span> <span class="token punctuation">}</span>          <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> date<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> date<span class="token punctuation">.</span><span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Date d<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码会得到一个编译错误，这应该是很常见的调用方式。为什么呢？显然，就是因为 <code>month</code> 成员函数没有以 <code>const</code> 修饰。<strong><code>C++</code> 不允许 const 的对象调用没有以 const 修饰的成员函数</strong>，事实上这个语义非常的合理：我都是 const 对象了，你为啥要修改？但是明明 <code>month</code> 函数根本没有修改对象的数据，所以这其实是开发者的问题，不应该写出这种代码。当前的语境很简单，我们只需要改成：</p><p>但是明明 <code>month</code> 函数根本没有修改对象的数据，所以这其实是开发者的问题，不应该写出这种代码。</p><p>当前的语境很简单，我们只需要改成：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Month <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// const 对象和非 const 对象都能调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你阅读过 <code>STL</code> 源码，或者看过基本的<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/container/array">文档</a>，会知道，<strong>大部分成员函数都要提供 <code>const</code> 和非 <code>const</code> 两种版本，我们以 <code>std::array</code> 的 <code>operator[]</code> 为例</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> reference <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span> size_type pos <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">constexpr</span> const_reference <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span> size_type pos <span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个成员函数都不会修改自己存储的对象，但是为什么要写 <code>const</code> 版本呢？<strong>注意返回类型</strong>。</p><ul><li>如果没有以 const 修饰的 std::array 对象，那么它调用 <code>operator[]</code> 自然是可以修改的，行为就像普通数组那样，我们就返回 <code>reference</code>。</li><li>如果是以 const 修饰的 std::array 对象，那么它调用 <code>operator[]</code> 根据我们的语义，自然不该让它外部能够修改，所以我们返回 <code>const_reference</code>。</li></ul><p><strong>一个成员函数是否以 const 修饰，不在于这个成员函数到底是否会修改自己的成员，而在于 “可变性”。</strong></p><p>相对于 标准库（STL）的算法，使用 for 或 while 等方式的手工循环通常也有上面一样的可读性问题。比如下面这样：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//不好</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>        index <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//更好</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个专业的 C++ 开发者应该了解 <strong>STL 算法</strong>。使用它们的话，你就可以避免显式使用循环，你的代码也会变得更容易理解，更容易维护，因此，也更不容易出错。现代 C++ 中有一句谚语：</p><ul><li><em>如果你显式使用循环的话，说明你不了解 STL 算法。</em></li></ul><blockquote><p>其实就是说成员函数注意返回类型的名字，和 const 修饰，增加可读性。 多使用 STL 算法，而不是自己搓，既能增加可读性也能减少错误。</p></blockquote><h3 id="P-2-用-ISO-标准写代码"><a href="#P-2-用-ISO-标准写代码" class="headerlink" title="P.2 用 ISO 标准写代码"></a>P.2 用 ISO 标准写代码</h3><p>要想得到一个可移植的 C++ 程序，最好的选择就是按照标准写代码。</p><p>使用当前的 C++ 标准，不要使用编译器扩展，同时注意，<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/ub">未定义行为和实现定义行为</a>。</p><p><strong>当你必须使用没有写在 ISO 标准里的扩展时，可以用一个稳定的接口将它们封装起来</strong>。</p><blockquote><p>比如将使用的编译器扩展用宏封装起来，以后如果要修改，或者说要适应别的平台，都很方便。举一个古代<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/jGfGz941G">例子</a>：</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus >= 201103L</span><span class="token macro property">#<span class="token directive keyword">define</span> INLINE inline</span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token macro property">#<span class="token directive keyword">define</span> INLINE __attribute__((__always_inline__))</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="P-3-表达意图"><a href="#P-3-表达意图" class="headerlink" title="P.3 表达意图"></a>P.3 表达意图</h3><p>以下的隐式和显式循环中，你能看出什么意图？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> v<span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>                              <span class="token comment" spellcheck="true">// (1)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> v<span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>                                    <span class="token comment" spellcheck="true">// (2)</span>std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span> vec<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// (3) 很抽象，这种形式其实根本做不到，当伪代码就好</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>循环（1）不修改容器 vec 的元素。（2）有可能修改。算法 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/algorithm/for_each">std::for_each</a>（3）以并行方式（<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">std::execution::par</a>）执行。这意味着我们不关心处理的顺序。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/hxfdnT6W8">举个例子</a>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>vec<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//打印的顺序是随机的</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//12345</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表达意图也是良好代码文档的一个重要准测。</p><ul><li><em>文档应该说明代码会做什么，而不是代码会怎么做</em>。</li></ul><blockquote><p>其实这里是在指，文档应该讲功能，而非实现细节。 不过事实上技术文档一般都不会完全这样，多少会提一些实现细节的，具体情况具体分析。</p></blockquote><h3 id="P-4-理想情况下，程序应该是静态类型安全的"><a href="#P-4-理想情况下，程序应该是静态类型安全的" class="headerlink" title="P.4 理想情况下，程序应该是静态类型安全的"></a>P.4 理想情况下，程序应该是静态类型安全的</h3><p>C++ 是一种静态类型的语言。静态类型意味着编译器知道数据的类型，此外，还说明，编译器可以检测到类型错误。 由于现有的问题领域，我们并非一直能够达到这一目标，但对于联合体、转型(cast)、数组退化、范围错误或窄化转换，确实是有办法的。</p><ul><li>在 C++17 中，可以使用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/utility/variant">std::variant</a> 安全地替代<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/union">联合体</a>。</li><li>基于模板的泛型代码减少了转型的需要，因此，也减少了类型错误。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/YrfcvsTGY">如</a>。</li><li>当用一个 C 数组调用一个函数时，就会发生<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/implicit_conversion">数组退化</a>。函数需要用指向数组第一个元素的指针，另加数组的长度。这意味着，你从一个类型丰富的数据结构 C 数组开始，却以类型极差的数组首项指针结束。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/KPPcP5j89">解决方法</a>在 C++20 里：<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/container/span">std::span</a>。std::span 可以自动推算出 C 数组的大小，也可以防止范围错误的发生。如果你还没有使用 C++20，请使用 Guidelines 支持库（GSL）提供的实现。</li><li><a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/list_initialization">窄化转换</a>是对算术值的有精度损失的隐式转换。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">i1</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> i2 <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你使用 {} 初始化语法，编译器就能<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/j6GTbGvvn">检测到窄化转换</a>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i1<span class="token punctuation">{</span><span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> i2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="P-5-编译期检查优先于运行期检查"><a href="#P-5-编译期检查优先于运行期检查" class="headerlink" title="P.5 编译期检查优先于运行期检查"></a>P.5 编译期检查优先于运行期检查</h3><ul><li><em>如果可以在编译期检查，那就应该在编译期检查</em>。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Int 被用作整数的别名</span><span class="token keyword">int</span> bits <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 请勿如此: 可以避免的代码</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Int i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token operator">++</span>bits<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>bits <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span>    cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Int too small\n"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子并没有达成其所要达成的目的（因为溢出是未定义行为），应当被替换为简单的 static_assert：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// Int 被用作整数类型的别名</span><span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Int<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// do: 编译时检查</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者更好的方式是直接利用类型系统，将 int 替换 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/types/integer">int32_t</a>。</p><blockquote><p>如果当前环境有 int32_t 这个别名，那么代表，你的环境支持 32位整数类型。</p></blockquote><p>或用来检测<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/meta%23.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7">类型特征</a>（type traits），比如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>is_integral_v<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="P-6-不能在编译期检查的事项应该在运行期检查"><a href="#P-6-不能在编译期检查的事项应该在运行期检查" class="headerlink" title="P.6 不能在编译期检查的事项应该在运行期检查"></a>P.6 不能在编译期检查的事项应该在运行期检查</h3><p>因为有 <code>dynamic_cast</code> ，可以安全的将类的指针和引用沿着继承层次结构进行向上，向下以及测向的转换。如果转型失败，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span> 新类型 <span class="token operator">></span><span class="token punctuation">(</span> 表达式 <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果转型失败且 新类型 是指针类型，那么它会返回该类型的空指针。</p><p>如果转型失败且 新类型 是引用类型，那么它会抛出与类型 <code>std::bad_cast</code> 的处理块匹配的异常。</p><p>第五章中 “dynamic_cast” 一节中会有更多的细节。</p><h3 id="P-7-尽早识别运行期错误"><a href="#P-7-尽早识别运行期错误" class="headerlink" title="P.7 尽早识别运行期错误"></a>P.7 尽早识别运行期错误</h3><p>可以采取很多对策来摆脱运行期错误。管理好指针和 C 数组，检查他们的范围。对于转换，同样需要检测：</p><ul><li><em>如有可能，应尽量避免转换，对于窄化转换，尤其如此。检查输入也属于这个范畴</em>。</li></ul><h3 id="P-8-不要泄露任何资源"><a href="#P-8-不要泄露任何资源" class="headerlink" title="P.8 不要泄露任何资源"></a>P.8 不要泄露任何资源</h3><p>资源可以是内存、文件句柄、套接字，等等。处理资源的惯用法是 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/raii">RAII</a> 。RAII 是资源获取即初始化（Resource Acquisition Is Initialization）。 是一种 C++ 编程技术，它将必须在使用前请求的资源（分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存期相绑定。 即：构造函数中获取资源，析构函数中释放资源。</p><p>C++ 大量使用 RAII：锁负责处理互斥量，智能指针负责处理原始内存，STL 的容器负责处理底层元素，等等。</p><blockquote><p>这里居然用中文的 “锁” 这个字来指代那些通用锁管理类（<code>std::lock_guard</code>），原书这里用这个字描述是有问题的，请不要模仿。</p></blockquote><h3 id="P-9-不要浪费时间和空间"><a href="#P-9-不要浪费时间和空间" class="headerlink" title="P.9 不要浪费时间和空间"></a>P.9 不要浪费时间和空间</h3><p>节省时间和空间都是一种美德。我们用的是 C++。你发现下面循环中的问题了吗？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">lower</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">tolower</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>虽然是个错误示例，但这代码写的太过愚蠢了，函数形参不用引用直接拷贝是其一，s 明明是个 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/string/basic_string">std::string</a> 对象，不去调用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/string/basic_string/size">size()</a> 成员函数，跑去用 C 标准库的玩意？</p></blockquote><p>使用 STL 中的算法 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/algorithm/transform">std::transform</a> ，就可以把前面的函数变成一行。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">tolower</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与函数 lower 相比，算法 std::transform 自动确定了字符串的大小。因此，你不需要使用 std::strlen 指定字符串的长度。</p><p>下面是另一个经常出现在生产代码中的典型例子。为一个用户定义的数据类型声明拷贝语义。（拷贝构造函数和拷贝赋值运算符）。最终，编译器永远用不了廉价的移动语义。（即使实际上移动是适用的），而只能一直依赖代价高昂的拷贝语义。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> S<span class="token punctuation">{</span>    std<span class="token operator">::</span>string s_<span class="token punctuation">;</span>    <span class="token function">S</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">s_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">S</span><span class="token punctuation">(</span><span class="token keyword">const</span> S<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">s_</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>s_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    S<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> S<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> s_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>s_<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">S s1<span class="token punctuation">;</span>S s2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//进行拷贝，而不能从 s1.s_ 移动。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>这里没有任何问题，但是我们详细的描述一下，因为我觉得很多人不清楚移动语义能带来什么。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//不修改 S 类</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    S s1<span class="token punctuation">{</span> <span class="token string">"aaaaaaaaaaaaaaaa"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    S s2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/5Kr51KeMo">打印</a>的地址不一样，这代表实际上是复制了 <code>std::string</code> 管理的数据的。</p><p>但是，如果我们修改 S 类，比如直接把复制构造和复制赋值运算符给删了，会怎么样？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">struct</span> S<span class="token punctuation">{</span>    std<span class="token operator">::</span>string s_<span class="token punctuation">;</span>    <span class="token function">S</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">s_</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    S s1<span class="token punctuation">{</span><span class="token string">"aaaaaaaaaaaaaaaa"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    S s2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span>s_<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/4rGxq1h5Y">打印</a>的地址完全一致。</p><p>这代表了 std::string 对象管理的数据并没有真的进行复制。</p><p>我们讲一下为什么：没有了复制构造函数和复制赋值运算符后，移动构造不会再被抑制了，编译器可以<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/move_constructor">隐式定义移动构造函数</a>。</p><p>这个隐式定义的移动构造函数，你大约可以理解为，我们的 <code>S s2 = std::move(s1)</code> 这里调用了 S 的移动构造函数，那么，它的数据成员，同时，也会被 移动，如果是类类型，且有移动构造函数的话，会被调用，相当于，<code>std::string</code> 被调用了移动构造，然后进行了转移。我们知道 std::string 的移动构造，是转移所有权（其实你就可以理解为把原对象的指向数据的指针给了我们当前的对象，然后原对象赋空）。</p><p>我们举个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token function">X</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"X(X&amp;&amp;)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"X(const X&amp;)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Y<span class="token punctuation">{</span>    X x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Y y1<span class="token punctuation">;</span>    Y y2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>y1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码会打印一个 <code>X(X&amp;&amp;)</code>，这证明了我们前面说的：</p><p>编译器隐式定义的移动构造函数，被调用，相当于会把自身的数据成员也进行移动，如果它是类类型，且有移动构造，那么也会匹配上，进行调用。</p><h3 id="P-10-不可变数据优先于可变数据"><a href="#P-10-不可变数据优先于可变数据" class="headerlink" title="P.10 不可变数据优先于可变数据"></a>P.10 不可变数据优先于可变数据</h3><p>使用不可变数据的理由有很多。首先，当你使用常量时，你的代码更容易验证。<strong>常量也有更高的优化潜力</strong>。但最重要的是，常量在并发程序中具有很大的优势。不可变数据在设计上是没有数据竞争的，因为数据竞争的必要条件就是对数据进行修改。</p><blockquote><p>其实只需要考虑一个事情：<strong>如果它可以是常量，那就把它设置为常量</strong>。</p></blockquote><h3 id="P-11-封装杂乱的构建，不要让它在代码中散布开"><a href="#P-11-封装杂乱的构建，不要让它在代码中散布开" class="headerlink" title="P.11 封装杂乱的构建，不要让它在代码中散布开"></a>P.11 封装杂乱的构建，不要让它在代码中散布开</h3><p>混乱的代码往往是低级代码，易于隐藏错误，容易出问题。如果可能的话，用 STL 中的高级构建（如容器或算法）来取代你的杂乱代码。如果这不可能，就把那些杂乱代码封装到一个用户定义的类型或函数中去。</p><h3 id="P-12-适当使用辅助工具"><a href="#P-12-适当使用辅助工具" class="headerlink" title="P.12 适当使用辅助工具"></a>P.12 适当使用辅助工具</h3><p>计算机比人类更擅长做枯燥和重复性的工作。也就是说，应该使用静态分析工具、并发工具和测试工具来自动完成这些验证步骤。<strong>用一个以上的 C++ 编译器来编译代码，往往是验证代码的最简方式</strong>。一个编译器可能检测不到某种未定义行为，而另一个编译器可能会在同样情况下发出警告或产生错误。</p><h3 id="P-13-适当使用支持库"><a href="#P-13-适当使用支持库" class="headerlink" title="P.13 适当使用支持库"></a>P.13 适当使用支持库</h3><p>这也很好解释。你应该去找设计良好、文档齐全、支持良好的库。你会得到经过良好测试、<strong>几乎</strong>没有错误的库，其中的算法经过领域专家的高度优化。突出的例子包括：<strong>C++ 标准库</strong>、Guidelines 支持库和 Boost 库。</p><blockquote><p>我觉得一定有人看到这段会嗤之以鼻，但是总体其实没错的。</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是服务的提供者和使用者之间的契约。根据 C++ Core Guidelines，接口”可能是代码辅助中最重要的一个方面”。“接口”这一部分大约有 20 条规则。</p><blockquote><p><em>让接口易于正确使用，难以错误使用</em>。</p></blockquote><h3 id="I-2-避免非-const-的全局变量"><a href="#I-2-避免非-const-的全局变量" class="headerlink" title="I.2 避免非 const 的全局变量"></a>I.2 避免非 const 的全局变量</h3><p>当然，你应该避免非 const 的全局变量。但是为什么呢？为什么全局变量（尤其是当它不是常量时）会很糟糕？<strong>全局变量会在函数中注入隐藏的依赖，而该依赖并不是接口的一部分</strong>。下面的代码片段说明了我的观点：</p><blockquote><p>加粗的话注意理解。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> glob<span class="token punctuation">{</span> <span class="token number">2011</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span> fac<span class="token punctuation">)</span><span class="token punctuation">{</span>    glob <span class="token operator">*</span><span class="token operator">=</span> glob<span class="token punctuation">;</span>    <span class="token keyword">return</span> glob <span class="token operator">*</span> fac<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 multiply 的执行有一个副作用——会改变全局变量 glob 的值。因此，<strong>你无法对函数进行孤立测试或推理</strong>。当更多的线程并发地使用 multiply 时，你就必须对变量 glob 加以保护。非 const 的全局变量还有更多其他弊端。<strong>如果函数 multiply 没有副作用，那你可以为了性能而将之前的结果存储到缓存中以进行复用。</strong></p><blockquote><p>注意到我们加粗的内容了吗？这非常重要，自行理解。 我们就讲一下最后一句，这其实是在描述<strong>编译器优化</strong> ，我们举个例子：什么情况才可能会是我们说的：<strong>没有副作用，那你可以为了性能而将之前的结果存储到缓存中以进行复用</strong>。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实无非就是：编译器看到你用同样的入参调用了两次 就可以干掉第二次调用。之前的结果被缓存了。（前提是这得是<a href="https://en.m.wikipedia.org/wiki/Pure_function">纯函数</a>）。</p><p>但是我们前面依赖了全局变量，就不行，它有外部的副作用，返回的结果可能会根据全局变量的不同而不同，没办法缓存。不能保证：<strong>多次调用传入的数据相同就能得到完全一致的结果</strong>。</p><h3 id="3-1-非-const-全局变量的弊端"><a href="#3-1-非-const-全局变量的弊端" class="headerlink" title="3.1 非 const 全局变量的弊端"></a>3.1 非 const 全局变量的弊端</h3><p>非 const 的全局变量有许多弊端。首当其冲的弊端是，<strong>非 const 的全局变量破坏了封装。这种对封装的破坏让你无法对函数/类（实体）进行独立思考</strong>。下面列举非 const 全局变量的主要弊端。</p><ul><li><strong>可测试性</strong>：无法孤立地测试你的实体。如果单元不存在，那么单元测试也将不存在。你只能进行系统测试。实体的执行效果要依赖整个系统状态。</li><li><strong>重构</strong>：因为你无法孤立地对代码进行推理，重构它会相当有挑战。</li><li><strong>优化</strong>：你无法轻易地重新安排函数调用或者在不同的线程上进行函数调用，因为可能有隐藏的依赖。缓存之前函数调用的结果也极为危险。</li><li><strong>并发</strong>：产生数据竞争的必要条件是有共享而可变的状态。而非 const 全局变量正是共享而可变的。</li></ul><h3 id="I-3-避免单例"><a href="#I-3-避免单例" class="headerlink" title="I.3 避免单例"></a>I.3 避免单例</h3><p>有时，全局变量伪装得很好。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// singleton.cpp</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">MySingleton</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> MySingleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    MySingleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> MySingleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> MySingleton<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span><span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> MySingleton<span class="token operator">*</span> instance<span class="token punctuation">;</span>    <span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">MySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>MySingleton<span class="token operator">*</span> MySingleton<span class="token operator">::</span>instance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><em>单例就是全局变量，因此你应当尽可能*</em>避免单例***。</li></ul><p>单例简单、直接地保证该类最多只有一个实例存在。作为全局变量，单例注入了一个依赖，而该依赖忽略了函数的接口。这是因为作为静态变量，单例通常会被直接调用，正如上面例子主函数中的两行所展示的那样：Singleton::getInstance()。而对单例的直接调用有一些严重的后果。你无法对有单例的函数进行<strong>单元测试</strong>，因为单元不存在。此外，你也不能创建单例的伪对象并在运行期替换，因为单例并不是函数接口的一部分。</p><blockquote><p>我们先聊一下最后一句话：其实就是说，我没办法创造一个和单例一样类型的对象，然后进行函数传参。因为单例不是函数接口的一部分，它通常会被直接调用。 另外，我们要明白，“单例” 它是<strong>带状态</strong>的，单例的状态是经常变化和难以确定的，因为大家都使用和修改这个单例。如果某个函数使用了这个单例，就没办法对它进行单独的单元测试，因为单例的状态无法确定，单例的状态依赖于所有修改它的代码。这也就是前面说的：<strong>你无法对有单例的函数进行单元测试</strong>。</p></blockquote><ul><li><em>简而言之，单例破坏了代码的可测试性</em>。</li></ul><p>实现单例看似小事一桩，但其实不然。你将面对几个挑战：</p><ul><li>谁来负责单例的销毁？</li><li>是否应该允许从单例派生？</li><li>如何以线程安全的方式初始化单例？</li><li>当单例互相依赖并属于不同的翻译单元时，应该以何种顺序初始化这些单例？这里要吓唬吓唬你了。这一难题被称为<strong><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/xd3G9sh7P">静态初始化顺序问题</a></strong>。</li></ul><h3 id="3-2-运用依赖注入化解"><a href="#3-2-运用依赖注入化解" class="headerlink" title="3.2 运用依赖注入化解"></a>3.2 运用依赖注入化解</h3><p><strong>当某个对象使用单例的时候，注入的依赖就被注入对象中</strong>。而借助依赖注入技术，这个依赖可以变成接口的一部分，并且服务时从外界注入的。这样，客户代码和注入的服务之间就没有依赖了。依赖注入的典型方式是构造函数、设置函数（setter）成员或模板参数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">class</span> <span class="token class-name">Logger</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SimpleLogger</span><span class="token operator">:</span><span class="token keyword">public</span> Logger<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> mess<span class="token punctuation">)</span> override<span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> mess <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">TimeLogger</span><span class="token operator">:</span><span class="token keyword">public</span> Logger<span class="token punctuation">{</span>    <span class="token keyword">using</span> MySecondTick <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">double</span> <span class="token function">timeSinceEpoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">auto</span> timeNow <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> duration <span class="token operator">=</span> timeNow<span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MySecondTick <span class="token function">sec</span><span class="token punctuation">(</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sec<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> mess<span class="token punctuation">)</span> override<span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>fixed<span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Time since epoch: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">timeSinceEpoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> mess <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Client</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Client</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Logger<span class="token operator">></span>log<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">logger</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        logger<span class="token operator">-</span><span class="token operator">></span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"Message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setLogger</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Logger<span class="token operator">></span>log<span class="token punctuation">)</span><span class="token punctuation">{</span>        logger <span class="token operator">=</span> log<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Logger<span class="token operator">></span>logger<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Client <span class="token function">cl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>SimpleLogger<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//（1）</span>    cl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cl<span class="token punctuation">.</span><span class="token function">setLogger</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>TimeLogger<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// （2）</span>    cl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-构建良好的接口"><a href="#3-3-构建良好的接口" class="headerlink" title="3.3 构建良好的接口"></a>3.3 构建良好的接口</h3><ul><li><em>函数应该通过接口（而不是全局变量）进行沟通</em>。</li></ul><p>现在我们来到了本章的核心。按照 C++ Core Guidelines，下面是关于接口的建议。</p><ul><li>接口明确（I.1）</li><li>接口精确并具有强类型（I.4）</li><li>保持较低的参数数目（I.23）</li><li>避免相同类型却不相关的参数相邻（I.24）</li></ul><p>下面的函数 showRectangle 违反了刚提及的接口的所有规则：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">showRectangle</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span><span class="token keyword">double</span> b<span class="token punctuation">,</span><span class="token keyword">double</span> c<span class="token punctuation">,</span><span class="token keyword">double</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>    a <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token function">ceil</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">showRectangle</span><span class="token punctuation">(</span>Point top_left<span class="token punctuation">,</span> Point bottom_right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 好</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管函数 showRectangle 本应当只显示一个矩形，但修改了它的参数。实质上它有两个目的，因此，它的名字有误导性（I.1）。另外，函数签名没有提供关于参数应该是什么的任何信息，也没有关于应该以什么顺序提供参数的信息（I.23 和 I.24）。此外，参数是没有取值范围约束的双精度浮点数。因此，这种约束必须在函数中确立（I.4）。对比而言，第二个 showRectangle 函数接受两个具体的点对象（Point）。</p><ul><li><em>检查 Point是否合法值是 Point 构造函数的工作。这种检查工作本来就不是函数 showRectangle 的职责</em>。</li></ul><p>进一步阐述规则 <strong>I.23</strong> 和 <strong>I.24</strong> 以及标准模板库（STL）中的函数 <strong><code>std::transform_reduce</code></strong>。首先，需要定义属于“<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/named_req/Callable">可调用</a>”（callable）。可调用实体是在行为上像函数的东西。它可以是函数，也可以是函数对象，或者是 lambda 表达式。如果可调用实体接受一个参数，它就是一元可调用实体；如果它接受两个参数，则称为二元可调用实体。</p><p>std::transform_reduce 先将一元可调用实体应用到一个范围或将二元可调用实体应用在两个范围，然后将二元可调用实体应用到前一步的结果的范围上。当你使用一个一元 lambda 表达式调用 std::transform_reduce时，这种调用易于正确使用。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>strVec<span class="token punctuation">{</span><span class="token string">"Only"</span><span class="token punctuation">,</span> <span class="token string">"for"</span><span class="token punctuation">,</span> <span class="token string">"testing"</span><span class="token punctuation">,</span> <span class="token string">"purpose"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>size_t res <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">transform_reduce</span><span class="token punctuation">(</span>    std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span>    strVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t a<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//res 值为 21。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>事实上原书给的上面这段代码是有问题的，无法在 <code>msvc</code> 通过编译，这里使用的是 <code>0</code> 做初始值，有窄化转换，<a href="https://zhuanlan.zhihu.com/p/662592729/https://github.com/microsoft/STL/blob/adea8d5ae280cafb91ae69b8dfaecd1c37a847d9/stl/inc/execution#L4235">msvc 使用的是 {} 初始化</a>。，检测到了，于是编译错误。（但是需要注意，不是简单的 <code>{}</code> 检测的问题，msvc 的实现和其他 stl 从根本上就不一样） 这里其实可以算作是 msvc 的bug，这个场景需要良构 这里应该把 0 换成 <code>Oull</code> （基于当前 64 位环境），或者标准够高使用 <code>0uz</code>，再或者直接 <code>std::size_t{0}</code>。</p></blockquote><p>函数 <code>std::transform_reduce</code> 先将每个字符串变换为它的长度 <code>[](std::string s) {return s.size(); }</code> , 并将二元可调用实体 <code>[](std::size_t a, std::size_t b) {return a + b; },</code> 应用到结果的范围上。求和的初始值是 0。整个计算是并行的 <code>std::execution::par</code>。</p><p>当你使用以下接受两个二元可调用实体的重载版本时，函数声明会变得相当复杂且易错。这违反了 I.23 和 I.24。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ExecutionPolicy</span><span class="token punctuation">,</span>         <span class="token keyword">class</span> <span class="token class-name">ForwardIt1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">ForwardIt2</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">BinaryOp1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">BinaryOp2</span><span class="token operator">></span>T <span class="token function">transform_reduce</span><span class="token punctuation">(</span>ExecutionPolicy<span class="token operator">&amp;&amp;</span> policy<span class="token punctuation">,</span>                   ForwardIt1 first1<span class="token punctuation">,</span> ForwardIt1 last1<span class="token punctuation">,</span> ForwardIt2 first2<span class="token punctuation">,</span>                   T init<span class="token punctuation">,</span> BinaryOp1 binary_op1<span class="token punctuation">,</span> BinaryOp2 binary_op2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用这个重载函数需要 6 个模板参数和 7 个函数参数。按正确顺序使用两个二元可调用实体，可能也是个挑战。</p><blockquote><p>我们展示一下使用这个重载函数的示例代码</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>strVec<span class="token punctuation">{</span><span class="token string">"Only"</span><span class="token punctuation">,</span> <span class="token string">"for"</span><span class="token punctuation">,</span> <span class="token string">"testing"</span><span class="token punctuation">,</span> <span class="token string">"purpose"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>vec<span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>size_t res <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">transform_reduce</span><span class="token punctuation">(</span>    std<span class="token operator">::</span>execution<span class="token operator">::</span>par<span class="token punctuation">,</span>    strVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    std<span class="token operator">::</span>size_t<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t a<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">,</span> std<span class="token operator">::</span>string s2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>res</code> <a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/oeffEexrc">结果</a> 是 25。</p><p>函数 std::transform_reduce 复杂的原因在于两个函数被合并成了一个。更好的选择应该是分别定义函数 transform 和 reduce，并支持管道运算符调用：<strong>transform | reduce</strong>。</p><h3 id="I-13-不要用单个指针来传递数组"><a href="#I-13-不要用单个指针来传递数组" class="headerlink" title="I.13 不要用单个指针来传递数组"></a>I.13 不要用单个指针来传递数组</h3><ul><li><em>不要用单个指针来传递数组</em>。</li></ul><p>这是一条非常特殊的规则，肯定会有很多人不屑一顾。这条规则的出现正是为了解决一些未定义行为。例如下面的函数 copy_n 相当容易出错。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">copy_n</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">*</span> p<span class="token punctuation">,</span> T<span class="token operator">*</span> q<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从[p:p+n] 拷贝到 [q:q+n]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">copy_n</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也许某一天累得精疲力尽，就数错了一个。结果会引发一个元素的越界错误，造成未定义行为。补救方法也很简单，使用 STL 中的容器，如 <strong>std::vector</strong>，并在函数体中检查容器大小。C++20 提供的 std::span 能更优雅地解决这个问题。<strong>std::span</strong> 是个对象，它可以指代连续存储的一串对象。 std::span 永远不是所有者（其实就是说它是个视图，没所有权）。而这段连续的内容可以是数组，或是带有大小的指针，或是 std::vector。</p><blockquote><p>函数传参数组不用指针，而是用 C++20 的 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/container/span">std::span</a>。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>std<span class="token operator">::</span>span<span class="token operator">&lt;</span><span class="token keyword">const</span> T<span class="token operator">></span>src<span class="token punctuation">,</span> std<span class="token operator">::</span>span<span class="token operator">&lt;</span>T<span class="token operator">></span> des<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">copy</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>copy 不需要元素的数目。一种常见的错误来源就这样被 <code>std::span&lt;T&gt;</code> 消除了。</p><h3 id="I-27-为了库-ABI-的文档，考虑使用-PImpl"><a href="#I-27-为了库-ABI-的文档，考虑使用-PImpl" class="headerlink" title="I.27 为了库 ABI 的文档，考虑使用 PImpl"></a>I.27 为了库 ABI 的文档，考虑使用 PImpl</h3><p>由于私有数据成员参与类的内存布局，而私有成员函数参与重载决议，<strong>对这些实现细节的改动都要求使用了这类的所有用户全部重新编译</strong>。而持有指向实现的指针（Pimpl）的 非多态的接口类，则可以将类的用户从其实现的改变隔离开来，<strong>而代价是一层间接</strong>。</p><ul><li><strong>接口： Widget.h</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">widget</span> <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">impl</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>impl<span class="token operator">></span> pimpl<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 公开 API 转发给实现</span>    <span class="token function">widget</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义于实现文件中</span>    <span class="token operator">~</span><span class="token function">widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 定义于实现文件中，其中 impl 将为完整类型</span>    <span class="token function">widget</span><span class="token punctuation">(</span>widget<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义于实现文件中</span>    <span class="token function">widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> widget<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>widget<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义于实现文件中</span>    widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> widget<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>实现： Widget.cpp</strong></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">widget</span><span class="token operator">::</span>impl <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// private data</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">const</span> widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* ... */</span> <span class="token punctuation">}</span>    <span class="token function">impl</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">n</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> widget<span class="token operator">::</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> pimpl<span class="token operator">-</span><span class="token operator">></span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>widget<span class="token operator">::</span><span class="token function">widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> pimpl<span class="token punctuation">{</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>impl<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>widget<span class="token operator">::</span><span class="token function">widget</span><span class="token punctuation">(</span>widget<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>widget<span class="token operator">::</span><span class="token operator">~</span><span class="token function">widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>widget<span class="token operator">&amp;</span> widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>widget<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.zhihu.com/?target=http%3A//cppreference.com">http://cppreference.com</a> 提供了关于 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/pimpl">PImpl</a> 惯用法的更多信息。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="4-1-函数定义"><a href="#4-1-函数定义" class="headerlink" title="4.1 函数定义"></a>4.1 函数定义</h3><ul><li><em>好软件的重要原则是好名字</em>。</li></ul><p>这一原则经常被忽视，但对函数而言它尤其适用。</p><h3 id="好名字"><a href="#好名字" class="headerlink" title="好名字"></a>好名字</h3><p>C++ Core Guidelines 用了前三条规则专门讨论好的名字：“F.1：将有意义的操作 ‘打包’ 成精心命名的函数” “F.2：一个函数应该执行单一的逻辑操作” “F.3：使函数保持简短”。</p><blockquote><p>让我从一则轶事开始。几年前，一位软件开发者问我：“我应该如何称呼我的函数？”我告诉他给函数起一个如 verbObject（动词加对象）这样的名字。如果是成员函数，可能用 verb 就可以了，因为该函数已经对一个对象执行了操作。动词代表了对象执行的操作。那位软件开发者反驳这是不可能的；该函数必须被称为 getTimeAndAddToPhonebook 或 processData，因为这些函数执行不止一项工作（单一责任原则）。</p></blockquote><ul><li><em>当你无法为函数找到一个有意义的名称（F.1）时，这充分说明你的函数执行不止一项逻辑操作（F.2），而且你的函数并不简短（F.3）</em>。</li></ul><p>如果一个函数放不进一屏，那就是太长了。一屏意味着大约 60 行，每行 140 个字符，但你的衡量标准可能有所不同。这时，你就应该识别出函数的操作，并将这些操作打包成精心命名的函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">read_and_print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//不好</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    std<span class="token operator">::</span>cin <span class="token operator">>></span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//检查错误</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于许多原因，函数 read_and_print 不好。该函数与特定的输入和输出捆绑在一起，不能在不同的上下文中使用。将该函数重构为两个函数，可以解决这些问题，使其更易于测试和维护。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream<span class="token operator">&amp;</span>is<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//更好</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    is <span class="token operator">>></span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span>os<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    os <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;sstream></span></span><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream<span class="token operator">&amp;</span>is<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//更好</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    is <span class="token operator">>></span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span>os<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    os <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>stringstream s<span class="token punctuation">{</span><span class="token string">"10 "</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//从 stringstream 中读取</span>    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//输出到标准输出中</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//打印 stringstream 中的内容</span>    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//输出到 stringstream 中。</span>    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//输出到 stringstream 中。</span>    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//输出到 stringstream 中。</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//打印 stringstream 中的内容</span>    s<span class="token punctuation">.</span><span class="token function">seekg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//需要进行回溯，因为默认读取位置在上一个read到的位置</span>    <span class="token keyword">auto</span> result2 <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result2 <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//从 stringstream 中读取</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-4-如果函数有可能需要在编译期求值，就把它声明为-constexpr"><a href="#F-4-如果函数有可能需要在编译期求值，就把它声明为-constexpr" class="headerlink" title="F.4 如果函数有可能需要在编译期求值，就把它声明为 constexpr"></a>F.4 如果函数有可能需要在编译期求值，就把它声明为 constexpr</h3><p>constexpr 函数是可能在编译期运行的函数。当你在常量表达式中调用 constexpr 函数时，或者当你要用一个 constexpr 变量来获取 constexpr 函数的结果时，它会在编译期运行。也可以用只能在运行期求值的参数来调用 constexpr 函数。constexpr 函数是隐含内联的。</p><p>编译期求值的 constexpr 的结果通常会被系统标记为只读。性能是 constexpr 函数的一大好处；它的第二大好处是：</p><p><strong>编译期求值的 constexpr 是纯函数，因此 constexpr 函数是线程安全的</strong>。</p><blockquote><p>加粗这句话是因为这句话是 <strong>错误</strong> 的。 我们下面把这句话分开来聊：</p></blockquote><ul><li>“<strong>constexpr 函数是线程安全的</strong>”？</li></ul><p>完全错误。</p><p>这里会涉及到一个问题：</p><ul><li>C++23 前，标准要求至少存在一组实参值，使得函数的一个调用为核心常量表达式的被求值的子表达式（对于构造函数为足以用于常量初始化器）。<strong>不要求诊断是否违反这点</strong>。</li><li>C++23 起，<strong>标准移除了这一要求</strong>。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//永远不可能编译期求值</span>    <span class="token keyword">return</span> n <span class="token operator">*</span><span class="token operator">=</span> n<span class="token punctuation">,</span> n <span class="token operator">*</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//C++23前可能可以通过编译，也可能不行；C++23起能通过编译</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过这还是太牵强了，我们可以用一个更简单直接的 demo 展示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">++</span>a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//运行期调用，修改b</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上这段代码显然不是线程安全的，各位可以自己<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/co8TdvEos">测试</a>。<strong>你可能可以看到结果是正确的，但是事实上这没什么价值，某些 CPU 能保证标量类型的读写线程安全</strong>。</p><ul><li>“<strong>编译期求值的 constexpr 函数是纯函数</strong>“？</li></ul><p>完全错误（C++11 以后）</p><blockquote><p>C++11 的常量求值中函数只能表现为纯的，一旦有修改操作就导致常量求值失败</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>    v <span class="token operator">+</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> v <span class="token operator">*</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">constexpr</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> r1 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> r2 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> r1<span class="token punctuation">,</span>r2 <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">constexpr</span> <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我的函数 f <strong>的确是编译期求值</strong>，没毛病，难不成它是<a href="https://link.zhihu.com/?target=https%3A//en.m.wikipedia.org/wiki/Pure_function">纯函数</a>？你要不看看它都做了什么.</p><blockquote><p>我们回到前面的性能话题</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>b<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">auto</span> t <span class="token operator">=</span> b<span class="token punctuation">;</span>        b <span class="token operator">=</span> a <span class="token operator">%</span> b<span class="token punctuation">;</span>        a <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">121</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//（1）编译期求值</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">121</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//（2）非编译期求值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原书这里是要你看<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/qjzxxv5oe">汇编</a>的，友情提示，别开优化，这么点代码，开优化，啥 call 都没有。 下面是使用 gcc13.2 生成的 Intel 风格的汇编代码。</p></blockquote><p><img src="/posts/8961/image.png" alt></p><p>（1）所对应汇编指令就是 26行。（2）所对应的汇编指令就是 31~34 行。</p><p>调用 <code>constexpr int i = gcd(11, 121);</code> 会变成值 11，但调用 <code>int j = gcd(a, b);</code> 却会产生一个函数调用。</p><h3 id="F-6-如果你的函数必定不抛出异常，就把它声明为-noexcept"><a href="#F-6-如果你的函数必定不抛出异常，就把它声明为-noexcept" class="headerlink" title="F.6 如果你的函数必定不抛出异常，就把它声明为 noexcept"></a>F.6 如果你的函数必定不抛出异常，就把它声明为 noexcept</h3><p>通过将函数声明为 noexcept，你减少了备选控制路径的数量；因此，noexcept 对优化器来说是一个有价值的提示。</p><ul><li><em>即使你的函数可以抛出异常，noexcept 往往也合理</em>。</li></ul><p>noexcept 在这种情况下意味着：</p><ul><li><em>我不在乎异常。其原因可能是，你无法对异常做出反应</em>。</li></ul><p>这种情况下，系统处理异常的唯一办法是调用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/error/terminate">std::terminate()</a>。这个 noexcept 声明也为代码的读者提供了有价值的信息。</p><p>下面的函数会在内存耗尽时崩溃。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> <span class="token function">collect</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream<span class="token operator">&amp;</span> is<span class="token punctuation">)</span><span class="token keyword">noexcept</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span>res<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">;</span> is <span class="token operator">>></span> s<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下类型的函数永远不该抛出异常：析构函数（见第 5 章中 “失败的析构函数” 一节）、swap 函数，移动操作和默认构造函数。</p><h3 id="F-8-优先使用纯函数"><a href="#F-8-优先使用纯函数" class="headerlink" title="F.8 优先使用纯函数"></a>F.8 优先使用纯函数</h3><ul><li><em>纯函数是指在给定相同参数时总返回相同结果的函数</em>。</li></ul><blockquote><p>其实还有：该函数没有副作用（局部静态变量、非局部变量、可变引用参数或输入/输出流没有突变）。下面也略微提到了。</p></blockquote><p>函数模板 square 就是纯函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">square</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> t <span class="token operator">*</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而非纯函数是指 random() 或 time() 这样的函数，<strong>它们会在不同的调用中返回不同的结果</strong>。换句话说：</p><ul><li><em>与函数体之外的状态交互的函数是不纯的</em>。</li></ul><p>纯函数可以：</p><ul><li>孤立地侧测试</li><li>孤立地验证或重构</li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/Mq-b/Loser-HomeWork/blob/main/C%2B%2BCoreGuidelines%E8%A7%A3%E6%9E%90/%E7%AC%AC3%E7%AB%A0-%E6%8E%A5%E5%8F%A3.md%23i2-%E9%81%BF%E5%85%8D%E9%9D%9E-const-%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">缓存其结果</a></li><li>被自动重排或在其他线程上执行</li></ul><p>纯函数也被称为数学函数。C++ 中的函数默认情况下不是像纯函数式编程语言 Haskell 中那样的纯函数。 在 C++ 中使用纯函数时要基于程序员的素养。<strong>constexpr 函数在编译期求值时是纯的</strong>。</p><blockquote><p>加粗的原因很简单，因为这句话是<strong>错的</strong> 在 <code>F.4</code> 已经介绍过了。</p></blockquote><p>模板元编程时一种嵌在命令式语言 C++ 中的纯函数式语言。</p><p>第 13 章将简单介绍编译期编程，其中包括模板元编程。</p><h3 id="4-2-参数传递：入与出"><a href="#4-2-参数传递：入与出" class="headerlink" title="4.2 参数传递：入与出"></a>4.2 参数传递：入与出</h3><p>C++ Core Guidelines 有若干条规则表达了在函数中传入和传出参数的各种方式。</p><h3 id="F-15-优先采用简单而约定俗成的信息传递方式"><a href="#F-15-优先采用简单而约定俗成的信息传递方式" class="headerlink" title="F.15 优先采用简单而约定俗成的信息传递方式"></a>F.15 优先采用简单而约定俗成的信息传递方式</h3><p>第一条规则展示了大局。首先，它提供了一个概览，介绍了在函数中传入和传出信息的各种方式（见表 4.1）</p><p>表 4.1 很简洁：表头表述了数据在拷贝和移动开销方面的特征，而各行则表明了参数传递的方向。</p><p><strong>表 4.1 普通的参数传递</strong></p><table><thead><tr><th></th><th>拷贝开销低或不可能拷贝</th><th>移动开销低到中，或者未知</th><th>移动开销高</th></tr></thead><tbody><tr><td>入</td><td>func(x)</td><td>func(const X&amp;)</td><td></td></tr><tr><td>入并保留“拷贝”</td><td></td><td></td><td></td></tr><tr><td>入/出</td><td>func(X&amp;)</td><td></td><td></td></tr><tr><td>出</td><td>X func()</td><td>func(X&amp;)</td><td></td></tr></tbody></table><ul><li>数据类型</li><li><strong>拷贝开销低或不可能拷贝</strong>：<code>int</code> 或 <code>std::unique_ptr</code></li><li><strong>移动开销低</strong>：<code>std::vector&lt;T&gt;</code> 或 <code>BigPOD</code>（POD 代表 Old Data “简旧数据”，意为一般的传统数据——没有析构函数、构造函数以及虚成员函数的类）</li><li><strong>移动开销未知</strong>：模板</li><li><strong>移动开销高</strong>：<code>BigPOD[]</code> 或者 <code>std::array&lt;BigPOD&gt;</code></li><li>参数传递的方向</li><li><strong>入</strong>：输入参数</li><li><strong>入并保留“拷贝”</strong>：被调用者保留一份数据</li><li><strong>入/出</strong>：参数会被修改</li><li><strong>出</strong>：输出参数</li></ul><p>对几个 int 大小的数据的操作是低开销的；在不进行内存分配的前提下，1000 字节左右的操作属于中等开销。</p><p>这些普通的参数传递规则则应当是你的首选。不过，也有高级的参数传递规则（见表4.2）。实质上，就是加入了“入并移入”的语义。</p><p><strong>表 4.2 高级的参数传递</strong></p><table><thead><tr><th></th><th>拷贝开销低或不可能拷贝</th><th>移动开销低到中，或者未知</th><th>移动开销高</th></tr></thead><tbody><tr><td>入</td><td>func(x)</td><td>func(const X&amp;)</td><td></td></tr><tr><td>入并保留“拷贝”</td><td></td><td></td><td></td></tr><tr><td>入并移入</td><td>func(X&amp;&amp;)</td><td></td><td></td></tr><tr><td>入/出</td><td>func(X&amp;)</td><td></td><td></td></tr><tr><td>出</td><td>X func()</td><td>func(X&amp;)</td><td></td></tr></tbody></table><blockquote><p>这两个表的 “<strong>出</strong>” 用的 <code>func(X&amp;)</code> 其实是指代那种老式的写法，传入参数做传出参数，Win32中很常见。 “<strong>不可能拷贝</strong>” 其实是指：<code>f(X{})</code> 这种形式，C++17 起强制的复制消除，不可能再复制。 “<strong>入并移入</strong>” 就是让你 <code>f(std::move(...))</code>。</p></blockquote><p>在 “入并移入” 调用后，参数处在所谓的被移动状态。被移动状态意味着它处于合法但未指定的状态。基本上，你在重新使用被移动的对象前必须对它进行初始化。</p><p>其余的参数传递规则为以上这些表格提供了必要的背景信息。</p><h3 id="F-16-对于-“入”参，拷贝开销低的类型按值传递，其他类型则以-const-引用来传递"><a href="#F-16-对于-“入”参，拷贝开销低的类型按值传递，其他类型则以-const-引用来传递" class="headerlink" title="F.16 对于 “入”参，拷贝开销低的类型按值传递，其他类型则以 const 引用来传递"></a>F.16 对于 “入”参，拷贝开销低的类型按值传递，其他类型则以 const 引用来传递</h3><p>这条规则执行起来直截了当。默认情况下，输入值可以拷贝就拷贝。如果拷贝开销不低，就通过 const 引用来传入。C++ Core Guidelines 给出了回答以下问题的经验法则：</p><p><strong>哪些对象拷贝开销低？哪些对象拷贝高？</strong></p><ul><li><em>如果 `sizeof(par) &lt;= 2 \</em> sizeof(void*)`，则按值传递参数 par*。</li><li><em>如果 `sizeof(par) &gt; 2 \</em> sizeof(void*)`，则按 const 引用 传递参数 par*。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可以：按 const 的引用传递；</span>                                 <span class="token comment" spellcheck="true">// 总是低开销</span><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 差劲：潜在的高昂开销</span><span class="token keyword">void</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 可以：无可匹敌</span><span class="token keyword">void</span> <span class="token function">f4</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 差劲：在 f4() 里面访问时有额外开销</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-19-对于“转发”参数，要用-Tp-amp-amp-来传递，并且只-std-forward-该参数"><a href="#F-19-对于“转发”参数，要用-Tp-amp-amp-来传递，并且只-std-forward-该参数" class="headerlink" title="F.19 对于“转发”参数，要用 Tp&amp;&amp; 来传递，并且只 std::forward 该参数"></a>F.19 对于“转发”参数，要用 Tp&amp;&amp; 来传递，并且只 std::forward 该参数</h3><p>这条规则代表了一种特殊的输入值。有时你想完美转发参数 par。这意味着你希望保持左值的左值性，以及右值的右值性，这样才能“完美”地转发参数，使它的语义不发生变化。</p><p>该转发参数的典型用例是工厂函数，工厂函数通过调用某个用户指定对象的构造函数创造处该对象。你不知道参数是不是右值，也不知道构造函数需要多少参数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>T1<span class="token operator">></span>     <span class="token comment" spellcheck="true">//（1）</span>T <span class="token function">create</span><span class="token punctuation">(</span>T1<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>t1<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> MyType<span class="token punctuation">{</span>    <span class="token function">MyType</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 左值</span>    <span class="token keyword">int</span> five <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> myFive <span class="token operator">=</span> create<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>five<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右值</span>    <span class="token keyword">int</span> myFive2 <span class="token operator">=</span> create<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 无参数</span>    <span class="token keyword">int</span> myZero <span class="token operator">=</span> create<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 三个参数；（左值，右值，右值）</span>    MyType myType <span class="token operator">=</span> create<span class="token operator">&lt;</span>MyType<span class="token operator">></span><span class="token punctuation">(</span>myZero<span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>形参包的打包和解包</strong></p><p>当省略号在类型参数 T1 的左边时，参数包被打包；当省略号在右边时，参数包被解包。返回语句 <code>T(std::forwardt1(t1)...)</code> 中的这种解包实质上意味着表达式 <code>std::forwardt1(t1)</code> <strong>被不断重复，直到形参包中的所有参数都被消耗掉，并且会在每一个子表达式之间加一个逗号</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>T1<span class="token operator">></span>     <span class="token comment" spellcheck="true">//（1）</span>T <span class="token function">create</span><span class="token punctuation">(</span>T1<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>t1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> X<span class="token punctuation">{</span>    <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    X resutl <span class="token operator">=</span> create<span class="token operator">&lt;</span>X<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码的 <code>create</code> 模板，实例化相当于下面这种形式：（也符合前面说的“被不断重复，直到形参包中的所有参数都被消耗掉，并且会在每一个子表达式之间加一个逗号”）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>X create<span class="token operator">&lt;</span>X<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> __t10<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">&amp;&amp;</span> __t11<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">&amp;&amp;</span> __t12<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token function">X</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>__t10<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>__t11<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span>__t12<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于好奇的读者 <a href="https://link.zhihu.com/?target=https%3A//cppinsights.io/">C++ Insights</a> 可以展示这个过程。</p><p>转发与变参模板的结合是 C++ 中典型的创建模式。下面是 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique">std::make_unique</a> 的一种可能实现。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_unique</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-17-对于“入-出”参数，使用非-const-的引用来传递"><a href="#F-17-对于“入-出”参数，使用非-const-的引用来传递" class="headerlink" title="F.17 对于“入-出”参数，使用非 const 的引用来传递"></a>F.17 对于“入-出”参数，使用非 const 的引用来传递</h3><p>这条规则把函数的设计意图传递给了调用方：该函数会修改它的参数。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>myVec<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">modifyVector</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> vec<span class="token punctuation">)</span><span class="token punctuation">{</span>    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-20-对于“出”的输出值，优先使用返回值而非输出参数"><a href="#F-20-对于“出”的输出值，优先使用返回值而非输出参数" class="headerlink" title="F.20 对于“出”的输出值，优先使用返回值而非输出参数"></a>F.20 对于“出”的输出值，优先使用返回值而非输出参数</h3><p>这条规则很简单。</p><ul><li><em>用返回值就好，但别用 const，因为它不但没有附加价值，而且会干扰移动语义</em>。</li></ul><p>也许你认为值的复制开销巨大，这<strong>既对也不对</strong>。原因在于编译器会应用 RVO（return value optimization，返回值优化）或 NRVO（named return value optimization，具名返回值优化）。</p><p>RVO 意味着编译器可以消除不必要的复制操作。到了 C++17，原本只是可能会做的优化成了一种<strong>保证</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp">MyType <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> MyType<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// C++17 中不会拷贝</span><span class="token punctuation">}</span>MyType myType <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// C++17 中不会拷贝</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这几行中可能会发生两次不必要的拷贝操作：第一次在返回调用中，第二次在函数调用中。C++17 中则不会有拷贝操作发生。如果这个返回值有名字，我们就称这种优化为 NRVO。你大概也已经猜到了。</p><pre class="line-numbers language-cpp"><code class="language-cpp">MyType <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    NyType myValue<span class="token punctuation">;</span>    <span class="token keyword">return</span> myValue<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 允许拷贝一次</span><span class="token punctuation">}</span>MyType myType <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 在 C++17 中不会拷贝</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一个细微的区别：按照 C++17 编译器仍然可以在返回语句中拷贝值 myValue，但在函数调用的地方则不会发生拷贝。</p><blockquote><p>这里详细聊一下 复制消除 NRVO RVO 吧：</p></blockquote><p>下列环境下，允许但不要求编译器省略类对象的复制和移动 (C++11 起)构造，即使复制/移动 (C++11 起)构造函数和析构函数拥有可观察的副作用。这些对象将直接构造到它们本来要复制/移动到的存储中。<strong>这是一项优化</strong>：即使进行了优化而不调用复制/移动 (C++11 起)构造函数，它仍然必须存在且可访问（如同完全未发生优化），否则程序非良构</p><p><strong>在对象的初始化中，当源对象是无名临时量且与目标对象具有相同类型（忽略 cv 限定）时。当无名临时量为 return 语句的操作数时，称这种复制消除的变体为 RVO，“返回值优化 (return value optimization)”。</strong></p><p>C++17起 返回值优化是<strong>强制要求的</strong>（也就是不再被当成优化），而不再被当做复制消除。</p><p>这就是 RVO 的规则，只要满足，那么在 C++17 就不可能有复制开销。</p><p>我们看到先前的代码示例，之所以第一个示例在 C++17 都不会有额外拷贝就是因为它</p><p><code>return MyType{};</code> 满足了：<strong>当无名临时量为 return 语句的操作数</strong>。</p><p><code>MyType myType = func();</code> 满足了：<strong>在对象的初始化中，当源对象是无名临时量且与目标对象具有相同类型（忽略 cv 限定）时</strong>。</p><p>因为 <strong>NRVO</strong> 的存在，不一定会拷贝，只是不保证而已。</p><p><strong>return 语句中，当操作数是拥有自动存储期的非 volatile 对象的名字，该名字不是函数形参或 catch 子句形参，且其具有与函数返回类型相同的类类型（忽略 cv 限定）时。这种复制消除的变体被称为</strong> NRVO<strong>，“具名返回值优化 (named return value optimization)”。</strong></p><p>函数往往必须返回多于一个值。于是，规则 F.21 来了。</p><h3 id="F-21-要返回多个“出”值，优先考虑返回结构体或者多元组"><a href="#F-21-要返回多个“出”值，优先考虑返回结构体或者多元组" class="headerlink" title="F.21 要返回多个“出”值，优先考虑返回结构体或者多元组"></a>F.21 要返回多个“出”值，优先考虑返回结构体或者多元组</h3><p>当你向 std::set 中插入一个值时，成员函数 insert 的重载会返回一个 std::pair，它由两部分组成：一个指向所插入元素的迭代器；还有一个 bool，如果插入成功，它会被设置为 true。C++11 中的 std::tie 和 C++17 中的结构化绑定是将两个值绑定到某变量的两种优雅方式。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;tuple></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>mySet<span class="token punctuation">;</span>    std<span class="token operator">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator iter<span class="token punctuation">;</span>    <span class="token keyword">bool</span> inserted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token function">tie</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> inserted<span class="token punctuation">)</span> <span class="token operator">=</span> mySet<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//（1）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2011 was inserted successfully\n"</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> <span class="token punctuation">[</span>iter2<span class="token punctuation">,</span> inserted2<span class="token punctuation">]</span> <span class="token operator">=</span> mySet<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2017</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//（2）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted2<span class="token punctuation">)</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2017 was inserted successfully\n"</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在（1）处，我们使用 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/utility/tuple/tie">std::tie</a> 将插入操作的返回值解包到 iter 和 inserted 中。而在（2）处，我们使用结构化绑定将插入操作的返回值解包到 iter2 和 inserted2 中。与结构化绑定相比，std::tie 还需要预先声明的变量。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/3GKbGeYsY">运行结果</a>：</p><pre class="line-numbers language-text"><code class="language-text">2011 was inserted successfully2017 was inserted successfully<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-3-参数传递：所有权语义"><a href="#4-3-参数传递：所有权语义" class="headerlink" title="4.3 参数传递：所有权语义"></a>4.3 参数传递：所有权语义</h3><p>上一节探讨参数的流向：哪些参数是入，哪些参数是入/出或出。但对参数来说，除了流动的方向，还有其他需要考虑的问题。传递参数也事关<strong>所有权语义</strong>。但本节会介绍 5 种典型的参数传递方式：通过拷贝、通过指针、通过引用、通过 std::unique_ptr 和通过 std::shared_ptr 。</p><p>只有通过智能指针传参的相关规则是在本节内新出现的。</p><p>通过拷贝传参的规则是 4.2 节“参数传递：入与出” 的一部分。而通过指针和引用传参的规则是 第 3 章的一部分。</p><p><strong>表 4.3 参数传递的所有权语义</strong></p><table><thead><tr><th>例子</th><th>所有权</th><th>规则</th></tr></thead><tbody><tr><td>func(value)</td><td>func 是资源所有者</td><td>F.16</td></tr><tr><td>func(pointer*)</td><td>func 借用了资源</td><td>I.11 和 F.7</td></tr><tr><td>func(reference&amp;)</td><td>func 借用了资源</td><td>I.11 和 F.7</td></tr><tr><td>func(std::unique_ptr)</td><td>func 是资源的独占所有者</td><td>F.26</td></tr><tr><td>func(std::shared_ptr)</td><td>func 是资源的共享所有者</td><td>F.27</td></tr></tbody></table><p>更多细节如下。</p><ul><li>func(value)：函数 func 自己有一份 value 的拷贝并且就是其所有者。func 会自动释放该资源。</li><li>func(pointer*)：func 借用了资源，所以无权删除该资源。func 在每次使用前都必须检查该指针是否为空指针。</li><li>func(reference&amp;)：func 借用了资源。与指针不同，引用的值总是合法的。</li><li>func(std::unique_ptr)：func 是资源的新所有者。func 的调用方显式地把资源的所有权传给了被调用方。func 会自动释放该资源。</li><li>func(std::shared_ptr)：func 是资源的额外所有者。func 会延长资源的生存期。在 func 结束时，它也会结束对资源的所有权。如果 func 是资源的最后一个所有者，那么它的结束会导致资源的释放。</li></ul><h3 id="谁是所有者？"><a href="#谁是所有者？" class="headerlink" title="谁是所有者？"></a>谁是所有者？</h3><p>务必明确表达出所有权。试想一下，你的程序是用传统 C++ 编写的，只能使用原始指针来表达指针、引用、std::unique_ptr 或 std::shared_ptr 这四种传参方式的所有权语义。</p><ul><li><em>传统 C++ 的关键问题是，谁是所有者？</em></li></ul><p>下面的代码说明了我的观点：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">double</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键问题是，谁是资源的所有者？是使用该数组的 func 中的被调用方，还是创建该数组的 func 的调用方？如果 func 是所有者，那么它必须释放该资源。如果不是，则func 不可以释放资源。这种情况不能令人满意。如果 func 不释放资源，可能会发生内存泄露。如果 func 释放了资源，可能会导致未定义行为。</p><p>因此，所有权需要记录在文档中。使用现代 C++ 中的类型系统来定义所有权的契约是朝正确方向迈出的一大步，可以消除文档的模糊性。</p><ul><li>！！！！！<em>在应用层面使用 <code>std::move</code> 的意图并不在于移动，而是所有权的转移</em>。</li></ul><p>举例来说，若对 std::unique_ptr 应用 std::move，会将内存的所有权转移到另一个 std::unique_ptr。智能指针 uniquePtr1 是原来的所有者，而 uniquePtr2 将成为新的所有者。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> uniquePtr1 <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> uniquePtr2<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>uniquePtr1<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面是所有权在实践中的五种变体：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span><span class="token keyword">class</span> <span class="token class-name">MyInt</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">MyInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">myInt</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">MyInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> myInt <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> myInt<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">funcCopy</span><span class="token punctuation">(</span>MyInt myInt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">funcPtr</span><span class="token punctuation">(</span>MyInt<span class="token operator">*</span> myInt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">funcRef</span><span class="token punctuation">(</span>MyInt<span class="token operator">&amp;</span> myInt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">funcUniqPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>MyInt<span class="token operator">></span>myInt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">funcSharedPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>MyInt<span class="token operator">></span>myInt<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=== Begin"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    MyInt myInt<span class="token punctuation">{</span> <span class="token number">1998</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    MyInt<span class="token operator">*</span> myIntPtr <span class="token operator">=</span> <span class="token operator">&amp;</span>myInt<span class="token punctuation">;</span>    MyInt<span class="token operator">&amp;</span> myIntRef <span class="token operator">=</span> myInt<span class="token punctuation">;</span>    <span class="token keyword">auto</span> uniqPtr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>MyInt<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> sharedPtr <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>MyInt<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">funcCopy</span><span class="token punctuation">(</span>myInt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">funcPtr</span><span class="token punctuation">(</span>myIntPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">funcRef</span><span class="token punctuation">(</span>myIntRef<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">funcUniqPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>uniqPtr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">funcSharedPtr</span><span class="token punctuation">(</span>sharedPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=== End"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/z8Tn197Ph">运行结果</a>：</p><pre class="line-numbers language-text"><code class="language-text">=== Begin19982011=== End20141998<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果显示，有两个析构函数在 main 函数结束之前被调用，还有两个析构函数在 main 函数结束的地方被调用。</p><p>在 main 函数结束之前析构的是 被<strong>拷贝</strong>到函数中（<code>funcCopy(myInt)</code>），以及被<strong>移动</strong>到函数中 （<code>funcUniqPtr(std::move(uniqPtr))</code>）。</p><ol><li>拷贝拷贝了一份新的 MyInt 到函数 func 中，func 结束的时候，自然进行析构，打印 <code>1998</code>。</li><li>移动转移了智能指针资源的所有权，所以在 func 结束的时候，<code>RAII</code> 释放了内存，打印 <code>2011</code>。</li><li><code>shared_ptr</code> 对象的资源并没有转移，它是共享的，有两个对象共享资源，分别是 main 函数局部的，以及 func 函数中的，所以当 func 结束的时候，只是引用计数减一，不会释放资源。只能等到 main 函数也结束的时候才会析构，释放内存，打印 <code>2014</code> 。</li><li><code>MyInt myInt</code> 析构，打印 <code>1998</code>。其实你可以注意到，打印了两次 <code>1998</code>，因为第一次析构的是复制到函数中的。</li></ol><h3 id="4-4-值返回语义"><a href="#4-4-值返回语义" class="headerlink" title="4.4 值返回语义"></a>4.4 值返回语义</h3><p>本节中的 7 条规则与前面提到的规则 “F.20：对于‘出’的输出值，优先使用返回值而非输出参数”相一致。这一节的规则还与一些特殊用例和不建议的做法相关。</p><h3 id="F-42-返回-T-（仅仅）用于表示位置"><a href="#F-42-返回-T-（仅仅）用于表示位置" class="headerlink" title="F.42 返回 T* （仅仅）用于表示位置"></a>F.42 返回 T* （仅仅）用于表示位置</h3><ul><li><em>指针仅用于表示位置</em></li></ul><p>这正是 find 的作用。</p><pre class="line-numbers language-cpp"><code class="language-cpp">Node <span class="token operator">*</span> <span class="token function">find</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>t <span class="token operator">||</span> t<span class="token operator">-</span><span class="token operator">></span>name <span class="token operator">==</span> s<span class="token punctuation">)</span><span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里指针表示名字与 s 相匹配的 Node 的位置。</p><h3 id="F-44-当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回-T-amp"><a href="#F-44-当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回-T-amp" class="headerlink" title="F.44 当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回 T&amp;"></a>F.44 当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回 T&amp;</h3><p>当不存在“没有返回对象” 这种可能性的时候就可以返回引用而非指针了。</p><p>有时你<strong>想进行链式操作</strong>，但不想为不必要的临时对象进行拷贝和析构。典型的用例是输入和输出流或赋值运算符（“F.47：从赋值运算符返回 T&amp;”）。在下面的代码片段中，通过 <strong>T&amp;</strong> 返回和通过 <strong>T</strong> 返回有什么微秒的区别？</p><pre class="line-numbers language-cpp"><code class="language-cpp">A<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>A <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>A a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3<span class="token punctuation">;</span>a1 <span class="token operator">=</span> a2 <span class="token operator">=</span> a3<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回拷贝（A）的拷贝赋值运算符会触发两个额外的 A 类型临时对象的创建。</p><h3 id="局部对象的引用"><a href="#局部对象的引用" class="headerlink" title="局部对象的引用"></a>局部对象的引用</h3><p>返回局部对象的引用（指针）是<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/ub">未定义行为</a>。</p><ul><li><em>未定义行为本质上意味着，不要假想程序的行为</em>。</li></ul><p>先修复未定义行为。程序 <code>lambdaFuncionCapture.cpp</code> 返回了局部对象的引用。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">auto</span> <span class="token function">makeLambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> std<span class="token operator">::</span>string val <span class="token operator">=</span> <span class="token string">"on stack created"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>val<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">return</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//（2）</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> bad <span class="token operator">=</span> <span class="token function">makeLambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//（1）</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">bad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//（3）</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main 函数调用函数 makeLambda()（1）。该函数返回一个 Lambda 表达式，它具有对局部变量 val（2）的引用。</p><p>调用 bad()（3）导致了未定义行为，因为 Lambda 表达式使用了局部变量 val 的引用。由于它是局部变量，它的生存期随着 makeLambda() 的作用域结束而结束。</p><p>执行该程序时会得到无法预知的结果。有时我得到整个字符串，有时得到字符串的一部分，有时只得到 0。</p><blockquote><p>且可能随着 C++ 标准的不同，优化的等级等，而<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/GzGe7T97o">变化</a>。纠结这个结果并没有多少价值，<strong>未定义行为本质上意味着，不要假想程序的行为</strong>。</p></blockquote><h3 id="F-45-不要返回-T-amp-amp"><a href="#F-45-不要返回-T-amp-amp" class="headerlink" title="F.45 不要返回 T&amp;&amp;"></a>F.45 不要返回 T&amp;&amp;</h3><p>以及</p><h3 id="F-48-不要返回-std-move-本地变量"><a href="#F-48-不要返回-std-move-本地变量" class="headerlink" title="F.48 不要返回 std::move(本地变量)"></a>F.48 不要返回 std::move(本地变量)</h3><p>两条规则都非常严格。</p><p>不应当以 T&amp;&amp; 作为返回类型。下面的小例子展示了这个问题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">returnRvalueReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> myInt <span class="token operator">=</span> <span class="token function">returnRvalueReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在编译时，GCC 编译器会立即抱怨对临时对象的引用。准确地说，临时对象的生存期随着整个表达式 <code>auto myInt = returnRvalueReference();</code> 的结束而结束。</p><blockquote><p><strong>在函数调用中绑定到函数形参的临时量，存在到含这次函数调用的全表达式结尾为止：如果函数返回一个生命长于全表达式的引用，那么它会成为悬垂引用。</strong></p></blockquote><pre class="line-numbers language-text"><code class="language-text"><source>: In function 'int&& returnRvalueReference()':<source>:2:16: warning: returning reference to temporary [-Wreturn-local-addr]    2 |     return int{};      |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="std-move-本地变量"><a href="#std-move-本地变量" class="headerlink" title="std::move(本地变量)"></a>std::move(本地变量)</h3><p>由于 RVO 和 NRVO 的拷贝消除，return std::move(本地变量)的使用不是优化而是劣化。劣化意味着<strong>程序可能会变得更慢</strong>。</p><blockquote><p>std::move(本地变量)的确毫无意义，但是 <code>return std::move(expr)</code> 不是，可以看之前的<a href="https://zhuanlan.zhihu.com/p/654113232">文章</a>。</p></blockquote><h3 id="F-46-main-的返回类型是-int"><a href="#F-46-main-的返回类型是-int" class="headerlink" title="F.46 main() 的返回类型是 int"></a>F.46 main() 的返回类型是 int</h3><p>依照 C++ 标准，main 函数体有两种变体：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第二个版本等效于 <code>int main(int argc, char* argv[]){ ... }</code>。</p><p>main 函数并不需要返回语句。如果控制流抵达 main 函数的末尾而没有碰到一条返回语句，其效果相当于 <code>return 0;</code>。return 0 意味着程序成功执行。</p><blockquote><p>这里最前面说的 <strong>依照 C++ 标准</strong>。 我们都知道 main 函数的形式远不止这些，但那些都是编译器的扩展，我们用 msvc 举几个例子。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">wmain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">wmain</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">wchar_t</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参见 <a href="https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/cpp/cpp/main-function-command-line-args%3Fview%3Dmsvc-170">msvc 文档</a>。</p><h3 id="F-50-当函数不适用时（需要捕获局部变量，或者编写一个局部函数），请使用-Lambda-表达式"><a href="#F-50-当函数不适用时（需要捕获局部变量，或者编写一个局部函数），请使用-Lambda-表达式" class="headerlink" title="F.50 当函数不适用时（需要捕获局部变量，或者编写一个局部函数），请使用 Lambda 表达式"></a>F.50 当函数不适用时（需要捕获局部变量，或者编写一个局部函数），请使用 Lambda 表达式</h3><p>这条规则说明了 Lambda 表达式的使用场合。这立刻引出了问题：</p><ul><li>什么时候必须用 Lambda 表达式？</li><li>什么时候必须用普通函数？</li></ul><p>这里有两条明显的理由。</p><ul><li><strong>如果可调用实体必须捕获局部变量，或者它是在局部作用域内声明的，你就必须使用 Lambda 表达式</strong>。</li><li><strong>如果可调用实体需要支持重载，那么应使用普通函数</strong>。</li></ul><p>现在我想亮出我对 Lambda 表达式的关键论点，它们经常会被忽视。</p><p><strong>表达力</strong></p><p>”明确优于隐晦“这条来自 Python（PEP 20 —— 《Python 之阐》）的元规则也适用于 C++。它意味着代码应该明确地表达其意图（见规则”P.1：在代码中直接表达思想“）。 当然，这对 Lambda 表达式来说尤其正确。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> myStrVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"523345"</span><span class="token punctuation">,</span><span class="token string">"4336893456"</span><span class="token punctuation">,</span><span class="token string">"7234"</span><span class="token punctuation">,</span>                                    <span class="token string">"564"</span><span class="token punctuation">,</span><span class="token string">"199"</span><span class="token punctuation">,</span><span class="token string">"433"</span><span class="token punctuation">,</span><span class="token string">"2435345"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>myStrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> myStrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> f<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> f<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> myStrVec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"523345"</span><span class="token punctuation">,</span><span class="token string">"4336893456"</span><span class="token punctuation">,</span><span class="token string">"7234"</span><span class="token punctuation">,</span>                                        <span class="token string">"564"</span><span class="token punctuation">,</span><span class="token string">"199"</span><span class="token punctuation">,</span><span class="token string">"433"</span><span class="token punctuation">,</span><span class="token string">"2435345"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">lessLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> f<span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> f<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>myStrVec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> myStrVec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>lessLength<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Lambda 表达式和函数都为排序算法提供了相同的顺序谓词。如果你不相信他们，你就必须分析其实现。也许这并不可能，因为你只有函数的声明。有了 Lambda 表达式，你的同事无法欺骗你。代码就是真相。让我更挑衅的说：</p><ul><li><strong><em>你的代码的表达能力应该强到不需要文档\</em></strong>。</li></ul><blockquote><p><strong>表达能力与不要重复自己</strong><br>“用 Lambda 编写表达力丰富的代码”这条设计规则往往与另一条重要的设计规则相矛盾：不要重复自己（don’t repeat yourself, DRY）。DRY 意味着你不应该多次编写相同的代码。编写一个可重复使用的单元，如一个函数，并给它指定一个不言自明的名称，是对 DRY 的合适补救。最终，必须在具体的案例中决定是否把表达力看得比 DRY 更重要。</p></blockquote><h3 id="F-52-在局部使用（包括要传递给算法）的-Lambda-表达式中，优先通过引用来捕获"><a href="#F-52-在局部使用（包括要传递给算法）的-Lambda-表达式中，优先通过引用来捕获" class="headerlink" title="F.52 在局部使用（包括要传递给算法）的 Lambda 表达式中，优先通过引用来捕获"></a>F.52 在局部使用（包括要传递给算法）的 Lambda 表达式中，优先通过引用来捕获</h3><p>以及</p><h3 id="F-53-在非局部使用（包括要被返回、存储在堆上或要传给其他线程）的-Lambda-表达式中，避免通过引用来捕获"><a href="#F-53-在非局部使用（包括要被返回、存储在堆上或要传给其他线程）的-Lambda-表达式中，避免通过引用来捕获" class="headerlink" title="F.53 在非局部使用（包括要被返回、存储在堆上或要传给其他线程）的 Lambda 表达式中，避免通过引用来捕获"></a>F.53 在非局部使用（包括要被返回、存储在堆上或要传给其他线程）的 Lambda 表达式中，避免通过引用来捕获</h3><p>这两条规则高度关联，它们可以归结为：<strong>Lambda 表达式应该只对有效数据进行操作</strong>。</p><ul><li>当 Lambda 通过拷贝捕获数据时，根据定义，数据总是有效的。</li><li>当 Lambda 通过引用捕获数据时，数据的生存期必须超过 Lambda 的生存期。</li></ul><p>前面局部对象引用的例子就展示了 Lambda 引用无效数据时的各种问题。</p><p>有时问题还不那么容易发现。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string str<span class="token punctuation">{</span><span class="token string">"C++11"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>thread thr<span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>str<span class="token punctuation">]</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    thr<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在新创建的线程 thr 中使用的 Lambda 表达式通过引用捕获了变量 str。之后，thr 从其创建者（即主线程）的生存期中分离出来。因此，不能保证创建的线程 thr 使用的是有效的字符串 str，因为 str 的生存期与主线程的生存期绑定了。</p><p>可以采用一个直截了断的方法来解决这个问题。通过拷贝捕获 str。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string str<span class="token punctuation">{</span><span class="token string">"C++11"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>thread thr<span class="token punctuation">{</span><span class="token punctuation">[</span>str<span class="token punctuation">]</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    thr<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题解决了吗？没有！关键的问题是:</p><ul><li><strong>谁是 std::cout 的所有者？</strong></li></ul><p>std::cout 的生存期与进程的生存期绑定。这意味着，在屏幕上打印出“C++11”之前，std::cout 对象可能已经消失了。解决这个问题的方法是汇合（join）线程 thr。这种情况下，创建者会等待，直到被创建者完全任务，因此，通过引用捕获也就可以了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string str<span class="token punctuation">{</span><span class="token string">"C++11"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>thread thr<span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>str<span class="token punctuation">]</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    thr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="F-51-在有选择的情况下，优先采用默认参数而非重载"><a href="#F-51-在有选择的情况下，优先采用默认参数而非重载" class="headerlink" title="F.51 在有选择的情况下，优先采用默认参数而非重载"></a>F.51 在有选择的情况下，优先采用默认参数而非重载</h3><p>如果你需要不同数量的参数来调用一个函数，尽可能优先采用默认参数而不是重载。这样你就遵循了 DRY（不要重复自己）原则。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> format f <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若要使用重载实现相同的功能，则需要两个函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> format f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="F-55-不要使用-va-arg-参数"><a href="#F-55-不要使用-va-arg-参数" class="headerlink" title="F.55 不要使用 va_arg 参数"></a>F.55 不要使用 va_arg 参数</h3><p>当你的函数需要接受任意数量的参数时，要使用变参模板而不是 va_arg 参数。</p><p>变参函数（variadic function）是像 std::printf 这样的函数，可以接受任意数量的参数。问题是，必须假设传递的类型总是正确的。当然，这种假设非常容易出错，其正确性依赖于程序员的素养。</p><blockquote><p>std::printf 不是类型安全的函数，很多东西理论上根本无法检测，但是因为用的太多了，大部分编译器都给它开洞检查类型之类的玩意了。</p></blockquote><p>为了理解变参函数的隐含危险，请看下面的小例子。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdarg></span></span><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    va_list argPointer<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>argPointer<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>        sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>argPointer<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>argPointer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(1, 5): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(3, 1, 2, 3): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(3, 1, 2, 3, 4): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//（1）</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(3, 1, 2, 3.5): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//（2）</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sum 是一个变参数函数。它的第一个参数是需要被求和的参数个数。以下是关于 va_arg 宏的背景信息，有助于理解该代码。</p><ul><li><strong>va_list:</strong> 保存下列宏的必要信息。</li><li><strong>va_start:</strong> 启用对变参函数参数的访问。</li><li><strong>va_arg:</strong> 访问下一个变参函数的参数。</li><li><strong>va_end:</strong> 结束对变参函数参数的访问。</li></ul><p>请阅读 <a href="https://link.zhihu.com/?target=http%3A//cppreference.com">http://cppreference.com</a> 中关于<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/variadic_arguments">变参数函数</a>的部分来获取进一步的信息。</p><p>代码行（1）和（2）中出了些状况。（1）中参数 num 的数量是错的；（2）中我提供了一个 double 而不是一个int。<a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/nch8fjdf5">输出结果</a>显示了这两个问题。（1）中的最后一个元素丢失了，而 double 被解释为 int（2）。</p><pre class="line-numbers language-text"><code class="language-text">sum(1, 5): 5sum(3, 1, 2, 3): 6sum(3, 1, 2, 3, 4): 6sum(3, 1, 2, 3.5): 539767595<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，最后一个输出结果并不一定，我们只是按照书上的结果写了。经过实测的话，msvc 和 mingw clang 都是 <strong>6</strong>，gcc 是 <strong>3075</strong>。</p></blockquote><p>这些问题可以通过 C++17 的折叠表达式轻松解决。跟 va_arg 相比，折叠表达式会自动推导出其参数的数量和类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(5): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(1, 2, 3): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(1, 2, 3, 4): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sum(1, 2, 3.5): "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 sum 可能看起来挺可怕，它需要至少一个参数，并使用 C++11 的变参模板。变参模板可以接受任意数量的参数。这些任意数量的参数由所谓的参数包持有，用省略号（…）表示。此外，在 C++17 中，可以用二元运算符直接对参数包进行归约。这一针对变参模板的增强被称为折叠表达式。在 sum 函数的例子中，应用了二元的 + 运算符（… + args）。想要了解 C++17 折叠表达式的更多信息可参阅 <a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/fold">https://zh.cppreference.com/w/cpp/language/fold</a> 了解更多细节。</p><p>程序的输出正如预期：</p><pre class="line-numbers language-text"><code class="language-text">sum(5): 5sum(1, 2, 3): 6sum(1, 2, 3, 4): 10sum(1, 2, 3.5): 6.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6-相关规则"><a href="#4-6-相关规则" class="headerlink" title="4.6 相关规则"></a>4.6 相关规则</h3><p>关于 Lambda 表达式的另一条规则在第 8 章中——“SE.28”：使用 Lambda 表达式进行复杂的初始化（尤其是对 const 变量）。</p><p>我在本章中跳过了 C++20 特性 std::span。我会在第 7 章中提供关于 std::span 的基本信息。</p><hr><p><strong>本章精华</strong></p><p><strong>重要</strong></p><ul><li>一个函数应该执行一个操作，要简短，并有一个精心选择的名字。</li><li>要把可以在编译期运行的函数实现为 constexpr。</li><li>如果可能的话，将你的函数实现为纯函数。</li><li>区分一个函数的入、入/出和出参。对入参使用按值传递或按 const 引用传递，对入/出参使用按引用传递，对出参使用按值传递。</li><li>向函数传递参数涉及所有权语义的问题。按值传递使函数称为资源的独立所有者。按指针或引用传递意味着函数只是借用了该资源。std::unique_ptr 将所有权转移给函数，std::shared_ptr 则使函数称为共享的所有者。</li><li>当你的函数需要接受任意数量的参数时，要使用变参模板而不是 va_arg 参数。</li></ul><h2 id="类和类的层次结构"><a href="#类和类的层次结构" class="headerlink" title="类和类的层次结构"></a>类和类的层次结构</h2><p>类是一种用户定义类型，程序员可以为其指定表示方法、操作和接口。类的层次结构被用来组织相关的结构。</p><p>C++ Core Guidelines 中大约有100条关于用户定义类型的规则。</p><p>Guidelines 先给出了一些概要规则，然后深入讨论了下面的特殊规则：</p><ul><li>具体类型</li><li>构造函数、赋值和析构函数</li><li>类的层次结构</li><li>重载和运算符重载</li><li>联合体</li></ul><p>下面的 8 条概要规则为特殊规则提供了背景。</p><h3 id="5-1-概要规则"><a href="#5-1-概要规则" class="headerlink" title="5.1 概要规则"></a>5.1 概要规则</h3><p>概要规则相当简短，没有涉及太多细节。它们对类概括提供了有价值的深刻见解。</p><blockquote><p><strong>class（类）和struct（结构体）之间的语法差异</strong> 本节经常提到类和结构体之间的语义区别。首先。语法上的差异是什么？差异很小，但很重要： - 在结构体中，所有成员默认为 public（公开）；类为（private）私有。 - 继承情况也是如此。结构体默认继承权限为 public，类为 private。</p></blockquote><p><strong>除此之外，二者在语言语法层面完全一致</strong>。</p><h3 id="C-1-把相关的数据组织到结构（struct-或-class）中"><a href="#C-1-把相关的数据组织到结构（struct-或-class）中" class="headerlink" title="C.1 把相关的数据组织到结构（struct 或 class）中"></a>C.1 把相关的数据组织到结构（struct 或 class）中</h3><p>如何改进 draw 的接口？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token keyword">int</span> fromX<span class="token punctuation">,</span> <span class="token keyword">int</span> fromY<span class="token punctuation">,</span> <span class="token keyword">int</span> toX<span class="token punctuation">,</span> <span class="token keyword">int</span> toY<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不明显的是，这些 int 代表了什么。因此，调用函数的时候参数顺序可能会出错。可以对比一下上面的 draw 和下面的新函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span>Point from<span class="token punctuation">,</span> Point to<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过将相关元素放在结构体中，函数签名变得可以自我描述，因此，比起之前的函数，新函数更不容易出错。</p><blockquote><p>类对象的构造函数也可以用来检测参数的合法性，不过这里的 Point 类型倒是没啥好检测的了。</p></blockquote><h3 id="C-2-当类具有不变式时使用-class；如果数据成员可以独立变化，则使用-struct"><a href="#C-2-当类具有不变式时使用-class；如果数据成员可以独立变化，则使用-struct" class="headerlink" title="C.2 当类具有不变式时使用 class；如果数据成员可以独立变化，则使用 struct"></a>C.2 当类具有不变式时使用 class；如果数据成员可以独立变化，则使用 struct</h3><blockquote><p>不变式（Invariant）是一个在程序执行过程中永远保持成立的条件。不变式在检测程序是否正确方面非常有用。例如编译器优化就用到了不变式。</p></blockquote><p>类的不变式是用于约束类的实例的不变式。成员函数必须使这个不变式保持成立。 不变式约束了类的实例的可能取值。</p><p>这是 C++ 中一个常见的问题：<em>什么时候该使用 class，什么时候该用 struct？</em></p><p>C++ Core Guidelines 给出了以下建议。<strong>如果类有不变式，就使用 class</strong>。</p><blockquote><p><strong>如果类有一个需要在程序执行过程中永远保持成立的条件，就使用 class</strong>。</p></blockquote><p>一个可能的类的不变式是，（y，m，d）可表示一个有效的日期。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Pair<span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//成员可以独立变化</span>    string name<span class="token punctuation">;</span>    <span class="token keyword">int</span> volume<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//校验 {yy，mm，dd}是不是合法的日期并进行初始化</span>    <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> yy<span class="token punctuation">,</span> Month mm<span class="token punctuation">,</span> <span class="token keyword">char</span> dd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span>    Month m<span class="token punctuation">;</span>    <span class="token keyword">char</span> d<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//日</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类的不变式在构造函数中被初始化和检查。数据类型 Pair 没有不变式，因为名称（name）和体积（volume）的所有值都是有效的。Pair 是简单的数据持有者，不需要显式提供构造函数。</p><blockquote><p>值得一提的是，很多库并没有很好的遵守，我们举例 <a href="https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qpoint.html">QPoint</a>，<a href="https://link.zhihu.com/?target=https%3A//codebrowser.dev/qt5/qtbase/src/corelib/tools/qpoint.h.html">源码</a>。</p></blockquote><p>QPoint 显然是没有不变式，它的成员（xp，yp）所有的值都是有效的，但它依旧使用的是 class。 以及，它没有将它的数据成员设置为 public，反而提供了愚蠢的 6 个成员函数进行访问：<code>rx，ry，x，y，setX，setY</code>。</p><h3 id="C-3-在类中体现出接口和实现之间的区别"><a href="#C-3-在类中体现出接口和实现之间的区别" class="headerlink" title="C.3 在类中体现出接口和实现之间的区别"></a>C.3 在类中体现出接口和实现之间的区别</h3><p>类的公开成员函数是类的接口，私有部分则是实现。</p><pre class="line-numbers language-cpp"><code class="language-cpp">类的公开成员函数是类的接口，私有部分则是实现。<span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//校验 {yy，mm，dd}是不是合法的日期并进行初始化</span>    <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> yy<span class="token punctuation">,</span> Month mm<span class="token punctuation">,</span> <span class="token keyword">char</span> dd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">day</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>    Month <span class="token function">month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// ... 具体的内部表示</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从可维护性的角度看，可以修改 Date 类的实现，而毫不影响该类的使用者。</p><blockquote><p>就是说面向对象的<strong>封装</strong>，数据和操作数据的方法（即类的接口）捆绑在一起，并对外部隐藏对象的内部状态。这样可以确保类的接口有效性和不变性。</p></blockquote><h3 id="C-4-仅当函数需要直接访问类的内部表示时，才把它变成成员"><a href="#C-4-仅当函数需要直接访问类的内部表示时，才把它变成成员" class="headerlink" title="C.4 仅当函数需要直接访问类的内部表示时，才把它变成成员"></a>C.4 仅当函数需要直接访问类的内部表示时，才把它变成成员</h3><p>如果一个函数不需要访问类的内部结构，它就不应该是成员。这样的话，你会得到松耦合，而且类的内部结构的改变不会影响辅助函数。</p><blockquote><p>一个函数不修改类的私有数据成员，它就不该是成员</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ... 相对小的接口 ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//辅助函数</span>Date <span class="token function">next_weekday</span><span class="token punctuation">(</span>Date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span> <span class="token punctuation">(</span>Date<span class="token punctuation">,</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运算符 <code>=</code>、<code>()</code>、<code>[]</code>、<code>-&gt;</code> 必须是类的成员。</p><blockquote><p>事实上这条规则没那么好遵守，有非常多的额外情况，英文原书和我们当前描写的都太少了。可以看<a href="https://link.zhihu.com/?target=https%3A//github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md%23c4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class">英文文档</a>，或<a href="https://link.zhihu.com/?target=https%3A//github.com/lynnboy/CppCoreGuidelines-zh-CN/blob/master/CppCoreGuidelines-zh-CN.md%23c4-%E4%BB%85%E5%BD%93%E5%87%BD%E6%95%B0%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E8%A1%A8%E7%A4%BA%E6%97%B6%E6%89%8D%E8%AE%A9%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%85%B6%E6%88%90%E5%91%98">国人翻译</a>。</p></blockquote><h3 id="C-5-将辅助函数与它们支持的类放在同一个命名空间中"><a href="#C-5-将辅助函数与它们支持的类放在同一个命名空间中" class="headerlink" title="C.5 将辅助函数与它们支持的类放在同一个命名空间中"></a>C.5 将辅助函数与它们支持的类放在同一个命名空间中</h3><p>辅助函数应该在类的命名空间中，因为它是类的接口的一部分。与成员函数相反，辅助函数不需要直接访问类的内部表示。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> Chrono<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 在这里放置跟时间有关的服务</span>    <span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 辅助函数：</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span> <span class="token punctuation">(</span>Date<span class="token punctuation">,</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span>    Date <span class="token function">next_weekday</span><span class="token punctuation">(</span>Date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>date1 <span class="token operator">==</span> date2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//（1）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于有<a href="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/adl">实参依赖查找</a>（argument-dependent lookup，ADL），比较 date1 == date2 将额外查找 Chrono 命名空间中的相等运算符。ADL 对于重载的运算符尤其重要，如输出运算符&lt;&lt;。</p><h3 id="C-7-不要在一条语句里定义类或枚举的同时声明该类型的变量"><a href="#C-7-不要在一条语句里定义类或枚举的同时声明该类型的变量" class="headerlink" title="C.7 不要在一条语句里定义类或枚举的同时声明该类型的变量"></a>C.7 不要在一条语句里定义类或枚举的同时声明该类型的变量</h3><p>若在一条语句里定义类或枚举并同时声明其他类型的变量，会引起混淆，因此应该避免。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 不好</span><span class="token keyword">struct</span> Date <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span> date <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 好</span><span class="token keyword">struct</span> Date<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Date date<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C-8-如果有任何非公开成员，就使用-class-而不是-struct"><a href="#C-8-如果有任何非公开成员，就使用-class-而不是-struct" class="headerlink" title="C.8 如果有任何非公开成员，就使用 class 而不是 struct"></a>C.8 如果有任何非公开成员，就使用 class 而不是 struct</h3><p>明确某事被隐藏/抽象。这是一个有用的约定。</p><blockquote><p>除此之外可能还有很多乱七八糟的理由，但总而言之，就是这样，<strong>约定</strong>。</p></blockquote><h3 id="C-9-尽量减少成员的暴露"><a href="#C-9-尽量减少成员的暴露" class="headerlink" title="C.9 尽量减少成员的暴露"></a>C.9 尽量减少成员的暴露</h3><p>数据隐藏和<strong>封装</strong>是面向对象类设计的基石之一：你将类中的成员封装起来，只允许通过公共成员函数进行访问。你的类可能有两种接口：一种是用于外部的 public 接口，一种是用于派生类的 protected 接口。其余成员都应该属于 private。</p><blockquote><p>封装。信息隐藏。最大限度地减少意外访问的机会。这简化了维护。 需要注意的是，也不要什么成员都给封装了，这样会走上 java 的邪路，<code>get</code>、<code>set</code> …</p></blockquote><h3 id="5-2-具体类型"><a href="#5-2-具体类型" class="headerlink" title="5.2 具体类型"></a>5.2 具体类型</h3><p>本节只有两条规则，但引入了具体类型和规范类型这两个术语。 根据 C++ Core Guidelines：</p><p><strong>具体类型是“最简单的一种类”</strong>。它常常被称作值类型，不属于某个类型层次结构的一部分 。</p><p><strong>规范类型是一种“行为类似于 int”的类型</strong>，因此，它必须支持拷贝和赋值、相等比较，以及可交换。更正式的说法是，一个规范类型 X 行为上像 int，支持下列操作。</p><ul><li>默认构造：X()</li><li>拷贝构造：X(const X&amp;)</li><li>拷贝赋值：operator = (const X&amp;)</li><li>移动构造：X(X&amp;&amp;)</li><li>移动赋值：operator = (X&amp;&amp;)</li><li>析构：~X()</li><li>交换操作：swap(X&amp;, X&amp;)</li><li>相等运算符：operator ==(const X&amp;, const X&amp;)</li></ul><h3 id="C-10-优先使用具体类型而不是类层次结构"><a href="#C-10-优先使用具体类型而不是类层次结构" class="headerlink" title="C.10 优先使用具体类型而不是类层次结构"></a>C.10 优先使用具体类型而不是类层次结构</h3><p>如果没有需要类层次结构的用例，就使用具体类型。具体的类型更容易实现，更小，且更快。不必担心继承、虚性、引用或指针，包括内存分配和释放。不会有虚派发，因此也没有运行期开销。</p><p>长话短说：应用 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/KISS_principle">KISS</a> 原则（“keep it simple,stupid”原则，保持简单，让傻瓜都能理解）。你的类型行为像普通数值一样。</p><h3 id="C-11-让具体类型规范化"><a href="#C-11-让具体类型规范化" class="headerlink" title="C.11 让具体类型规范化"></a>C.11 让具体类型规范化</h3><p>规范类型（如 int）易于理解，它们本身就很直观。这意味着：</p><ul><li>如果你有一个具体类型，可以考虑将它升级为规范类型。</li></ul><p>内置类型（如 int 或 double）是规范类型，而用户定义类型（如 std::string）或容器（std::vector 或 std::unordered_map）也是如此。</p><p>C++20 支持 regular （规范）概念。</p><h3 id="5-3-构造函数、赋值运算符和析构函数"><a href="#5-3-构造函数、赋值运算符和析构函数" class="headerlink" title="5.3 构造函数、赋值运算符和析构函数"></a>5.3 构造函数、赋值运算符和析构函数</h3><p>这一节讨论构造函数、赋值运算符和析构函数，在本章范围内，此类规则的数量是目前为止最多的。它们控制着对象的生命周期：创建、拷贝、移动和销毁。简而言之，我们把它们称为“六大”。下面是这六个特殊的成员函数。</p><ul><li>默认构造函数：X()</li><li>拷贝构造函数：X(const X&amp;)</li><li>拷贝赋值运算符：operator = (const X&amp;)</li><li>移动构造：X(X&amp;&amp;)</li><li>移动赋值运算符：operator = (X&amp;&amp;)</li><li>析构函数：~X()</li></ul><p>编译器可以为这“六大”生成默认实现。本节从有关默认操作的规则开始；接着是有关构造函数、拷贝和移动操作以及析构函数的规则；最后是不属于前四类的其他默认操作的规则。</p><p>根据默认构造函数的声明，你可能有这样的印象：默认构造函数不需要参数。这是不对的。默认构造函数可以在没有参数的情况下被调用，但它可能每个参数都有默认值。</p><h3 id="预置操作"><a href="#预置操作" class="headerlink" title="预置操作"></a>预置操作</h3><p>默认情况下，如果需要，编译器可以生成“六大”。可以定义这六个特殊的成员函数，但也可明确用 = default（预置）来要求编译器提供它们，或者用 = delete（弃置）来删除它们。</p><h3 id="C-20-如果能避免定义默认操作，那么就这么做"><a href="#C-20-如果能避免定义默认操作，那么就这么做" class="headerlink" title="C.20 如果能避免定义默认操作，那么就这么做"></a>C.20 如果能避免定义默认操作，那么就这么做</h3><p>这一规则也被称为“零法则”。这意味着你可以通过使用有合适的拷贝/移动语义的类型，来避免自行编写构造函数、拷贝/移动构造函数、赋值运算符或析构函数。有合适的拷贝/移动语义的类型包括规范类型，如内置类型 bool 或 double，也包括标准模板库（STL）的容器，如 std::vector 或 std::string。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Named_map</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// ... 没有声明任何默认操作 ...</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>    std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> rep<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Named_map mm<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 默认构造</span>Named_map nm2 <span class="token punctuation">{</span>nm<span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 拷贝构造</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认构造和拷贝构造之所以有效，是因为 std::string 和 std::map 已经定义了相应的操作。</p><ul><li><strong>编译器所自动生成的拷贝构造函数会调用当前类所有成员的拷贝构造函数</strong>。</li></ul><blockquote><p>特殊成员函数都是这样，不局限于拷贝构造，这个其实以前在 <strong><a href="https://zhuanlan.zhihu.com/p/662592729/第2章-理念.md">P.9</a></strong> 提起过。（另外强调一下，这些话全说的是类类型）</p></blockquote><h3 id="C-21-如果定义或-delete-了任何默认操作，就对所有默认操作进行定义或-delete"><a href="#C-21-如果定义或-delete-了任何默认操作，就对所有默认操作进行定义或-delete" class="headerlink" title="C.21 如果定义或 =delete 了任何默认操作，就对所有默认操作进行定义或 =delete"></a>C.21 如果定义或 =delete 了任何默认操作，就对所有默认操作进行定义或 =delete</h3><p>“六大”是紧密相关的。由于这种关系，你应该对所有特殊成员函数进行定义或 =delete。因此，这条规则被称为“六法则”。有时你会听到“五法则”，这是因为默认构造函数很特殊，有时会被排除在外</p><ul><li><em>当你定义*</em>任何构造函数*<em>时，默认构造函数就没有了。默认构造函数是可以在没有参数的情况下调用的构造函数</em>。</li><li><em>当你用 =default 或 =delete 定义或删除*</em>默认构造函数*<em>时，其他特殊成员函数都不受影响</em>。</li><li>当你用 =default 或 =delete 定义或删除<strong>析构函数</strong>、<strong>拷贝构造函数</strong>或<strong>拷贝赋值操作符</strong>时，编译器不会生成移动构造函数和移动赋值运算符。这意味着移动构造或移动赋值这样的移动操作会回退到拷贝构造或拷贝赋值。这种回退的自动操作在表格中以深色标出。</li><li>当用 =default 或 =delete 定义或删除<strong>移动构造函数</strong>或<strong>移动赋值运算符</strong>时，只能得到定义的 =default 或 =delete 的移动构造函数或移动赋值运算符。<strong>后果是，拷贝构造函数和拷贝赋值运算符被设置为 =delete[^2]</strong>。因此调用一个拷贝操作，如拷贝构造或拷贝赋值，将导致编译错误。</li></ul><p>当你不遵循这条规则时，你会得到非常不直观的对象。下面是 Guidelines 中的一个直观的例子。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstddef></span></span><span class="token keyword">class</span> <span class="token class-name">BitArray</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">BitArray</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t len<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">len_</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">data_</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">BitArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>size_t len_<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> data_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    BitArray <span class="token function">bitArray1</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    BitArray <span class="token function">bitArray2</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bitArray2 <span class="token operator">=</span> bitArray1<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//（1）</span><span class="token punctuation">}</span>                               <span class="token comment" spellcheck="true">//（2）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么这个程序有未定义行为？例子中默认的拷贝赋值操作 bitArray2 = bitArray1（1）拷贝了 bigArray2 的所有成员。拷贝意味着，在目前情况下，被拷贝的是 data 指针，而不是其指向的数据。因此，bigArray1 和 bigArray2 的析构函数被调用（2），由于<strong>重复释放</strong>，我们得到了未定义行为。</p><p>这个例子中不直观的行为是，编译器生成的 BigArray 的拷贝赋值操作符对 BigArray 进行了浅拷贝，但是 BigArray 的显式实现的析构函数假设了数据的所有权。</p><p><a href="https://link.zhihu.com/?target=https%3A//godbolt.org/z/5qzoz6qx3">运行效果</a>：</p><pre class="line-numbers language-text"><code class="language-text">double free or corruption (!prev)Program terminated with signal: SIGSEGV<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章实际上是&lt;a href=&quot;https://zhuanlan.zhihu.com/p/662592729&quot;&gt;C++ Core Guid
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>git如何更新新的个人令牌Tokens</title>
    <link href="https://joytsing.github.io/posts/21341/"/>
    <id>https://joytsing.github.io/posts/21341/</id>
    <published>2023-10-09T08:45:38.000Z</published>
    <updated>2023-10-09T08:59:49.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2021年8月13日开始，GitHub在使用Git操作远程仓库时不再支持使用用户名密码形式进行身份验证，需使用个人访问令牌。<br>使用Git操作GitHub仓库时使用用户名密码进行身份验证会报错：</p><p><img src="/posts/21341/9b5b233bb4d94a83aa1a4465e5755bec.png" alt></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用token登录的方式，就是把你的密码替换成token即可</p><h3 id="1、创建自己的token"><a href="#1、创建自己的token" class="headerlink" title="1、创建自己的token"></a>1、创建自己的token</h3><p><strong>1.1、登录GitHub，在GitHub右上角点击个人资料头像，点击settings</strong><br><img src="/posts/21341/90c2a62d20bc4065a161b7f5a94e60f9.png" alt><br><strong>1.2、新打开的窗口，左边栏点击选择 Developer settings（开发人员设置）</strong><br><img src="/posts/21341/f4e699246d294cad8a5f6cd300295e09.png" alt><br><strong>1.3、点击Personal access tokens （个人访问令牌）</strong><br>点击Personal access tokens ，选择Tokens(classic)即可，然后点击【Generate new token】（设置新的访问令牌）<br>注意：点击【Generate new token】此处还是有两个选项，选择【Tokens(classic)】<br><img src="/posts/21341/cf8b484f25654d4897453669eec60593.png" alt><br><strong>1.4、添加令牌描述信息（Note），过期时间（Expiration）、作用域（Select scopes）等</strong><br><strong>注意</strong>::作用域，一般勾选<code>repo</code>和<code>delet_repo</code>即可，其他权限，看个人需求。<br>repo：要使用token从命令行访问仓库<br>delete_repo：要使用token从命令行删除仓库<br><img src="/posts/21341/aec0732ccbc94e469d1c24aff707c3f4.png" alt><br><strong>repo</strong><br><img src="/posts/21341/ebcce4033edb4ae98b31c936e4a9f18a.png" alt><br><strong>delete_repo</strong><br><img src="/posts/21341/c60e1d166cfc4ec3ab63de9165af4f97.png" alt><br><strong>1.5、点击【generate token】生成令牌。</strong><br><img src="/posts/21341/c2b8f96c42ce4eac9da3bb7c1ab1371b.png" alt><br><strong>1.6、生成令牌，需要复制并保存好令牌</strong></p><blockquote><p>注意：Github为了安全，<code>关闭页面后将不能再次看到生成的令牌</code>，一定要记得保存令牌。</p></blockquote><p><img src="/posts/21341/935409e69d1b47b9a1d388171980f8b5.png" alt></p><h3 id="2、使用token-classic"><a href="#2、使用token-classic" class="headerlink" title="2、使用token(classic)"></a>2、使用token(classic)</h3><p>使用Git操作GitHub仓库时使用token进行身份验证<br>使用令牌 正常连接github会给你调起登录框 密码框中不在输入密码输入令牌即可</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit -m <span class="token string">" "</span><span class="token function">git</span> push orgin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/posts/21341/dbe5f0f624044205a9b9beca6e34eb0b.png" alt><br><img src="/posts/21341/eefc7a46048b4f529f0aea7ba4c28628.png" alt></p><h3 id="3、使用token-方法二"><a href="#3、使用token-方法二" class="headerlink" title="3、使用token(方法二)"></a>3、使用token(方法二)</h3><p><strong>修改现有项目的url</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> remote set-url origin  https://<span class="token operator">&lt;</span>your_token<span class="token operator">></span>@github.com/<span class="token operator">&lt;</span>USERNAME<span class="token operator">></span>/<span class="token operator">&lt;</span>REPO<span class="token operator">></span>.git将<span class="token operator">&lt;</span>your_token<span class="token operator">></span>换成你自己得到的令牌。<span class="token operator">&lt;</span>USERNAME<span class="token operator">></span>是你自己github的用户名，<span class="token operator">&lt;</span>REPO<span class="token operator">></span>是你的项目名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>比如：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> remote set-url origin  https://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@github.com/nlp-greyfoss/typora_notes.git/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其实上面的报错中就有提示，不需要重新去找：</p><p><strong>fatal: unable to access ‘<a href="https://github.com//.git’；">https://github.com//.git’；</a></strong></p><pre><code>//正确格式：https://你的令牌@github.com/&lt;USERNAME&gt;/&lt;REPO&gt;.git</code></pre><p>然后再执行git pull，世界又恢复原样了。</p><p><strong>从Github下载到本地</strong><br>对于全新版本，克隆的时候也在github.com前面加个令牌就好了。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone https://<span class="token operator">&lt;</span>TOKEN<span class="token operator">></span>@github.com/<span class="token operator">&lt;</span>user_name<span class="token operator">></span>/<span class="token operator">&lt;</span>repo_name<span class="token operator">></span>.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="更新Tokens"><a href="#更新Tokens" class="headerlink" title="更新Tokens"></a>更新Tokens</h2><p>因为token的有效期一般就三个月，如果过期了的话需要重新生成，具体操作的话，需要先去github，实际上就是换了个新的token:</p><blockquote><p>生成token：<br>settings -&gt; developer settings -&gt; personal access tokens -&gt; generate new token</p></blockquote><p><strong>注意！:　务必保存一下token的值</strong></p><p>下面是在git上需要替换token的方法。</p><ol><li>git remote -v 查看remote分支</li></ol><pre class="line-numbers language-shell"><code class="language-shell">[wqj@VM-0-15-centos Linux]$ git remote -vorigin    https://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@github.com/wuqiongjin/Linux.git/ (fetch)origin    https://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@github.com/wuqiongjin/Linux.git/ (push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>中间的<code>ghp_.....</code>到@之前，是过期的token。</p><ol start="2"><li>我们需要删除这个token</li></ol><pre class="line-numbers language-shell"><code class="language-shell">git remote rm origin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>添加新的token，也就是方法二的</li></ol><pre class="line-numbers language-shell"><code class="language-shell">git remote add origin https://新的token@github.com/账号名称/仓库名字.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就大功告成了! 下次push的时候需要使用<code>git push --set-upstream origin main</code>，如果还有报错类似下面这种：</p><pre class="line-numbers language-shell"><code class="language-shell">fatal: unable to access 'https://github.com********/': OpenSSL SSL_read: Connection was aborted, errno 10053<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要再执行</p><pre class="line-numbers language-shell"><code class="language-shell">git config --global http.sslVerify "false"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_44341110/article/details/120510816">Git使用个人访问令牌提交代码到仓库</a><br><a href="https://blog.csdn.net/wxbug/article/details/126808354">使用git上传代码遇到关于remote: Support for password authentication was removed on August 13, 2021.的问题</a><br><a href="https://blog.csdn.net/u014090429/article/details/126509415">github token个人令牌</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2021年8月13日开始，GitHub在使用Git操作远程仓库时不再支持使用用户名密码形式进行身份验证，需使用个人访问令牌。&lt;br&gt;使用Gi
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX学习资源</title>
    <link href="https://joytsing.github.io/posts/25965/"/>
    <id>https://joytsing.github.io/posts/25965/</id>
    <published>2023-09-26T07:39:08.000Z</published>
    <updated>2023-09-26T07:41:07.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="入门必读书"><a href="#入门必读书" class="headerlink" title="入门必读书"></a>入门必读书</h2><h3 id="中文入门资料"><a href="#中文入门资料" class="headerlink" title="中文入门资料"></a>中文入门资料</h3><ul><li><p>一份不太简短的 LaTeX2ε 介绍【中文资料】（<a href="http://mirrors.ctan.org/info/lshort/chinese/lshort-zh-cn.pdf">lshort中文版</a>）</p></li><li><p>LaTeX Notes 雷太赫排版系统简介, 包太雷, 2019【中文资料】 （<a href="http://static.latexstudio.net/article/2019/0504/lnotes-master.zip">LaTeX 笔记 v2.56 (PDF 含源码 )</a>）</p></li><li><p>简单粗暴 LaTeX（点击这里下载：<a href="http://www.latexstudio.net/archives/10541.html">http://www.latexstudio.net/archives/10541.html</a>）</p></li><li><p>《LaTeX 入门》 刘海洋, 2013年, 电子工业出版社【中文纸质书籍】<a href="http://www.broadview.com.cn/book/1461">博文视点</a>，适合入门，但要跳着看。</p></li><li><p>LaTeX2e 完全学习手册 (第二版), 胡伟编著, 清华大学出版社, 2013.【中文纸质书籍】 <a href="http://www.tup.tsinghua.edu.cn/booksCenter/book_04015501.html">清华介绍</a>，适合查阅，可以翻着看。</p></li><li><p><a href="http://www.tup.tsinghua.edu.cn/booksCenter/book_07231501.html">LaTeX2e 文类和宏包学习手册</a>，编写 LaTeX2e 宏的用户可翻阅，一部解说 LaTeX 文类和宏包文件编写方法，将 LaTeX 命令集中注释的工具书。</p></li></ul><h3 id="英文入门资料"><a href="#英文入门资料" class="headerlink" title="英文入门资料"></a>英文入门资料</h3><ul><li><p>LaTeX for Complete Novices【英文资料】（<a href="http://www.dickimaw-books.com/latex/novices/novices-report.pdf">pdf</a>, <a href="http://www.dickimaw-books.com/latex/novices/novices-1_4.zip">源代码</a>, <a href="http://www.dickimaw-books.com/latex/novices/">http://www.dickimaw-books.com/latex/novices/</a>）</p></li><li><p>The LaTeX Companion (2nd), M. Goosens 等, 2004. 【英文纸质书籍】</p></li></ul><h2 id="插图使用"><a href="#插图使用" class="headerlink" title="插图使用"></a>插图使用</h2><ul><li>《LaTeX2e 插图指南》中译本第三版，点击<a href="http://www.latexstudio.net/archives/10738">这里</a>下载。</li></ul><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><ul><li><p><a href="http://www.latexstudio.net/wp-content/uploads/2013/10/Higher-Mathematics-ch8.pdf">Higher-Mathematics-ch8.pdf</a>，The LaTeX Companion (2nd)第八章的内容。简短实用！</p></li><li><p><a href="http://www.latexstudio.net/archives/7395">More Math Into LaTeX</a> (5th), G. Gratzer, 2016.</p></li><li><p><a href="http://www.biwako.shiga-u.ac.jp/sensei/kumazawa/texindex3.html#formula">较全面的 LaTeX 各种数学字体、公式展示和源码</a></p></li></ul><h2 id="符号输入"><a href="#符号输入" class="headerlink" title="符号输入"></a>符号输入</h2><ul><li><p><a href="http://mirrors.ctan.org/info/symbols/comprehensive/symbols-a4.pdf">The Comprehensive LaTeX Symbol List</a>，LaTeX 符号大全，可在命令行中输入：texdoc  symbols-a4</p></li><li><p>手写识别 LaTeX 符号网站，点击<a href="http://detexify.kirelabs.org/classify.html">这里</a></p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="http://www.cs.stir.ac.uk/~kjt/software/latex/showbst.html">http://www.cs.stir.ac.uk/~kjt/software/latex/showbst.html</a> 各种bst类型样例，可以到这里查找。</p></li><li><p>黄正华简易学习 BiBTeX  <a href="http://aff.whu.edu.cn/huangzh/bibTeX%E7%94%9F%E6%88%90%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE.pdf">如何用 BibTeX 生成参考文献</a></p></li></ul><h2 id="PGF-绘图资源"><a href="#PGF-绘图资源" class="headerlink" title="PGF 绘图资源"></a>PGF 绘图资源</h2><p>简易入门中文资料  </p><ul><li><p><a href="http://www.latexstudio.net/archives/1398.html">PGF/TikZ 绘图学习笔记</a> </p></li><li><p><a href="http://www.latexstudio.net/archives/51577.html">[LaTeX 绘图指南 - 001] TikZ 的简介、资源以及学习方法</a></p></li><li><p><a href="http://www.latexstudio.net/archives/11825.html">TiKZ 学习笔记</a></p></li></ul><p>官网学习资料-英文：<a href="http://www.texdoc.net/texmf-dist/doc/generic/pgf/pgfmanual.pdf">pgfmanual.pdf</a> </p><h2 id="演示文稿"><a href="#演示文稿" class="headerlink" title="演示文稿"></a><a href="http://aff.whu.edu.cn/huangzh/bibTeX%E7%94%9F%E6%88%90%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE.pdf">演示文稿</a></h2><ul><li><p>本站整理的 beamer 主题：<a href="http://www.latexstudio.net/archives/category/tex-slides/beamer-theme-template">beamer-theme-template</a>  </p></li><li><p>beamer 主题样式墙：<a href="https://hartwork.org/beamer-theme-matrix">https://hartwork.org/beamer-theme-matrix</a> </p></li><li><p>模板合集（带汉化）：<a href="https://github.com/XiangyunHuang/awesome-beamers">https://github.com/XiangyunHuang/awesome-beamers</a>   </p></li></ul><h2 id="样例模板库"><a href="#样例模板库" class="headerlink" title="样例模板库"></a>样例模板库</h2><ul><li><p><a href="https://github.com/MartinThoma/LaTeX-examples/">MartinThoma’s LaTeX example</a> - GitHub 的大量好用的 LaTeX 例子文档.</p></li><li><p><a href="https://tex.stackexchange.com/questions/1319/showcase-of-beautiful-typography-done-in-tex-friends">showcase-of-beautiful-typography-done-in-tex-friends</a> 超级棒的排版样例.</p></li><li><p><a href="http://www.latextemplates.com/">http://www.latextemplates.com</a> – 各种模板 </p></li><li><p><a href="https://github.com/latexstudio/LaTeXPackages-CN">TeX 常用宏包中文翻译库</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;入门必读书&quot;&gt;&lt;a href=&quot;#入门必读书&quot; class=&quot;headerlink&quot; title=&quot;入门必读书&quot;&gt;&lt;/a&gt;入门必读书&lt;/h2&gt;&lt;h3 id=&quot;中文入门资料&quot;&gt;&lt;a href=&quot;#中文入门资料&quot; class=&quot;headerlink&quot; title=&quot;中
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="LaTeX" scheme="https://JoyTsing.github.io/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>STL容器速查</title>
    <link href="https://joytsing.github.io/posts/37537/"/>
    <id>https://joytsing.github.io/posts/37537/</id>
    <published>2023-09-26T07:34:14.000Z</published>
    <updated>2023-12-14T07:43:49.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容器（containers）"><a href="#容器（containers）" class="headerlink" title="容器（containers）"></a>容器（containers）</h1><h2 id="array"><a href="#array" class="headerlink" title="array"></a><a href="https://github.com/huihut/interview/tree/master/STL#array"></a>array</h2><p>array 是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>begin</td><td>返回指向数组容器中第一个元素的迭代器</td></tr><tr><td>end</td><td>返回指向数组容器中最后一个元素之后的理论元素的迭代器</td></tr><tr><td>rbegin</td><td>返回指向数组容器中最后一个元素的反向迭代器</td></tr><tr><td>rend</td><td>返回一个反向迭代器，指向数组中第一个元素之前的理论元素</td></tr><tr><td>cbegin</td><td>返回指向数组容器中第一个元素的常量迭代器（const_iterator）</td></tr><tr><td>cend</td><td>返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）</td></tr><tr><td>crbegin</td><td>返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</td></tr><tr><td>crend</td><td>返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）</td></tr><tr><td>size</td><td>返回数组容器中元素的数量</td></tr><tr><td>max_size</td><td>返回数组容器可容纳的最大元素数</td></tr><tr><td>empty</td><td>返回一个布尔值，指示数组容器是否为空</td></tr><tr><td>operator[]</td><td>返回容器中第 n（参数）个位置的元素的引用</td></tr><tr><td>at</td><td>返回容器中第 n（参数）个位置的元素的引用</td></tr><tr><td>front</td><td>返回对容器中第一个元素的引用</td></tr><tr><td>back</td><td>返回对容器中最后一个元素的引用</td></tr><tr><td>data</td><td>返回指向容器中第一个元素的指针</td></tr><tr><td>fill</td><td>用 val（参数）填充数组所有元素</td></tr><tr><td>swap</td><td>通过 x（参数）的内容交换数组的内容</td></tr><tr><td>get（array）</td><td>形如 <code>std::get&lt;0&gt;(myarray)</code>；传入一个数组容器，返回指定位置元素的引用</td></tr><tr><td>relational operators (array)</td><td>形如 <code>arrayA &gt; arrayB</code>；依此比较数组每个元素的大小关系</td></tr></tbody></table><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a><a href="https://github.com/huihut/interview/tree/master/STL#vector"></a>vector</h2><p>vector 是表示可以改变大小的数组的序列容器。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>vector</td><td>构造函数</td></tr><tr><td>~vector</td><td>析构函数，销毁容器对象</td></tr><tr><td>operator=</td><td>将新内容分配给容器，替换其当前内容，并相应地修改其大小</td></tr><tr><td>begin</td><td>返回指向容器中第一个元素的迭代器</td></tr><tr><td>end</td><td>返回指向容器中最后一个元素之后的理论元素的迭代器</td></tr><tr><td>rbegin</td><td>返回指向容器中最后一个元素的反向迭代器</td></tr><tr><td>rend</td><td>返回一个反向迭代器，指向中第一个元素之前的理论元素</td></tr><tr><td>cbegin</td><td>返回指向容器中第一个元素的常量迭代器（const_iterator）</td></tr><tr><td>cend</td><td>返回指向容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）</td></tr><tr><td>crbegin</td><td>返回指向容器中最后一个元素的常量反向迭代器（const_reverse_iterator）</td></tr><tr><td>crend</td><td>返回指向容器中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）</td></tr><tr><td>size</td><td>返回容器中元素的数量</td></tr><tr><td>max_size</td><td>返回容器可容纳的最大元素数</td></tr><tr><td>resize</td><td>调整容器的大小，使其包含 n（参数）个元素</td></tr><tr><td>capacity</td><td>返回当前为 vector 分配的存储空间（容量）的大小</td></tr><tr><td>empty</td><td>返回 vector 是否为空</td></tr><tr><td>reserve</td><td>请求 vector 容量至少足以包含 n（参数）个元素</td></tr><tr><td>shrink_to_fit</td><td>要求容器减小其 capacity（容量）以适应其 size（元素数量）</td></tr><tr><td>operator[]</td><td>返回容器中第 n（参数）个位置的元素的引用</td></tr><tr><td>at</td><td>返回容器中第 n（参数）个位置的元素的引用</td></tr><tr><td>front</td><td>返回对容器中第一个元素的引用</td></tr><tr><td>back</td><td>返回对容器中最后一个元素的引用</td></tr><tr><td>data</td><td>返回指向容器中第一个元素的指针</td></tr><tr><td>assign</td><td>将新内容分配给 vector，替换其当前内容，并相应地修改其 size</td></tr><tr><td>push_back</td><td>在容器的最后一个元素之后添加一个新元素</td></tr><tr><td>pop_back</td><td>删除容器中的最后一个元素，有效地将容器 size 减少一个</td></tr><tr><td>insert</td><td>通过在指定位置的元素之前插入新元素来扩展该容器，通过插入元素的数量有效地增加容器大小</td></tr><tr><td>erase</td><td>从 vector 中删除单个元素（<code>position</code>）或一系列元素（<code>[first，last)</code>），这有效地减少了被去除的元素的数量，从而破坏了容器的大小</td></tr><tr><td>swap</td><td>通过 x（参数）的内容交换容器的内容，x 是另一个类型相同、size 可能不同的 vector 对象</td></tr><tr><td>clear</td><td>从 vector 中删除所有的元素（被销毁），留下 size 为 0 的容器</td></tr><tr><td>emplace</td><td>通过在 position（参数）位置处插入新元素 args（参数）来扩展容器</td></tr><tr><td>emplace_back</td><td>在 vector 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</td></tr><tr><td>get_allocator</td><td>返回与vector关联的构造器对象的副本</td></tr><tr><td>swap(vector)</td><td>容器 x（参数）的内容与容器 y（参数）的内容交换。两个容器对象都必须是相同的类型（相同的模板参数），尽管大小可能不同</td></tr><tr><td>relational operators (vector)</td><td>形如 <code>vectorA &gt; vectorB</code>；依此比较每个元素的大小关系</td></tr></tbody></table><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a><a href="https://github.com/huihut/interview/tree/master/STL#deque"></a>deque</h2><p>deque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>deque</td><td>构造函数</td></tr><tr><td>push_back</td><td>在当前的最后一个元素之后 ，在 deque 容器的末尾添加一个新元素</td></tr><tr><td>push_front</td><td>在 deque 容器的开始位置插入一个新的元素，位于当前的第一个元素之前</td></tr><tr><td>pop_back</td><td>删除 deque 容器中的最后一个元素，有效地将容器大小减少一个</td></tr><tr><td>pop_front</td><td>删除 deque 容器中的第一个元素，有效地减小其大小</td></tr><tr><td>emplace_front</td><td>在 deque 的开头插入一个新的元素，就在其当前的第一个元素之前</td></tr><tr><td>emplace_back</td><td>在 deque 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后</td></tr></tbody></table><h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a><a href="https://github.com/huihut/interview/tree/master/STL#forward_list"></a>forward_list</h2><p>forward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>forward_list</td><td>返回指向容器中第一个元素之前的位置的迭代器</td></tr><tr><td>cbefore_begin</td><td>返回指向容器中第一个元素之前的位置的 const_iterator</td></tr></tbody></table><h2 id="list"><a href="#list" class="headerlink" title="list"></a><a href="https://github.com/huihut/interview/tree/master/STL#list"></a>list</h2><p>list，双向链表，是序列容器，允许在序列中的任何地方进行常数时间插入和擦除操作，并在两个方向上进行迭代。</p><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a><a href="https://github.com/huihut/interview/tree/master/STL#stack"></a>stack</h2><p>stack 是一种容器适配器，用于在LIFO（后进先出）的操作，其中元素仅从容器的一端插入和提取。</p><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a><a href="https://github.com/huihut/interview/tree/master/STL#queue"></a>queue</h2><p>queue 是一种容器适配器，用于在FIFO（先入先出）的操作，其中元素插入到容器的一端并从另一端提取。</p><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><a href="https://github.com/huihut/interview/tree/master/STL#priority_queue"></a>priority_queue</h2><h2 id="set"><a href="#set" class="headerlink" title="set"></a><a href="https://github.com/huihut/interview/tree/master/STL#set"></a>set</h2><p>set 是按照特定顺序存储唯一元素的容器。</p><h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a><a href="https://github.com/huihut/interview/tree/master/STL#multiset"></a>multiset</h2><h2 id="map"><a href="#map" class="headerlink" title="map"></a><a href="https://github.com/huihut/interview/tree/master/STL#map"></a>map</h2><p>map 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>map</td><td>构造函数</td></tr><tr><td>begin</td><td>返回引用容器中第一个元素的迭代器</td></tr><tr><td>key_comp</td><td>返回容器用于比较键的比较对象的副本</td></tr><tr><td>value_comp</td><td>返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前</td></tr><tr><td>find</td><td>在容器中搜索具有等于 k（参数）的键的元素，如果找到则返回一个迭代器，否则返回 map::end 的迭代器</td></tr><tr><td>count</td><td>在容器中搜索具有等于 k（参数）的键的元素，并返回匹配的数量</td></tr><tr><td>lower_bound</td><td>返回一个非递减序列 <code>[first, last)</code>（参数）中的第一个大于等于值 val（参数）的位置的迭代器</td></tr><tr><td>upper_bound</td><td>返回一个非递减序列 <code>[first, last)</code>（参数）中第一个大于 val（参数）的位置的迭代器</td></tr><tr><td>equal_range</td><td>获取相同元素的范围，返回包含容器中所有具有与 k（参数）等价的键的元素的范围边界（<code>pair&lt; map&lt;char,int&gt;::iterator, map&lt;char,int&gt;::iterator &gt;</code>）</td></tr></tbody></table><h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a><a href="https://github.com/huihut/interview/tree/master/STL#multimap"></a>multimap</h2><h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a><a href="https://github.com/huihut/interview/tree/master/STL#unordered_set"></a>unordered_set</h2><h2 id="unordered-multiset"><a href="#unordered-multiset" class="headerlink" title="unordered_multiset"></a><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multiset"></a>unordered_multiset</h2><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a><a href="https://github.com/huihut/interview/tree/master/STL#unordered_map"></a>unordered_map</h2><h2 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multimap"></a>unordered_multimap</h2><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a><a href="https://github.com/huihut/interview/tree/master/STL#tuple"></a>tuple</h2><p>元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。</p><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a><a href="https://github.com/huihut/interview/tree/master/STL#pair"></a>pair</h2><p>这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。</p><h1 id="算法（algorithms）"><a href="#算法（algorithms）" class="headerlink" title="算法（algorithms）"></a><a href="https://github.com/huihut/interview/tree/master/STL#%E7%AE%97%E6%B3%95algorithms"></a>算法（algorithms）</h1><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 简单查找算法，要求输入迭代器（input iterator）</span><span class="token function">find</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，指向输入序列中第一个等于 val 的元素，未找到返回 end</span><span class="token function">find_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，指向第一个满足 unaryPred 的元素，未找到返回 end</span><span class="token function">find_if_not</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，指向第一个令 unaryPred 为 false 的元素，未找到返回 end</span><span class="token function">count</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个计数器，指出 val 出现了多少次</span><span class="token function">count_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 统计有多少个元素满足 unaryPred</span><span class="token function">all_of</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 bool 值，判断是否所有元素都满足 unaryPred</span><span class="token function">any_of</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 bool 值，判断是否任意（存在）一个元素满足 unaryPred</span><span class="token function">none_of</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 bool 值，判断是否所有元素都不满足 unaryPred</span><span class="token comment" spellcheck="true">// 查找重复值的算法，传入向前迭代器（forward iterator）</span><span class="token function">adjacent_find</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end</span><span class="token function">adjacent_find</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 end</span><span class="token function">search_n</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> count<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end</span><span class="token function">search_n</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> count<span class="token punctuation">,</span> val<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end</span><span class="token comment" spellcheck="true">// 查找子序列算法，除 find_first_of（前两个输入迭代器，后两个前向迭代器） 外，都要求两个前向迭代器</span><span class="token function">search</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1</span><span class="token function">search</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1</span><span class="token function">find_first_of</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1</span><span class="token function">find_first_of</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1</span><span class="token function">find_end</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1</span><span class="token function">find_end</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1</span><span class="token comment" spellcheck="true">// 其他只读算法，传入输入迭代器</span><span class="token function">for_each</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryOp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对输入序列中的每个元素应用可调用对象 unaryOp，unaryOp 的返回值被忽略</span><span class="token function">mismatch</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素</span><span class="token function">mismatch</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素</span><span class="token function">equal</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 比较每个元素，确定两个序列是否相等。</span><span class="token function">equal</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 比较每个元素，确定两个序列是否相等。</span><span class="token comment" spellcheck="true">// 二分搜索算法，传入前向迭代器或随机访问迭代器（random-access iterator），要求序列中的元素已经是有序的。通过小于运算符（&lt;）或 comp 比较操作实现比较。</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 end</span><span class="token function">upper_bound</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</span><span class="token function">upper_bound</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 end</span><span class="token function">equal_range</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 pair，其 first 成员是 lower_bound 返回的迭代器，其 second 成员是 upper_bound 返回的迭代器</span><span class="token function">binary_search</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 bool 值，指出序列中是否包含等于 val 的元素。对于两个值 x 和 y，当 x 不小于 y 且 y 也不小于 x 时，认为它们相等。</span><span class="token comment" spellcheck="true">// 只写不读算法，要求输出迭代器（output iterator）</span><span class="token function">fill</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 val 赋予每个元素，返回 void</span><span class="token function">fill_n</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> cnt<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 val 赋予 cnt 个元素，返回指向写入到输出序列最有一个元素之后位置的迭代器</span><span class="token function">genetate</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> Gen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每次调用 Gen() 生成不同的值赋予每个序列，返回 void</span><span class="token function">genetate_n</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> cnt<span class="token punctuation">,</span> Gen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每次调用 Gen() 生成不同的值赋予 cnt 个序列，返回指向写入到输出序列最有一个元素之后位置的迭代器</span><span class="token comment" spellcheck="true">// 使用输入迭代器的写算法，读取一个输入序列，将值写入到一个输出序列（dest）中</span><span class="token function">copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从输入范围将元素拷贝所有元素到 dest 指定定的目的序列</span><span class="token function">copy_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从输入范围将元素拷贝满足 unaryPred 的元素到 dest 指定定的目的序列</span><span class="token function">copy_n</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> n<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从输入范围将元素拷贝前 n 个元素到 dest 指定定的目的序列</span><span class="token function">move</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对输入序列中的每个元素调用 std::move，将其移动到迭代器 dest 开始始的序列中</span><span class="token function">transform</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> unaryOp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用给定操作（一元操作），并将结果写到dest中</span><span class="token function">transform</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> binaryOp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用给定操作（二元操作），并将结果写到dest中</span><span class="token function">replace_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> old_val<span class="token punctuation">,</span> new_val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将每个元素拷贝到 dest，将等于 old_val 的的元素替换为 new_val</span><span class="token function">replace_copy_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> unaryPred<span class="token punctuation">,</span> new_val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将每个元素拷贝到 dest，将满足 unaryPred 的的元素替换为 new_val</span><span class="token function">merge</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 两个输入序列必须都是有序的，用 &lt; 运算符将合并后的序列写入到 dest 中</span><span class="token function">merge</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 两个输入序列必须都是有序的，使用给定的比较操作（comp）将合并后的序列写入到 dest 中</span><span class="token comment" spellcheck="true">// 使用前向迭代器的写算法，要求前向迭代器</span><span class="token function">iter_swap</span><span class="token punctuation">(</span>iter1<span class="token punctuation">,</span> iter2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 交换 iter1 和 iter2 所表示的元素，返回 void</span><span class="token function">swap_ranges</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将输入范围中所有元素与 beg2 开始的第二个序列中所有元素进行交换。返回递增后的的 beg2，指向最后一个交换元素之后的位置。</span><span class="token function">replace</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> old_val<span class="token punctuation">,</span> new_val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用 new_val 替换等于 old_val 的每个匹配元素</span><span class="token function">replace_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">,</span> new_val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用 new_val 替换满足 unaryPred 的每个匹配元素</span><span class="token comment" spellcheck="true">// 使用双向迭代器的写算法，要求双向选代器（bidirectional iterator）</span><span class="token function">copy_backward</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从输入范围中拷贝元素到指定目的位置。如果范围为空,则返回值为 dest；否则，返回值表示从 *beg 中拷贝或移动的元素。</span><span class="token function">move_backward</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 从输入范围中移动元素到指定目的位置。如果范围为空,则返回值为 dest；否则,返回值表示从 *beg 中拷贝或移动的元素。</span><span class="token function">inplace_merge</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用 &lt; 比较元素。</span><span class="token function">inplace_merge</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用给定的 comp 操作。</span><span class="token comment" spellcheck="true">// 划分算法，要求双向选代器（bidirectional iterator）</span><span class="token function">is_partitioned</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果所有满足谓词 unaryPred 的元素都在不满足 unarypred 的元素之前，则返回 true。若序列为空，也返回 true</span><span class="token function">partition_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest1<span class="token punctuation">,</span> dest2<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将满足 unaryPred 的元素拷贝到到 dest1，并将不满足 unaryPred 的元素拷贝到到 dest2。返回一个迭代器 pair，其 first 成员表示拷贝到 dest1 的的元素的末尾，second 表示拷贝到 dest2 的元素的末尾。</span><span class="token function">partitioned_point</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输入序列必须是已经用 unaryPred 划分过的。返回满足  unaryPred 的范围的尾后迭代器。如果返回的迭代器不是 end，则它指向的元素及其后的元素必须都不满足 unaryPred</span><span class="token function">stable_partition</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg</span><span class="token function">partition</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg</span><span class="token comment" spellcheck="true">// 排序算法，要求随机访问迭代器（random-access iterator）</span><span class="token function">sort</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序整个范围</span><span class="token function">stable_sort</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序整个范围（稳定排序）</span><span class="token function">sort</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序整个范围</span><span class="token function">stable_sort</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序整个范围（稳定排序）</span><span class="token function">is_sorted</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 bool 值，指出整个输入序列是否有序</span><span class="token function">is_sorted</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 bool 值，指出整个输入序列是否有序</span><span class="token function">is_sorted_until</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器</span><span class="token function">is_sorted_until</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器</span><span class="token function">partial_sort</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置</span><span class="token function">partial_sort</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置</span><span class="token function">partial_sort_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> destBeg<span class="token punctuation">,</span> destEnd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中</span><span class="token function">partial_sort_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> destBeg<span class="token punctuation">,</span> destEnd<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中</span><span class="token function">nth_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> nth<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它</span><span class="token function">nth_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> nth<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它</span><span class="token comment" spellcheck="true">// 使用前向迭代器的重排算法。普通版本在输入序列自身内部重拍元素，_copy 版本完成重拍后写入到指定目的序列中，而不改变输入序列</span><span class="token function">remove</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span><span class="token function">remove_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span><span class="token function">remove_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span><span class="token function">remove_copy_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> unaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器</span><span class="token function">unique</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span><span class="token function">unique</span> <span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span><span class="token function">unique_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span><span class="token function">unique_copy_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> binaryPred<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置</span><span class="token function">rotate</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素</span><span class="token function">rotate_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素</span><span class="token comment" spellcheck="true">// 使用双向迭代器的重排算法</span><span class="token function">reverse</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 翻转序列中的元素，返回 void</span><span class="token function">reverse_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 翻转序列中的元素，返回一个迭代器，指向拷贝到目的序列的元素的尾后位置</span><span class="token comment" spellcheck="true">// 使用随机访问迭代器的重排算法</span><span class="token function">random_shuffle</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 混洗输入序列中的元素，返回 void</span><span class="token function">random_shuffle</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> rand<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 混洗输入序列中的元素，rand 接受一个正整数的随机对象，返回 void</span><span class="token function">shuffle</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> Uniform_rand<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 混洗输入序列中的元素，Uniform_rand 必须满足均匀分布随机数生成器的要求，返回 void</span><span class="token comment" spellcheck="true">// 最小值和最大值，使用 &lt; 运算符或给定的比较操作 comp 进行比较</span><span class="token function">min</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> va12<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 val1 和 val2 中的最小值，两个实参的类型必须完全一致。参数和返回类型都是 const的引引用，意味着对象不会被拷贝。下略</span><span class="token function">min</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">min</span><span class="token punctuation">(</span>init_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">min</span><span class="token punctuation">(</span>init_list<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">max</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">max</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">max</span><span class="token punctuation">(</span>init_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">max</span><span class="token punctuation">(</span>init_list<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">minmax</span><span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 pair，其 first 成员为提供的值中的较小者，second 成员为较大者。下略</span><span class="token function">minmax</span><span class="token punctuation">(</span>vall<span class="token punctuation">,</span> val2<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">minmax</span><span class="token punctuation">(</span>init_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">minmax</span><span class="token punctuation">(</span>init_list<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">min_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指向输入序列中最小元素的迭代器</span><span class="token function">min_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指向输入序列中最小元素的迭代器</span><span class="token function">max_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指向输入序列中最大元素的迭代器</span><span class="token function">max_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回指向输入序列中最大元素的迭代器</span><span class="token function">minmax_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素</span><span class="token function">minmax_element</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素</span><span class="token comment" spellcheck="true">// 字典序比较，根据第一对不相等的元素的相对大小来返回结果。如果第一个序列在字典序中小于第二个序列，则返回 true。否则，返回 fa1se。如果个序列比另一个短，且所有元素都与较长序列的对应元素相等，则较短序列在字典序中更小。如果序列长度相等，且对应元素都相等，则在字典序中任何一个都不大于另外一个。</span><span class="token function">lexicographical_compare</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">lexicographical_compare</span><span class="token punctuation">(</span>beg1<span class="token punctuation">,</span> end1<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p><img src="/posts/37537/image-20230919203531494.png" alt><br><img src="/posts/37537/image-20230919203542561.png" alt></p><h2 id="迭代器算术"><a href="#迭代器算术" class="headerlink" title="迭代器算术"></a>迭代器算术</h2><p>迭代器本质是对象，但使用方法类似于指针<br><img src="/posts/37537/image-20230919203600724.png" alt><br><img src="/posts/37537/image-20230919203606111.png" alt><br><img src="/posts/37537/image-20230919203609563.png" alt><br>把同一个容器的两个迭代器配合使用，可以表示容器元素的一个连续子集。在数学上，迭代器it1和it2所表达的元素范围可以表示成[<strong>it1, it2</strong>) ，这是一个左闭右开的区间，它表示子集中的元素从it1所指向的元素（<strong>包含，左闭</strong>)开始，到it2所指向的元素结束，且<strong>不包含右开</strong>it2所指向的元素。：</p><ul><li>[it1, it2) 表示从A到L的全部元素，请注意it2是尾后迭代器，它指向L的后面一个“元素”。</li><li>[it3, it4) 表示从D到H的元素，即D、E、F、G、H共5个元素。请注意，it4所指向的元素I并未包含。</li><li>[it5, it6) 则表示从L到A的全部元素，请注意it5和it6都是反向迭代器，且it6指向“首前元素”。<br><img src="/posts/37537/image-20230919203947402.png" alt></li></ul><h2 id="容器元素的增加"><a href="#容器元素的增加" class="headerlink" title="容器元素的增加"></a>容器元素的增加</h2><p><img src="/posts/37537/image-20230919204045344.png" alt></p><p><img src="/posts/37537/image-20230919204150799.png" alt></p><h2 id="容器元素的删除"><a href="#容器元素的删除" class="headerlink" title="容器元素的删除"></a>容器元素的删除</h2><p><img src="/posts/37537/image-20230919204217090.png" alt></p><p><img src="/posts/37537/image-20230919204221561.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;容器（containers）&quot;&gt;&lt;a href=&quot;#容器（containers）&quot; class=&quot;headerlink&quot; title=&quot;容器（containers）&quot;&gt;&lt;/a&gt;容器（containers）&lt;/h1&gt;&lt;h2 id=&quot;array&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>EffectiveModernCpp:条款与实践</title>
    <link href="https://joytsing.github.io/posts/46568/"/>
    <id>https://joytsing.github.io/posts/46568/</id>
    <published>2023-09-26T07:25:53.000Z</published>
    <updated>2023-09-26T07:42:08.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章：类型推导"><a href="#第一章：类型推导" class="headerlink" title="第一章：类型推导"></a>第一章：类型推导</h2><h3 id="条款-1：理解模板类型推导"><a href="#条款-1：理解模板类型推导" class="headerlink" title="条款 1：理解模板类型推导"></a>条款 1：理解模板类型推导</h3><p>函数模板大致形如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在编译期，编译器会通过表达式推导出两个类型：一个是<code>T</code>的类型，另一个是<code>ParamType</code>的类型，这两个类型往往不一样，<code>ParamType</code>常包含一些饰词，如<code>const</code>或引用符号等限定词。</p><p><strong>情况 1：ParamType 是个指针或引用，但不是个万能引用</strong></p><ol><li>若表达式具有引用类型，则先将引用部分忽略。</li><li>对表达式的类型和<code>ParamType</code>进行匹配来决定<code>T</code>的类型。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int, paramType 为 const int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int, paramType 为 const int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若我们假定<code>param</code>具有常引用类型，则<code>T</code>的类型推导结果中也就没必要包含<code>const</code>了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 const int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 const int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果<code>param</code>是个指针（或指向 const 对象的指针）而非引用，运作方式本质上并无不同：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">*</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> px <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 int*</span><span class="token function">f</span><span class="token punctuation">(</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int, paramType 为 const int*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>情况 2：ParamType 是个万能引用</strong></p><blockquote><p>详细说明请参考<strong>条款 24</strong>。</p></blockquote><ol><li>如果表达式是个左值，则<code>T</code>和<code>ParamType</code>都会被推导为左值引用。</li><li>如果表达式是个右值，则遵循情况 1 中的规则。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 左值的情况</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 的类型为 int&amp;, paramType 为 int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int&amp;, paramType 为 const int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const int&amp;, paramType 为 const int&amp;</span><span class="token comment" spellcheck="true">// 右值的情况</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// T 的类型为 int, paramType 为 int&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>情况 3：ParamType 既非指针也非引用</strong></p><p>这种情况即为按值传递，无论传入的是什么，<code>param</code>都会是它的一个副本。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 和 param 的类型均为 int</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 和 param 的类型均为 int</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 和 param 的类型均为 int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是对于指向 const 对象的 const 指针的传递，仅有指针本身的常量性会被忽略：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr <span class="token operator">=</span> <span class="token string">"Fun with pointers"</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// T 和 param 的类型均为 const char*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>数组实参：</strong></p><p>按值传递给函数模板的数组类型将退化为指针类型，但按引用传递却能推导出真正的数组类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"J. P. Briggs"</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// T 的类型为 const char[13], paramType 为 const char (&amp;)[13]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用声明数组引用这一能力可以创造出一个模板，用来推导出数组含有的元素个数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t N<span class="token operator">></span><span class="token keyword">constexpr</span> std<span class="token operator">::</span>size_t <span class="token function">arraySize</span><span class="token punctuation">(</span><span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> N<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数实参：</strong></p><p>函数类型同样也会退化成函数指针，并且和数组类型的规则类似：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f1</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// param 被推导为函数指针，具体类型为 void (*)(int, double)</span><span class="token function">f2</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// param 被推导为函数引用，具体类型为 void (&amp;)(int, double)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-2：理解-auto-类型推导"><a href="#条款-2：理解-auto-类型推导" class="headerlink" title="条款 2：理解 auto 类型推导"></a>条款 2：理解 auto 类型推导</h3><p><code>auto</code>类型推导除了在一个例外情况下，和模板类型推导的规则一模一样，同样可以分为三种情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 情况 3</span><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 类型为 int</span><span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 类型为 const int</span><span class="token comment" spellcheck="true">// 情况 1</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类型为 const int&amp;</span><span class="token comment" spellcheck="true">// 情况 2</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref1 <span class="token operator">=</span> x<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 类型为 int&amp;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref2 <span class="token operator">=</span> cx<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 类型为 const int&amp;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref3 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 类型为 int&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组和函数实参的非引用退化规则也同样适用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"J. P. Briggs"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类型为 const char[13]</span><span class="token keyword">auto</span> arr1 <span class="token operator">=</span> name<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 类型为 const char*</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> arr2 <span class="token operator">=</span> name<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 类型为 const char (&amp;)[13]</span><span class="token keyword">void</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 类型为 void(int, double)</span><span class="token keyword">auto</span> func1<span class="token operator">=</span> someFunc<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 类型为 void (*)(int, double)</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> func2<span class="token operator">=</span> someFunc<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 类型为 void (&amp;)(int, double)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们将讨论例外情况：<code>auto</code>会假定用大括号括起的初始化表达式代表一个<code>std::initializer_list</code>，但模板类型推导不会。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">27</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 类型为 std::initializer_list&lt;int>，值为 { 27 }</span><span class="token keyword">auto</span> x4<span class="token punctuation">{</span> <span class="token number">27</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 同上</span><span class="token keyword">auto</span> x5 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误，类型不一致</span>                            <span class="token comment" spellcheck="true">// 无法推导出 std::initializer_list&lt;T> 中的 T</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 错误</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">></span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 正确，ParamType 为 std::initializer_list&lt;int></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++14 中，允许使用<code>auto</code>来说明函数返回值需要推导，而且 lambda 表达式也会在形参声明中用到<code>auto</code>。然而这些<code>auto</code>用法使用的是模板类型推导而非<code>auto</code>类型推导，因此也不能使用大括号括起的初始化表达式。</p><h3 id="条款-3：理解-decltype"><a href="#条款-3：理解-decltype" class="headerlink" title="条款 3：理解 decltype"></a>条款 3：理解 decltype</h3><p>绝大多数情况下，<code>decltype</code>会得出变量或表达式的类型而不作任何修改。对于类型为<code>T</code>的左值表达式，除非该表达式仅有一个名字，否则<code>decltype</code>总是得出类型<code>T&amp;</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 推导结果为 int</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 推导结果为 int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 C++11 中，<code>decltype</code>的主要用途是声明返回值类型依赖于形参类型的函数模板，这需要用到<strong>返回值类型尾置语法（trailing return type syntax）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Container<span class="token punctuation">,</span> <span class="token keyword">typename</span> Index<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">authenticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 允许对单表达式的 lambda 的返回值实施类型推导，而 C++14 将这个允许范围扩张到了一切函数和一切 lambda，包括那些多表达式的。这就意味着在 C++14 中可以去掉返回值类型尾置语法，仅保留前导<code>auto</code>。</p><p>但编译器会为<code>auto</code>指定为返回值类型的函数实施模板类型推导，这样就会留下隐患（例如忽略初始化表达的引用性），使用<code>decltype(auto)</code>来说明我们采用的是<code>decltype</code>的规则，就可以解决这个问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Container<span class="token punctuation">,</span> <span class="token keyword">typename</span> Index<span class="token operator">></span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">authenticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在初始化表达式处也可以应用<code>decltype</code>类型推导规则：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> cw <span class="token operator">=</span> w<span class="token punctuation">;</span><span class="token keyword">auto</span> myWidget1 <span class="token operator">=</span> cw<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// auto 推导出类型为 Widget</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> myWidget2 <span class="token operator">=</span> cw<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// decltype 推导出类型为 const Widget&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述情形中，我们无法向函数传递右值容器，若想要采用一种既能绑定到左值也能绑定到右值的引用形参，就需要借助万能引用，并应用<code>std::forward</code>（参考<strong>条款 25</strong>）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Container<span class="token punctuation">,</span> <span class="token keyword">typename</span> Index<span class="token operator">></span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">authenticateUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Container<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-4：掌握查看类型推导结果的方法"><a href="#条款-4：掌握查看类型推导结果的方法" class="headerlink" title="条款 4：掌握查看类型推导结果的方法"></a>条款 4：掌握查看类型推导结果的方法</h3><p><strong>1. IDE 编辑器</strong></p><p><strong>2. 编译器诊断信息</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token comment" spellcheck="true">// 只声明 TD 而不定义</span><span class="token keyword">class</span> <span class="token class-name">TD</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// TD 是 “类型显示类”（Type Displayer）的缩写</span>TD<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">></span> xType<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 诱发包括 x 和 y 的类型的错误信息</span>TD<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">></span> yType<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 运行时输出</strong></p><p>针对某个对象调用<code>typeid</code>，可以得到一个<code>std::type_info</code>对象，其拥有一个成员函数<code>name</code>，该函数产生一个代表类型的 C-style 的字符串。</p><p>但遗憾的是，不同编译器对于<code>std::type_info::name</code>的实现各不相同，无法保证完全可靠。并且按照标准，<code>std::type_info::name</code>中处理类型的方式和向函数模板按值传参一样，因此类型的引用性以及<code>const</code>和<code>volatile</code>限定符也将被忽略。</p><p>原书中介绍了 Boost.TypeIndex 第三方库用于代替<code>typeid</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;boost/type_index.hpp></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>cout<span class="token punctuation">;</span>    <span class="token keyword">using</span> boost<span class="token operator">::</span>typeindex<span class="token operator">::</span>type_id_with_cvr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 显示 T 的类型</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"T =          "</span>         <span class="token operator">&lt;&lt;</span> type_id_with_cvr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pretty_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 显示 param 的类型</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"param =          "</span>         <span class="token operator">&lt;&lt;</span> type_id_with_cvr<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pretty_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第二章：auto"><a href="#第二章：auto" class="headerlink" title="第二章：auto"></a>第二章：auto</h2><h3 id="条款-5：优先选用-auto，而非显式类型声明"><a href="#条款-5：优先选用-auto，而非显式类型声明" class="headerlink" title="条款 5：优先选用 auto，而非显式类型声明"></a>条款 5：优先选用 auto，而非显式类型声明</h3><p><code>auto</code>变量要求必须初始化，基本上可以避免会导致兼容性和效率问题的类型不匹配现象，还可以简化重构流程，通常也比显式指定类型要少打一些字，但在使用时需要注意<strong>条款 2</strong> 和<strong>条款 6</strong> 中提到的问题。</p><p>使用<code>auto</code>和<code>std::function</code>都可以存储闭包：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// C++14 允许在 lambda 表达式的形参中使用 auto</span><span class="token keyword">auto</span> derefLess <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p2<span class="token punctuation">)</span>                  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">,</span>                   <span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span>    derefUPLess <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> p1<span class="token punctuation">,</span>                     <span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> p2<span class="token punctuation">)</span>                   <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>auto</code>声明的、存储着一个闭包的变量和该闭包是同一类型，从而它要求的内存量也和该闭包相同；而使用<code>std::function</code>声明的、存储着一个闭包的变量是<code>std::function</code>的一个实例，不管给定的签名如何，它都占有固定大小的内存，而这个大小对于其存储的闭包而言并不一定够用，如果是这样，那么<code>std::function</code>的构造函数就会分配堆上的内存来存储该闭包。再有，编译器的细节一般都会限制内联，并会产生间接函数调用。</p><p>综上所述，<code>std::function</code>通常比起<code>auto</code>更大更慢，还可能导致内存消耗异常，因此实际使用时更推荐<code>auto</code>。</p><p>考虑以下代码的隐患：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> m<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> p <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::unordered_map</code>的键值部分是 const 的，所以哈希表中的<code>std::pair</code>类型应为<code>std::pair&lt;const std::string, int&gt;</code>而非<code>std::pair&lt;std::string, int&gt;</code>，类型的不匹配会导致额外的临时对象被复制出来，降低了运行效率。</p><p>使用<code>auto</code>就可以轻松避免这种问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="条款-6：当-auto-推导的类型不符合要求时，使用显式类型初始化惯用法"><a href="#条款-6：当-auto-推导的类型不符合要求时，使用显式类型初始化惯用法" class="headerlink" title="条款 6：当 auto 推导的类型不符合要求时，使用显式类型初始化惯用法"></a>条款 6：当 auto 推导的类型不符合要求时，使用显式类型初始化惯用法</h3><p>“隐形” 的代理类型可以导致<code>auto</code>根据初始化表达式推导出 “错误的” 类型，应该防止写出这样的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> someVar <span class="token operator">=</span> <span class="token string">" 隐形 "</span> 代理类型表达式<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个隐形代理类的典型例子是<code>std::vector&lt;bool&gt;</code>，它经过了特化，与一般的<code>std::vector</code>的行为不同，和<code>std::bitset</code>的行为相似，使用一种压缩形式表示其持有的<code>bool</code>元素，每个<code>bool</code>元素用一个比特来表示。因此，<code>std::vector&lt;bool&gt;</code>的<code>operator[]</code>并不会直接返回一个<code>bool&amp;</code>，而是会返回一个具有类似行为的<code>std::vector&lt;bool&gt;::reference</code>类型的对象，并可以隐式转换为<code>bool</code>类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">features</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>Widget w<span class="token punctuation">;</span><span class="token keyword">bool</span> highPriority1 <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 得到正确的 bool 变量</span><span class="token keyword">auto</span> highPriority2 <span class="token operator">=</span> <span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误地得到了 std::vector&lt;bool>::reference 对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了<code>std::vector&lt;bool&gt;</code>以外，标准库中的智能指针和另外一些 C++ 库中的类也使用了代理类的设计模式，例如为了提高数值计算代码效率的<strong>表达式模板</strong>技术：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Matrix sum <span class="token operator">=</span> m1 <span class="token operator">+</span> m2 <span class="token operator">+</span> m3 <span class="token operator">+</span> m4<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过使 operator+ 返回结果的代理来提高效率</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在实际编写代码时，记得通过查看文档或头文件中的函数原型来确认手头上的类是否为代理类。</p></blockquote><p>解决代理类问题的做法是：使用带显式类型的初始值设定项来强制<code>auto</code>推导出你想要的类型。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> highPriority <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种用法并不仅限于会产生代理类型的初始值设定项，它同样可以应用于你想要强调创建一个类型不同于初始化表达式类型的场合，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">calcEpsilon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">float</span> ep1 <span class="token operator">=</span> <span class="token function">calcEpsilon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 进行从 double 到 float 的隐式类型转换</span><span class="token keyword">auto</span> ep2 <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">calcEpsilon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 强调了类型转换的存在</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第三章：转向现代-C"><a href="#第三章：转向现代-C" class="headerlink" title="第三章：转向现代 C++"></a>第三章：转向现代 C++</h2><h3 id="条款-7：在创建对象时注意区分-和"><a href="#条款-7：在创建对象时注意区分-和" class="headerlink" title="条款 7：在创建对象时注意区分 () 和 {}"></a>条款 7：在创建对象时注意区分 () 和 {}</h3><p>为了着手解除众多的初始化语法带来的困惑，也为了解决这些语法不能覆盖所有初始化场景的问题，C++11 引入了统一初始化，以<strong>大括号初始化（braced initialize）</strong> 的形式存在：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 下面两种写法等价</span><span class="token keyword">int</span> x<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>大括号可以用于指定容器的初始内容：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>大括号和等号可以用于为非静态成员指定默认初始化值，而小括号不行：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> x<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可行</span>    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可行</span>    <span class="token keyword">int</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不可行！</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不可复制的对象可以采用大括号和小括号进行初始化，而不能使用等号：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ai1<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可行</span>std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ai2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 可行</span>std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ai3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不可行！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>大括号初始化禁止内建类型之间进行<strong>隐式窄化类型转换（narrowing conversion）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span><span class="token keyword">int</span> sum1<span class="token punctuation">{</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 错误！double 之和可能无法用 int 表达</span><span class="token keyword">int</span> <span class="token function">sum2</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确，表达式的值被截断为 int</span><span class="token keyword">int</span> sum3 <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 同上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大括号初始化可以避免<strong>最令人烦恼的解析语法（most vexing parse）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget <span class="token function">w1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 调用 Widget 构造函数</span>Widget <span class="token function">w2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 声明了一个名为 w2，返回值为 Widget 对象的函数</span>Widget w3<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用没有形参的 Widget 构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>大括号初始化也有一些缺点，其中一个是<strong>条款 2</strong> 中提到的 auto 推导问题，另一个则产生于对带有<code>std::initializer_list</code>类型形参的重载版本的强烈偏向性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">bool</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Widget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Widget <span class="token function">w1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用第一个构造函数</span>Widget w2<span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 调用带有 std::initializer_list 形参的构造函数</span>Widget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 调用第二个构造函数</span>Widget w4<span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 错误！禁止窄化类型转换</span>Widget <span class="token function">w5</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 调用拷贝构造函数</span>Widget w6<span class="token punctuation">{</span> w4 <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将 w4 强制转换为 int 后，调用带有 std::initializer_list 形参的构造函数</span>Widget <span class="token function">w7</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 调用移动构造函数</span>Widget w8<span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w4<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 情况和 w6 相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有在找不到任何办法把大括号初始值设定项中的实参转换为<code>std::initializer_list</code>模板中的类型时，编译器才会退而检查普通的重载决议。</p><p>值得注意的是，一对空大括号代表的意义是 “没有实参”，而非 “空的<code>std::initializer_list</code>”，后者可以用套娃的括号来表示：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget w1<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 调用默认构造函数</span>Widget w2<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 仍然调用默认构造函数</span>Widget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 变成了函数声明语句</span>Widget <span class="token function">w4</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 调用带有 std::initializer_list 形参的构造函数</span>                <span class="token comment" spellcheck="true">// 并传入空的 std::initializer_list</span>Widget w5<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 同上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用模板进行对象创建时，到底该使用小括号还是大括号会成为一个棘手的问题。举例来说，如果你想以任意数量的实参来创建一个任意类型的对象，那么，一个可变参数模板将会是不错的选择：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">doSomeWork</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 利用 params 创建 T 类型的局部对象</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>doSomeWork<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而此时，在模板内部创建局部对象时，对小括号和大括号的选择将会影响实际创建出的内容：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 得到一个包含 10 个元素的 std::vector</span>T <span class="token function">localObject</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 得到一个包含 2 个元素的 std::vector</span>T localObject<span class="token punctuation">{</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标准库函数<code>std::make_unique</code>和<code>std::make_shared</code>也面临着这个问题，它们的解决方案是在内部使用小括号，并将这个决定写进文档中，作为其接口的组成部分。</p><h3 id="条款-8：优先选用-nullptr，而非-0-或-NULL"><a href="#条款-8：优先选用-nullptr，而非-0-或-NULL" class="headerlink" title="条款 8：优先选用 nullptr，而非 0 或 NULL"></a>条款 8：优先选用 nullptr，而非 0 或 NULL</h3><p><code>nullptr</code>的实际类型是<code>std::nullptr_t</code>，该类型可以隐式转换到所有的裸指针类型，因此<code>nullptr</code>可以扮演所有类型的指针。与<code>0</code>和<code>NULL</code>不同，<code>nullptr</code>不具备整数类型，因此不具有多义性。</p><p><code>0</code>和<code>NULL</code>导致的重载问题提醒我们应当尽量避免在整型和指针类型之间进行重载：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// f 的三个重载版本</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 调用 f(int)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 可能无法通过编译，但一般会调用 f(int)，绝不会调用 f(void*)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 调用 f(void*)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>nullptr</code>在有模板的前提下表现最亮眼：模板类型推导会将<code>0</code>和<code>NULL</code>推导成 “错误” 类型（即它们的真实类型，而非空指针这个含义），而使用<code>nullptr</code>的话，模板就不会带来特殊的麻烦。考虑如下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">f1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token function">f2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> upw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">f3</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> FuncType<span class="token punctuation">,</span> <span class="token keyword">typename</span> MuxType<span class="token punctuation">,</span> <span class="token keyword">typename</span> PtrType<span class="token operator">></span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">lockAndCall</span><span class="token punctuation">(</span>FuncType func<span class="token punctuation">,</span> MuxType<span class="token operator">&amp;</span> mutex<span class="token punctuation">,</span> PtrType ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>std<span class="token operator">::</span>mutex f1m<span class="token punctuation">,</span> f2m<span class="token punctuation">,</span> f3m<span class="token punctuation">;</span><span class="token keyword">auto</span> result1 <span class="token operator">=</span> <span class="token function">lockAndCall</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span> f1m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 错误！</span><span class="token keyword">auto</span> result2 <span class="token operator">=</span> <span class="token function">lockAndCall</span><span class="token punctuation">(</span>f2<span class="token punctuation">,</span> f2m<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 错误！</span><span class="token keyword">auto</span> result3 <span class="token operator">=</span> <span class="token function">lockAndCall</span><span class="token punctuation">(</span>f3<span class="token punctuation">,</span> f3m<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-9：优先选用别名声明，而非-typedef"><a href="#条款-9：优先选用别名声明，而非-typedef" class="headerlink" title="条款 9：优先选用别名声明，而非 typedef"></a>条款 9：优先选用别名声明，而非 typedef</h3><p>很多人发现别名声明在处理涉及函数指针的类型时，比<code>typedef</code>更容易理解：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代替为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> FP <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但别名声明的压倒性优势在于<strong>别名模板（alias template）</strong>，它给予了 C++11 程序员一种直截了当的表达机制，用以表达 C++98 程序员不得不用嵌套在模板化的<code>struct</code>里面的<code>typedef</code>才能硬搞出来的东西。考虑如下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">struct</span> MyAllocList <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span> type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">typename</span> MyAllocList<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type list<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用别名模板，就可以让整个写法更简洁，并且可以摆脱类型前的<code>typename</code>限定符：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">using</span> MyAllocList <span class="token operator">=</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    MyAllocList<span class="token operator">&lt;</span>T<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++11 中，标准库的<code>&lt;type_traits&gt;</code>给出了一整套用于进行值类别转换的模板，它们是使用<code>typedef</code>实现的，对于给定待变换类型 T，其结果类型需要通过<code>std::transformation&lt;T&gt;::type</code>的方式获得。而在 C++14 中，所有的值类别转换都加上了对应的别名模板，通过<code>std::transformation_t&lt;T&gt;</code>的方式使用，这显然比<code>typedef</code>实现的版本更加好用。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>remove_const<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type          <span class="token comment" spellcheck="true">// C++11: const T -> T</span>std<span class="token operator">::</span>remove_const_t<span class="token operator">&lt;</span>T<span class="token operator">></span>              <span class="token comment" spellcheck="true">// C++14 中的等价物</span>std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type      <span class="token comment" spellcheck="true">// C++11: T&amp;/T&amp;&amp; -> T</span>std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span>          <span class="token comment" spellcheck="true">// C++14 中的等价物</span>std<span class="token operator">::</span>add_lvalue_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type  <span class="token comment" spellcheck="true">// C++11: T -> T&amp;</span>std<span class="token operator">::</span>add_lvalue_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span>      <span class="token comment" spellcheck="true">// C++14 中的等价物</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型"><a href="#条款-10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型" class="headerlink" title="条款 10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型"></a>条款 10：优先选用限定作用域的枚举类型，而非不限作用域的枚举类型</h3><p>C++98 中的枚举类型被称为不限作用域的枚举类型，与之相对的即是 C++11 中引入的限定作用域的枚举类型，即枚举类<code>enum class</code>，它的优点很明显：不会产生名称污染。</p><p>除此以外，枚举类还是强类型的，而不限范围的枚举类型中的枚举量可以隐式转换到整型（并由此更进一步转换到浮点型）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> Color <span class="token punctuation">{</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span> <span class="token function">primeFactors</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t x<span class="token punctuation">)</span><span class="token punctuation">;</span>Color c <span class="token operator">=</span> red<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">14.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> factors <span class="token operator">=</span> <span class="token function">primeFactors</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想要用<code>enum class</code>代替<code>enum</code>，对其施以强制类型转换即可，但是无法确保转换的合法性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span> <span class="token function">primeFactors</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t x<span class="token punctuation">)</span><span class="token punctuation">;</span>Color c <span class="token operator">=</span> Color<span class="token operator">::</span>red<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">14.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> factors <span class="token operator">=</span> <span class="token function">primeFactors</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于不限范围的枚举类型，编译器为了节约使用内存，通常会为枚举类型选用足够表示枚举量取值的最小底层类型。即使在某些情况下，编译器会采取空间换时间的策略，导致放弃选择尺寸最小的类型，然而它仍然需要保留优化空间的能力。因此，在 C++98 中，<code>enum</code>只允许在声明处定义，没有提供对前置声明的支持。</p><p>而在 C++11 中，无论是<code>enum class</code>还是<code>enum</code>都可以进行前置声明，<code>enum class</code>的默认底层类型是<code>int</code>，而<code>enum</code>不具备默认底层类型，只有在指定了的前提下才可以进行前置声明：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Status</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 底层类型是 int</span><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Status</span> <span class="token operator">:</span> std<span class="token operator">::</span>uint32_t<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 底层类型是 std::uint32_t</span><span class="token keyword">enum</span> Color <span class="token operator">:</span> std<span class="token operator">::</span>uint8_t<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 底层类型是 std::uint8_t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>底层类型指定同样也可以在定义时进行：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Status</span> <span class="token operator">:</span> std<span class="token operator">::</span>uint32_t <span class="token punctuation">{</span>    good <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    failed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>    incomplete <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>    corrupt <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">,</span>    audited <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">,</span>    indetermine <span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不限范围的枚举类型在你需要更便捷地为数字和名称建立联系时，还是比较好用的，例如在访问元组的元素时，你可以使用枚举量而非直接使用难懂的数字：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> UserInfo <span class="token operator">=</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">enum</span> UserInfoFields <span class="token punctuation">{</span> uiName<span class="token punctuation">,</span> uiEmail<span class="token punctuation">,</span> uiReputation <span class="token punctuation">}</span><span class="token punctuation">;</span>UserInfo uInfo<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">auto</span> val <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span>uiEmail<span class="token operator">></span><span class="token punctuation">(</span>uInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而使用<code>enum class</code>就要啰嗦得多：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> val <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>size_t<span class="token operator">></span><span class="token punctuation">(</span>UserInfoFields<span class="token operator">::</span>uiEmail<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>uInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你实在无法忍受名称污染，执意打算使用<code>enum class</code>，那么可以考虑使用以下辅助类来简化书写：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> E<span class="token operator">></span>    <span class="token comment" spellcheck="true">// C++14</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> <span class="token function">toUType</span><span class="token punctuation">(</span>E enumerator<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>underlying_type_t<span class="token operator">&lt;</span>E<span class="token operator">>></span><span class="token punctuation">(</span>enumerator<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">auto</span> val <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token function">toUType</span><span class="token punctuation">(</span>UserInfoFields<span class="token operator">::</span>uiEmail<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>uInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-11：优先选用删除函数，而非-private-未定义函数"><a href="#条款-11：优先选用删除函数，而非-private-未定义函数" class="headerlink" title="条款 11：优先选用删除函数，而非 private 未定义函数"></a>条款 11：优先选用删除函数，而非 private 未定义函数</h3><p>删除函数和将函数声明为 private 看起来只是风格不同的选择，但其实有更多值得思考的微妙之处，例如：被删除的函数无法通过任何方法调用，对于成员和友元函数中的代码也是如此。</p><p>习惯上，删除函数会被声明为 public，而非 private，这样做的理由是：C++ 会先校验可访问性，后校验删除状态，当我们尝试调用某个 private 删除函数时，编译器可能只会提醒函数无法访问，而非更应关心的函数是否被删除。</p><p>以下是 C++11 中<code>std::basic_ios</code>阻止被复制的方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">charT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">traits</span> <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>charT<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">basic_ios</span> <span class="token operator">:</span> <span class="token keyword">public</span> ios_base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">basic_ios</span><span class="token punctuation">(</span><span class="token keyword">const</span> basic_ios<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    basic_ios<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> basic_ios<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任何函数都能被删除，藉此我们可以过滤掉不想要的函数重载版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 原始版本</span><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拒绝 char 类型</span><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">bool</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拒绝 bool 类型</span><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 拒绝 double 和 float 类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>float</code>类型的参数会优先转换到<code>double</code>类型，因此传入<code>float</code>时会调用<code>double</code>类型的重载版本，但由于这个重载版本被删除了，所以编译会被阻止。</p><p>删除函数还可以阻止那些不应该进行的模板具现。举例来说，假设你需要一个和内建指针协作的模板，却不想要它对<code>void*</code>和<code>char*</code>指针进行处理，那么可以写出以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">processPointer</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> processPointer<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> processPointer<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> processPointer<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> processPointer<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 删去其它版本，如 volatile void* 和 volatile char*</span><span class="token comment" spellcheck="true">// 与其它标准字符类型，如 std::wchar_t, std::char16_t 和 std::char32_t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员函数模板可以在类外被删除：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">processPointer</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> Widget<span class="token operator">::</span>processPointer<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-12：为意在改写的函数添加-override-声明"><a href="#条款-12：为意在改写的函数添加-override-声明" class="headerlink" title="条款 12：为意在改写的函数添加 override 声明"></a>条款 12：为意在改写的函数添加 override 声明</h3><p>如果要使虚函数重写发生，有一系列要求需要满足：</p><ol><li>基类中的函数必须是虚函数。</li><li>基类和派生类中的<strong>函数名称</strong>必须完全相同（析构函数除外）。</li><li>基类和派生类中的<strong>函数形参类型</strong>必须完全相同。</li><li>基类和派生类中的<strong>函数常量性</strong>必须完全相同。</li><li>基类和派生类中的<strong>函数返回值</strong>和<strong>异常规格</strong>必须兼容。</li><li>基类和派生类的<strong>函数引用限定符</strong>必须完全相同。</li></ol><p>由于对声明派生类中的重写，保证正确性很重要，而出错又很容易，C++11 提供了<code>override</code>声明来显式地标明派生类中的函数是为了重写基类版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> override<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> override<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 加个 "virtual" 没问题，但也没必要</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样做的好处不仅在于让编译器提醒你想要重写的函数实际上并未重写，还可以让你在打算更改基类中虚函数的签名时，衡量一下其所造成的影响。</p><blockquote><p><code>override</code>和<code>final</code>是 C++11 中加入的<strong>语境关键字（contextual keyword）</strong>，它们的特点是仅会在特定语境下才发挥被保留的意义，因此如果你有一些遗留代码，其中已经用过<code>override</code>和<code>final</code>作为名称的话，并不需要为它们改名。</p></blockquote><p><strong>函数引用限定符（reference qualifier）：</strong> 限制成员函数仅用于左值对象或右值对象。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>   <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 仅在 *this 是左值时调用</span>   <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 仅在 *this 是右值时调用</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Widget w<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>w<span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 以左值调用 Widget::doWork &amp;</span><span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 以右值调用 Widget::doWork &amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>带引用限定符的成员函数并不常见，但有时也是需要的。举例来说，假设我们的<code>Widget</code>类中有个<code>std::vector</code>类型的数据成员，我们提供一个函数让用户能对这个数据成员直接访问，但对于左值对象和右值对象有不同的行为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> DataType <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span>    DataType<span class="token operator">&amp;</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>              <span class="token comment" spellcheck="true">// 对于左值 Widget 类型，返回左值</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> values<span class="token punctuation">;</span> <span class="token punctuation">}</span>    DataType <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>              <span class="token comment" spellcheck="true">// 对于右值 Widget 类型，返回右值</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    DataType values<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Widget w<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">auto</span> vals1 <span class="token operator">=</span> w<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 调用 Widget::data 的左值重载版本</span>                                    <span class="token comment" spellcheck="true">// vals1 采用拷贝构造完成初始化</span><span class="token keyword">auto</span> vals2 <span class="token operator">=</span> <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 调用 Widget::data 的右值重载版本</span>                                    <span class="token comment" spellcheck="true">// vals2 采用移动构造完成初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-13：优先选用-const-iterator，而非-iterator"><a href="#条款-13：优先选用-const-iterator，而非-iterator" class="headerlink" title="条款 13：优先选用 const_iterator，而非 iterator"></a>条款 13：优先选用 const_iterator，而非 iterator</h3><p><code>const_iterator</code>是 STL 中提供的与指向 const 的指针含义相同之物，它们指向不可被修改的值。任何时候只要你需要一个迭代器而其所指向的内容没有修改的必要，那就应该使用 const_iterator。</p><p>但在 C++98 中，<code>const_iterator</code>得到的支持不够全面，想要获取它们就很不容易，而获取到了以后使用它们的方法也很受限。例如在 C++98 中，我们会被迫写出以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator IterT<span class="token punctuation">;</span><span class="token keyword">typedef</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator ConstIterT<span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> values<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ConstIterT ci <span class="token operator">=</span>     std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ConstIterT<span class="token operator">></span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ConstIterT<span class="token operator">></span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>              <span class="token number">1983</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// const_iterator 作为参数，返回 const_iterator</span>values<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>IterT<span class="token operator">></span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1998</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// C++98 中 insert 只能接受 iterator</span>                                                <span class="token comment" spellcheck="true">// 从 const_iterator 到 iterator 不存在可移植的类型转换</span>                                                <span class="token comment" spellcheck="true">// 可能无法通过编译</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在 C++11 中，这些现象得到了彻底的改变，获取和使用<code>const_iterator</code>都变得容易了。要把原始的、使用<code>iterator</code>的 C++98 代码修改成使用<code>const_iterator</code>的 C++11 代码也很简单：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> values<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1983</span><span class="token punctuation">)</span><span class="token punctuation">;</span>values<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token number">1998</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 对于<code>const_iterator</code>支持的唯一缺陷是只为<code>begin</code>和<code>end</code>提供了对应的非成员函数版本，而没有为<code>cbegin</code>、<code>cend</code>、<code>rbegin</code>、<code>cend</code>、<code>crbegin</code>和<code>crend</code>这些返回<code>const_iterator</code>的函数提供对应的非成员函数版本，这个问题在 C++14 中得到了解决。想要自己实现它们也很简单，如下就是非成员函数版本的<code>cbegin</code>的一个实现方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该模板在传入一个内建数组时也管用，此时<code>container</code>会成为一个 const 数组的引用。</p><blockquote><p>C++11 的非成员函数版本的<code>begin</code>为内建数组提供了一个特化版本，它返回一个指向数组首元素的指针。由于 const 数组的元素都为 const，所以若给<code>begin</code>传入一个 const 数组，则返回的指针是个指向 const 的指针，即数组意义下的 const_iterator。</p></blockquote><p>由于内建数组和第三方库的存在，最通用化的代码往往不会假定成员函数的存在，而是更多地采用非成员函数版本，例如以下<code>findAndInsert</code>模板的通用形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> C<span class="token punctuation">,</span> <span class="token keyword">typename</span> V<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">findAndInsert</span><span class="token punctuation">(</span>C<span class="token operator">&amp;</span> container<span class="token punctuation">,</span> <span class="token keyword">const</span> V<span class="token operator">&amp;</span> targetVal<span class="token punctuation">,</span> <span class="token keyword">const</span> V<span class="token operator">&amp;</span> insertVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>cbegin<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>cend<span class="token punctuation">;</span>    <span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">cbegin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cend</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span> targetVal<span class="token punctuation">)</span><span class="token punctuation">;</span>    container<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> insertVal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-14：只要函数不会抛出异常，就为其加上-noexcept-声明"><a href="#条款-14：只要函数不会抛出异常，就为其加上-noexcept-声明" class="headerlink" title="条款 14：只要函数不会抛出异常，就为其加上 noexcept 声明"></a>条款 14：只要函数不会抛出异常，就为其加上 noexcept 声明</h3><p>在 C++11 中，C++98 风格的异常规范已经被弃用，而转为为不会抛出异常的函数提供<code>noexcept</code>声明，函数是否要加上这个声明，事关接口声明。</p><p>调用方可以查询函数的<code>noexcept</code>状态，而查询结果可能会影响调用代码的异常安全性和运行效率。这么一来，函数是否带有<code>noexcept</code>声明就是和成员函数是否带有 const 声明同等重要的信息。当你明明知道一个函数不会抛出异常却未给它加上<code>noexcept</code>声明的话，就属于接口规格设计缺陷。</p><p>相当于不带<code>noexcept</code>声明的函数，带有<code>noexcept</code>声明的函数有更多机会得到优化：</p><pre class="line-numbers language-cpp"><code class="language-cpp">RetType <span class="token function">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 最优化</span>RetType <span class="token function">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 优化不足</span>RetType <span class="token function">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 优化不足</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在带有<code>noexcept</code>声明的函数中，优化器不需要在异常传出函数的前提下，将运行时栈保持在可展开状态；也不需要在异常逸出函数的前提下，保证所有其中的对象以其被构造顺序的逆序完成析构。而那些以<code>throw()</code>异常规格声明的函数就享受不到这样的优化灵活性，和那些没有加上异常规格的函数一样。</p><p><code>noexcept</code>属性对于移动操作、swap、内存释放函数和析构函数最有价值。C++11 STL 中的大部分函数遵循 “能移动则移动，必须复制才复制” 策略，但这必须保证在使用移动操作代替复制操作后，函数依旧具备强异常安全性。为了得知移动操作会不会产生异常，就需要校验这个操作是否带有<code>noexcept</code>声明。</p><p><code>swap</code>函数是许多 STL 算法实现的核心组件，它的广泛使用昭示着针对其实施<code>noexcept</code>声明带来的收益是可观的。标准库中的<code>swap</code>是否带有<code>noexcept</code>声明，取决于用户定义的<code>swap</code>自身。例如，标准库为数组和<code>std::pair</code>准备的<code>swap</code>函数如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t N<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>          <span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span><span class="token keyword">struct</span> pair <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>pair<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">swap</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> p<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                                <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">swap</span><span class="token punctuation">(</span>second<span class="token punctuation">,</span> p<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些函数带有条件式<code>noexcept</code>声明，它们到底是否具备<code>noexcept</code>属性，取决于它的<code>noexcept</code>分句中的表达式是否结果为<code>noexcept</code>。在此处，数组和<code>std::pair</code>的<code>swap</code>具备<code>noexcept</code>属性的前提是，其每一个元素的<code>swap</code>都具备<code>noexcept</code>属性。</p><p>对于某些函数来说，具备<code>noexcept</code>属性是如此之重要，所以它们默认就是如此。在 C++11 中，内存释放函数和所有的析构函数都默认隐式地具备<code>noexcept</code>属性。析构函数未隐式地具备<code>noexcept</code>属性的唯一情况，就是所有类中有数据成员（包括继承而来的成员，以及在其他数据成员中包含的数据成员）的类型显式地将其析构函数声明为<code>noexcept(false)</code>，即可能抛出异常。</p><blockquote><p>不具备<code>noexcept</code>属性的析构函数很少见，标准库里一个都没有，而如果标准库使用了某个对象，其析构函数抛出了异常，则该行为是未定义的。</p></blockquote><p>大多数函数都是<strong>异常中立（exception-neutral）</strong> 的，不具备<code>noexcept</code>属性。此类函数自身并不抛出异常，但它们调用的函数可能会抛出异常，这些异常会经由异常中立函数传至调用栈的更深一层。</p><p>C++ 允许带有<code>noexcept</code>声明的函数依赖于缺乏<code>noexcept</code>保证的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得一提的是，有些库的接口设计者会把函数区分为带有<strong>宽松规约（wide constract）</strong> 和带有<strong>狭隘规约（narrow constract）</strong> 的不同种类。带有宽松规约的函数是没有前置条件的，要调用这样的函数也无须关心程序状态；而对于带有狭隘规约的函数，如果前置条件被违反，则结果将成为未定义的。一般而言，我们只会把<code>noexcept</code>声明保留给那些带有宽松规约的函数。</p><h3 id="条款-15：只要有可能使用-constexpr，就使用它"><a href="#条款-15：只要有可能使用-constexpr，就使用它" class="headerlink" title="条款 15：只要有可能使用 constexpr，就使用它"></a>条款 15：只要有可能使用 constexpr，就使用它</h3><p><strong><code>constexpr</code>对象：</strong> 具备 const 属性，并由编译期已知的值完成初始化。</p><p>在编译阶段就已知的值拥有许多特权，它们可能被放置在只读内存里（对于嵌入式开发尤为重要）；在编译阶段就已知的常量整型值可以用在 C++ 要求整型常量表达式的语境中，包括数组的尺寸规格、整型模板实参、枚举量的值、对齐规格等，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> sz<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// 非 constexpr 变量</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">const</span> <span class="token keyword">auto</span> arraySize <span class="token operator">=</span> sz<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 正确，arraySize 是 sz 的一个 const 副本</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> arraySize<span class="token operator">></span> data<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误！arraySize 的值非编译期可知</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> arraySize1 <span class="token operator">=</span> sz<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 错误！sz 的值在编译期未知</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> sz<span class="token operator">></span> data1<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 错误！问题同上</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> arraySize2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 正确，10 是编译期常量</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> arraySize2<span class="token operator">></span> data2<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确，arraySize2 是编译期常量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>constexpr</code>函数：</strong></p><ul><li><code>constexpr</code>函数可以用在要求编译期常量的语境中。在这种情况下，若传给一个<code>constexpr</code>函数的实参值是在编译期已知的，则结果也会在编译期计算出来；如果任何一个实参值在编译期未知，则代码将无法通过编译。</li><li><code>constexpr</code>函数也可以运用在非编译期常量的语境中，此时传入的值可以有一个或多个在编译期未知。它的运作方式和普通函数无异，同样在运行期完成结果的计算。</li><li>在 C++11 中，<code>constexpr</code>函数不得包含多于一个可执行语句，即一条<code>return</code>语句；而到了 C++14，就没有了这种限制。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">int</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// C++11</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>exp <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> base <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> exp <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">int</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// C++14</span>    <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> exp<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> result <span class="token operator">*</span><span class="token operator">=</span> base<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> numConds <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> numConds<span class="token punctuation">)</span><span class="token operator">></span> results<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>constexpr</code>函数仅限于传入和返回<strong>字面类型（literal type）</strong>，这些类型能够持有编译期可以决议的值。在 C++11 中，除了<code>void</code>的所有内建类型都是字面类型；此外，我们也可以自定义字面类型，这需要将其构造函数和部分成员函数声明为<code>constexpr</code>函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">constexpr</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">double</span> xVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> yVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span>        <span class="token function">x</span><span class="token punctuation">(</span>xVal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>yVal<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> newY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">constexpr</span> Point <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">9.4</span><span class="token punctuation">,</span> <span class="token number">27.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 在编译期执行 constexpr 构造函数</span><span class="token keyword">constexpr</span> Point <span class="token function">p2</span><span class="token punctuation">(</span><span class="token number">28.8</span><span class="token punctuation">,</span> <span class="token number">5.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 同上</span><span class="token keyword">constexpr</span> Point <span class="token function">midpoint</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p2<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span>             <span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用 constexpr 成员函数</span><span class="token punctuation">}</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> mid <span class="token operator">=</span> <span class="token function">midpoint</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使用 constexpr 函数的返回值来初始化 constexpr 对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++14 中，就连返回值类型为<code>void</code>的 setter 函数也可以声明为<code>constexpr</code>函数，这就使以下代码变为可能：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> newY<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">constexpr</span> Point <span class="token function">reflection</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    Point result<span class="token punctuation">;</span>    result<span class="token punctuation">.</span><span class="token function">setX</span><span class="token punctuation">(</span><span class="token operator">-</span>p<span class="token punctuation">.</span><span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    result<span class="token punctuation">.</span><span class="token function">setY</span><span class="token punctuation">(</span><span class="token operator">-</span>p<span class="token punctuation">.</span><span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> reflectionMid <span class="token operator">=</span> <span class="token function">reflection</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，一旦你把一个对象或函数声明成了<code>constexpr</code>，而后来你又感觉对<code>constexpr</code>运用不当，然后进行了移除，那么这会导致非常多客户代码无法通过编译。因此，“只要有可能使用<code>constexpr</code>，就使用它” 这句话中的 “只要有可能” 的含义就是你是否有一个长期的承诺，将由<code>constexpr</code>带来的种种限制施加于相关的函数和对象上。</p><h3 id="条款-16：保证-const-成员函数的线程安全性"><a href="#条款-16：保证-const-成员函数的线程安全性" class="headerlink" title="条款 16：保证 const 成员函数的线程安全性"></a>条款 16：保证 const 成员函数的线程安全性</h3><p>对于 const 成员函数，我们通常认为它代表的是读操作，而多个线程在没有同步的情况下执行读操作应该是安全的。因此，我们需要保证 const 成员函数的线程安全性，除非可以确信它们不会在并发语境中被使用。</p><p>考虑如下情形，我们将计算出的多项式的根存入缓存中，以避免代价高昂的重复计算：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Polynomial</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> RootsType <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span>    RootsType <span class="token function">roots</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootsAreValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 如果缓存无效</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            rootsAreValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 则计算根，并将其存入 rootVals</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> rootsVals<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">mutable</span> <span class="token keyword">bool</span> rootsAreValid<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">mutable</span> RootsType rootVals<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 mutable 成员变量的存在，可能有不同的多个线程通过<code>roots</code>成员函数在没有同步的情况下读写同一块内存，造成<strong>数据竞争（data race）</strong>，这会导致未定义行为的出现。</p><p>有两种方法可以解决这个问题，最简单的方法也是最常见的，引入一个 mutex 互斥量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Polynomial</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> RootsType <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span>    RootsType <span class="token function">roots</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 互斥量加锁</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootsAreValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 如果缓存无效</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            rootsAreValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 则计算根，并将其存入 rootVals</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> rootsVals<span class="token punctuation">;</span>    <span class="token punctuation">}</span>                                       <span class="token comment" spellcheck="true">// 互斥量解锁</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">mutable</span> std<span class="token operator">::</span>mutex m<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 添加 mutable 的互斥量</span>    <span class="token keyword">mutable</span> <span class="token keyword">bool</span> rootsAreValid<span class="token punctuation">{</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">mutable</span> RootsType rootVals<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种方法是使用<code>std::atomic</code>类型的变量，这会比使用互斥量提供更好的性能，但更适用于对单个变量或内存区域的操作。以下情况更适合使用<code>std::atomic</code>来确保线程安全性：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">double</span> <span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>callCount<span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">// 带原子性的自增操作</span>        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">mutable</span> std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">></span> callCount<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 存储调用次数</span>    <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论是<code>std::mutex</code>还是<code>std::atomic</code>都是只移类型，无法进行复制，因此加入它们都会使类失去可复制性，但仍然可以移动。</p><h3 id="条款-17：理解特殊成员函数的生成机制"><a href="#条款-17：理解特殊成员函数的生成机制" class="headerlink" title="条款 17：理解特殊成员函数的生成机制"></a>条款 17：理解特殊成员函数的生成机制</h3><p>在 C++11 中，支配特殊成员函数的机制如下（所有生成的默认特殊函数都是 inline 的，且具有 public 访问权限）：</p><ul><li><strong>默认构造函数：</strong> 与 C++98 的机制相同。仅当类中不包含用户声明的构造函数时才生成。</li><li><strong>析构函数：</strong> 与 C++98 的机制基本相同，唯一的区别在于析构函数默认为 noexcept（参考<strong>条款 14</strong>）。仅当基类的析构函数为虚时，派生类的析构函数才为虚。</li><li><strong>拷贝构造函数：</strong> 运行期行为与 C++98 相同：<strong>按成员</strong>进行<strong>非静态</strong>数据成员的拷贝构造。仅当类中不包含用户声明的拷贝构造函数时才生成。如果该类声明了移动操作，则拷贝构造函数将被删除。在已经存在拷贝赋值运算符或析构函数的情况下，仍然生成拷贝构造函数已经成为了被废弃的行为（但未被禁止），原因见三者法则。</li><li><strong>拷贝赋值运算符：</strong> 运行期行为与 C++98 相同：<strong>按成员</strong>进行<strong>非静态</strong>数据成员的拷贝赋值。仅当类中不包含用户声明的拷贝赋值运算符时才生成。如果该类声明了移动操作，则拷贝赋值运算符将被删除。在已经存在拷贝构造函数或析构函数的情况下，仍然生成拷贝构造函数已经成为了被废弃的行为（但未被禁止），原因见三者法则。</li></ul><blockquote><p><strong>三者法则（Rule of Three）：</strong> 如果你声明了拷贝构造函数、拷贝赋值运算符或析构函数中的任何一个，你就得同时声明所有这三个。<br>三者法则根植于这样的思想：如果有改写拷贝操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：  </p><ol><li>在一种拷贝操作中进行的任何资源管理，也极有可能在另一种拷贝操作中也需要进行。  </li><li>该类的析构函数也会参与到该资源的管理中（通常是对资源进行释放）。<br>三者法则对移动操作也同样成立。</li></ol></blockquote><ul><li><strong>移动构造函数和移动赋值运算符：</strong> 都<strong>按成员</strong>进行<strong>非静态</strong>数据成员的移动操作。仅当类中不包含用户声明的拷贝操作、移动操作和析构函数时才生成。声明一个移动构造函数会阻止编译器生成移动赋值运算符，而声明一个移动赋值运算符也会阻止编译器生成移动构造函数。</li></ul><blockquote><p>声明拷贝操作（无论是拷贝构造还是拷贝赋值）的行为表明了对象的常规拷贝方式（按成员拷贝）对于该类并不适用，那么编译器就会认为按成员移动极有可能也不适用于移动操作。因此，一旦显式声明了拷贝操作，编译器就不再会为其生成移动操作，反之亦然。</p></blockquote><p>如果你有一些代码依赖于编译器自动生成的特殊函数，并且你确信这些函数会正确执行，那么可以用<code>=default</code>显式指定让它们生成：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 使析构函数成为虚的</span>    <span class="token function">Base</span><span class="token punctuation">(</span>Base<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 提供移动操作的支持</span>    Base<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Base<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 提供拷贝操作的支持</span>    Base<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员函数模板在任何情况下都不会抑制特殊成员函数的生成，例如下面这个类：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 以任意类型构造 Widget</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以任意类型对 Widget 赋值</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器会始终生成<code>Widget</code>的拷贝和移动操作，即使这些模板的具现化生成了拷贝构造函数和拷贝赋值运算符的函数签名。</p><h2 id="第四章：智能指针"><a href="#第四章：智能指针" class="headerlink" title="第四章：智能指针"></a>第四章：智能指针</h2><p>以下理由使得裸指针不受欢迎：</p><ol><li>裸指针没有在声明中指出，其指向的内容是单个对象还是数组。</li><li>裸指针没有在声明中指出，是否该在其指向的对象使用完后进行析构。</li><li>无法得知怎样析构裸指针才是适当的，是使用<code>delete</code>运算符，还是有专门用于析构的函数。</li><li>在已知使用<code>delete</code>的情况下，难以确定该用<code>delete</code>还是<code>delete[]</code>。</li><li>很难保证对指针所指向对象的析构，在所有代码路径上只执行一次。</li><li>没有正规的方式来检测指针是否空悬（dangle）。</li></ol><p>因此，在大多数时候，应该优先选用智能指针。<code>std::auto_ptr</code>是从 C++98 中残留下来的弃用特性，应该被 C++11 中的 <code>std::unique_ptr</code>所替代。</p><h3 id="条款-18：使用-std-unique-ptr-管理具备专属所有权的资源"><a href="#条款-18：使用-std-unique-ptr-管理具备专属所有权的资源" class="headerlink" title="条款 18：使用 std::unique_ptr 管理具备专属所有权的资源"></a>条款 18：使用 std::unique_ptr 管理具备专属所有权的资源</h3><p><code>std::unique_ptr</code>是小巧、高速的、具备只移类型的智能指针，对于托管的指针实施专属所有权语义。它和裸指针所占大小相同，并且不允许被拷贝，在执行析构操作时，同时析构其所管理的资源。</p><p><code>std::unique_ptr</code>的一个常见用法是在继承体系中，作为工厂函数的返回值类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Investment</span> <span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Investment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 必备的虚析构函数！</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Stock</span> <span class="token operator">:</span> <span class="token keyword">public</span> Investment <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Bond</span> <span class="token operator">:</span> <span class="token keyword">public</span> Investment <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">RealEstate</span> <span class="token operator">:</span> <span class="token keyword">public</span> Investment <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 std::unique_ptr</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">auto</span> pInvestment <span class="token operator">=</span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// *pInvestment 在此处析构</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认地，资源析构采用<code>delete</code>运算符来完成，但也可以指定自定义删除器，并且删除器将会被视作<code>std::unique_ptr</code>类型的一部分。下面的例子中使用了 lambda 表达式作为自定义删除器，并在删除时写入一条日志：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> delInvmt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Investment<span class="token operator">*</span> pInvestment<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span>pInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pInvestment<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>delInvmt<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 改进后的返回值类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++14 中，由于有了函数返回值类型推导（参考<strong>条款 3</strong>），<code>makeInvestment</code>可以用更加简单的、封装性更好的方法实现，自定义删除器也可以放在函数内部，完整的代码演示如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 现在自定义删除器位于函数内部</span>    <span class="token keyword">auto</span> delInvmt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Investment<span class="token operator">*</span> pInvestment<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">makeLogEntry</span><span class="token punctuation">(</span>pInvestment<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span> pInvestment<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Investment<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>delInvmt<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">pInv</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> delInvmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 待返回的指针</span>    <span class="token comment" spellcheck="true">// 使用 reset 来让 pInv 获取 new 产生的对象的所有权</span>    <span class="token comment" spellcheck="true">// 对每一次 new 的调用结果，都使用 std::forward 对实参进行完美转发（参考条款 25）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment" spellcheck="true">/* 应创建一个 Stock 类型的对象 */</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        pInv<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Stock</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment" spellcheck="true">/* 应创建一个 Bond 类型的对象 */</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        pInv<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Bond</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment" spellcheck="true">/* 应创建一个 RealEstate 类型的对象 */</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        pInv<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">RealEstate</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pInv<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用自定义删除器后，<code>std::unique_ptr</code>的大小可能不再和裸指针相同：有状态的删除器和采用函数指针的删除器会增加<code>std::unique_ptr</code>类型的对象尺寸大小。无状态的函数对象（例如无捕获的 lambda 表达式）不会浪费任何存储内存，而函数指针通常会使<code>std::unique_ptr</code>的大小增加一到两个字长（word），这意味着无捕获的 lambda 表达式往往是用作删除器的最佳选择。</p><p><code>std::unique_ptr</code>提供了两种形式，一种是单个对象（<code>std::unique_ptr&lt;T&gt;</code>），另一种是数组（<code>std::unique_ptr&lt;T[]&gt;</code>）。为了避免二义性，单个对象形式不提供索引运算符（<code>operator[]</code>），而数组形式不提供解引用运算符（<code>operator*</code>和<code>operator-&gt;</code>）。但实际上，数组形式用到的场合非常少，唯一的应用场合大概是在使用 C 风格 API 时，它返回了存放在堆上的裸指针；大部分时候我们会优先考虑<code>std::array</code>、<code>std::vector</code>和<code>std::string</code>这些数据结构。</p><p><code>std::unique_ptr</code>可以方便高效地转换为<code>std::shared_ptr</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> sp <span class="token operator">=</span> <span class="token function">makeInvestment</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="条款-19：使用-std-shared-ptr-管理具备共享所有权的资源"><a href="#条款-19：使用-std-shared-ptr-管理具备共享所有权的资源" class="headerlink" title="条款 19：使用 std::shared_ptr 管理具备共享所有权的资源"></a>条款 19：使用 std::shared_ptr 管理具备共享所有权的资源</h3><p><code>std::shared_ptr</code>提供了方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。与<code>std::unique_ptr</code>相比，<code>std::shared_ptr</code>所占大小通常是裸指针的两倍，它还会带来控制块的开销，并且要求成本高昂的原子化的引用计数操作。</p><p>默认的资源析构通过<code>delete</code>运算符来完成，但同时也支持自定义删除器。与<code>std::unique_ptr</code>不同的是，删除器的类型对<code>std::shared_ptr</code>的类型没有影响，也不会影响<code>std::shared_ptr</code>的尺寸大小：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> loggingDel <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pw<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>loggingDel<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">upw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span>                       <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这使得<code>std::shared_ptr</code>的设计更具弹性，拥有不同类型自定义删除器的<code>std::shared_ptr</code>也可以被放在同一个容器中：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> customDeleter1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 自定义删除器</span><span class="token keyword">auto</span> customDeleter2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 各有不同的类型</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">pw1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> customDeleter1<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">pw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> customDeleter2<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">>></span> vpw<span class="token punctuation">{</span> pw1<span class="token punctuation">,</span> pw2 <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>控制块（control block）：</strong> 每一个由<code>std::shared_ptr</code>管理的对象都拥有一个控制块，它的内存被动态分配在堆上，除了包含引用计数以外，还包含作用于<code>std::weak_ptr</code>的弱计数（参考<strong>条款 20</strong>），自定义删除器以及从分配器等内容。</p><p>一个对象的控制块应该在创建首个指向该对象的<code>std::shared_ptr</code>时确定，因此，控制块的创建遵循以下规则：</p><ol><li>使用<code>std::make_shared</code>（参考<strong>条款 21</strong>）总是会创建一个控制块。</li><li>从具备专属所有权的指针（<code>std::unique_ptr</code>或<code>std::auto_ptr</code>）出发构造一个<code>std::shared_ptr</code>时，会创建一个控制块。</li><li>用裸指针作为实参调用<code>std::shared_ptr</code>的构造函数时，会创建一个控制块。</li></ol><p>由以上规则我们可以得出，应该避免使用裸指针类型的变量来创建<code>std::shared_ptr</code>。用同一个裸指针构造出不止一个<code>std::shared_ptr</code>将会使对象拥有多重的控制块，这会导致对资源的多次析构，产生未定义行为，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> pw <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pw 是个裸指针</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw1</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应该改为：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span>spw1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当你希望一个托管到<code>std::shared_ptr</code>的类能够安全地由<code>this</code>指针创建一个<code>std::shared_ptr</code>时，应该使该类继承自<code>std::enable_shared_from_this</code>，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::enable_shared_from_this</code>定义了一个成员函数<code>std::shared_from_this</code>，它会创建一个<code>std::shared_ptr</code>指向当前对象，但不会重复创建控制块：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">>></span> processedWidget<span class="token punctuation">;</span><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 处理对象本身</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 将指向当前对象的 std::shared_ptr 加入 processedWidget</span>    processedWidget<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免用户在<code>std::shared_ptr</code>指向该对象前就调用了<code>std::shared_from_this</code>（这会导致其无法查询到对象拥有的控制块，产生未定义行为），继承自<code>std::enable_shared_from_this</code>的类通常会将其构造函数声明为 private，并且只允许通过调用返回<code>std::shared_ptr</code>的工厂函数来创建对象。例如，以下是<code>Widget</code>类的一个可能实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 将实参完美转发给 private 构造函数的工厂函数</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>    <span class="token keyword">static</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Widget</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 构造函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::unique_ptr</code>可以轻易转换为<code>std::shared_ptr</code>，反之却并不成立，一旦资源的生存期被托管给了<code>std::shared_ptr</code>，就不能回收该资源的所有权，并让一个<code>std::unique_ptr</code>来托管它。并且和<code>std::unique_ptr</code>不同，<code>std::shared_ptr</code>直到 C++17 才拥有处理数组的能力（<code>std::shared_ptr&lt;T[]&gt;</code>），在 C++11/14 中，它的 API 仅被设计用来处理指向单个对象的指针。</p><h3 id="条款-20：对于类似-std-shared-ptr-但有可能空悬的指针使用-std-weak-ptr"><a href="#条款-20：对于类似-std-shared-ptr-但有可能空悬的指针使用-std-weak-ptr" class="headerlink" title="条款 20：对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr"></a>条款 20：对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr</h3><p><code>std::weak_ptr</code>并不是一种独立的智能指针，而是<code>std::shared_ptr</code>的一种扩充。它一般是通过<code>std::shared_ptr</code>来创建的，两者会指向相同位置，但<code>std::weak_ptr</code>并不影响所指向对象的引用计数，而是会影响控制块中的弱计数。</p><p>使用<code>expired</code>函数来检测<code>std::weak_ptr</code>的空悬：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> spw <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">wpw</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>spw <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// Widget 对象被析构，wpw 空悬</span><span class="token keyword">if</span> <span class="token punctuation">(</span>wpw<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 若 wpw 不再指向任何对象</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过<code>std::weak_ptr</code>创建<code>std::shared_ptr</code>，可以在未失效情况下提供对资源的访问：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 使用 lock 函数时，若 wpw 失效，则 spw1 和 spw2 为空</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw1 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> spw2 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 直接构造时，若 wpw 失效，则抛出 std::bad_weak_ptr 类型的异常</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw3</span><span class="token punctuation">(</span>wpw<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::weak_ptr</code>有以下可能的用武之地：</p><ul><li>创建带缓存的工厂函数：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> Widget<span class="token operator">></span> <span class="token function">fastLoadWidget</span><span class="token punctuation">(</span>WidgetID id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span>WidgetID<span class="token punctuation">,</span> std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> Widget<span class="token operator">>></span> cache<span class="token punctuation">;</span>    <span class="token keyword">auto</span> objPtr <span class="token operator">=</span> cache<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果对象不在缓存中，则返回空指针</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>objPtr<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// 加载并缓存对象</span>        objPtr <span class="token operator">=</span> <span class="token function">loadWidget</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> objPtr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> objPtr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>观察者设计模式（Observer design pattern）：多个观察者（observer）对象同时监听一个主题（subject）对象，主题对象会在其发生状态改变时发出通知。主题对象不会控制其观察者的生存期，但需要确认当一个观察者对象被析构后，主题对象不会再访问它。一种合理的设计就是让每个主题对象持有指向其观察者对象的<code>std::weak_ptr</code>，以便在使用之前确认它是否空悬。</li><li>避免<code>std::shared_ptr</code>循环引用：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">></span> pb<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> pa<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">auto</span> pa <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pb <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pa<span class="token operator">-</span><span class="token operator">></span>pb <span class="token operator">=</span> pb<span class="token punctuation">;</span>pb<span class="token operator">-</span><span class="token operator">></span>pa <span class="token operator">=</span> pa<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，<code>A</code>和<code>B</code>互相保存着指向对方的<code>std::shared_ptr</code>，产生了循环引用，两者会永久保持彼此的引用计数至少为一，这会阻止<code>A</code>和<code>B</code>被析构，实际上产生了内存泄漏。</p><p>将其中一者改为<code>std::weak_ptr</code>可以避免循环的产生：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">></span> pb<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> pa<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-21：优先选用-std-make-unique-和-std-make-shared，而非直接使用-new"><a href="#条款-21：优先选用-std-make-unique-和-std-make-shared，而非直接使用-new" class="headerlink" title="条款 21：优先选用 std::make_unique 和 std::make_shared，而非直接使用 new"></a>条款 21：优先选用 std::make_unique 和 std::make_shared，而非直接使用 new</h3><p><code>std::make_shared</code>是 C++11 的一部分，但<code>std::make_unique</code>到了 C++14 才被加入标准库，不过要写出一个基础版本的<code>std::make_unique</code>非常容易：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_unique</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>相对于直接使用<code>new</code>运算符，make 函数有以下优势：</p><ul><li>消除重复代码：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">upw1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用 make 函数</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">upw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不使用 make 函数</span><span class="token keyword">auto</span> <span class="token function">spw1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用 make 函数</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不使用 make 函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>改进了异常安全性：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 有潜在的内存泄漏风险</span><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 不具有潜在的内存泄漏风险</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在直接使用<code>new</code>运算符的情况下，由于分配<code>Widget</code>对象、执行<code>std::shared_ptr</code>构造函数、执行<code>computePriority</code>函数三者并不存在固定顺序，<code>computePriority</code>函数可能会晚于<code>Widget</code>对象的分配，先于<code>std::shared_ptr</code>的构造函数执行，此时若<code>computePriority</code>产生异常，那么分配的<code>Widget</code>内存就会发生泄漏。使用<code>std::make_shared</code>则不会产生这个问题。</p><ul><li>使用<code>std::make_shared</code>和<code>std::allocate_shared</code>有助于生成的尺寸更小、速度更快的目标代码。</li></ul><blockquote><p><code>std::make_shared</code>会将指向的对象和与其相关联的控制块分配在单块内存中，这种优化减少了程序的静态尺寸，并且因为只进行一次内存分配，还可以加块代码的运行速度。使用<code>std::make_shared</code>还可以减少对控制块一些簿记信息（bookkeeping information）的需要，潜在地减少了程序的内存占用量（memory footprint）。<code>std::allocate_shared</code>也是同理。</p></blockquote><p>虽然有着如此多的优势，但还是有一些情形下，不能或者不应该使用 make 函数：</p><ul><li>使用 make 函数无法自定义删除器，以及直接传递大括号内的初始值设定项：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 想要自定义删除器，就只能使用 new 运算符</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>widgetDeleter<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">upw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> widgetDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span>                          <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> widgetDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 只能间接传递初始化列表给 make 函数</span><span class="token keyword">auto</span> initList <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> spv <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">(</span>initList<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>不建议对自定义内存管理方式的类使用 make 函数：通常情况下，类自定义的<code>operator new</code>和<code>operator delete</code>被设计成用来分配和释放能精确容纳该类大小的内存块，但<code>std::allocate_shared</code>所要求的内存大小并不等于动态分配对象的大小，而是在其基础上加上控制块的大小。因此，使用 make 函数去创建重载了<code>operator new</code>和<code>operator delete</code>类的对象，通常并不是个好主意。</li><li>当处于特别关注内存的系统中时，若存在非常大的对象和比相应的<code>std::shared_ptr</code>生存期更久的<code>std::weak_ptr</code>，不建议使用 make 函数：这会导致对象的析构和内存的释放之间产生延迟，而若直接使用<code>new</code>运算符，内存的释放就不必等待<code>std::weak_ptr</code>的析构。</li></ul><p>如果你发现自己处于不应该使用<code>std::make_shared</code>的情形下，又不想受到之前所述异常安全问题的影响。最好的方法是确保在直接使用<code>new</code>时，立即将结果传递给智能指针的构造函数，并且在这条语句中不做其它任何事：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> cusDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="条款-22：使用-Pimpl-惯用法时，将特殊成员函数的定义放到实现文件中"><a href="#条款-22：使用-Pimpl-惯用法时，将特殊成员函数的定义放到实现文件中" class="headerlink" title="条款 22：使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中"></a>条款 22：使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中</h3><p>Pimpl 惯用法的第一部分，是声明一个指针类型的数据成员，指向一个非完整类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> Impl<span class="token punctuation">;</span>    Impl<span class="token operator">*</span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二部分是动态分配和回收持有原始类中数据成员的对象，而分配和回收的代码被放在实现文件中：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Widget<span class="token operator">::</span>Impl <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">// Widget::Impl 的实现</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 包含在原始 Widget 类中的数据成员</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span>    Gadget g1<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> g3<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span><span class="token keyword">new</span> Impl<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 为 Widget 对象分配数据成员所需内存</span>Widget<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> pImpl<span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 为 Widget 对象析构数据成员</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面展示的是 C++98 的写法，使用了裸指针、裸<code>new</code>运算符和裸<code>delete</code>运算符。而到了 C++11，使用<code>std::unique_ptr</code>替代指向<code>Impl</code>的裸指针成为了首选：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明代码位于头文件 widget.h 内</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> Impl<span class="token punctuation">;</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 实现代码位于实现文件 widget.cpp 内</span><span class="token keyword">struct</span> Widget<span class="token operator">::</span>Impl <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 同前</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span>    Gadget g1<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> g3<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Impl<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遗憾的是，这段代码本身能通过编译，但在创建对象时却会报错。因为编译器自动生成的析构函数默认是<code>inline</code>的，而<code>std::unique_ptr</code>的默认删除器要求其指向完整类型，所以即使默认特殊函数的实现有着正确行为，我们仍必须将其声明和实现分离：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明代码位于头文件 widget.h 内</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> Impl<span class="token punctuation">;</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 实现代码位于实现文件 widget.cpp 内</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Impl<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>Widget<span class="token operator">::</span><span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 写成 Widget::~Widget() = default; 效果相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<strong>条款 17</strong> 中我们提到，声明析构函数会阻止编译器生成移动操作，所以假如你需要支持移动操作，也必须采用声明和实现分离的方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明代码位于头文件 widget.h 内</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 实现代码位于实现文件 widget.cpp 内</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器不会为带有<code>std::unique_ptr</code>这种只移类型的类生成拷贝操作，假如你需要支持拷贝操作，则需要自行编写执行深拷贝的函数实现，并且同样需要遵守前面所说的规则：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 声明代码位于头文件 widget.h 内</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 实现代码位于实现文件 widget.cpp 内</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Widget<span class="token operator">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Impl<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>pImpl <span class="token operator">=</span> <span class="token operator">*</span>rhs<span class="token punctuation">.</span>pImpl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述建议仅仅适用于<code>std::unique_ptr</code>，而不适用于<code>std::shared_ptr</code>。对于<code>std::shared_ptr</code>而言，删除器类型并非智能指针类型的一部分，这就会导致更大的运行时数据结构以及更慢的目标代码，但在使用编译器生成的特殊函数时，并不要求其指向完整类型。以下代码并不会产生问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token comment" spellcheck="true">// 不再需要析构函数或移动操作的声明</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> Impl<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就 Pimpl 惯用法而言，并不需要在<code>std::unique_ptr</code>和<code>std::shared_ptr</code>的特性之间作出权衡，因为<code>Widget</code>和<code>Impl</code>之间的关系是专属所有权，所以在此处<code>std::unique_ptr</code>就是完成任务的合适工具。</p><h2 id="第五章：右值引用、移动语义和完美转发"><a href="#第五章：右值引用、移动语义和完美转发" class="headerlink" title="第五章：右值引用、移动语义和完美转发"></a>第五章：右值引用、移动语义和完美转发</h2><p>在阅读本章中的条款时，需要铭记一点：形参总是左值，即使其类型是右值引用。例如给定函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>尽管形参<code>w</code>的类型是指向<code>Widget</code>对象的右值引用，可以传入绑定到右值的实参，但它仍然是个左值。</p><h3 id="条款-23：理解-std-move-和-std-forward"><a href="#条款-23：理解-std-move-和-std-forward" class="headerlink" title="条款 23：理解 std::move 和 std::forward"></a>条款 23：理解 std::move 和 std::forward</h3><p><code>std::move</code>执行的是向右值的无条件强制类型转换，就其自身而言，它不会移动任何东西。它的基本实现大致是这样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// C++11 版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">typename</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> ReturnType <span class="token operator">=</span> <span class="token keyword">typename</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ReturnType<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// C++14 版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> ReturnType <span class="token operator">=</span> remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ReturnType<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::move</code>并不改变常量性，也不保证经过其强制类型转换后的对象可被移动，针对常量对象执行的移动操作可能会悄无声息地转化为拷贝操作，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Annotation</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Annotation</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string text<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 想要将 text “移动入” value</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 但实际上执行了 std::string 的拷贝构造函数</span>                                            <span class="token comment" spellcheck="true">// 而非移动构造函数 string(string&amp;&amp;)</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，如果想要取得对某个对象执行移动操作的能力，就不要将其声明为常量。</p><p>与<code>std::move</code>不同，<code>std::forward</code>是有条件的。仅当传入的实参被绑定到右值时，<code>std::forward</code>才会针对该实参执行向右值的强制类型转换，它同样不会转发任何东西。</p><p><code>std::forward</code>的一个典型应用场景，是某个函数模板使用万能引用作为形参，随后将其传递给另一个函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> lvalArg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 处理左值</span><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rvalArg<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 处理右值</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">logAndProcess</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 使用万能引用作为实参</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span><span class="token string">"Calling 'process'"</span><span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若在调用<code>logAndProcess</code>时传入左值，那么该左值自然会传递给处理左值版本的<code>process</code>函数；若在调用<code>logAndProcess</code>时传入右值，由于函数形参皆为左值，必须要通过<code>std::forward</code>将<code>param</code>强制转换为右值类型，才能得以正确调用处理右值版本的<code>process</code>函数。<code>std::forward</code>会通过模板类型<code>T</code>来判断是否该对<code>param</code>进行强制类型转换，具体的原理细节参考<strong>条款 28</strong>。</p><p>尽管<code>std::move</code>和<code>std::forward</code>归根结底都是强制类型转换，但两者的行为具有本质上的不同：前者用于为移动操作进行铺垫，而后者仅仅用于转发一个对象到另一个函数，在此过程中该对象仍保持原来的左值性或右值性。</p><blockquote><p>需要注意的是，在运行期，<code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p></blockquote><h3 id="条款-24：区分万能引用和右值引用"><a href="#条款-24：区分万能引用和右值引用" class="headerlink" title="条款 24：区分万能引用和右值引用"></a>条款 24：区分万能引用和右值引用</h3><p>如果函数模板形参的类型为<code>T&amp;&amp;</code>，并且 T 的类型需要推导得到，或一个对象使用<code>auto&amp;&amp;</code>声明其类型，则此处的<code>T&amp;&amp;</code>和<code>auto&amp;&amp;</code>表示<strong>万能引用（universal reference）</strong>；如果类型声明不是标准的<code>type&amp;&amp;</code>形式，或者并未发生类型推导，则此处的<code>type&amp;&amp;</code>表示右值引用。</p><p>符合万能引用的情形如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> var2 <span class="token operator">=</span> var1<span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> timeFuncInvocation <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> func<span class="token punctuation">,</span> <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// C++14</span>    std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span>                         <span class="token comment" spellcheck="true">// 调用 func</span>        std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               <span class="token comment" spellcheck="true">// 取用 params</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型声明不是标准<code>type&amp;&amp;</code>的情形如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// param 是右值引用</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// param 是右值引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型是<code>T&amp;&amp;</code>，但并未发生类型推导的情形如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// x 是右值引用</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若使用右值来初始化万能引用，就会得到一个右值引用；同理，若使用左值来初始化万能引用，就会得到一个左值引用。如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// param 是万能引用</span>Widget w<span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 左值被传递给 f，param 的类型为 Widget&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右值被传递给 f，param 的类型为 Widget&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-25：针对右值引用实施-std-move，针对万能引用实施-std-forward"><a href="#条款-25：针对右值引用实施-std-move，针对万能引用实施-std-forward" class="headerlink" title="条款 25：针对右值引用实施 std::move，针对万能引用实施 std::forward"></a>条款 25：针对右值引用实施 std::move，针对万能引用实施 std::forward</h3><p>右值引用一定会被绑定到右值，因此当转发右值引用给其他函数时，应当通过<code>std::move</code>对其实施向右值的无条件强制类型转换：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">p</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SomeDataStructure<span class="token operator">></span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而万能引用不一定会被绑定到右值，因此当转发万能引用时，应当通过<code>std::forward</code>对其实施向右值的有条件强制类型转换：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然针对右值引用实施<code>std::forward</code>也能硬弄出正确行为，但代码啰嗦、易错，且不符合习惯用法；而针对万能引用实施<code>std::move</code>会造成更加严重的后果，这会导致某些左值遭受意外的改动：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SomeDataStructure<span class="token operator">></span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>string <span class="token function">getWidgetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 工厂函数</span>Widget w<span class="token punctuation">;</span><span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token function">getWidgetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 将 n 移入 w</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                         <span class="token comment" spellcheck="true">// n 的值变为未知</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一种手法是将万能引用的版本改成对左值和右值分别进行重载：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> newName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        name <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种手法虽然看似可以解决问题，但是拥有更大的缺点：第一，需要编写和维护更多源码；第二，效率会大打折扣（产生额外的临时对象）；第三，可扩展性太差。因此，正确地使用万能引用才是问题的唯一解决之道。</p><p>在有些情况下，你可能想在函数内将某个对象不止一次地绑定到右值引用或万能引用，并且想保证在完成对该对象地其它所有操作之前，其值不会发生移动，那么就得仅在最后一次使用该引用时，对其实施<code>std::move</code>或<code>std::forward</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">setSignText</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> text<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sign<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 使用 text，但不修改其值</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    signHistory<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 有条件地将 text 强制转换为右值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在极少数的情况下，你需要用<code>std::move_if_noexcept</code>来代替<code>std::move</code>。</p><blockquote><p><code>std::move_if_noexcept</code>是<code>std::move</code>的一个变体，它是否会将对象强制转换为右值，取决于其类型的移动构造函数是否带有 noexcept 声明。</p></blockquote><p>在按值返回的函数中，如果返回的是绑定到右值引用或万能引用的对象，则当你返回该引用时，应当对其实施<code>std::move</code>或<code>std::forward</code>，这样可以避免编译器将其视作左值，从而消除拷贝左值进入返回值存储位置的额外开销：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 按值返回右值引用形参</span>Matrix <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>Matrix<span class="token operator">&amp;&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Matrix<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    lhs <span class="token operator">+</span><span class="token operator">=</span> rhs<span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 按值返回万能引用形参</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>Fraction <span class="token function">reduceAndCopy</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> frac<span class="token punctuation">)</span> <span class="token punctuation">{</span>    frac<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>frac<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是若局部对象可能适用于<strong>返回值优化（return value optimization，RVO）</strong>，则请勿对其实施<code>std::move</code>或<code>std::forward</code>。这是因为当 RVO 的前提条件得到满足时，要么发生<strong>拷贝省略（copy elision）</strong>，要么<code>std::move</code>会隐式地被实施于返回的局部对象上；而人为地添加<code>std::move</code>或<code>std::forward</code>，会导致编译器失去执行 RVO 的能力。</p><p>下面的<code>makeWidget</code>函数满足 RVO 的两个前提条件：局部对象类型和函数返回值类型相同，且返回的就是局部对象本身：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> w<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但由于函数形参不适合实施拷贝省略，所以编译器必须处理以上代码，使其与以下代码等价：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-26：避免对万能引用类型进行重载"><a href="#条款-26：避免对万能引用类型进行重载" class="headerlink" title="条款 26：避免对万能引用类型进行重载"></a>条款 26：避免对万能引用类型进行重载</h3><p>形参为万能引用的函数是 C++ 中最贪婪的，它们会在具现过程中和几乎所有实参类型产生精确匹配（极少的不适用实参将在<strong>条款 30</strong> 中介绍），这就是为何把重载和万能引用两者结合通常不会达到预期效果。考虑如下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>string <span class="token function">nameFromIdx</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">short</span> nameIdx<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 用 short 类型持有索引值</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">logAndAdd</span><span class="token punctuation">(</span>nameIdx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用的却是万能引用版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>logAndAdd</code>有两个重载版本，形参类型为万能引用的版本可以将<code>T</code>推导为<code>short</code>，从而产生精确匹配；而形参类型为<code>int</code>的版本却只能在类型提升后才可以匹配到<code>short</code>类型的实参。因此，形参类型为万能引用的版本才是被优先调用的版本。</p><p>当完美转发出现在类的构造函数中时，情况会变得更加复杂：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>        <span class="token comment" spellcheck="true">// 完美转发构造函数</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 形参为 int 的构造函数</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 拷贝构造函数（由编译器生成）</span>    <span class="token function">Person</span><span class="token punctuation">(</span>Person<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 移动构造函数（由编译器生成）</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于非常量的左值类型，完美转发构造函数一般都会优先于拷贝构造函数形成匹配；而对于常量左值类型，完美转发构造函数和拷贝构造函数具有相等的匹配程度，此时由于非函数模板会优先于函数模板被匹配，编译器才会转向调用拷贝构造函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Person <span class="token function">p</span><span class="token punctuation">(</span><span class="token string">"Nancy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> <span class="token function">cloneOfP</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 调用完美转发构造函数，无法通过编译</span><span class="token keyword">const</span> Person <span class="token function">cp</span><span class="token punctuation">(</span><span class="token string">"Nancy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 对象成为了常量</span><span class="token keyword">auto</span> <span class="token function">cloneOfCp</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 会正确调用拷贝构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完美转发构造函数还会劫持派生类中对基类的拷贝和移动构造函数的调用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SpecialPerson</span> <span class="token operator">:</span> <span class="token keyword">public</span> Person <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">SpecialPerson</span><span class="token punctuation">(</span><span class="token keyword">const</span> SpecialPerson<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 拷贝构造函数</span>        <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 调用的是基类的完美转发构造函数！</span>    <span class="token function">SpecialPerson</span><span class="token punctuation">(</span>SpecialPerson<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 移动构造函数</span>        <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// 调用的是基类的完美转发构造函数！</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-27：熟悉对万能引用类型进行重载的替代方案"><a href="#条款-27：熟悉对万能引用类型进行重载的替代方案" class="headerlink" title="条款 27：熟悉对万能引用类型进行重载的替代方案"></a>条款 27：熟悉对万能引用类型进行重载的替代方案</h3><p><strong>1. 放弃重载</strong></p><p><strong>2. 传递<code>const T&amp;</code>类型的形参</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法可以避免重载万能引用带来的不良影响，但会舍弃一些性能。</p><p><strong>3. 传值</strong></p><p>把传递的形参从引用类型换成值类型，是一种经常能够提升性能，却不会增加任何复杂性的方法，尽管这有些反直觉。这种设计遵循了<strong>条款 41</strong> 的建议——当你知道肯定需要复制形参时，考虑按值传递对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string n<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 替换掉 T&amp;&amp; 类型的构造函数</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 同前</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 使用标签分派（tag dispatch）</strong></p><p>在这个方案中，我们将实际重载和实现功能的函数改为<code>logAndAddImpl</code>，而<code>logAndAdd</code>仅仅用于执行完美转发和标签分派：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">logAndAddImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>        std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// C++14 可以使用 std::remove_reference_t</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对<code>std::is_integral</code>产生的布尔值，我们可以写出两个<code>logAndAddImpl</code>重载版本，用于区分它们的类型<code>std::false_type</code>和<code>std::true_type</code>就是所谓 “标签”。具体实现代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">logAndAddImpl</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">,</span> std<span class="token operator">::</span>false_type<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 非整型实参</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>string <span class="token function">nameFromIdx</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">logAndAddImpl</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> std<span class="token operator">::</span>true_type<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 整型实参</span>    <span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. 对接受万能引用的模板施加限制</strong></p><p>通过 SFINAE 技术和<code>std::enable_if</code>，我们可以让一些模板在满足了指定条件的情况下才被启用，它的使用方式大致如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span>             <span class="token keyword">typename</span> <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span>condition<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span>    <span class="token comment" spellcheck="true">// C++14 可以使用 std::enable_if_t</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处我们想要<code>T</code>是<code>Person</code>以外的类型时，才启用该模板构造函数，则我们可以写下面这样的条件：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token operator">!</span>std<span class="token operator">::</span>is_same<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>decay<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span><span class="token operator">::</span>value  <span class="token comment" spellcheck="true">// C++17 可以使用 std::is_same_v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>std::decay</code>用于使类型完全退化，在此处用来移除<code>T</code>的引用和 cv 限定符（即<code>const</code>或<code>volatile</code>限定符），使我们可以更加纯粹地关注类型本身。<code>std::decay</code>还可以用于把数组和函数类型强制转换为指针类型（参考<strong>条款 1</strong>），它当然也拥有更易用的 C++14 版本，即<code>std::decay_t</code>。</p><p>写出这个条件并不意味着完成，<strong>条款 26</strong> 中还提到了在派生类中调用基类的拷贝和移动构造函数时，错误调用完美转发构造函数的问题。因此，我们想要的是为<code>Person</code>和继承自<code>Person</code>的类型都不一样的实参类型启用模板构造函数。标准库中的<code>std::is_base_of</code>用于判断一个类型是否由另一个类型派生而来，用它代替<code>std::is_same</code>就可以得到我们想要的东西（C++17 可以使用<code>std::is_base_of_v</code>）：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span>        <span class="token keyword">typename</span> T<span class="token punctuation">,</span>        <span class="token keyword">typename</span> <span class="token operator">=</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span>                       <span class="token operator">!</span>std<span class="token operator">::</span>is_base_of<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span>                                         <span class="token keyword">typename</span> std<span class="token operator">::</span>decay<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type                                       <span class="token operator">></span><span class="token operator">::</span>value                   <span class="token operator">></span><span class="token operator">::</span>type    <span class="token operator">></span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再加上处理整型实参的构造函数重载版本，并进一步限制模板构造函数，禁止其接受整型实参，我们得到的完美的<code>Person</code>类代码如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span>        <span class="token keyword">typename</span> T<span class="token punctuation">,</span>        <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>            <span class="token operator">!</span>std<span class="token operator">::</span>is_base_of<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> std<span class="token operator">::</span>decay_t<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token operator">::</span>value            <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span>std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span>std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token operator">::</span>value        <span class="token operator">></span>    <span class="token operator">></span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">// 接受 std::string 类型以及可以强制转换为 </span>    <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// std::string 类型的实参的构造函数</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 接受整型实参的构造函数</span>    <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment" spellcheck="true">// 拷贝和移动构造函数等</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>权衡</strong></p><p>本条款讨论的前三种方案（舍弃重载，传递<code>const T&amp;</code>类型的形参和传值）都需要对待调用的函数形参逐一指定类型，而后两种方案（使用标签分派和对接受万能引用的模板施加限制）则使用了完美转发，因此无需指定形参类型。</p><p>按照常理，完美转发的效率更高，因为它将类型保持和形参声明时完全一致，所以会避免创建临时对象。但完美转发也有一些不足：首先是针对某些类型无法实现完美转发（参考<strong>条款 30</strong>），其次是完美转发会使得在传递非法形参时，出现更难理解的错误信息。</p><p><code>std::is_constructible</code>这个类型特征（type trait）可以在编译期判断某个类型的对象是否可以用另一类型的对象（或不同类型的多个对象）来构造，我们可以用它来验证转发函数的万能引用形参是否合法。下面是增加了<code>static_assert</code>后的<code>Person</code>类，它可以产生更明确的报错信息：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">>></span>  <span class="token comment" spellcheck="true">// 同前</span>    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 断言可以用 T 类型的对象构造 std::string</span>        <span class="token keyword">static_assert</span><span class="token punctuation">(</span>            std<span class="token operator">::</span>is_constructible<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// C++17 可以使用 std::is_constructible_v</span>            <span class="token string">"Parameter n can't be used to construct a std::string"</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// 构造函数通常要完成的工作</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-28：理解引用折叠"><a href="#条款-28：理解引用折叠" class="headerlink" title="条款 28：理解引用折叠"></a>条款 28：理解引用折叠</h3><p>在<strong>条款 24</strong> 中我们了解了万能引用和右值引用的区别，但实际上万能引用并非一种新的引用类型，其实它就是在满足下面两个条件的语境中的右值引用：</p><ol><li>类型推导的过程中会区分左值和右值；</li><li>会发生<strong>引用折叠（reference collapsing）</strong>。</li></ol><p>C++ 标准禁止直接声明 “引用的引用” ，但引用折叠不受此限制。当左值被传递给接受万能引用的函数模板时，会发生下面这样的状况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用 func 并传入左值，T 推导出的类型为 Widget&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>代入<code>T</code>的推导类型，我们可以得到下面这样的具现化模板：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现了引用的引用！然而这并不违规，引用折叠的规则会把双重引用折叠成单个引用，规则如下：</p><blockquote><p>如果任一引用为左值引用，则结果为左值引用，否则（即两个皆为右值引用），结果为右值引用。</p></blockquote><p>所以实际上的函数签名为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>引用折叠是使<code>std::forward</code>得以运作的关键，也是将左值或右值信息编码到万能引用形参<code>T</code>中的实现途径。<code>std::forward</code>的任务是，当且仅当编码在<code>T</code>中的信息表明传递的实参是右值，即<code>T</code>推导出的类型是个非引用类型时，对左值形参实施到右值的强制类型转换。它的基本实现大致是这样的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// C++11 版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// C++14 版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设传递给函数<code>forward</code>的实参类型是左值<code>Widget</code>，则模板的具现化结果可以写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>发生引用折叠后，生成的最终结果如下，可以看出左值类型并不会发生改变：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>假设传递给函数<code>forward</code>的实参类型是右值<code>Widget</code>，则模板的具现化结果可以写成：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>发生引用折叠后，生成的最终结果如下，显然左值类型的形参会被强制转换为右值：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>引用折叠会在四种语境中出现：模板具现化，<code>auto</code>类型推断，创建和使用<code>typedef</code>和别名声明，以及<code>decltype</code>。</p><p><code>auto</code>类型推断中发生的引用折叠：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 变量（左值）</span>Widget <span class="token function">widgetFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回右值的函数</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> w1 <span class="token operator">=</span> w<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 推导出 Widget&amp; &amp;&amp; w1，引用折叠后为 Widget&amp; w1</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> w2 <span class="token operator">=</span> <span class="token function">widgetFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 推导出 Widget&amp;&amp; w1，不会发生引用折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建和使用<code>typedef</code>中发生的引用折叠：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> T<span class="token operator">&amp;&amp;</span> RvalueRefToT<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Widget<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span> w<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用左值引用类型来具现化 Widget 模板</span><span class="token comment" spellcheck="true">// 具现化后得到 typedef int&amp; &amp;&amp; RvalueRefToT</span><span class="token comment" spellcheck="true">// 引用折叠后为 typedef int&amp; RvalueRefToT</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一种会发生引用折叠的语境在<code>decltype</code>的运用中：如果在分析一个涉及<code>decltype</code>的类型时出现了引用的引用，则引用折叠会介入并将其消灭。</p><h3 id="条款-29：假定移动操作不存在、成本高、未被使用"><a href="#条款-29：假定移动操作不存在、成本高、未被使用" class="headerlink" title="条款 29：假定移动操作不存在、成本高、未被使用"></a>条款 29：假定移动操作不存在、成本高、未被使用</h3><p>在下面几个情形下，C++11 的移动语义不会给你带来什么好处：</p><ul><li><strong>没有移动操作：</strong> 待移动的对象未能提供移动操作。因此，移动请求就变成了拷贝请求。</li><li><strong>移动未能更快：</strong> 待移动的对象虽然有移动操作，但并不比其拷贝操作更快。</li></ul><blockquote><p>移动操作不比拷贝操作更快的例子：<code>std::array</code>将数据直接存储在对象内，移动<code>std::array</code>需要逐个移动容器内的每个元素；开启了<strong>短字符串优化（small string optimization，SSO）</strong> 的<code>std::string</code>，它会将字符串存储在<code>std::string</code>对象的某个缓冲区内，而非使用堆上的内存。</p></blockquote><ul><li><strong>移动不可用：</strong> 移动本可以发生的情况下，要求移动操作不会抛出异常，但该操作未加上<code>noexcept</code>声明。</li><li><strong>源对象是左值：</strong> 只有右值可以作为移动操作的源。</li></ul><p>因此，我们应该为通用的代码假定移动操作不存在、成本高且未被使用。然而，对于已知的类型或支持移动语义的代码中，就不需要作上述假定，在你知道移动操作成本低廉的情况下，可以放心大胆地将拷贝操作替换为相对不那么昂贵的移动操作。</p><h3 id="条款-30：熟悉完美转发的失败情形"><a href="#条款-30：熟悉完美转发的失败情形" class="headerlink" title="条款 30：熟悉完美转发的失败情形"></a>条款 30：熟悉完美转发的失败情形</h3><p>完美转发的含义是我们不仅转发对象，还转发其特征：类型，是左值还是右值，以及是否带有<code>const</code>和<code>volatile</code>限定符。出于此目的，我们会运用万能引用来将左、右值信息编码到类型中，而用于转发的函数自然也该是泛型的，它的标准形式如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fwd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了使转发函数能接受任意数量的形参，使用可变参数模板也在我们的考虑范围内：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fwd</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>若用相同实参调用<code>f</code>和<code>fwd</code>会执行不同的操作，则称<code>fwd</code>将实参完美转发到<code>f</code>失败。完美转发的失败情形源于模板类型推导失败，或推导出错误的类型。下面我们将了解会造成完美转发失败的典型例子。</p><p><strong>大括号初始值设定项（Braced initializers）</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// “{ 1, 2, 3 }” 会隐式转换为 std::vector&lt;int></span><span class="token function">fwd</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 无法通过编译！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于<code>fwd</code>的形参为被声明为<code>std::initializer_list</code>，编译器就会被禁止在<code>fwd</code>的调用过程中从表达式<code>{ 1, 2, 3 }</code>出发来推导类型。既然无法推导出形参的类型，那么编译器也只能拒绝对<code>fwd</code>的调用。</p><p>我们可以通过先用<code>auto</code>声明一个局部变量，再传递给<code>fwd</code>来避免这个问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> il <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// il 的类型被推导为 std::initializer_list&lt;int></span><span class="token function">fwd</span><span class="token punctuation">(</span>il<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 没问题，将 il 完美转发给 f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>0 和 NULL 作空指针</strong></p><p><strong>条款 8</strong> 中曾经说明过，当你试图将<code>0</code>或<code>NULL</code>作为空指针传递给模板时，类型推导就会发生错误，将实参推导为一个整型而非指针类型，结果不管是<code>0</code>还是<code>NULL</code>都不会作为空指针被完美转发。解决方法非常简单，传一个<code>nullptr</code>而不是<code>0</code>或<code>NULL</code>。</p><p><strong>仅有声明的整型<code>static const</code>成员变量</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> std<span class="token operator">::</span>size_t MinVals <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 仅提供 MinVals 的声明</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                          <span class="token comment" spellcheck="true">// 未给出 MinVals 的定义</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>Widget<span class="token operator">::</span>MinVals<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 没问题，当作 “f(28)” 处理</span><span class="token function">fwd</span><span class="token punctuation">(</span>Widget<span class="token operator">::</span>MinVals<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 可能无法通过链接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般而言，编译器会绕过<code>MinVals</code>缺少定义的事实，并用其值替换所有涉及到<code>MinVals</code>的地方，但并不会为其实际分配存储空间。这就导致如果我们尝试对<code>MinVals</code>实施取地址或对它进行引用，就会导致链接无法通过，这也就是为何不能将<code>Widget::MinVals</code>作为实参传递给<code>fwd</code>。</p><p>按照标准，按引用传递<code>MinVals</code>时要求<code>MinVals</code>有定义。然而并不是所有实现都遵循了这个规定，对于一些编译器和链接器，你会发现将<code>MinVals</code>用于完美转发并不会产生错误，甚至对它取地址也不会。但为了代码的可移植性，还是应当重视此处所讲的规则，为<code>static const</code>成员变量提供定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> std<span class="token operator">::</span>size_t Widget<span class="token operator">::</span>MinVals<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 在 Widget 的 .cpp 文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>重载函数的名称和模板名称</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 或者 void f(int pf(int))</span><span class="token keyword">int</span> <span class="token function">processVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">processVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>processVal<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 没问题</span><span class="token function">fwd</span><span class="token punctuation">(</span>processVal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 错误！无法确定是哪个重载版本</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>T <span class="token function">workOnVal</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token function">fwd</span><span class="token punctuation">(</span>workOnVal<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 错误！无法确定是 workOnVal 的哪个实例</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们将<code>processVal</code>传递给<code>f</code>时，由于<code>f</code>的形参类型是已知的，编译器自然也知道它需要的是<code>processVal</code>的哪个重载版本；但纯粹的函数名称<code>processVal</code>并不包含类型信息，类型推导更是无从谈起，将它传递给<code>fwd</code>只会造成完美转发失败而已。</p><p>要让<code>fwd</code>接受重载函数的名称或模板名称，只能手动指定需要转发的哪个重载版本或模板实例。例如下面的做法就是合理的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> ProcessFuncType <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ProcessFuncType processValPtr <span class="token operator">=</span> processVal<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 指定了需要的 processVal 签名</span><span class="token function">fwd</span><span class="token punctuation">(</span>processValPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// 没问题</span><span class="token function">fwd</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ProcessFuncType<span class="token operator">></span><span class="token punctuation">(</span>workOnVal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 也没问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>位域</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> IPv4Header <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">// 用于表示 IPv4 头部的模型</span>    std<span class="token operator">::</span>uint32_t version<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>                  IHL<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>                  DSCP<span class="token operator">:</span><span class="token number">6</span><span class="token punctuation">,</span>                  ECN<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>                  totalLength<span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>size_t sz<span class="token punctuation">)</span><span class="token punctuation">;</span>IPv4Header h<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 没问题</span><span class="token function">fwd</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 错误！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++ 标准规定：非常引用不得绑定到位域。位域是由机器字的若干任意部分组成的，但这样的实体是无法对其直接取地址的，无法将指针指向它，因此也无法对其进行引用。</p><blockquote><p>实际上常引用也不可能绑定到位域，它们绑定到的是 “常规” 对象（某种标准整型，例如<code>int</code>），其中拷贝了位域的值。</p></blockquote><p>将位域传递给转发函数的可能途径是制作一个副本，并以该副本调用转发函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 拷贝位域值，使用的初始化形式参考条款 6</span><span class="token keyword">auto</span> length <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>uint16_t<span class="token operator">></span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwd</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转发该副本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第六章：lambda-表达式"><a href="#第六章：lambda-表达式" class="headerlink" title="第六章：lambda 表达式"></a>第六章：lambda 表达式</h2><p>在开始本章之前，需要理解几个基本的概念：</p><ul><li><strong>lambda 表达式（lambda expression）：</strong> 表达式的一种，它的基本写法如下所示：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;</span> val <span class="token operator">&amp;&amp;</span> val <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>闭包（closure）：</strong> lambda 所创建的运行期对象，根据不同的捕获模式，闭包会持有数据的副本或引用。</li><li><strong>闭包类（closure class）：</strong> 实例化闭包的类，每个 lambda 都会使编译器生成唯一的闭包类。lambda 中的语句会成为其闭包类的成员函数中的可执行指令。</li></ul><blockquote><p>lambda 表达式和闭包类存在于编译期，而闭包存在于运行期。</p></blockquote><h3 id="条款-31：避免默认捕获模式"><a href="#条款-31：避免默认捕获模式" class="headerlink" title="条款 31：避免默认捕获模式"></a>条款 31：避免默认捕获模式</h3><p>C++11 中有两种默认捕获模式：按引用或按值。按引用捕获会导致闭包内包含指向局部变量的引用，或指向定义 lambda 的作用域内形参的引用，一旦由 lambda 所创建的闭包越过了该局部变量或形参的生命周期，那么闭包内的引用就会发生空悬：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> FilterContainer <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">;</span>FilterContainer filters<span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">// 元素为筛选函数的容器</span><span class="token keyword">void</span> <span class="token function">addDivisorFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> calc1 <span class="token operator">=</span> <span class="token function">computeSomeValue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> calc2 <span class="token operator">=</span> <span class="token function">computeSomeValue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> divisor <span class="token operator">=</span> <span class="token function">computeDivisor</span><span class="token punctuation">(</span>calc1<span class="token punctuation">,</span> calc2<span class="token punctuation">)</span><span class="token punctuation">;</span>    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 危险！指向 divisor 的引用可能空悬</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换作用显式方式按引用捕获<code>divisor</code>，问题依旧会发生，但更容易看出 lambda 依赖于<code>divisor</code>的生命周期这一问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token operator">&amp;</span>divisor<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一种权宜之计是不使用容器来存放筛选函数，转而使用 C++11 的<code>std::all_of</code>对每个元素逐一进行判断。但如果将该 lambda 拷贝到其它闭包比<code>divisor</code>生命周期更长的语境中，则空悬引用的问题仍会发生：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> C<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">workWithContainer</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> calc1 <span class="token operator">=</span> <span class="token function">computeSomeValue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> calc2 <span class="token operator">=</span> <span class="token function">computeSomeValue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> divisor <span class="token operator">=</span> <span class="token function">computeDivisor</span><span class="token punctuation">(</span>calc1<span class="token punctuation">,</span> calc2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> ContElemT <span class="token operator">=</span> <span class="token keyword">typename</span> C<span class="token operator">::</span>value_type<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 取得容器中的元素类型（参考条款 13）</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>begin<span class="token punctuation">;</span>    <span class="token keyword">using</span> std<span class="token operator">::</span>end<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">all_of</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 判断是否所有元素都是 divisor 的倍数</span>        <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> ContElemT<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">// C++14 可以直接写成 const auto&amp; value</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本例中，使用默认的按值捕获模式就足以解决问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp">filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是默认的按值捕获模式也有其问题：默认的按值捕获极易受到空悬指针的影响（尤其是<code>this</code>指针），并且会误导人们认为 lambda 是独立的。考虑如下情形：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> divisor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用于 Widget 的 filters</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于此处的 lambda 而言，<code>divisor</code>既不是局部变量，也不是形参，按理来讲是压根无法被捕获的。事实也确实如此，被捕获的实际上是<code>Widget</code>的<code>this</code>指针，而不是<code>divisor</code>。对于编译器来说，<code>addFilter</code>的代码相当于：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> currentObjectPtr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span>currentObjectPtr<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> currentObjectPtr<span class="token operator">-</span><span class="token operator">></span>divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>理解了这一点，也就能理解 lambda 闭包的存活依赖于它含有的<code>this</code>指针副本所指向的<code>Widget</code>对象的生命周期。假如面临以下代码，空悬指针的问题将出现在我们的眼前：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> FilterContainer <span class="token operator">=</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">;</span>FilterContainer filters<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 同前</span><span class="token keyword">void</span> <span class="token function">doSomeWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> pw <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 创建 Widget，std::make_unique 的使用参考条款 21</span>    pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 添加使用了 Widget::divisor 的筛选函数</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>                                           <span class="token comment" spellcheck="true">// Widget 被销毁，filters 现在持有空悬指针！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一种解决方法是将你想捕获的成员变量拷贝至局部变量中，之后再捕获该副本局部变量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> divisorCopy <span class="token operator">=</span> divisor<span class="token punctuation">;</span>    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span>divisorCopy<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisorCopy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++14 中，捕获成员变量的一种更好的方法是使用<strong>广义 lambda 捕获（generalized lambda capture，参考条款 32）</strong>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> Widget<span class="token operator">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span>divisor <span class="token operator">=</span> divisor<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// C++14: 将 divisor 拷贝入闭包并使用副本</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认的按值捕获模式的另一个缺点是，它会使人们误认为闭包是独立的，与闭包外的数据变化相隔绝。但实际上并非如此，lambda 可能不仅依赖于局部变量和形参，还会依赖于<strong>静态存储期（static storage duration）对象</strong>，这样的对象可以在 lambda 中使用，但却无法被捕获。下面这个例子足以体现这一点会造成的问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">addDivisorFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">auto</span> calc1 <span class="token operator">=</span> <span class="token function">computeSomeValue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">auto</span> calc2 <span class="token operator">=</span> <span class="token function">computeSomeValue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">auto</span> divisor <span class="token operator">=</span> <span class="token function">computeDivisor</span><span class="token punctuation">(</span>calc1<span class="token punctuation">,</span> calc2<span class="token punctuation">)</span><span class="token punctuation">;</span>    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>        <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true">// 未捕获任何东西！</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 引用上面的 static 对象</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>divisor<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 意外修改了 divisor</span>                                            <span class="token comment" spellcheck="true">// 导致每个 lambda 都出现新的行为</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-32：使用初始化捕获将对象移入闭包"><a href="#条款-32：使用初始化捕获将对象移入闭包" class="headerlink" title="条款 32：使用初始化捕获将对象移入闭包"></a>条款 32：使用初始化捕获将对象移入闭包</h3><p>C++14 中新增的<strong>初始化捕获（init capture，又称广义 lambda 捕获）</strong>，可以让你指定：</p><ol><li>由 lambda 生成的闭包类中成员变量的名字。</li><li>一个用于初始化该成员变量的表达式。</li></ol><p>下面演示了如何使用初始化捕获将<code>std::unique_ptr</code>移入闭包内：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">isProcessed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> pw <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 创建 Widget，std::make_unique 的使用参考条款 21</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 配置 *pw</span><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">// 使用 std::move(pw) 初始化闭包类的数据成员</span>            <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果经由<code>std::make_unique</code>创建的对象已具备被 lambda 捕获的合适状态，则闭包类成原对象可以直接由<code>std::make_unique</code>完成初始化：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在初始化捕获的代码中，位于<code>=</code>左侧的是所指定的闭包类成员变量的名称，右侧的则是其初始化表达式。值得一提的是，<code>=</code>的左右两侧位于不同的作用域，左侧作用域就是闭包的作用域，而右侧作用域则与 lambda 定义所在的作用域相同。</p><p>在 C++11 中，我们虽然无法使用初始化捕获，但是可以依靠原理相同的手写类达到目的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">IsValAndArch</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> DataType <span class="token operator">=</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token keyword">explicit</span> <span class="token function">IsValAndArch</span><span class="token punctuation">(</span>DataType<span class="token operator">&amp;&amp;</span> ptr<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// std::move 的使用参考条款 25</span>        <span class="token operator">:</span> <span class="token function">pw</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// 编写仿函数</span>        <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    DataType pw<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token function">IsValAndArch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你非要使用 lambda，按移动捕获也可以通过以下方法模拟：</p><ol><li>将需要捕获的对象移至<code>std::bind</code>所产生的函数对象中。</li><li>给予 lambda 一个指向想要 “捕获” 的对象的引用。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span><span class="token keyword">auto</span> func <span class="token operator">=</span>    std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// C++11 模拟初始化捕获</span>              <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 使用 data */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>              std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::bind</code>的第一个实参是个可调用对象，接下来的所有实参表示传给该对象的值。和 lambda 表达式类似，<code>std::bind</code>也会生成函数对象（原书中称其为<strong>绑定对象，bind object</strong>），其中含有传递给<code>std::bind</code>的所有实参的副本，其中左值实参执行的是拷贝构造，而右值实参执行的则是移动构造。因此，在此处用<code>std::move(data)</code>作为实参可以让<code>data</code>被移入绑定对象中，被 lambda 的左值引用形参所接受。</p><p>默认情况下，lambda 生成的闭包类中的<code>operator()</code>成员函数会带有<code>const</code>限定符，它会导致是闭包类里的所有成员变量在 lambda 的函数体内都会带有<code>const</code>限定符。但是，绑定对象里通过移动构造得到的<code>data</code>副本却并不带有<code>const</code>限定符。因此，为了防止该<code>data</code>副本在 lambda 中被意外修改，我们会将其形参声明为常引用。但如果 lambda 在声明时带有<code>mutable</code>限定符，则闭包里的<code>operator()</code>就不再会带有<code>const</code>限定符，也不必再将形参声明为常引用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span>    std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token keyword">mutable</span>              <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 使用 data */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>              std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>回到之前的例子，使用 C++14 在闭包内创建<code>std::unique_ptr</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它在 C++11 中的模拟代码可以这样编写：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> pw<span class="token punctuation">)</span>                      <span class="token punctuation">{</span> <span class="token keyword">return</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-</span><span class="token operator">></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>                      std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="条款-33：对-auto-amp-amp-类型的形参使用-decltype-以对其实施-std-forward"><a href="#条款-33：对-auto-amp-amp-类型的形参使用-decltype-以对其实施-std-forward" class="headerlink" title="条款 33：对 auto&amp;&amp; 类型的形参使用 decltype 以对其实施 std::forward"></a>条款 33：对 auto&amp;&amp; 类型的形参使用 decltype 以对其实施 std::forward</h3><p>C++14 支持<strong>泛型 lambda（generic lambda）</strong>，可以在声明形参时使用<code>auto</code>，即闭包类中的<code>operator()</code>可以用模板实现。例如，给定以下 lambda：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则闭包类的<code>operator()</code>实现大致如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SomeCompilerGeneratedClassName</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// auto 类型的返回值，参考条款 3</span>        <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此处，lambda 总会传递左值给<code>normalize</code>，这对于一个会区别对待左、右值的<code>normalize</code>显然是不行的。如果想要保留实参的左、右值性，就需要将形参声明为万能引用（参考<strong>条款 24</strong>），并使用<code>std::forward</code>将其转发给<code>normalize</code>（参考<strong>条款 25</strong>）。这样的改造十分简单，唯一的问题是在 lambda 中，我们并没有可用的模板形参<code>T</code>，只能对要转发的形参使用<code>decltype</code>，以取得其类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>条款 28</strong> 说明了，使用<code>std::forward</code>的惯例是：用左值引用类型的模板形参来表明想要返回左值，用非引用类型的模板形参来表明想要返回右值。而在此处，如果<code>param</code>是左值，则<code>decltype(param)</code>会产生左值引用类型，这符合惯例；但如果<code>param</code>是右值，则<code>decltype(param)</code>会产生右值引用类型，不符合惯例的非引用，在这种情况下，<code>std::forward</code>将被具现化为：</p><pre class="line-numbers language-cpp"><code class="language-cpp">Widget<span class="token operator">&amp;&amp;</span> <span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;&amp;</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于引用折叠的存在，<code>Widget&amp;&amp; &amp;&amp;</code>将被折叠为<code>Widget&amp;&amp;</code>，所以实际上生成的代码和使用非引用类型作为模板形参生成的版本并没有什么区别。综上所述，在此处使用<code>decltype(param)</code>并不会产生任何问题，这是个非常不错的结果。</p><p>C++14 的 lambda 也支持可变参数，只需稍加改动，就可以得到能接受多个参数的完美转发 lambda 版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="条款-34：优先选用-lambda，而非-std-bind"><a href="#条款-34：优先选用-lambda，而非-std-bind" class="headerlink" title="条款 34：优先选用 lambda，而非 std::bind"></a>条款 34：优先选用 lambda，而非 std::bind</h3><p>之所以优先选用 lambda 而非 std::bind，最主要的原因是 lambda 具有更高的可读性。举个例子，假设我们有个函数用来设置警报声：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 表示时刻的类型</span><span class="token keyword">using</span> Time <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>steady_clock<span class="token operator">::</span>time_point<span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Sound</span> <span class="token punctuation">{</span> Beep<span class="token punctuation">,</span> Siren<span class="token punctuation">,</span> Whistle <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 表示时长的类型</span><span class="token keyword">using</span> Duration <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>steady_clock<span class="token operator">::</span>duration<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在时刻 t，发出声音 s，持续时长 d</span><span class="token keyword">void</span> <span class="token function">setAlarm</span><span class="token punctuation">(</span>Time t<span class="token punctuation">,</span> Sound s<span class="token punctuation">,</span> Duration d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以编写一个 lambda，设置在一小时后发出警报并持续 30 秒，同时提供接口，以指定发出的声音：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> setSoundL <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Sound s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>chrono<span class="token punctuation">;</span>    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>literals<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 引入 C++14 中的字面量后缀</span>    <span class="token function">setAlarm</span><span class="token punctuation">(</span>steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> 1h<span class="token punctuation">,</span> s<span class="token punctuation">,</span> 30s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// C++11 需要用 hours 和 seconds 代替后缀</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们将尝试使用<code>std::bind</code>来编写相应的代码。下面的这段代码并不正确，但足以让我们发现<code>std::bind</code>的难用之处：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>chrono<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>literals<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>placeholders<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 引入占位符</span><span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">,</span>                           steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> 1h<span class="token punctuation">,</span>                           _1<span class="token punctuation">,</span>                           30s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>占位符<code>_1</code>表示它在<code>std::bind</code>形参列表中的映射位置，在此处表示调用<code>setSoundB</code>时传入的第一个实参，会作为第二个实参传递给<code>setAlarm</code>。这显然已经不如 lambda 直观。</p><p>更重要的是上述代码所隐含的问题：调用时间的错误。在<code>std::bind</code>的调用中，<code>steady_clock::now() + 1h</code>作为实参被传递给了<code>std::bind</code>，而非<code>setAlarm</code>，这意味着该表达式会在调用<code>std::bind</code>的时刻计算出具体值，而非调用<code>setAlarm</code>的时刻，这与我们的意图显然不符。想要解决这个问题，就要嵌套第二层<code>std::bind</code>的调用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">,</span>                           std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>plus<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// C++11 无法省略 std::plus&lt;steady_clock::time_point>()</span>                                     steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                     1h<span class="token punctuation">)</span><span class="token punctuation">,</span>                           _1<span class="token punctuation">,</span>                           30s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个<code>std::bind</code>不如 lambda 的例子是重载。假如有个重载版本会接受第四个形参，用于指定警报的音量：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Volume</span> <span class="token punctuation">{</span> Normal<span class="token punctuation">,</span> Loud<span class="token punctuation">,</span> LoudPlusPlus <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">setAlarm</span><span class="token punctuation">(</span>Time t<span class="token punctuation">,</span> Sound s<span class="token punctuation">,</span> Duration d<span class="token punctuation">,</span> Volume v<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原来的 lambda 仍会正常运作，而<code>std::bind</code>会立刻发生错误，因为它只有函数名，并不知道要调用哪个重载版本的函数。为使得<code>std::bind</code>的调用能通过编译，必须将<code>setAlarm</code>强制转换到适当的函数指针类型：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> SetAlarm3ParamType <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Time t<span class="token punctuation">,</span> Sound s<span class="token punctuation">,</span> Duration d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>SetAlarm3ParamType<span class="token operator">></span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">)</span><span class="token punctuation">,</span>                           std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>plus<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 1h<span class="token punctuation">)</span><span class="token punctuation">,</span>                           _1<span class="token punctuation">,</span>                           30s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是一个更极端的例子，演示了<code>std::bind</code>到底有多晦涩：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// lambda 版本（C++14）</span><span class="token keyword">auto</span> betweenL <span class="token operator">=</span> <span class="token punctuation">[</span>lowVal<span class="token punctuation">,</span> highVal<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> lowVal <span class="token operator">&lt;=</span> val <span class="token operator">&amp;&amp;</span> val <span class="token operator">&lt;=</span> highVal<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// std::bind 版本（C++14）</span><span class="token keyword">auto</span> betweenB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>logical_and<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                          std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>less_equal<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lowVal<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">,</span>                          std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token operator">::</span>less_equal<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span> highVal<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::bind</code>总是拷贝其实参，调用时需要借助<code>std::ref</code>来达到按引用存储实参的目的，这一点同样也不如 lambda 来得明确：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> compressRateL <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>w<span class="token punctuation">]</span><span class="token punctuation">(</span>CompLevel lev<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">compress</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> lev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> compressRateB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>compress<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>除了可读性以外，编译器通常能更好地以内联优化 lambda 所调用的函数，而对于使用函数指针的<code>std::bind</code>则很难做到，这会导致使用 lambda 有可能会生成比使用<code>std::bind</code>运行得更快的代码。</p><p>在 C++11 中，<code>std::bind</code>仅在两个受限的场合还有使用的理由：</p><ol><li>移动捕获（参考<strong>条款 32</strong>）；</li><li>多态函数对象（这在 C++14 中可以被泛型 lambda 轻易实现）：</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PolyWidget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>PolyWidget pw<span class="token punctuation">;</span><span class="token keyword">auto</span> boundPW <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 可以用不同类型的实参调用 PolyWidget::operator()</span><span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token number">1930</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token string">"Rosebud"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 原书作者玩的《公民凯恩》梗（应该是吧）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第七章：并发-API"><a href="#第七章：并发-API" class="headerlink" title="第七章：并发 API"></a>第七章：并发 API</h2><h3 id="条款-35：优先选用基于任务而非基于线程的程序设计"><a href="#条款-35：优先选用基于任务而非基于线程的程序设计" class="headerlink" title="条款 35：优先选用基于任务而非基于线程的程序设计"></a>条款 35：优先选用基于任务而非基于线程的程序设计</h3><p>如果你想以异步方式执行函数<code>doAsyncWork</code>，你可以选择<strong>基于线程（thread-based）</strong> 的方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">doAsyncWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也可以将<code>doAsyncWork</code>传递给<code>std::async</code>，这是<strong>基于任务（task-based）</strong> 的方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 需要 #include &lt;future></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>“线程” 在带有并发的 C++ 软件中有三重含义：</p><ul><li><strong>硬件线程（hardware threads）</strong> 是实际执行计算的线程。现代计算机架构会为每个 CPU 内核提供一个或多个硬件线程。</li><li><strong>软件线程（software threads，也称系统线程）</strong> 是操作系统（或嵌入式系统）用于实现跨进程的管理，以及进行硬件线程调度的线程。通常，能够创建的软件线程比硬件线程要多，因为当一个软件线程被阻塞时，运行其它未阻塞线程能够提高吞吐率。</li><li><strong><code>std::thread</code></strong> 是 C++ 进程中的对象，用作底层软件线程的句柄。有些<code>std::thread</code>对象表现为 “null” 句柄，表示其无软件线程，可能的原因有：处于默认构造状态（没有要执行的函数），被移动了（被移动的目标对象成为了该软件线程的句柄），被联结（join）了（函数已执行结束），被分离（detach）了（与其软件线程的连接被切断）。</li></ul><p>软件线程和硬件线程都是有限的。如果你试图创建多于系统能提供的数量的线程，就会抛出<code>std::system_error</code>异常，即使待执行的函数带有<code>noexcept</code>限定符也一样。如果非阻塞的软件线程数量超过了硬件线程数量，就会产生<strong>资源超额（oversubscription）</strong> 问题，此时线程调度器会将软件线程的 CPU 时间切片，分配到硬件线程之上。当一个软件线程的时间片执行结束，就会让给另一个软件线程，并产生上下文切换。在这种情况下，新的软件线程几乎不能命中 CPU 缓存，同时还会污染为旧线程所准备的数据（旧线程很可能还会再被调度到同一内核上运行），这会造成高昂的线程管理开销。</p><blockquote><p>避免资源超额很困难，因为软件线程和硬件线程的最佳比例取决于软件线程的执行频率，那是动态改变的，例如一个程序从 IO 密集型变成计算密集型，会使执行频率发生改变。而且该比例还依赖于上下文切换的开销以及软件线程对于 CPU 缓存的使用效率。计算机本身的架构也会对其具体细节产生很大的影响。</p></blockquote><p>比起基于线程，基于任务的设计能够减轻手动管理线程的艰难，而且它提供了一种很自然的方式（藉由<code>get</code>函数），让你检查异步执行函数的结果（即返回值或异常）。</p><p>虽然说了这么多，但仍有以下几种情况，直接使用线程会更合适：</p><ul><li><strong>你需要访问非常底层的线程 API。</strong> C++ 并发 API 通常会采用特定平台的低级 API 来实现，例如 pthread 和 Windows 线程库，它们提高的 API 比 C++ 更丰富。为了访问底层的线程 API，<code>std::thread</code>通常会提供<code>native_handle</code>成员函数，而<code>std::async</code>的返回值<code>std::future</code>则没有该功能。</li><li><strong>你需要且有能力为你的应用优化线程的使用。</strong> 例如在完成性能分析的情况下为专一硬件平台开发应用。</li><li><strong>你需要实现实现超越 C++ 并发 API 的线程技术。</strong> 例如为 C++ 未提供线程池的平台实现线程池。</li></ul><h3 id="条款-36：如果异步是必要的，则指定-std-launch-async"><a href="#条款-36：如果异步是必要的，则指定-std-launch-async" class="headerlink" title="条款 36：如果异步是必要的，则指定 std::launch::async"></a>条款 36：如果异步是必要的，则指定 std::launch::async</h3><p>在调用<code>std::async</code>时，有以下两种启动策略可以选择：</p><ul><li><code>std::launch::async</code>启动策略意味着函数必须以异步方式在另一条线程上执行。</li><li><code>std::launch::deferred</code>启动策略意味着函数会被推迟到<code>std::async</code>所返回的<code>std::future</code>的<code>get</code>或<code>wait</code>函数得到调用时才执行（这是个简化说法，关键点其实是<code>std::future</code>引用的共享状态，参考<strong>条款 38</strong>）。在那之后，调用<code>get</code>或<code>wait</code>的线程将会被阻塞，直至函数执行结束为止。如果<code>get</code>或<code>wait</code>都没得到调用，则函数将不会被执行。</li></ul><p><code>std::async</code>的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行，即下面两个调用是等价的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> fut2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async <span class="token operator">|</span> std<span class="token operator">::</span>launch<span class="token operator">::</span>deferred<span class="token punctuation">,</span>                       f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种弹性使得<code>std::async</code>和标准库的线程管理组件能够承担起线程的创建和销毁，避免资源超额，以及负载均衡的责任。但也会带来一些意料之外的问题：</p><ul><li>无法预知<code>f</code>是否会与调用<code>std::async</code>的线程并发执行，它也可能会被推迟执行。</li><li>无法预知<code>f</code>是否会在与调用<code>get</code>和<code>wait</code>函数的线程不同的线程上执行。</li><li>无法预知<code>f</code>在读或写此<strong>线程本地存储（thread-local，TLS）</strong> 时，会在哪个线程的本地存储上完成操作，这会影响到<code>thread_local</code>变量的使用。</li><li>就连<code>f</code>是否会被执行这种基本的事情都无法预知。</li></ul><p>延迟启动策略还会影响以超时为条件的基于 wait 的循环：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>literals<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>1s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>100ms<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 循环至 f 完成执行</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">// 若 f 被推迟执行，则 fut.wait_for 返回 std::future_status::deferred</span>    <span class="token comment" spellcheck="true">// 循环永远不会被终止！</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决这个问题的方法很简单，只需要确认任务是否被推迟，可以通过调用一个基于超时的函数（例如<code>wait_for</code>）并检查其返回值来实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>0s<span class="token punctuation">)</span> <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>deferred<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果任务被推迟了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// 调用 fut 的 wait 或 get，以同步方式执行 f</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                                                  <span class="token comment" spellcheck="true">// 如果任务未被推迟</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>100ms<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// 不断去做并发任务，直至 f 完成执行</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// fut 已经就绪</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上所述，如果需要执行的任务满足以下条件，就可以使用<code>std::async</code>的默认启动策略：</p><ol><li>任务不需要与调用<code>get</code>或<code>wait</code>的线程并发执行。</li><li>读或写哪个线程的<code>thread_local</code>变量并无影响。</li><li>保证在<code>std::async</code>返回的<code>std::future</code>对象上调用<code>get</code>或<code>wait</code>，或者可以接受任务可能永不执行。</li><li>使用<code>wait_for</code>或<code>wait_until</code>的代码会考虑到任务被推迟的可能性。</li></ol><p>如果其中任何一个条件不满足，就需要确保任务以异步方式执行：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以编写一个辅助函数来自动执行<code>std::async</code>的异步启动策略：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> F<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span><span class="token keyword">inline</span> std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>result_of<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span> <span class="token comment" spellcheck="true">// C++14 可以直接用 auto 推导返回值类型</span><span class="token function">reallyAsync</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span>                      std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span>                      std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Ts<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>用于获取可调用对象返回值类型的<code>std::result_of</code>在 C++17 后被弃用，其替代品为<code>std::invoke_result</code>。</p></blockquote><h3 id="条款-37：使-std-thread-对象在所有路径皆不可联结"><a href="#条款-37：使-std-thread-对象在所有路径皆不可联结" class="headerlink" title="条款 37：使 std::thread 对象在所有路径皆不可联结"></a>条款 37：使 std::thread 对象在所有路径皆不可联结</h3><p>当<code>std::thread</code>处于可联结的状态时，它对应于正在运行或可能将要运行的底层执行线程，这包括正在等待调度的或者被阻塞的线程，以及运行结束的线程。</p><p>以下几种<code>std::thread</code>对象处于不可联结的状态：</p><ul><li>默认构造的<code>std::thread</code>。</li><li>已移动的<code>std::thread</code>。</li><li>已联结（join）的<code>std::thread</code>。</li><li>已分离（detach）的<code>std::thread</code>。</li></ul><p>当<code>std::thread</code>执行析构时，若其处于可联结状态，就会导致程序终止运行（通常会调用<code>std::abort</code>）。考虑以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> tenMillion <span class="token operator">=</span> <span class="token number">10</span><span class="token string">'000'</span><span class="token number">000</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// C++14 的单引号数字分隔符</span><span class="token keyword">bool</span> <span class="token function">doWork</span><span class="token punctuation">(</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> filter<span class="token punctuation">,</span> <span class="token keyword">int</span> maxVal <span class="token operator">=</span> tenMillion<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> goodVals<span class="token punctuation">;</span>    std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>filter<span class="token punctuation">,</span> maxVal<span class="token punctuation">,</span> <span class="token operator">&amp;</span>goodVals<span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 遍历 goodVals</span>                      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxVal<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>                      <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">filter</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> goodVals<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>                  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> nh <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">native_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 使用 t 的原生句柄来设定线程的优先级</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">conditionAreSatisfied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                   <span class="token comment" spellcheck="true">// 让 t 结束运行</span>        <span class="token function">performComputation</span><span class="token punctuation">(</span>goodVals<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">// 计算已实施</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                                   <span class="token comment" spellcheck="true">// 计算未实施</span><span class="token punctuation">}</span>                                                   <span class="token comment" spellcheck="true">// 此处析构 std::thread 会导致程序终止</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标准委员会并没有选择让<code>std::thread</code>在销毁时，隐式执行<code>join</code>或<code>detach</code>，因为这带来的问题会比直接让程序终止运行还要严重：</p><ul><li><strong>隐式<code>join</code></strong> 会使<code>std::thread</code>的析构函数等待底层异步线程执行完毕。这听上去很合理，但却可能导致难以追踪的性能异常。例如，即使<code>conditionAreSatisfied</code>已经返回<code>false</code>了，<code>doWork</code>仍然会继续执行遍历操作，这是违反直觉的。</li><li><strong>隐式<code>detach</code></strong> 会使<code>std::thread</code>的析构函数分离<code>std::thread</code>对象和底层执行线程之间的连接，而该底层执行线程会继续运行。这会导致更要命的调试问题。假如<code>conditionAreSatisfied</code>返回了<code>false</code>，则<code>doWork</code>也会直接返回，同时销毁局部变量并弹出栈帧。但线程仍然在<code>doWork</code>的调用点继续运行，并导致栈帧上的内存被意外修改，</li></ul><p>我们可以编写一个 RAII 类，并让调用者自行选择在销毁时为<code>std::thread</code>调用<code>join</code>还是<code>detach</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ThreadRAII</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">DtorAction</span> <span class="token punctuation">{</span> join<span class="token punctuation">,</span> detach <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 关于枚举类，参考条款 20</span>    <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>std<span class="token operator">::</span>thread<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">,</span> DtorAction a<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 对 t 执行操作 a</span>        <span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">ThreadRAII</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先校验 t 是否处于可联结状态</span>        <span class="token comment" spellcheck="true">// 对不可联结的 std::thread 调用 join 或 detach 是未定义行为</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token operator">==</span> DtorAction<span class="token operator">::</span>join<span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>ThreadRAII<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 支持移动操作</span>    ThreadRAII<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>ThreadRAII<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>thread<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 返回底层的 std::thread 对象</span><span class="token keyword">private</span><span class="token operator">:</span>    DtorAction action<span class="token punctuation">;</span>    std<span class="token operator">::</span>thread t<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 使 t 最后被初始化，确保它可以安全访问其它成员</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>不需要担心在<code>t.joinable()</code>的执行和<code>join</code>或<code>detach</code>的调用之间，有另一个线程会让<code>t</code>变得不可联结。因为<code>std::thread</code>对象只能通过调用成员函数来从可联结状态转换为不可联结状态，而当<code>ThreadRAII</code>对象的析构函数被调用时，不应该有其它线程调用该对象的成员函数。一般地，若要在一个对象上同时调用两个成员函数，只有当所有这些函数都带有<code>const</code>限定符时才安全（参考<strong>条款 16</strong>）。</p></blockquote><p>在<code>doWork</code>函数的代码中，可以这样使用<code>ThreadRAII</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">doWork</span><span class="token punctuation">(</span>std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> filter<span class="token punctuation">,</span> <span class="token keyword">int</span> maxVal <span class="token operator">=</span> tenMillion<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> goodVals<span class="token punctuation">;</span>    ThreadRAII <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>filter<span class="token punctuation">,</span> maxVal<span class="token punctuation">,</span> <span class="token operator">&amp;</span>goodVals<span class="token punctuation">]</span> <span class="token punctuation">{</span>                                 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxVal<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>                                 <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">filter</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> goodVals<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>                             <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                 ThreadRAII<span class="token operator">::</span>DtorAction<span class="token operator">::</span>join<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> nh <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">native_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">conditionAreSatisfied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">performComputation</span><span class="token punctuation">(</span>goodVals<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-38：注意不同线程句柄的析构行为"><a href="#条款-38：注意不同线程句柄的析构行为" class="headerlink" title="条款 38：注意不同线程句柄的析构行为"></a>条款 38：注意不同线程句柄的析构行为</h3><p>future 位于通信信道的一端，被调用者通过该信道将结果发送给调用者。被调用者（通常以异步方式运行）将其计算所得的结果写入信道（通常经过<code>std::promise</code>对象），而调用者则使用 future 来读取该结果。</p><p>但被调用者的结果要存储在哪里呢？既不能存储在被调用者的<code>std::promise</code>对象中，因为它是个局部对象，在被调用者执行结束后会被销毁；也不能存储在调用者的 future 中，因为<code>std::future</code>可能会被用来创建<code>std::shared_future</code>，而后者会导致原始<code>std::future</code>析构之后被多次拷贝，但被调用者的结果并不能保证一定可以被拷贝，很难做到使它与最后一个指向它的 future 生命周期一样长。</p><p>因此该结果会被存储在位于两者外部的某个位置，这个位置称为<strong>共享状态（shared state）</strong>，通常用堆上的对象来表示，但是其类型、接口和实现皆未在标准中指定。我们可以把调用者，被调用者以及共享状态之间的关系用下图来表示：</p><p><img src="https://pic2.zhimg.com/80/v2-006b36a9b3ae2533a73d8c1646d49511_720w.webp" alt></p><p>共享状态的存在非常重要，因为 future 对象的析构行为取决于与其关联的共享状态。具体来说就是：</p><ul><li>常规的 future 对象在析构时仅会析构该 future 的成员变量。这相当于对底层执行线程执行了隐式<code>detach</code>。</li><li>引用了共享状态（使用<code>std::async</code>启动未延迟任务时创建的）的最后一个 future 对象的析构函数将会被阻塞住，直至该任务结束。这相当于对正在运行<code>std::async</code>所创建任务的线程执行了隐式<code>join</code>。</li></ul><p>也就是说，只有在满足下列条件时，future 的非常规析构行为才会被触发：</p><ol><li>future 所引用的共享状态是在调用<code>std::async</code>时创建的；</li><li>该任务执行异步启动策略，即<code>std::launch::async</code>（参考<strong>条款 36</strong>）；</li><li>该 future 是最后一个引用了该共享状态的 future。</li></ol><p>future 的 API 没有提供任何办法判断它引用的共享状态是否诞生于<code>std::async</code>的调用，因此任意给定一个 future 对象，我们没有办法判断它是否会在析构函数中阻塞。这可能会导致一些意外的情况：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 该容器的析构函数可能会发生阻塞</span><span class="token comment" spellcheck="true">// 因为它持有 future 可能会有一个或多个</span><span class="token comment" spellcheck="true">// 满足触发非常规析构行为的条件</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">>></span> futs<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 关于 std::future&lt;void>，参考条款 39</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>                          <span class="token comment" spellcheck="true">// Widget 对象的析构函数可能会发生阻塞</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>shared_future<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> fut<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>std::packaged_task</code>也能创建出共享对象，但是其衍生的 future 都会执行常规的析构行为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">calcValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>       <span class="token comment" spellcheck="true">// 给 calcValue 加上包装</span>    <span class="token function">pt</span><span class="token punctuation">(</span>calcValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 使之能以异步方式执行</span>    <span class="token keyword">auto</span> fut <span class="token operator">=</span> pt<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 取得 pt 的 future</span>    std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// std::packaged_task 是只移类型</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment" spellcheck="true">// 析构 std::thread（参考条款 37）</span><span class="token punctuation">}</span>                                   <span class="token comment" spellcheck="true">// 以常规方式析构 future 对象 fut</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-39：考虑对一次性事件通信使用-void-的-futures"><a href="#条款-39：考虑对一次性事件通信使用-void-的-futures" class="headerlink" title="条款 39：考虑对一次性事件通信使用 void 的 futures"></a>条款 39：考虑对一次性事件通信使用 void 的 futures</h3><p>有的时候，让一个任务能够在发生了特定事件后，通知另一个异步运行的任务，会是很有用的。为了实现这种简单的事件通信，使用条件变量会是一个显而易见的做法：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>condition_variable cv<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 事件的条件变量</span>std<span class="token operator">::</span>mutex m<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 配合 cv 使用的互斥量</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 检测事件</span>cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 通知反应任务，对多个任务使用 notify_all</span><span class="token comment" spellcheck="true">// 反应任务的代码</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 准备作出反应</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 为互斥量加锁</span>    cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 等待通知到来</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment" spellcheck="true">// 针对事件作出反应</span><span class="token punctuation">}</span>                                       <span class="token comment" spellcheck="true">// 通过 lk 的析构函数为 m 解锁</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 继续等待反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种途径会导致以下几个问题：</p><ul><li><strong>代码异味（code smell）：</strong> 虽然代码能够运行，但总感觉哪里不太对劲。此处对互斥量的使用似乎有些多余，互斥量是用于控制共享数据访问的，但检测和反应任务之间大可以根本不需要这种介质。</li><li>如果检测任务在反应任务调用<code>wait</code>之前就通知了条件变量，则反应任务将会失去响应。</li><li>反应任务的<code>wait</code>语句无法应对<strong>虚假唤醒（spurious wakeups）</strong>，即使条件变量没有得到通知，针对该条件变量等待的代码也有可能被唤醒。如果反应线程可以确认它所等待的事件是否已经发生，那么我们可以通过将 lambda 传递给<code>wait</code>来处理这种情况：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> 事件是否真的已经发生<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基于 flag 的设计可以避免上述问题，但这一设计基于轮询而非阻塞，会对 CPU 核心产生额外的性能消耗：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">flag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 共享的 bool flag</span>                                <span class="token comment" spellcheck="true">// 关于 std::atomic，参考条款 40</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment" spellcheck="true">// 检测事件</span>flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 通知反应任务</span><span class="token comment" spellcheck="true">// 反应任务的代码</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment" spellcheck="true">// 准备作出反应</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 等待事件</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment" spellcheck="true">// 针对事件作出反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>条件变量可以和 flag 一起使用，但这样的通信机制设计看起来不太自然：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>condition_variable cv<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 同前</span>std<span class="token operator">::</span>mutex m<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">flag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// 非 std::atomic 对象</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment" spellcheck="true">// 检测事件</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 为 m 加锁</span>    flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 通知反应任务（第一部分）</span><span class="token punctuation">}</span>cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 通知反应任务（第二部分）</span><span class="token comment" spellcheck="true">// 反应任务的代码</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment" spellcheck="true">// 准备作出反应</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 同前</span>    cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>flag<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> flag<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使用 lambda 应对虚假唤醒</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment" spellcheck="true">// 针对事件作出反应</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment" spellcheck="true">// 继续等待反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外一种方法是摆脱条件变量，互斥量和 flag，让反应任务去等待检测任务设置的 future。这种设计简单易行，检测任务有一个<code>std::promise</code>对象，反应任务有对应的 future。当检测任务发现它查找的事件已经发生时，它会设置<code>std::promise</code>对象；与此同时，反应任务调用<code>wait</code>以等待它的 future。由于在此处我们并不会真正向信道发送任何数据，所以对于<code>std::promise</code>、<code>std::future</code>和<code>std::shared_future</code>的模板类型形参，都只需使用<code>void</code>即可：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> p<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 检测事件</span>p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 通知反应任务</span><span class="token comment" spellcheck="true">// 反应任务的代码</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 准备作出反应</span>p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 等待 p 对应的 future</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment" spellcheck="true">// 针对事件作出反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种手法有两个最大的局限性：</p><ul><li><code>std::promise</code>和 future 之间依赖共享状态，而共享状态会带来在堆上分配和回收空间的成本。</li><li><code>std::promise</code>对象只能设置一次，这意味着该手法只能应用于一次性通信的情况。</li></ul><p>假如你想创建多个能暂停一次的线程，使用<code>void</code> future 手法就是合理的选择。代码演示如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> p<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">detect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> sf <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// sf 的类型是 std::shared_future&lt;void></span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>thread<span class="token operator">></span> vt<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 反应任务的容器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadsToRun<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vt<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">[</span>sf<span class="token punctuation">]</span> <span class="token punctuation">{</span> sf<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">react</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// sf 局部副本之上的 wait</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                                 <span class="token comment" spellcheck="true">// 若在此处抛出异常，则 detect 会失去响应！</span>    p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">// 让所有线程取消暂停</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                                 <span class="token comment" spellcheck="true">// 完成其它工作</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vt<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment" spellcheck="true">// 把所有线程设为不可联结的状态</span>        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-40：对并发使用-std-atomic，对特殊内存使用-volatile"><a href="#条款-40：对并发使用-std-atomic，对特殊内存使用-volatile" class="headerlink" title="条款 40：对并发使用 std::atomic，对特殊内存使用 volatile"></a>条款 40：对并发使用 std::atomic，对特殊内存使用 volatile</h3><p><code>std::atomic</code>可以保证它提供的操作被其它线程视为具有原子性，它产生的效果和受到互斥锁保护的操作类似，但是通常<code>std::atomic</code>的原子操作是通过特定的机器指令实现的，这比锁的实现更高效。考虑以下应用了<code>std::atomic</code>的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ai</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 ai 初始化为 0</span>ai <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 原子地将 ai 设为 10</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ai<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 原子地读取 ai 地值</span><span class="token operator">++</span>ai<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 原子地将 ai 自增为 11</span><span class="token operator">--</span>ai<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 原子地将 ai 自减为 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，在<code>std::cout &lt;&lt; ai</code>语句中，<code>std::atomic</code>仅能保证对于<code>ai</code>的读取操作具有原子性，而不能保证整条语句都具有原子性，在读取<code>ai</code>的值和调用<code>operator&lt;&lt;</code>之间，可能会有别的线程修改了<code>ai</code>的值，但这对使用按值传参的<code>operator&lt;&lt;</code>并没有什么影响。</p><p><code>ai</code>的自增和自减操作是<strong>读取-修改-写入（read-modify-write，RWM）</strong> 操作，<code>std::atomic</code>能确保它们整体以原子方式执行。这是<code>std::atomic</code>最重要的特性之一：<code>std::atomic</code>对象之上的所有成员函数都能被其它线程视为原子性的。</p><p><code>std::atomic</code>在 RWM 上具有的优势与<code>volatile</code>相比十分明显：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ac</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// atomic counter</span><span class="token keyword">volatile</span> <span class="token keyword">int</span> <span class="token function">vc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// volatile counter</span><span class="token comment" spellcheck="true">/* 在两个同时运行的线程中各自执行自增操作 */</span><span class="token comment" spellcheck="true">// 线程 1</span><span class="token operator">++</span>ac<span class="token punctuation">;</span><span class="token operator">++</span>vc<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 线程 2</span><span class="token operator">++</span>ac<span class="token punctuation">;</span><span class="token operator">++</span>vc<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在两个执行结束后，<code>ac</code>的值一定为 2，而<code>vc</code>却不一定，数据竞争导致它的最终结果实际上是无法预测的，下面是一种可能的情况：</p><ol><li>线程 1 读取<code>vc</code>的值为 0；</li><li>线程 2 读取<code>vc</code>的值仍为 0；</li><li>线程 1 将读取的值 0 自增为 1，写入<code>vc</code>；</li><li>线程 2 也将读取的值 0 自增为 1，写入<code>vc</code>；</li><li><code>vc</code>最终的值为 1。</li></ol><p>除了 RWM 以外，<code>std::atomic</code>还在确保<strong>顺序一致性（sequential consistency）</strong> 上具有优势，这种一致性是它默认采用的（尽管 C++ 还支持其它的一致性模型，但它们的安全性无法得到保证），它规定：在源代码中，<strong>任何位于<code>std::atomic</code>变量的写入操作之前的代码不得发生于写入操作之后</strong>。使用<code>std::atomic</code>可以保证以下代码中的赋值语句不会进行重新排序：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">valAvailable</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> imptValue <span class="token operator">=</span> <span class="token function">computeImportantValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 计算出值</span>valAvailable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 通知其它任务，值已可用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果不使用<code>std::atomic</code>，语句的顺序可能会被编译器或底层硬件重新排列，以使得代码运行得更快：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 重新排序后的结果</span>valAvailable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">auto</span> imptValue <span class="token operator">=</span> <span class="token function">computeImportantValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>std::atomic</code>是只移类型，因此以下代码无法通过编译：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>y <span class="token operator">=</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>正确的方式是调用<code>std::atomic</code>的成员函数<code>load</code>和<code>store</code>来以原子方式读取和写入：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">y</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>尽管在很多时候<code>load</code>和<code>store</code>并不是必要的，但是有些开发者还是很喜欢使用它们，因为这样做可以在代码中明确强调所使用的变量并非常规。这在很大程度上是一个代码风格的问题。</p><p><code>volatile</code>是用来处理特殊内存的工具，它会被用在读写操作不应该被优化的内存上。一般来讲，编译器会为常规内存的冗余读取和写入自动执行优化，例如以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 读取 x</span>y <span class="token operator">=</span> x<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 再次读取 x</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 写入 x</span>x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 再次写入 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在经过优化后就能变成十分精简的版本：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 读取 x</span>x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 写入 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但对于特殊内存，我们可能不想要编译器去执行这种优化。例如用于内存映射 I/O 的内存，这种内存的位置实际上会被用于与外部设备通信，而非用于读取或写入常规内存。这时，<code>volatile</code>就能派上用场：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">volatile</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 以 volatile 声明 x</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token comment" spellcheck="true">// 初始化 x</span><span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 读取 x</span>y <span class="token operator">=</span> x<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 再次读取 x（不会被优化掉）</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 写入 x（不会被优化掉）</span>x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 再次写入 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::atomic</code>和<code>volatile</code>用于不同的目的，它们甚至可以一起使用：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">volatile</span> std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vai<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 针对 vai 的操作具有原子性</span>                                <span class="token comment" spellcheck="true">// 并且不会被优化掉</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="第八章：微调"><a href="#第八章：微调" class="headerlink" title="第八章：微调"></a>第八章：微调</h2><h3 id="条款-41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递"><a href="#条款-41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递" class="headerlink" title="条款 41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递"></a>条款 41：对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递</h3><p>为了实现对传入函数的左值实参执行拷贝，对右值实参执行移动，我们一共有以下三种方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>                                  <span class="token comment" spellcheck="true">// 方法一：</span><span class="token keyword">public</span><span class="token operator">:</span>                                         <span class="token comment" spellcheck="true">// 对左值和右值分别重载</span>    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> names<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>                                  <span class="token comment" spellcheck="true">// 方法二：</span><span class="token keyword">public</span><span class="token operator">:</span>                                         <span class="token comment" spellcheck="true">// 使用万能引用</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>                                  <span class="token comment" spellcheck="true">// 方法三：</span><span class="token keyword">public</span><span class="token operator">:</span>                                         <span class="token comment" spellcheck="true">// 按值传递参数</span>    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++98 中，按值传递的形参总会通过拷贝构造函数创建，但在 C++11 后，形参仅在传入左值时才会被拷贝构造，而如果传入的是个右值，它会被移动构造。</p><p>对于可拷贝的，移动开销低的，并且总是会被拷贝的形参而言，按值传递和按引用传递的效率很接近，而且按值传递更容易实现，还可能会生成更少的目标代码。</p><p>对于不可拷贝的形参，由于它的拷贝构造函数已被禁用，我们也不需要为其左值类型的实参提供支持，只需要编写一个接受右值引用的版本就行了。考虑一个类，它含有一个<code>std::unique_ptr</code>类型的数据成员和对应的 setter，而<code>std::unique_ptr</code>是个只移类型，所以我们只需要编写单个函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">setPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token operator">&amp;&amp;</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Widget w<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>w<span class="token punctuation">.</span><span class="token function">setPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Modern C++"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用按值传参的前提是形参移动的成本足够低廉，因为按值传参会比按引用传参多一次额外的移动操作，如果这个前提不成立，那么执行不必要的移动就与执行不必要的拷贝没有什么区别。另外，你应当只对一定会被拷贝的形参考虑使用按值传参，以下代码就是一个反例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string newName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newName<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> minLen<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>newName<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> maxLen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> names<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即使没有向<code>names</code>添加任何内容，该函数也会造成构造和析构<code>newName</code>的开销，而如果使用按引用传参，就可以避免这笔开销。</p><p>通过构造拷贝形参的开销可能会比通过赋值拷贝形参要大得多。考虑以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Password</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Password</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string pwd<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 按值传参</span>        <span class="token operator">:</span> <span class="token function">text</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 对 text 进行构造</span>    <span class="token keyword">void</span> <span class="token function">changeTo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string newPwd<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 按值传参</span>        text <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>newPwd<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 对 text 进行赋值</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token operator">::</span>string text<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 表示密码</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>std<span class="token operator">::</span>string <span class="token function">initPwd</span><span class="token punctuation">(</span><span class="token string">"Supercalifragilisticexpialidocious"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 旧密码</span>Password <span class="token function">p</span><span class="token punctuation">(</span>initPwd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>std<span class="token operator">::</span>string newPassword <span class="token operator">=</span> <span class="token string">"Beware the Jabberwock"</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 新密码</span>p<span class="token punctuation">.</span><span class="token function">changeTo</span><span class="token punctuation">(</span>newPassword<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此处，旧密码比新密码更长，因此不需要进行任何内存分配和回收。如果采用重载的方式，可能就不会发生任何动态内存管理操作：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Password</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">changeTo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span> newPwd<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对左值的重载</span>        text <span class="token operator">=</span> newPwd<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 若 text.capacity() >= newPwd.size()</span>                                            <span class="token comment" spellcheck="true">// 则可以复用 text 的内存</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此情形下，使用按值传参就会造成额外的内存分配和回收的开销，这可能会比移动<code>std::string</code>的开销高出几个数量级。</p><p>综上所述，通过赋值拷贝一个形参进行按值传参所造成的额外开销，取决于传参的类型，左值和右值的比例，这个类型是否需要动态分配内存，以及，如果需要分配内存的话，赋值操作符的具体实现，还有赋值目标所占的内存是否至少和赋值源所占的内存一样大。对于<code>std::string</code>来说，开销还取决于实现是否使用了 SSO（参考<strong>条款 29</strong>），如果是，那么要赋的值是否匹配 SSO 缓冲区。</p><p>最后要注意的一点是，按值传参肯定会导致<strong>对象切片（object slicing）</strong> 的问题，所以基类类型不适合用于按值传递：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">//基类</span><span class="token keyword">class</span> <span class="token class-name">SpecialWidget</span> <span class="token operator">:</span> <span class="token keyword">public</span> Widget <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//派生类</span><span class="token keyword">void</span> <span class="token function">processWidget</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 针对任意类型的 Widget 的函数</span>                                                <span class="token comment" spellcheck="true">// 包括派生类型</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SpecialWidget sw<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">processWidget</span><span class="token punctuation">(</span>sw<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 发生对象切片，processWidget 只能看到 Widget</span>                                                <span class="token comment" spellcheck="true">// 而非 SpecialWidget</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款-42：考虑置入而非插入"><a href="#条款-42：考虑置入而非插入" class="headerlink" title="条款 42：考虑置入而非插入"></a>条款 42：考虑置入而非插入</h3><p>假如你想向 STL 容器中添加新元素，<strong>插入函数（insertion function）</strong> 通常是合乎逻辑的选择，但对于性能狂人而言，其背后所隐含的临时对象带来的开销是难以忍受的。考虑以下代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> vs<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 持有 std::string 对象的容器</span>vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 添加字符串字面量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此处添加的字符串字面量和<code>std::string</code>类型并不匹配，因此需要先创建一个<code>std::string</code>类型的临时对象，然后再将其绑定到<code>push_back</code>函数的右值引用形参。换句话说，你可以把这句调用看作下面这样：</p><pre class="line-numbers language-cpp"><code class="language-cpp">vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这之后，<code>push_back</code>会在<code>std::vector</code>中构造出一个形参的副本，这个过程是通过调用移动构造函数来完成的（这已经是第二次调用构造函数了）。在<code>push_back</code>返回后，临时对象将立刻被销毁，这又调用了<code>std::string</code>的析构函数。</p><p>从原理上来说，<strong>置入函数（emplacement function）</strong> 在大部分时候应该比插入函数更高效，而且不会有更低效的可能性。<code>emplace_back</code>函数使用了完美转发，因此调用它不会带来任何的临时对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp">vs<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但令人遗憾的是，插入函数还是有可能比置入函数更快的，这取决于传递的实参类型，使用的容器种类，置入或插入到容器中的位置，容器中类型的构造函数的异常安全性，和对于禁止重复值的容器（<code>std::set</code>，<code>std::map</code>，<code>std::unordered_set</code>和<code>set::unordered_map</code>）而言，要添加的值是否已经在容器中。不过在以下这些情况，置入函数很有可能会运行得更快：</p><ul><li>待添加的值是通过构造而非赋值方式加入容器。一个反例是向<code>std::vector</code>中已经被占据的位置置入对象：</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> vs<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment" spellcheck="true">// 向 vs 中添加元素</span>vs<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 向 vs 的开头添加元素，该位置已经存在对象</span>                                    <span class="token comment" spellcheck="true">// 使用的是赋值而非构造方式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>基于节点的容器一般都使用构造来添加新元素，而大多数标准库容器都是基于节点的，除了<code>std::vector</code>，<code>std::deque</code>和<code>std::string</code>等（<code>std::array</code>也不是基于节点的，但是它不支持置入和插入，所以和我们的讨论无关）。在不是基于节点的容器中，你可以确信<code>emplace_back</code>是使用构造来向容器添加元素的，这对于<code>std::deque</code>的<code>emplace_front</code>也同样成立。</p></blockquote><ul><li>传递的实参类型和容器所持有的类型不同。</li><li>容器不会因为存在重复值而拒绝待添加的值。</li></ul><p>在面对<code>new Widget</code>这样的表达式时，置入函数也没有什么优势。考虑以下两种向<code>std::shared_ptr</code>容器中添加新元素的方式：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">killWidget</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pWidget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 自定义删除器</span>ptrs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> killWidget<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 和 ptrs.push_back({ new Widget, killWidget }) 等价</span>ptrs<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> killWidget<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处使用<code>push_back</code>仍然会创建出<code>std::shared_ptr</code>类型的临时对象，但该临时对象却拥有了正面意义，如果在为链表节点分配内存时抛出了内存不足的异常，那么该<code>std::shared_ptr</code>临时对象可以自动调用<code>killWidget</code>来释放<code>Widget</code>的内存；但在使用<code>emplace_back</code>的情况下，起到保障作用的<code>std::shared_ptr</code>临时对象将不再存在，如果发生同样的异常，那么<code>Widget</code>的内存将不可避免地被泄漏。</p><p>如果你参考<strong>条款 21</strong> 所述，使用独立语句将<code>new Widget</code>产生的指针转交给资源管理对象，那么使用置入函数和插入函数的效果也是差不多的：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> killWidget<span class="token punctuation">)</span><span class="token punctuation">;</span>ptrs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 或 ptrs.emplace_back(std::move(spw))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后需要注意的一点是，置入函数可能会执行在插入函数中会被拒绝的类型转换。这是因为置入函数使用的是直接初始化，而插入函数使用的是拷贝初始化，只有直接初始化会将带有<code>explicit</code>限定符的构造函数纳入考虑范围。因此在使用置入函数时，要特别关注是否传递了正确的实参：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>regex<span class="token operator">></span> regexes<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// C++11 提供了对正则表达式的支持</span>regexes<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 无法通过编译！</span>regexes<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 能通过编译，但会产生未定义行为</span>                                    <span class="token comment" spellcheck="true">// 相当于执行 std::regex(nullptr)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章：类型推导&quot;&gt;&lt;a href=&quot;#第一章：类型推导&quot; class=&quot;headerlink&quot; title=&quot;第一章：类型推导&quot;&gt;&lt;/a&gt;第一章：类型推导&lt;/h2&gt;&lt;h3 id=&quot;条款-1：理解模板类型推导&quot;&gt;&lt;a href=&quot;#条款-1：理解模板类型推导&quot; c
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>ModernCpp快速教程</title>
    <link href="https://joytsing.github.io/posts/35627/"/>
    <id>https://joytsing.github.io/posts/35627/</id>
    <published>2023-09-26T07:14:00.000Z</published>
    <updated>2023-09-26T11:47:56.722Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记是<a href="https://changkun.de/modern-cpp/zh-cn/00-preface/">现代C++教材：告诉上手C++11/14/17/20</a>的学习记录，目的是为了让cmu15445做的不那么痛苦，因为对于该实验来说，由于 Bustub 是在 C++17 下实现的数据库，因此所有学生都需要在正式开始之前，完成 Project #0 来检测对C++，尤其是 C++ 现代语法的熟悉程度，对于选这门课的学生所有没有以满分通关这个 Project 的同学都会被要求 drop 掉这门课。</p><h2 id="第-1-章-迈向现代C"><a href="#第-1-章-迈向现代C" class="headerlink" title="第 1 章 迈向现代C++"></a>第 1 章 迈向现代C++</h2><ul><li><strong><code>auto_ptr</code> 被弃用，应使用 <code>unique_ptr</code>。</strong></li><li><strong>C 语言风格的类型转换被弃用（即在变量前使用 <code>(convert_type)</code>），应该使用 <code>static_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code> 来进行类型转换。</strong><br>在编写 C++ 时，也应该尽可能的避免使用诸如 <code>void*</code> 之类的程序风格。而在不得不使用 C 时，应该注意使用 <code>extern &quot;C&quot;</code> 这种特性，将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法，例如：</li></ul><h2 id="第-2-章-语言可用性的强化"><a href="#第-2-章-语言可用性的强化" class="headerlink" title="第 2 章 语言可用性的强化"></a>第 2 章 语言可用性的强化</h2><h3 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h3><h4 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h4><p><code>nullptr</code> 出现的目的是为了替代 <code>NULL</code>。在某种意义上来说，传统 C++ 会把 <code>NULL</code>、<code>0</code> 视为同一种东西，这取决于编译器如何定义 <code>NULL</code>，有些编译器会将 <code>NULL</code> 定义为 <code>((void*)0)</code>，有些则会直接将其定义为 <code>0</code>。</p><p>C++ <strong>不允许</strong>直接将 <code>void *</code> 隐式转换到其他类型。但如果编译器尝试把 <code>NULL</code> 定义为 <code>((void*)0)</code>，那么在下面这句代码中：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>ch <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>没有了 <code>void *</code> 隐式转换的 C++ 只好将 <code>NULL</code> 定义为 <code>0</code>。而这依然会产生新的问题，将 <code>NULL</code> 定义成 <code>0</code> 将导致 <code>C++</code> 中重载特性发生混乱。考虑下面这两个 <code>foo</code> 函数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么 <code>foo(NULL);</code> 这个语句将会去调用 <code>foo(int)</code>，从而导致代码违反直觉。</p><p>为了解决这个问题，C++11 引入了 <code>nullptr</code> 关键字，专门用来区分空指针、<code>0</code>。而 <code>nullptr</code> 的类型为 <code>nullptr_t</code>，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p><p><code>NULL</code> 不同于 <code>0</code> 与 <code>nullptr</code>。所以，请养成直接使用 <code>nullptr</code>的习惯。</p><p><code>decltype</code> 和 <code>std::is_same</code> 这两个属于现代 C++ 的语法，简单来说，<code>decltype</code> 用于类型推导，而 <code>std::is_same</code> 用于比较两个类型是否相同。</p><h4 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h4><p>C++ 本身已经具备了常量表达式的概念，比如 <code>1+2</code>, <code>3*4</code> 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。一个非常明显的例子就是在数组的定义阶段：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property">#<span class="token directive keyword">define</span> LEN 10  </span><span class="token keyword">int</span> <span class="token function">len_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">len_foo_constexpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">char</span> arr_1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 合法  </span>    <span class="token keyword">char</span> arr_2<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 合法  </span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// char arr_3[len];                  // 非法  </span>    <span class="token keyword">const</span> <span class="token keyword">int</span> len_2 <span class="token operator">=</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">constexpr</span> <span class="token keyword">int</span> len_2_constexpr <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// char arr_4[len_2];                // 非法  </span>    <span class="token keyword">char</span> arr_4<span class="token punctuation">[</span>len_2_constexpr<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 合法  </span>    <span class="token comment" spellcheck="true">// char arr_5[len_foo()+5];          // 非法  </span>    <span class="token keyword">char</span> arr_6<span class="token punctuation">[</span><span class="token function">len_foo_constexpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法  </span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 1, 1, 2, 3, 5, 8, 13, 21, 34, 55  </span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子中，<code>char arr_4[len_2]</code> 可能比较令人困惑，因为 <code>len_2</code> 已经被定义为了常量。为什么 <code>char arr_4[len_2]</code> 仍然是非法的呢？这是因为 C++ 标准中数组的长度必须是一个常量表达式，而对于 <code>len_2</code> 而言，这是一个 <code>const</code> 常数，而不是一个常量表达式，因此（即便这种行为在大部分编译器中都支持，但是）它是一个非法的行为，我们需要使用接下来即将介绍的 C++11 引入的 <code>constexpr</code> 特性来解决这个问题；而对于 <code>arr_5</code> 来说，C++98 之前的编译器无法得知 <code>len_foo()</code> 在运行期实际上是返回一个常数，这也就导致了非法的产生。</p><blockquote><p>注意，现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。</p></blockquote><p>C++11 提供了 <code>constexpr</code> 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 <code>len_foo</code> 在编译期就应该是一个常量表达式。</p><p>此外，<code>constexpr</code> 修饰的函数可以使用递归：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从 C++14 开始，<code>constexpr</code> 函数可以在内部使用局部变量、循环和分支等简单语句，但是对于C++11来说则需要简化到如上述代码才行，因为无法使用分支语句。</p><h3 id="2-2-变量及其初始化"><a href="#2-2-变量及其初始化" class="headerlink" title="2.2 变量及其初始化"></a>2.2 变量及其初始化</h3><h4 id="if-switch变量声明强化"><a href="#if-switch变量声明强化" class="headerlink" title="if/switch变量声明强化"></a>if/switch变量声明强化</h4><p>在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 <code>for</code> 语句内能够声明一个临时变量 <code>int</code>，但始终没有办法在 <code>if</code> 和 <code>switch</code> 语句中声明一个临时的变量。也就是需要在全局声明后才能在局部代码域内使用，比如：</p><pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">// 在 c++17 之前  </span>    <span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator itr <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>itr <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token operator">*</span>itr <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>itr</code> 这一变量是定义在整个 <code>main()</code> 的作用域内的，这导致当我们需要再次遍历整个 <code>std::vector</code> 时，需要重新命名另一个变量(因为容器已经更改了迭代器失效)。C++17 消除了这一限制，使得我们可以在 <code>if</code>（或 <code>switch</code>）中完成这一操作：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 将临时变量放到 if 语句内  </span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator itr <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      itr <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token operator">*</span>itr <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。 在传统 C++ 中，不同的对象有着不同的初始化方法，例如普通数组、 POD （<strong>P</strong>lain <strong>O</strong>ld <strong>D</strong>ata，即没有构造、析构和虚函数的类或结构体） 类型都可以使用 <code>{}</code> 进行初始化，也就是我们所说的初始化列表。 而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 <code>()</code> 进行。 这些不同方法都针对各自对象，不能通用。</p><p>比如最常见的：<br><img src="/posts/35627/image-20230919213531943.png" alt></p><p>为解决这个问题，C++11 首先把初始化列表的概念绑定到类型上，称其为 <code>std::initializer_list</code>，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁:</p><p><img src="/posts/35627/image-20230919213518078.png" alt><br>出现这个的原因是在C++中，当创建一个对象时，编译器要保证调用了所有子对象的构造函数，这是C++强制要求的，也是它的一个机制。而在一些自定义类中没有定义默认构造函数，只定义了一个有整型参数的构造函数，因此编译器并不会再去生成一个默认的构造函数，而BaseChild继承Base时，又没有显式地指定Base的构造函数，所以编译报错。</p><p>如果不修改Base，那么，我们用什么办法不去调用默认构造函数，而是显式的调用Base带参构造函数呢。答案就是初始化列表。</p><h4 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h4><p>结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新增了 <code>std::tuple</code> 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11/14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 <code>std::tie</code> 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。</p><p>C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码：</p><p><img src="/posts/35627/image-20230919215615980.png" alt></p><p>换句话说就是例如：返回一个结构体函数</p><pre class="line-numbers language-cpp"><code class="language-cpp">MyStruct <span class="token function">getStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> MyStruct<span class="token punctuation">{</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时我们可以直接通过结构化绑定拿到结构体的成员。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token punctuation">[</span>id<span class="token punctuation">,</span> val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另一个比较有意思的使用地方在于可以增加代码可读性，例如输出map中所有的键值对。map如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> mymap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"el"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"tom"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"nic"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结构化绑定之前我们遍历给定的是无意义的elem。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> elem <span class="token operator">:</span> mymap<span class="token punctuation">)</span> <span class="token punctuation">{</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> elem<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span>  <span class="token operator">&lt;&lt;</span> elem<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有了结构体绑定之后，我们只需要<code>[key, val]</code>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> val<span class="token punctuation">]</span> <span class="token operator">:</span> mymap<span class="token punctuation">)</span> <span class="token punctuation">{</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> key <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="左值引用限定符"><a href="#左值引用限定符" class="headerlink" title="左值引用限定符"></a>左值引用限定符</h4><p>刚才我们见到的结构化绑定都有一个复制的过程，会产生一个匿名对象。有时候复制的开销会比较大，我们当然想避免不必要的复制。于是我们可以为结构化绑定添加一个引用限定符，以引用的方式绑定到相应的对象上。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还记得刚刚说过结构化绑定过程中的匿名变量吗？它再一次派上大用场了。如果结构化绑定声明中包含引用限定符，那么这个引入的匿名变量就是一个引用！</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span><span class="token operator">&amp;</span> _unnamed_ <span class="token operator">=</span> arr<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a <span class="token operator">=</span> _unnamed_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> _unnamed_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> _unnamed_<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用 <code>_unnamed_</code> 绑定到 <code>arr</code>，而 <code>a</code> 又绑定到 <code>_unnamed_[0]</code>，也就是说 <code>a</code> 直接绑定到了 <code>arr[0]</code> 上。<code>b</code> 和 <code>c</code> 同理。再一次强调，即使添加了引用限定符，结构化绑定也不是引用，<code>decltype(a)</code> 仍然是 <code>int</code> 而不是 <code>int&amp;</code>。这里的引用只是为了表达绑定关系。</p><p>定义引用不会产生可观察的副作用，我们也就无法直接证明这个匿名变量确实是引用。当然我们还是可以从侧面来应证它，比如说左值引用不能绑定到右值。</p><pre class="line-numbers language-cpp"><code class="language-cpp">B <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> B<span class="token punctuation">{</span><span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">514</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Error，按值返回的函数调用是右值表达式</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="右值引用限定符"><a href="#右值引用限定符" class="headerlink" title="右值引用限定符"></a>右值引用限定符</h4><p>如果你要绑定右值表达式，自然可以用右值引用。实际上在结构化绑定中说“右值引用”限定符并不准确，毕竟前面还有一个 <code>auto</code> 占位符。<code>auto&amp;&amp;</code> 是不是右值引用可就说不准了，让我们来复习一下。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Error，右值引用不能绑定左值</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> rref <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// OK，auto&amp;&amp;会进行推导</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> lref <span class="token operator">=</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的示例代码中，<code>auto&amp;&amp; lref = i</code> 会进行类型推导，由于初始化器<code>i</code>是个左值，推导出 <code>auto -&gt; int&amp;</code> 再经过引用折叠 <code>int&amp; &amp;&amp; -&gt; int&amp;</code> 最终得到 <code>lref</code> 是个左值引用。</p><p>结构化绑定引入的匿名变量也是如此，如果引用限定符是 <code>&amp;&amp;</code> 那么匿名变量的类型就会根据这一规则自动推导，这也是 <code>auto&amp;&amp;</code> 被称为万能引用的原因。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> _unnamed_ <span class="token operator">=</span> arr<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 经过推导得到左值引用：</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>_unnamed_<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-类型推断"><a href="#2-3-类型推断" class="headerlink" title="2.3 类型推断"></a>2.3 类型推断</h3><p>C++11 引入了 <code>auto</code> 和 <code>decltype</code> 这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。</p><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>使用 <code>auto</code> 进行类型推导的一个最为常见而且显著的例子就是迭代器。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 在 C++11 之前  </span><span class="token comment" spellcheck="true">// 由于 cbegin() 将返回 vector&lt;int>::const_iterator  </span><span class="token comment" spellcheck="true">// 所以 it 也应该是 vector&lt;int>::const_iterator 类型  </span><span class="token keyword">for</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator it <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而有了 <code>auto</code> 之后可以：</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">// 从 C++11 起, 使用 auto 关键字进行类型推导  </span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> list<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">{</span>              vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：<code>auto</code> 还不能用于推导数组类型：</p><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p><code>decltype</code> 关键字是为了解决 <code>auto</code> 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 <code>typeof</code> 很相似：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有时候，我们可能需要计算某个表达式的类型，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">auto</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span> z<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="尾返回类型"><a href="#尾返回类型" class="headerlink" title="尾返回类型"></a>尾返回类型</h4><p>在介绍 <code>auto</code> 时，我们已经提过 <code>auto</code> 不能用于函数形参进行类型推导，那么 <code>auto</code> 能不能用于推导函数的返回类型呢？还是考虑一个加法函数的例子，在传统 C++ 中我们必须这么写：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> R<span class="token punctuation">,</span> <span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> U<span class="token operator">></span>R <span class="token function">add</span><span class="token punctuation">(</span>T x<span class="token punctuation">,</span> U y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>decltype</code> 推导 <code>x+y</code> 的类型，写出这样的代码:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>T x<span class="token punctuation">,</span> U y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是因为在编译器读到 decltype(x+y) 时，<code>x</code> 和 <code>y</code> 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做尾返回类型（trailing return type），利用 <code>auto</code> 关键字将返回类型后置：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> U<span class="token operator">></span>  <span class="token keyword">auto</span> <span class="token function">add2</span><span class="token punctuation">(</span>T x<span class="token punctuation">,</span> U y<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从 C++14 开始是可以直接让普通函数具备返回值推导,也就是无需再使用decltype而是直接用auto关键字即可。</p><h4 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h4><p><code>decltype(auto)</code> 是 C++14 开始提供的一个略微复杂的用法。简单来说，<code>decltype(auto)</code> 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 <code>decltype</code> 的参数表达式。考虑看下面的例子，当我们需要对下面两个函数进行封装时:</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string  <span class="token function">lookup1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&lt;</span>br<span class="token operator">></span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span> <span class="token function">lookup2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 C++11 中，封装实现是如下形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string <span class="token function">look_up_a_string_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">lookup1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  std<span class="token operator">::</span>string<span class="token operator">&amp;</span> <span class="token function">look_up_a_string_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">lookup2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而有了 <code>decltype(auto)</code>，我们可以让编译器完成这一件烦人的参数转发：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">look_up_a_string_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">lookup1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">look_up_a_string_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">lookup2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-控制流"><a href="#2-4-控制流" class="headerlink" title="2.4 控制流"></a>2.4 控制流</h3><p>正如本章开头出，我们知道了 C++11 引入了 <code>constexpr</code> 关键字，它将表达式或函数编译为常量结果。一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断，岂不是能让程序效率更高？C++17 将 <code>constexpr</code> 这个关键字引入到 <code>if</code> 语句中，允许在代码中声明常量表达式的判断条件，考虑下面的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>  <span class="token keyword">auto</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> t <span class="token operator">+</span> <span class="token number">0.001</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在编译时，实际代码就会表现为如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> t <span class="token operator">+</span> <span class="token number">0.001</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">print_type_info</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="区间for迭代"><a href="#区间for迭代" class="headerlink" title="区间for迭代"></a>区间for迭代</h4><p>C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句，我们可以进一步简化前面的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span>  </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> itr <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> itr <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span>itr <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> element <span class="token operator">:</span> vec<span class="token punctuation">)</span>          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> element <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// read only  </span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>element <span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>          element <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// writeable  </span>    <span class="token punctuation">}</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> element <span class="token operator">:</span> vec<span class="token punctuation">)</span>          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> element <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// read only  </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以配合结构化绑定查看插入是否成功：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 优雅地检查map的插入操作是否成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>iter<span class="token punctuation">,</span> ok<span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> <span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nnew item: { %d: %d }\n"</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> <span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nkey exsists: { %d: %d }\n"</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h3><p>模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。</p><h4 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h4><p>传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板的实例化。</p><p>为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token class-name">std</span><span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 强行实例化</span><span class="token keyword">extern</span> <span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token class-name">std</span><span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不在该当前编译文件中实例化模板</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="类型别名模板"><a href="#类型别名模板" class="headerlink" title="类型别名模板"></a>类型别名模板</h4><p>在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：<strong>模板是用来产生类型的。</strong> 在传统 C++ 中，<code>typedef</code> 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 不合法</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">typedef</span> MagicType<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span> FakeDarkMagic<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>C++11 使用 <code>using</code> 引入了下面这种形式的写法，并且同时支持对传统 <code>typedef</code> 相同的功效：<br><strong>通常我们使用 <code>typedef</code> 定义别名的语法是：<code>typedef 原名称 新名称;</code>，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>process<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">using</span> NewProcess <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">using</span> TrueDarkMagic <span class="token operator">=</span> MagicType<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="变长参数模板"><a href="#变长参数模板" class="headerlink" title="变长参数模板"></a>变长参数模板</h4><p> 在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子， 接受一组固定数量的模板参数；而 C++11 加入了新的表示方法， 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Magic</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如下面的定义：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Magic</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>              std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span>              std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span>              std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> darkMagic<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>既然是任意形式，所以个数为 <code>0</code> 的模板参数也是可以的：<code>class Magic&lt;&gt; nothing;</code>。如果不希望产生的模板参数个数为 <code>0</code>，可以手动的定义至少一个模板参数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Require<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Magic</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>变长参数模板也能被直接调整到到模板函数上。传统 C 中的 <code>printf</code> 函数， 虽然也能达成不定个数的形参的调用，但其并非类别安全。 而 C++11 除了能定义类别安全的变长参数函数外， 还可以使类似 <code>printf</code> 的函数能自然地处理非自带类别的对象。 除了在模板参数中能使用 <code>...</code> 表示不定长模板参数外， 函数参数也使用同样的表示法代表不定长参数， 这也就为我们简单编写变长参数函数提供了便捷的手段，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么我们定义了变长的模板参数，如何对参数进行解包呢？</p><p><strong>!!!!</strong> <strong>首先</strong>，我们可以使用 <code>sizeof...</code> 来计算参数的个数：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">magic</span><span class="token punctuation">(</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法：</p><h5 id="1-递归模板函数"><a href="#1-递归模板函数" class="headerlink" title="1.递归模板函数"></a>1.递归模板函数</h5><p>递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T0<span class="token operator">></span>  <span class="token keyword">void</span> <span class="token function">printf1</span><span class="token punctuation">(</span>T0 value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>  <span class="token keyword">void</span> <span class="token function">printf1</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token function">printf1</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">printf1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"123"</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-变参模板展开"><a href="#2-变参模板展开" class="headerlink" title="2.变参模板展开"></a>2.变参模板展开</h5><p>在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 <code>printf</code> 的编写：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T0<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">printf2</span><span class="token punctuation">(</span>T0 t0<span class="token punctuation">,</span> T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> t0 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">printf2</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 <code>std::bind</code> 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。</p><h4 id="非类型模板参数推导"><a href="#非类型模板参数推导" class="headerlink" title="非类型模板参数推导"></a>非类型模板参数推导</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span> BufSize<span class="token operator">></span>  <span class="token keyword">class</span> <span class="token class-name">buffer_t</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>      T<span class="token operator">&amp;</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span><span class="token operator">:</span>      T data<span class="token punctuation">[</span>BufSize<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  buffer_t<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token operator">></span> buf<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 100 作为模板参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种模板参数形式下，我们可以将 <code>100</code> 作为模板的参数进行传递。 在 C++11 引入了类型推导这一特性后，我们会很自然的问，既然此处的模板参数 以具体的字面量进行传递，能否让编译器辅助我们进行类型推导， 通过使用占位符 <code>auto</code> 从而不再需要明确指明类型？ 幸运的是，C++17 引入了这一特性，我们的确可以 <code>auto</code> 关键字，让编译器辅助完成具体类型的推导， 例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">auto</span> value<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      foo<span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// value 被推导为 int 类型  </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-面向对象"><a href="#2-6-面向对象" class="headerlink" title="2.6 面向对象"></a>2.6 面向对象</h3><h4 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h4><p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>      <span class="token keyword">int</span> value1<span class="token punctuation">;</span>      <span class="token keyword">int</span> value2<span class="token punctuation">;</span>      <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          value1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 委托 Base() 构造函数  </span>        value2 <span class="token operator">=</span> value<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Base <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>value1 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>value2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h4><p>在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 <code>using</code> 引入了继承构造函数的概念：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> value1<span class="token punctuation">;</span>    <span class="token keyword">int</span> value2<span class="token punctuation">;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        value1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 委托 Base() 构造函数</span>        value2 <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Subclass</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token operator">::</span>Base<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 继承构造</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Subclass <span class="token class-name">s</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>value1 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>value2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="显式虚函数重载"><a href="#显式虚函数重载" class="headerlink" title="显式虚函数重载"></a>显式虚函数重载</h4><p>在传统 C++ 中，经常容易发生意外重载虚函数的事情。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> SubClass<span class="token operator">:</span> Base <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>SubClass::foo</code> 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。</p><p>C++11 引入了 <code>override</code> 和 <code>final</code> 这两个关键字来防止上述情形的发生。</p><h5 id="override"><a href="#override" class="headerlink" title="override"></a>override</h5><p>当重载虚函数时，引入 <code>override</code> 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的其函数签名一致的虚函数，否则将无法通过编译：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> SubClass<span class="token operator">:</span> Base <span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> override<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> override<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非法, 父类没有此虚函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p><code>final</code> 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Base <span class="token punctuation">{</span>      <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> final<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">struct</span> SubClass1 final<span class="token operator">:</span> Base <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法  </span><span class="token keyword">struct</span> SubClass2 <span class="token operator">:</span> SubClass1 <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非法, SubClass1 已 final  </span><span class="token keyword">struct</span> SubClass3<span class="token operator">:</span> Base <span class="token punctuation">{</span>      <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非法, foo 已 final  </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="显式禁用默认函数"><a href="#显式禁用默认函数" class="headerlink" title="显式禁用默认函数"></a>显式禁用默认函数</h4><p>在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、 复制构造、赋值算符以及析构函数。 另外，C++ 也为所有类定义了诸如 <code>new</code> <code>delete</code> 这样的运算符。 当程序员有需要时，可以重载这部分函数。</p><p>这就引发了一些需求：无法精确控制默认函数的生成行为。 例如禁止类的拷贝时，必须将复制构造函数与赋值算符声明为 <code>private</code>。 尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。</p><p>并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器将不再生成默认构造函数， 但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。</p><p>C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数。 例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Magic</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Magic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 显式声明使用编译器生成的构造</span>    Magic<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Magic<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 显式声明拒绝编译器生成构造</span>    <span class="token function">Magic</span><span class="token punctuation">(</span><span class="token keyword">int</span> magic_number<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h4><p>在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），<strong>甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同</strong>，这通常不是我们希望看到的结果。</p><p>C++11 引入了枚举类（enumeration class），并使用 <code>enum class</code> 的语法进行声明：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">new_enum</span> <span class="token operator">:</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>      value1<span class="token punctuation">,</span>      value2<span class="token punctuation">,</span>      value3 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>      value4 <span class="token operator">=</span> <span class="token number">100</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较， 更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较，如上述的value3和value4可以比较。</p><p>而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 <code>&lt;&lt;</code> 这个算符来进行输出，可以收藏下面这个代码段：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>    <span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span>std<span class="token operator">::</span>is_enum<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span>        std<span class="token operator">::</span>ostream<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;</span> stream<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> stream <span class="token operator">&lt;&lt;</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>underlying_type<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第-3-章-语言运行期的强化"><a href="#第-3-章-语言运行期的强化" class="headerlink" title="第 3 章 语言运行期的强化"></a>第 3 章 语言运行期的强化</h2><h3 id="3-1-Lambda表达式"><a href="#3-1-Lambda表达式" class="headerlink" title="3.1 Lambda表达式"></a>3.1 Lambda表达式</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>Lambda 表达式的基本语法如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">[</span>捕获列表<span class="token punctuation">]</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span> <span class="token keyword">mutable</span><span class="token punctuation">(</span>可选<span class="token punctuation">)</span> 异常属性 <span class="token operator">-</span><span class="token operator">></span> 返回类型 <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 函数体  </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的语法规则除了 <code>[捕获列表]</code> 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去， 返回值使用了一个 <code>-&gt;</code> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。</p><p>所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：</p><h5 id="1-值捕获"><a href="#1-值捕获" class="headerlink" title="1. 值捕获"></a>1. 值捕获</h5><p>与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">lambda_value_capture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> copy_value <span class="token operator">=</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    value <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> stored_value <span class="token operator">=</span> <span class="token function">copy_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stored_value = "</span> <span class="token operator">&lt;&lt;</span> stored_value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这时, stored_value == 1, 而 value == 100.</span>    <span class="token comment" spellcheck="true">// 因为 copy_value 在创建时就保存了一份 value 的拷贝</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-引用捕获"><a href="#2-引用捕获" class="headerlink" title="2. 引用捕获"></a>2. 引用捕获</h5><p>与引用传参类似，引用捕获保存的是引用，值会发生变化。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">lambda_reference_capture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> copy_value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>value<span class="token punctuation">]</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    value <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> stored_value <span class="token operator">=</span> <span class="token function">copy_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"stored_value = "</span> <span class="token operator">&lt;&lt;</span> stored_value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这时, stored_value == 100, value == 100.</span>    <span class="token comment" spellcheck="true">// 因为 copy_value 保存的是引用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-隐式捕获"><a href="#3-隐式捕获" class="headerlink" title="3. 隐式捕获"></a>3. 隐式捕获</h5><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获.</p><p>总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：</p><ul><li>[] 空捕获列表</li><li>[name1, name2, …] 捕获一系列变量</li><li>[&amp;]引用捕获, 让编译器自行推导引用列表</li><li>[= ]值捕获, 让编译器自行推导值捕获列表</li></ul><h5 id="4-表达式捕获"><a href="#4-表达式捕获" class="headerlink" title="4. 表达式捕获"></a>4. 表达式捕获</h5><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。</p><p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 <code>auto</code> 本质上是相同的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span>  </span><span class="token comment" spellcheck="true">// std::make_unique</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span> </span><span class="token comment" spellcheck="true">// std::move</span><span class="token keyword">void</span> <span class="token function">lambda_expression_capture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> important <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> add <span class="token operator">=</span> <span class="token punctuation">[</span>v1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> v2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>important<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token operator">+</span>v1<span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">*</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中，important 是一个独占指针，是不能够被 “=” 值捕获到，这时候我们可以将其转移为右值，在表达式中初始化。</p><h3 id="3-2-函数对象包装器"><a href="#3-2-函数对象包装器" class="headerlink" title="3.2 函数对象包装器"></a>3.2 函数对象包装器</h3><h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h4><p>Lambda 表达式的本质是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象）， 当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">using</span> foo <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义函数类型, using 的使用见上一节中的别名语法  </span><span class="token keyword">void</span> <span class="token function">functional</span><span class="token punctuation">(</span>foo f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo*  </span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过函数指针调用函数  </span><span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token function">functional</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 传递闭包对象，隐式转换为 foo* 类型的函数指针值  </span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lambda 表达式调用  </span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用， 而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型， 统一称之为可调用类型。而这种类型，便是通过 <code>std::function</code> 引入的。</p><p>C++11 <code>std::function</code> 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。 例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> para<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> para<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// std::function 包装了一个返回值为 int, 参数为 int 的函数  </span>    std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> func <span class="token operator">=</span> foo<span class="token punctuation">;</span>      <span class="token keyword">int</span> important <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> func2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span>value<span class="token operator">+</span>important<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="std-bind-和-std-placeholder"><a href="#std-bind-和-std-placeholder" class="headerlink" title="std::bind 和 std::placeholder"></a>std::bind 和 std::placeholder</h4><p>而 std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。 例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将参数1,2绑定到函数 foo 上，</span>    <span class="token comment" spellcheck="true">// 但使用 std::placeholders::_1 来对第一个参数进行占位</span>    <span class="token keyword">auto</span> bindFoo <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span>    <span class="token function">bindFoo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-右值引用"><a href="#3-3-右值引用" class="headerlink" title="3.3 右值引用"></a>3.3 右值引用</h3><h4 id="左值、右值的纯右值、将亡值、右值"><a href="#左值、右值的纯右值、将亡值、右值" class="headerlink" title="左值、右值的纯右值、将亡值、右值"></a>左值、右值的纯右值、将亡值、右值</h4><p>要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。</p><p><strong>左值 (lvalue, left value)</strong>，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。</p><p><strong>右值 (rvalue, right value)</strong>，右边的值，是指表达式结束后就不再存在的<code>临时对象</code>。</p><p>而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。</p><p><strong>纯右值 (prvalue, pure rvalue)</strong>，纯粹的右值，要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值。</p><p>需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 正确，"01234" 类型为 const char [6]，因此是左值</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>left<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"01234"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 断言正确，确实是 const char [6] 类型，注意 decltype(expr) 在 expr 是左值</span>    <span class="token comment" spellcheck="true">// 且非无括号包裹的 id 表达式与类成员表达式时，会返回左值引用</span>    <span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>is_same<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token string">"01234"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误，"01234" 是左值，不可被右值引用</span>    <span class="token comment" spellcheck="true">// const char (&amp;&amp;right)[6] = "01234";</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是注意，数组可以被隐式转换成相对应的指针类型，而转换表达式的结果（如果不是左值引用）则一定是个右值（右值引用为将亡值，否则为纯右值）。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>   p   <span class="token operator">=</span> <span class="token string">"01234"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确，"01234" 被隐式转换为 const char*</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&amp;&amp;</span> pr  <span class="token operator">=</span> <span class="token string">"01234"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确，"01234" 被隐式转换为 const char*，该转换的结果是纯右值</span><span class="token comment" spellcheck="true">// const char*&amp; pl = "01234"; // 错误，此处不存在 const char* 类型的左值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>将亡值</strong> (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中， 纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。</p><p>将亡值可能稍有些难以理解，我们来看这样的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> temp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这样的代码中，就传统的理解而言，函数 <code>foo</code> 的返回值 <code>temp</code> 在内部创建然后被赋值给 <code>v</code>， 然而 <code>v</code> 获得这个对象时，会将整个 <code>temp</code> 拷贝一份，然后把 <code>temp</code> 销毁，如果这个 <code>temp</code> 非常大， 这将造成大量额外的开销（这也就是传统 C++ 一直被诟病的问题）。</p><p>在最后一行中，<code>v</code> 是左值、 <code>foo()</code> 返回的值就是右值（也是纯右值）。但是，<code>v</code> 可以被别的变量捕获到， 而 <code>foo()</code> 产生的那个返回值作为一个临时值，一旦被 <code>v</code> 复制后，将立即被销毁，无法获取、也不能修改。 而将亡值就定义了这样一种行为：临时的值能够被识别、同时又能够被移动。</p><p>在 C++11 之后，编译器为我们做了一些工作，此处的左值 <code>temp</code> 会被进行此隐式右值转换， 等价于 <code>static_cast&lt;std::vector&lt;int&gt; &amp;&amp;&gt;(temp)</code>，进而此处的 <code>v</code> 会将 <code>foo</code> 局部返回的值进行移动。 也就是后面我们将会提到的移动语义。</p><h4 id="右值引用和左值引用"><a href="#右值引用和左值引用" class="headerlink" title="右值引用和左值引用"></a>右值引用和左值引用</h4><p>要拿到一个将亡值，就需要用到右值引用：T &amp;&amp;，其中 T 是类型。 右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p><p><strong>C++11 提供了 <code>std::move</code> 这个方法将左值参数无条件的转换为右值， 有了它我们就能够方便的获得一个右值临时对象</strong>，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span>  </span><span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"左值"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;&amp;</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"右值"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      std<span class="token operator">::</span>string lv1 <span class="token operator">=</span> <span class="token string">"string,"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lv1 是一个左值  </span>    <span class="token comment" spellcheck="true">// std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值  </span>    std<span class="token operator">::</span>string<span class="token operator">&amp;&amp;</span> rv1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>lv1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法, std::move可以将左值转移为右值  </span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> rv1 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string,  </span>    <span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> lv2 <span class="token operator">=</span> lv1 <span class="token operator">+</span> lv1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法, 常量左值引用能够延长临时变量的生命周期  </span>    <span class="token comment" spellcheck="true">// lv2 += "Test"; // 非法, 常量引用无法被修改  </span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> lv2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string,string,  </span>    std<span class="token operator">::</span>string<span class="token operator">&amp;&amp;</span> rv2 <span class="token operator">=</span> lv1 <span class="token operator">+</span> lv2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法, 右值引用延长临时对象生命周期  </span>    rv2 <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"Test"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法, 非常量引用能够修改临时变量  </span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> rv2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string,string,string,Test  </span>    <span class="token function">reference</span><span class="token punctuation">(</span>rv2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出左值  </span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>rv2</code> 虽然引用了一个右值，但由于它是一个引用，所以 <code>rv2</code> 依然是一个左值。注意，这里有一个很有趣的历史遗留问题，我们先看下面的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// int &amp;a = std::move(1);    // 不合法，非常量左引用无法引用右值  </span>    <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 合法, 常量左引用允许引用右值  </span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个问题，为什么不允许非常量引用绑定到非左值？这是因为这种做法存在逻辑错误：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    v<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">increase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>int&amp;</code> 不能引用 <code>double</code> 类型的参数，因此必须产生一个临时值来保存 <code>s</code> 的值， 从而当 <code>increase()</code> 修改这个临时值时，调用完成后 <code>s</code> 本身并没有被修改。</p><p>第二个问题，为什么常量引用允许绑定到非左值？原因很简单，因为 Fortran 需要。</p><h4 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h4><p>传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的移动操作， 调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。 试想，搬家的时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份（重买）再放到新家、 再把原来的东西全部扔掉（销毁），这是非常反人类的一件事情。</p><p>传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据拷贝，浪费时间和空间。 右值引用的出现恰好就解决了这两个概念的混淆问题，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pointer<span class="token punctuation">;</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">pointer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"构造"</span> <span class="token operator">&lt;&lt;</span> pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">A</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">pointer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">.</span>pointer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"拷贝"</span> <span class="token operator">&lt;&lt;</span> pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 无意义的对象拷贝</span>    <span class="token function">A</span><span class="token punctuation">(</span>A<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">pointer</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>pointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span>pointer <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"移动"</span> <span class="token operator">&lt;&lt;</span> pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"析构"</span> <span class="token operator">&lt;&lt;</span> pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">delete</span> pointer<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 防止编译器优化</span>A <span class="token function">return_rvalue</span><span class="token punctuation">(</span><span class="token keyword">bool</span> test<span class="token punctuation">)</span> <span class="token punctuation">{</span>    A a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等价于 static_cast&lt;A&amp;&amp;>(a);</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> b<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 等价于 static_cast&lt;A&amp;&amp;>(b);</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    A obj <span class="token operator">=</span> <span class="token function">return_rvalue</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"obj:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> obj<span class="token punctuation">.</span>pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>obj<span class="token punctuation">.</span>pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中：</p><ol><li>首先会在 <code>return_rvalue</code> 内部构造两个 <code>A</code> 对象，于是获得两个构造函数的输出；</li><li>函数返回后，产生一个将亡值，被 <code>A</code> 的移动构造（<code>A(A&amp;&amp;)</code>）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 <code>obj</code> 中，而将亡值的指针被设置为 <code>nullptr</code>，防止了这块内存区域被销毁。</li></ol><p>从而避免了无意义的拷贝构造，加强了性能。再来看看涉及标准库的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span> </span><span class="token comment" spellcheck="true">// std::cout</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span> </span><span class="token comment" spellcheck="true">// std::move</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span> </span><span class="token comment" spellcheck="true">// std::vector</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span> </span><span class="token comment" spellcheck="true">// std::string</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string str <span class="token operator">=</span> <span class="token string">"Hello world."</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> v<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将使用 push_back(const T&amp;), 即产生拷贝行为</span>    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将输出 "str: Hello world."</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"str: "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将使用 push_back(const T&amp;&amp;), 不会出现拷贝行为</span>    <span class="token comment" spellcheck="true">// 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销</span>    <span class="token comment" spellcheck="true">// 这步操作后, str 中的值会变为空</span>    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将输出 "str: "</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"str: "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>前面我们提到了，一个声明的右值引用其实是一个左值。这就为我们进行参数转发（传递）造成了问题：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"左值"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"右值"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">pass</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"普通传参:"</span><span class="token punctuation">;</span>    <span class="token function">reference</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 始终调用 reference(int&amp;)</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"传递右值:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token function">pass</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1是右值, 但输出是左值</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"传递左值:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">pass</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// l 是左值, 输出左值</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 <code>pass(1)</code> 来说，虽然传递的是右值，但由于 <code>v</code> 是一个引用，所以同时也是左值。 因此 <code>reference(v)</code> 会调用 <code>reference(int&amp;)</code>，输出『左值』。 而对于<code>pass(l)</code>而言，<code>l</code>是一个左值，为什么会成功传递给 <code>pass(T&amp;&amp;)</code> 呢？</p><p>这是基于<strong>引用坍缩规则</strong>的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用， 但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用， 既能左引用，又能右引用。但是却遵循如下规则：</p><table><thead><tr><th align="center">函数形参类型</th><th align="center">实参参数类型</th><th align="center">推导后函数形参类型</th></tr></thead><tbody><tr><td align="center">T&amp;</td><td align="center">左引用</td><td align="center">T&amp;</td></tr><tr><td align="center">T&amp;</td><td align="center">右引用</td><td align="center">T&amp;</td></tr><tr><td align="center">T&amp;&amp;</td><td align="center">左引用</td><td align="center">T&amp;</td></tr><tr><td align="center">T&amp;&amp;</td><td align="center">右引用</td><td align="center">T&amp;&amp;</td></tr></tbody></table><p>因此，模板函数中使用 <code>T&amp;&amp;</code> 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。 更准确的讲，<strong>无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型</strong>。 这才使得 <code>v</code> 作为左值的成功传递。</p><p>完美转发就是基于上述规律产生的。所谓完美转发，就是为了让我们在传递参数的时候， 保持原来的参数类型（左引用保持左引用，右引用保持右引用）。 为了解决这个问题，我们应该使用 <code>std::forward</code> 来进行参数的转发（传递）：</p><pre class="line-numbers language-cpp"><code class="language-cpp">include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>  <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span>  </span><span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"左值引用"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"右值引用"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>  <span class="token keyword">void</span> <span class="token function">pass</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"              普通传参: "</span><span class="token punctuation">;</span>      <span class="token function">reference</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"       std::move 传参: "</span><span class="token punctuation">;</span>      <span class="token function">reference</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"    std::forward 传参: "</span><span class="token punctuation">;</span>      <span class="token function">reference</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"static_cast&lt;T&amp;&amp;> 传参: "</span><span class="token punctuation">;</span>      <span class="token function">reference</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"传递右值:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token function">pass</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"传递左值:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token function">pass</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>传递右值:              普通传参: 左值引用       std::move 传参: 右值引用    std::forward 传参: 右值引用static_cast&lt;T&amp;&amp;&gt; 传参: 右值引用传递左值:              普通传参: 左值引用       std::move 传参: 右值引用    std::forward 传参: 左值引用static_cast&lt;T&amp;&amp;&gt; 传参: 左值引用</code></pre><p>无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发； 由于类似的原因，<code>std::move</code> 总会接受到一个左值，从而转发调用了<code>reference(int&amp;&amp;)</code> 输出右值引用。</p><p>唯独 <code>std::forward</code> 即没有造成任何多余的拷贝，同时<strong>完美转发</strong>(传递)了函数的实参给了内部调用的其他函数。</p><p><code>std::forward</code> 和 <code>std::move</code> 一样，没有做任何事情，<code>std::move</code> 单纯的将左值转化为右值， <code>std::forward</code> 也只是单纯的将参数做了一个类型的转换，从现象上来看， <code>std::forward&lt;T&gt;(v)</code> 和 <code>static_cast&lt;T&amp;&amp;&gt;(v)</code> 是完全一样的。</p><p>当 <code>std::forward</code> 接受左值时，<code>_Tp</code> 被推导为左值，所以返回值为左值；而当其接受右值时， <code>_Tp</code> 被推导为 右值引用，则基于坍缩规则，返回值便成为了 <code>&amp;&amp; + &amp;&amp;</code> 的右值。 可见 <code>std::forward</code> 的原理在于巧妙的利用了模板类型推导中产生的差异。</p><p>这时我们能回答这样一个问题：为什么在使用循环语句的过程中，<code>auto&amp;&amp;</code> 是最安全的方式？ 因为当 <code>auto</code> 被推导为不同的左右引用时，与 <code>&amp;&amp;</code> 的坍缩组合是完美转发。</p><h2 id="第-4-章-容器"><a href="#第-4-章-容器" class="headerlink" title="第 4 章 容器"></a>第 4 章 容器</h2><h3 id="4-1-线性容器"><a href="#4-1-线性容器" class="headerlink" title="4.1 线性容器"></a>4.1 线性容器</h3><h4 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h4><p>看到这个容器的时候肯定会出现这样的问题：为什么要引入 std::array 而不是直接使用 std::vector？已经有了传统数组，为什么要用 std::array?</p><p>先回答第一个问题，与 <code>std::vector</code> 不同，<code>std::array</code> 对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用 <code>std::array</code> 容器。 另外由于 <code>std::vector</code> 是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作， 容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 <code>shrink_to_fit()</code> 释放这部分内存。</p><p>而第二个问题就更加简单，使用 <code>std::array</code> 能够让代码变得更加“现代化”，而且封装了一些操作函数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 <code>std::sort</code>。</p><p>当我们开始用上了 <code>std::array</code> 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">></span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// C 风格接口传参</span><span class="token comment" spellcheck="true">// foo(arr, arr.size()); // 非法, 无法隐式转换</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用 `std::sort`</span>std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="std-forward-list"><a href="#std-forward-list" class="headerlink" title="std::forward_list"></a>std::forward_list</h4><p><code>std::forward_list</code> 是一个列表容器，使用方法和 <code>std::list</code> 基本类似，因此我们就不花费篇幅进行介绍了。</p><p>需要知道的是，和 <code>std::list</code> 的双向链表的实现不同，<code>std::forward_list</code> 使用单向链表进行实现， 提供了 <code>O(1)</code> 复杂度的元素插入，不支持快速随机访问（这也是链表的特点）， 也是标准库容器中唯一一个不提供 <code>size()</code> 方法的容器。当不需要双向迭代时，具有比 <code>std::list</code> 更高的空间利用率。</p><h3 id="4-2-无序容器"><a href="#4-2-无序容器" class="headerlink" title="4.2 无序容器"></a>4.2 无序容器</h3><p>我们已经熟知了传统 C++ 中的有序容器 <code>std::map</code>/<code>std::set</code>，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 <code>O(log(size))</code>。在插入元素时候，会根据 <code>&lt;</code> 操作符比较元素大小并判断元素是否相同， 并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 <code>&lt;</code> 操作符的顺序来逐个遍历。</p><p>而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 <code>O(constant)</code>， 在不关心容器内部元素顺序时，能够获得显著的性能提升。</p><p>C++11 引入了的两组无序容器分别是：<code>std::unordered_map</code>/<code>std::unordered_multimap</code> 和 <code>std::unordered_set</code>/<code>std::unordered_multiset</code>。</p><p>它们的用法和原有的 <code>std::map</code>/<code>std::multimap</code>/<code>std::set</code>/<code>set::multiset</code> 基本类似。</p><h3 id="4-3-元组"><a href="#4-3-元组" class="headerlink" title="4.3 元组"></a>4.3 元组</h3><p>了解过 Python 的程序员应该知道元组的概念，纵观传统 C++ 中的容器，除了 <code>std::pair</code> 外， 似乎没有现成的结构能够用来存放不同类型的数据（通常我们会自己定义结构）。 但 <code>std::pair</code> 的缺陷是显而易见的，只能保存两个元素。</p><h4 id="元组基本操作"><a href="#元组基本操作" class="headerlink" title="元组基本操作"></a>元组基本操作</h4><p>关于元组的使用有三个核心的函数：</p><ol><li><code>std::make_tuple</code>: 构造元组</li><li><code>std::get</code>: 获得元组某个位置的值</li><li><code>std::tie</code>: 元组拆包</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;tuple></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">auto</span> <span class="token function">get_student</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 返回类型被推断为 std::tuple&lt;double, char, std::string></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">3.8</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">2.9</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">1.7</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果只写 0 会出现推断错误, 编译失败</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> student <span class="token operator">=</span> <span class="token function">get_student</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ID: 0, "</span>    <span class="token operator">&lt;&lt;</span> <span class="token string">"GPA: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>    <span class="token operator">&lt;&lt;</span> <span class="token string">"成绩: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>    <span class="token operator">&lt;&lt;</span> <span class="token string">"姓名: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">></span><span class="token punctuation">(</span>student<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> gpa<span class="token punctuation">;</span>    <span class="token keyword">char</span> grade<span class="token punctuation">;</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 元组进行拆包</span>    std<span class="token operator">::</span><span class="token function">tie</span><span class="token punctuation">(</span>gpa<span class="token punctuation">,</span> grade<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">get_student</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ID: 1, "</span>    <span class="token operator">&lt;&lt;</span> <span class="token string">"GPA: "</span> <span class="token operator">&lt;&lt;</span> gpa <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>    <span class="token operator">&lt;&lt;</span> <span class="token string">"成绩: "</span> <span class="token operator">&lt;&lt;</span> grade <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>    <span class="token operator">&lt;&lt;</span> <span class="token string">"姓名: "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::get</code> 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">,</span> <span class="token number">4.5</span><span class="token punctuation">,</span> <span class="token number">6.7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非法, 引发编译期错误</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">3</span><span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行期索引"><a href="#运行期索引" class="headerlink" title="运行期索引"></a>运行期索引</h4><p>如果你仔细思考一下可能就会发现上面代码的问题，<code>std::get&lt;&gt;</code> 依赖一个编译期的常量，所以下面的方式是不合法的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>std<span class="token operator">::</span>get<span class="token operator">&lt;</span>index<span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么要怎么处理？答案是，使用 <code>std::variant&lt;&gt;</code>（C++ 17 引入），提供给 <code>variant&lt;&gt;</code> 的类型模板参数 可以让一个 <code>variant&lt;&gt;</code> 从而容纳提供的几种类型的变量,这是 C++ 中的语法糖，它可以简化代码的编写，提高程序的可读性和可维护性。</p><p>在之前的版本中，C++ 可以使用 <code>union</code> 来存储不同类型的数据，但是 <code>union</code> 存在一些限制，比如不能存储非 POD 类型和类对象。而 <code>std::variant</code> 可以存储任意类型，包括非 POD 类型和类对象。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;variant></span></span><span class="token keyword">template</span> <span class="token operator">&lt;</span>size_t n<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">></span><span class="token keyword">constexpr</span> std<span class="token operator">::</span>variant<span class="token operator">&lt;</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> <span class="token function">_tuple_index</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token operator">&amp;</span> tpl<span class="token punctuation">,</span> size_t i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">out_of_range</span><span class="token punctuation">(</span><span class="token string">"越界."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span>        <span class="token keyword">return</span> std<span class="token operator">::</span>variant<span class="token operator">&lt;</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">{</span> std<span class="token operator">::</span>in_place_index<span class="token operator">&lt;</span>n<span class="token operator">></span><span class="token punctuation">,</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span>n<span class="token operator">></span><span class="token punctuation">(</span>tpl<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> _tuple_index<span class="token operator">&lt;</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> n<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>tpl<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">></span><span class="token keyword">constexpr</span> std<span class="token operator">::</span>variant<span class="token operator">&lt;</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> <span class="token function">tuple_index</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token operator">&amp;</span> tpl<span class="token punctuation">,</span> size_t i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> _tuple_index<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">(</span>tpl<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T0<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>ostream <span class="token operator">&amp;</span> s<span class="token punctuation">,</span> std<span class="token operator">::</span>variant<span class="token operator">&lt;</span>T0<span class="token punctuation">,</span> Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span> <span class="token keyword">const</span> <span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>     std<span class="token operator">::</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span> s <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就能：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">tuple_index</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="元组合并与遍历"><a href="#元组合并与遍历" class="headerlink" title="元组合并与遍历"></a>元组合并与遍历</h5><p>还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> new_tuple <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">tuple_cat</span><span class="token punctuation">(</span><span class="token function">get_student</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>马上就能够发现，应该如何快速遍历一个元组？但是我们刚才介绍了如何在运行期通过非常数索引一个 <code>tuple</code> 那么遍历就变得简单了， 首先我们需要知道一个元组的长度，可以：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>  <span class="token keyword">auto</span> <span class="token function">tuple_len</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>tpl<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> std<span class="token operator">::</span>tuple_size<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样就能够对元组进行迭代了：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 迭代</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token function">tuple_len</span><span class="token punctuation">(</span>new_tuple<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 运行期索引</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">tuple_index</span><span class="token punctuation">(</span>new_tuple<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第-5-章-智能指针与内存管理"><a href="#第-5-章-智能指针与内存管理" class="headerlink" title="第 5 章 智能指针与内存管理"></a>第 5 章 智能指针与内存管理</h2><h3 id="5-1-RAII与引用计数"><a href="#5-1-RAII与引用计数" class="headerlink" title="5.1 RAII与引用计数"></a>5.1 RAII与引用计数</h3><p>在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源而导致泄露。 所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间， 也就是我们常说的 RAII 资源获取即初始化技术。</p><p>凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 <code>new</code> 和 <code>delete</code> 去 『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针包括 <code>std::shared_ptr</code>/<code>std::unique_ptr</code>/<code>std::weak_ptr</code>，使用它们需要包含头文件 <code>&lt;memory&gt;</code>。</p><blockquote><p>注意：引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待， 更能够清晰明确的表明资源的生命周期。</p></blockquote><h3 id="5-2-std-shared-ptr"><a href="#5-2-std-shared-ptr" class="headerlink" title="5.2 std::shared_ptr"></a>5.2 std::shared_ptr</h3><p><code>std::shared_ptr</code> 是一种智能指针，它能够记录多少个 <code>shared_ptr</code> 共同指向一个对象，从而消除显式的调用 <code>delete</code>，当引用计数变为零的时候就会将对象自动删除。</p><p>但还不够，因为使用 <code>std::shared_ptr</code> 仍然需要使用 <code>new</code> 来调用，这使得代码出现了某种程度上的不对称。</p><p><code>std::make_shared</code> 就能够用来消除显式的使用 <code>new</code>，所以<code>std::make_shared</code> 会分配创建传入参数中的对象， 并返回这个对象类型的<code>std::shared_ptr</code>指针。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// auto pointer = new int(10); // illegal, no direct assignment</span>    <span class="token comment" spellcheck="true">// Constructed a std::shared_ptr</span>    <span class="token keyword">auto</span> pointer <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">foo</span><span class="token punctuation">(</span>pointer<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>pointer <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 11</span>    <span class="token comment" spellcheck="true">// The shared_ptr will be destructed before leaving the scope</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::shared_ptr</code> 可以通过 <code>get()</code> 方法来获取原始指针，通过 <code>reset()</code> 来减少一个引用计数， 并通过<code>use_count()</code>来查看一个对象的引用计数。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> pointer <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span> pointer2 <span class="token operator">=</span> pointer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引用计数+1  </span><span class="token keyword">auto</span> pointer3 <span class="token operator">=</span> pointer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引用计数+1  </span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> pointer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这样不会增加引用计数  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer2.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer3.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3  </span>pointer2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reset pointer2:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer2.use_count() = "</span>  <span class="token operator">&lt;&lt;</span> pointer2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pointer2 已 reset; 0  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer3.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2  </span>pointer3<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reset pointer3:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer2.use_count() = "</span> <span class="token operator">&lt;&lt;</span> pointer2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0  </span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pointer3.use_count() = "</span>  <span class="token operator">&lt;&lt;</span> pointer3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pointer3 已 reset; 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-std-unique-ptr"><a href="#5-3-std-unique-ptr" class="headerlink" title="5.3 std::unique_ptr"></a>5.3 std::unique_ptr</h3><p><code>std::unique_ptr</code> 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> pointer <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// make_unique 从 C++14 引入</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> pointer2 <span class="token operator">=</span> pointer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>make_unique</code> 并不复杂，C++11 没有提供 <code>std::make_unique</code>，可以自行实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span>  std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_unique</span><span class="token punctuation">(</span> Args<span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>既然是独占，换句话说就是不可复制。但是，我们可以利用 <code>std::move</code> 将其转移给其他的 <code>unique_ptr</code>，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">struct</span> Foo <span class="token punctuation">{</span>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Foo::Foo"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Foo::~Foo"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Foo::foo"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(const Foo&amp;)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>Foo<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// p1 不空, 输出</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p1<span class="token punctuation">)</span> p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p2 不空, 输出</span>        <span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p2 不空, 输出</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span> p2<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p1 为空, 无输出</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p2 为空, 无输出</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span> p2<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p2 被销毁"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// p1 不空, 输出</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p1<span class="token punctuation">)</span> p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Foo 的实例会在离开作用域时被销毁</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-std-weak-ptr"><a href="#5-4-std-weak-ptr" class="headerlink" title="5.4 std::weak_ptr"></a>5.4 std::weak_ptr</h3><p>如果你仔细思考 std::shared_ptr 就会发现依然存在着资源无法释放的问题。看下面这个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A<span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token punctuation">;</span><span class="token keyword">struct</span> A <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">></span> pointer<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A 被销毁"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B <span class="token punctuation">{</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> pointer<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B 被销毁"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> a <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> b <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token operator">-</span><span class="token operator">></span>pointer <span class="token operator">=</span> b<span class="token punctuation">;</span>    b<span class="token operator">-</span><span class="token operator">></span>pointer <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 <code>a,b</code>，这使得 <code>a,b</code> 的引用计数均变为了 2，而离开作用域时，<code>a,b</code> 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 <code>a,b</code> 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露:</p><p><img src="/posts/35627/image-20230920211900775.png" alt></p><p>解决这个问题的办法就是使用弱引用指针 <code>std::weak_ptr</code>，<code>std::weak_ptr</code>是一种弱引用（相比较而言 <code>std::shared_ptr</code> 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的释放流程如图所示：</p><p><img src="/posts/35627/image-20230920211910262.png" alt></p><p>在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。</p><p><code>std::weak_ptr</code> 没有 <code>*</code> 运算符和 <code>-&gt;</code> 运算符，所以不能够对资源进行操作，它可以用于检查 <code>std::shared_ptr</code> 是否存在，其 <code>expired()</code> 方法能在资源未被释放时，会返回 <code>false</code>，否则返回 <code>true</code>；除此之外，它也可以用于获取指向原始对象的 <code>std::shared_ptr</code> 指针，其 <code>lock()</code> 方法在原始对象未被释放时，返回一个指向原始对象的 <code>std::shared_ptr</code> 指针，进而访问原始对象的资源，否则返回<code>nullptr</code>。</p><h2 id="第-6-章-正则表达式"><a href="#第-6-章-正则表达式" class="headerlink" title="第 6 章 正则表达式"></a>第 6 章 正则表达式</h2><h3 id="6-1-正则表达式简介"><a href="#6-1-正则表达式简介" class="headerlink" title="6.1 正则表达式简介"></a>6.1 正则表达式简介</h3><h4 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h4><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表：</p><table><thead><tr><th align="center">特别字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>$</code></td><td align="left">匹配输入字符串的结尾位置。</td></tr><tr><td align="center"><code>(</code>,<code>)</code></td><td align="left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td></tr><tr><td align="center"><code>*</code></td><td align="left">匹配前面的子表达式零次或多次。</td></tr><tr><td align="center"><code>+</code></td><td align="left">匹配前面的子表达式一次或多次。</td></tr><tr><td align="center"><code>.</code></td><td align="left">匹配除换行符 <code>\n</code> 之外的任何单字符。</td></tr><tr><td align="center"><code>[</code></td><td align="left">标记一个中括号表达式的开始。</td></tr><tr><td align="center"><code>?</code></td><td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td></tr><tr><td align="center"><code>\</code></td><td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配 <code>&#39;\&#39;</code> 字符，而 <code>\(</code> 则匹配 <code>&#39;(&#39;</code> 字符。</td></tr><tr><td align="center"><code>^</code></td><td align="left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。</td></tr><tr><td align="center"><code>{</code></td><td align="left">标记限定符表达式的开始。</td></tr><tr><td align="center"><code>|</code></td><td align="left">指明两项之间的一个选择。</td></tr></tbody></table><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><p>限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表：</p><table><thead><tr><th align="center">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>*</code></td><td align="left">匹配前面的子表达式零次或多次。例如，<code>foo*</code> 能匹配 <code>fo</code> 以及 <code>foooo</code>。<code>*</code> 等价于<code>{0,}</code>。</td></tr><tr><td align="center"><code>+</code></td><td align="left">匹配前面的子表达式一次或多次。例如，<code>foo+</code> 能匹配 <code>foo</code> 以及 <code>foooo</code>，但不能匹配 <code>fo</code>。<code>+</code> 等价于 <code>{1,}</code>。</td></tr><tr><td align="center"><code>?</code></td><td align="left">匹配前面的子表达式零次或一次。例如，<code>Your(s)?</code> 可以匹配 <code>Your</code> 或 <code>Yours</code> 中的<code>Your</code> 。<code>?</code> 等价于 <code>{0,1}</code>。</td></tr><tr><td align="center"><code>{n}</code></td><td align="left"><code>n</code> 是一个非负整数。匹配确定的 <code>n</code> 次。例如，<code>o{2}</code> 不能匹配 <code>for</code> 中的 <code>o</code>，但是能匹配 <code>foo</code> 中的两个 <code>o</code>。</td></tr><tr><td align="center"><code>{n,}</code></td><td align="left"><code>n</code> 是一个非负整数。至少匹配 <code>n</code> 次。例如，<code>o{2,}</code> 不能匹配 <code>for</code> 中的 <code>o</code>，但能匹配 <code>foooooo</code> 中的所有 <code>o</code>。<code>o{1,}</code> 等价于 <code>o+</code>。<code>o{0,}</code> 则等价于 <code>o*</code>。</td></tr><tr><td align="center"><code>{n,m}</code></td><td align="left"><code>m</code> 和 <code>n</code> 均为非负整数，其中 <code>n</code> 小于等于 <code>m</code>。最少匹配 <code>n</code> 次且最多匹配 <code>m</code> 次。例如，<code>o{1,3}</code> 将匹配 <code>foooooo</code> 中的前三个 <code>o</code>。<code>o{0,1}</code> 等价于 <code>o?</code>。注意，在逗号和两个数之间不能有空格。</td></tr></tbody></table><h3 id="6-2-std-regex-及其相关"><a href="#6-2-std-regex-及其相关" class="headerlink" title="6.2 std::regex 及其相关"></a>6.2 std::regex 及其相关</h3><p>C++11 提供的正则表达式库操作 <code>std::string</code> 对象， 模式 <code>std::regex</code> (本质是 <code>std::basic_regex</code>)进行初始化， 通过 <code>std::regex_match</code> 进行匹配， 从而产生 <code>std::smatch</code> （本质是 <code>std::match_results</code> 对象）。</p><p>我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式:</p><ul><li><code>[a-z]+\.txt</code>: 在这个正则表达式中, <code>[a-z]</code> 表示匹配一个小写字母, <code>+</code> 可以使前面的表达式匹配多次， 因此 <code>[a-z]+</code> 能够匹配一个小写字母组成的字符串。 在正则表达式中一个 <code>.</code> 表示匹配任意字符，而 <code>\.</code> 则表示匹配字符 <code>.</code>， 最后的 <code>txt</code> 表示严格匹配 <code>txt</code> 则三个字母。因此这个正则表达式的所要匹配的内容就是由纯小写字母组成的文本文件。</li></ul><p><code>std::regex_match</code> 用于匹配字符串和正则表达式，有很多不同的重载形式。 最简单的一个形式就是传入 <code>std::string</code> 以及一个 <code>std::regex</code> 进行匹配， 当匹配成功时，会返回 <code>true</code>，否则返回 <code>false</code>。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;regex></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>string fnames<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"foo.txt"</span><span class="token punctuation">,</span> <span class="token string">"bar.txt"</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"a0.txt"</span><span class="token punctuation">,</span> <span class="token string">"AAA.txt"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在 C++ 中 \ 会被作为字符串内的转义符，</span>    <span class="token comment" spellcheck="true">// 为使 \. 作为正则表达式传递进去生效，需要对 \ 进行二次转义，从而有 \\.</span>    std<span class="token operator">::</span>regex <span class="token function">txt_regex</span><span class="token punctuation">(</span><span class="token string">"[a-z]+\\.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>fname<span class="token operator">:</span> fnames<span class="token punctuation">)</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> fname <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">regex_match</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> txt_regex<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种常用的形式就是依次传入 <code>std::string</code>/<code>std::smatch</code>/<code>std::regex</code> 三个参数， 其中 <code>std::smatch</code> 的本质其实是 <code>std::match_results</code>。 故而在标准库的实现中， <code>std::smatch</code> 被定义为了 <code>std::match_results&lt;std::string::const_iterator&gt;</code>， 也就是一个子串迭代器类型的 <code>match_results</code>。 使用 <code>std::smatch</code> 可以方便的对匹配的结果进行获取，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>regex <span class="token function">base_regex</span><span class="token punctuation">(</span><span class="token string">"([a-z]+)\\.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>smatch base_match<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>fname<span class="token operator">:</span> fnames<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">regex_match</span><span class="token punctuation">(</span>fname<span class="token punctuation">,</span> base_match<span class="token punctuation">,</span> base_regex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// std::smatch 的第一个元素匹配整个字符串</span>        <span class="token comment" spellcheck="true">// std::smatch 的第二个元素匹配了第一个括号表达式</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>base_match<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>string base <span class="token operator">=</span> base_match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sub-match[0]: "</span> <span class="token operator">&lt;&lt;</span> base_match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> fname <span class="token operator">&lt;&lt;</span> <span class="token string">" sub-match[1]: "</span> <span class="token operator">&lt;&lt;</span> base <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上两个代码段的输出结果为：</p><pre><code>foo.txt: 1bar.txt: 1test: 0a0.txt: 0AAA.txt: 0sub-match[0]: foo.txtfoo.txt sub-match[1]: foosub-match[0]: bar.txtbar.txt sub-match[1]: bar</code></pre><h2 id="第-7-章-并行与并发"><a href="#第-7-章-并行与并发" class="headerlink" title="第 7 章 并行与并发"></a>第 7 章 并行与并发</h2><h3 id="7-1-并行基础"><a href="#7-1-并行基础" class="headerlink" title="7.1 并行基础"></a>7.1 并行基础</h3><p><code>std::thread</code> 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含 <code>&lt;thread&gt;</code> 头文件， 它提供了很多基本的线程操作，例如 <code>get_id()</code> 来获取所创建线程的线程 ID，使用 <code>join()</code> 来等待一个线程结束（与该线程汇合）等等，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-互斥量与临界区"><a href="#7-2-互斥量与临界区" class="headerlink" title="7.2 互斥量与临界区"></a>7.2 互斥量与临界区</h3><p>我们在操作系统、亦或是数据库的相关知识中已经了解过了有关并发技术的基本知识，<code>mutex</code> 就是其中的核心之一。 C++11 引入了 <code>mutex</code> 相关的类，其所有相关的函数都放在 <code>&lt;mutex&gt;</code> 头文件中。</p><p><code>std::mutex</code> 是 C++11 中最基本的 <code>mutex</code> 类，通过实例化 <code>std::mutex</code> 可以创建互斥量， 而通过其成员函数 <code>lock()</code> 可以进行上锁，<code>unlock()</code> 可以进行解锁。 但是在实际编写代码的过程中，最好不去直接调用成员函数， 因为调用成员函数就需要在每个临界区的出口处调用 <code>unlock()</code>，当然，还包括异常。 这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类 <code>std::lock_guard</code>。 RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。</p><p>在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span>  </span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">critical_section</span><span class="token punctuation">(</span><span class="token keyword">int</span> change_v<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">static</span> std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span>      std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 执行竞争操作  </span>    v <span class="token operator">=</span> change_v<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 离开此作用域后 mtx 会被释放  </span><span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>critical_section<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t2</span><span class="token punctuation">(</span>critical_section<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 C++ 保证了所有栈对象在生命周期结束时会被销毁，所以这样的代码也是异常安全的。 无论 <code>critical_section()</code> 正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了 <code>unlock()</code>。</p><p>而 <code>std::unique_lock</code> 则是相对于 <code>std::lock_guard</code> 出现的，<code>std::unique_lock</code> 更加灵活， <code>std::unique_lock</code> 的对象会以独占所有权（没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权） 的方式管理 <code>mutex</code> 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 <code>std::unique_lock</code>。</p><p><code>std::lock_guard</code> 不能显式的调用 <code>lock</code> 和 <code>unlock</code>， 而 <code>std::unique_lock</code> 可以在声明后的任意位置调用， 可以缩小锁的作用范围，提供更高的并发度。</p><p>如果你用到了条件变量 <code>std::condition_variable::wait</code> 则必须使用 <code>std::unique_lock</code> 作为参数。</p><p>例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span>  </span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">critical_section</span><span class="token punctuation">(</span><span class="token keyword">int</span> change_v<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">static</span> std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span>      std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 执行竞争操作  </span>    v <span class="token operator">=</span> change_v<span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 将锁进行释放  </span>    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 在此期间，任何人都可以抢夺 v 的持有权  </span>    <span class="token comment" spellcheck="true">// 开始另一组竞争操作，再次加锁  </span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      v <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>critical_section<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t2</span><span class="token punctuation">(</span>critical_section<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-期物"><a href="#7-3-期物" class="headerlink" title="7.3 期物"></a>7.3 期物</h3><p>期物（Future）表现为 <code>std::future</code>，它提供了一个访问异步操作结果的途径，这句话很不好理解。 为了理解这个特性，我们需要先理解一下在 C++11 之前的多线程行为。</p><p>试想，如果我们的主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务，并返回我一个结果。 而这时候，线程 A 可能正在忙其他的事情，无暇顾及 B 的结果， 所以我们会很自然的希望能够在某个特定的时间获得线程 B 的结果。</p><p>在 C++11 的 <code>std::future</code> 被引入之前，通常的做法是： 创建一个线程 A，在线程 A 里启动任务 B，当准备完毕后发送一个事件，并将结果保存在全局变量中。 而主函数线程 A 里正在做其他的事情，当需要结果的时候，调用一个线程等待函数来获得执行的结果。</p><p>而 C++11 提供的 <code>std::future</code> 简化了这个流程，可以用来获取异步任务的结果。 自然地，我们很容易能够想象到把它作为一种简单的线程同步手段，即屏障（barrier）。</p><p>为了看一个例子，我们这里额外使用 <code>std::packaged_task</code>，它可以用来封装任何可以调用的目标，从而用于实现异步的调用。 举例来说：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;future></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将一个返回值为7的 lambda 表达式封装到 task 中</span>    <span class="token comment" spellcheck="true">// std::packaged_task 的模板参数为要封装函数的类型</span>    std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获得 task 的期物</span>    std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在一个线程中执行 task</span>    std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"waiting..."</span><span class="token punctuation">;</span>    result<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在此设置屏障，阻塞到期物的完成</span>    <span class="token comment" spellcheck="true">// 输出执行结果</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"done!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span> endl <span class="token operator">&lt;&lt;</span> <span class="token string">"future result is "</span>              <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在封装好要调用的目标后，可以使用 <code>get_future()</code> 来获得一个 <code>std::future</code> 对象，以便之后实施线程同步。</p><h3 id="7-4-条件变量"><a href="#7-4-条件变量" class="headerlink" title="7.4 条件变量"></a>7.4 条件变量</h3><p>条件变量 <code>std::condition_variable</code> 是为了解决死锁而生，当互斥操作不够用而引入的。 比如，线程可能需要等待某个条件为真才能继续执行， 而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。 所以，<code>condition_variable</code> 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。 <code>std::condition_variable</code>的 <code>notify_one()</code> 用于唤醒一个线程； <code>notify_all()</code> 则是通知所有线程。下面是一个生产者和消费者模型的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> produced_nums<span class="token punctuation">;</span>    std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span>    std<span class="token operator">::</span>condition_variable cv<span class="token punctuation">;</span>    <span class="token keyword">bool</span> notified <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 通知信号</span>    <span class="token comment" spellcheck="true">// 生产者</span>    <span class="token keyword">auto</span> producer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">900</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"producing "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            produced_nums<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            notified <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            cv<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此处也可以使用 notify_one</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 消费者</span>    <span class="token keyword">auto</span> consumer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>notified<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 避免虚假唤醒</span>                cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 短暂取消锁，使得生产者有机会在消费者消费空前继续生产</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 消费者慢于生产者</span>            std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>produced_nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"consuming "</span> <span class="token operator">&lt;&lt;</span> produced_nums<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>                produced_nums<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            notified <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分别在不同的线程中运行</span>    std<span class="token operator">::</span>thread <span class="token function">p</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>thread cs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    p<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在生产者中我们虽然可以使用 <code>notify_one()</code>，但实际上并不建议在此处使用， 因为在多消费者的情况下，我们的消费者实现中简单放弃了锁的持有，这使得可能让其他消费者争夺此锁，从而更好的利用多个消费者之间的并发。话虽如此，但实际上因为 <code>std::mutex</code> 的排他性， 我们根本无法期待多个消费者能真正意义上的并行消费队列的中生产的内容，我们仍需要粒度更细的手段。</p><h3 id="7-5-原子操作与内存模型"><a href="#7-5-原子操作与内存模型" class="headerlink" title="7.5 原子操作与内存模型"></a>7.5 原子操作与内存模型</h3><p>细心的读者可能会对前一小节中生产者消费者模型的例子可能存在编译器优化导致程序出错的情况产生疑惑。例如，布尔值 <code>notified</code> 没有被 <code>volatile</code> 修饰，编译器可能对此变量存在优化，例如将其作为一个寄存器的值， 从而导致消费者线程永远无法观察到此值的变化。这是一个好问题，为了解释清楚这个问题，我们需要进一步讨论 从 C++ 11 起引入的内存模型这一概念。我们首先来看一个问题，下面这段代码输出结果是多少？</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span>flag <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>          flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从直观上看，<code>t2</code> 中 <code>a = 5;</code> 这一条语句似乎总在 <code>flag = 1;</code> 之前得到执行，而 <code>t1</code> 中 <code>while (flag != 1)</code> 似乎保证了 <code>std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl;</code> 不会再标记被改变前执行。从逻辑上看，似乎 <code>b</code> 的值应该等于 5。 但实际情况远比此复杂得多，或者说这段代码本身属于未定义的行为，因为对于 <code>a</code> 和 <code>flag</code> 而言，他们在两个并行的线程中被读写， 出现了竞争。除此之外，即便我们忽略竞争读写，仍然可能受 CPU 的乱序执行，编译器对指令的重排的影响， 导致 <code>a = 5</code> 发生在 <code>flag = 1</code> 之后。从而 <code>b</code> 可能输出 0。</p><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p><code>std::mutex</code> 可以解决上面出现的并发读写的问题，但互斥锁是操作系统级的功能， 这是因为一个互斥锁的实现通常包含两条基本原理：</p><ol><li>提供线程间自动的状态转换，即『锁住』这个状态</li><li>保障在互斥锁操作期间，所操作变量的内存与临界区外进行隔离</li></ol><p>这是一组非常强的同步条件，换句话说当最终编译为 CPU 指令时会表现为非常多的指令（我们之后再来看如何实现一个简单的互斥锁）。 这对于一个仅需原子级操作（没有中间态）的变量，似乎太苛刻了。</p><p>关于同步条件的研究有着非常久远的历史，我们在这里不进行赘述。读者应该明白，现代 CPU 体系结构提供了 CPU 指令级的原子操作， 因此在 C++11 中多线程下共享变量的读写这一问题上，还引入了 <code>std::atomic</code> 模板，使得我们实例化一个原子类型，将一个 原子类型读写操作从一组指令，最小化到单个 CPU 指令。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> counter<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并为整数或浮点数的原子类型提供了基本的数值成员函数，举例来说， 包括 <code>fetch_add</code>, <code>fetch_sub</code> 等，同时通过重载方便的提供了对应的 <code>+</code>，<code>-</code> 版本。 比如下面的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span>std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> count <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          count<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 等价于 fetch_add  </span>        count <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 等价于 fetch_add  </span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，并非所有的类型都能提供原子操作，这是因为原子操作的可行性取决于具体的 CPU 架构，以及所实例化的类型结构是否能够满足该 CPU 架构对内存对齐 条件的要求，因而我们总是可以通过 <code>std::atomic&lt;T&gt;::is_lock_free</code> 来检查该原子类型是否需支持原子操作，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">struct</span> A <span class="token punctuation">{</span>      <span class="token keyword">float</span> x<span class="token punctuation">;</span>      <span class="token keyword">int</span> y<span class="token punctuation">;</span>      <span class="token keyword">long</span> <span class="token keyword">long</span> z<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span>A<span class="token operator">></span> a<span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>boolalpha <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span><span class="token function">is_lock_free</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h4><p>并行执行的多个线程，从某种宏观层面上讨论，可以粗略的视为一种分布式系统。 在分布式系统中，任何通信乃至本地操作都需要消耗一定时间，甚至出现不可靠的通信。</p><p>如果我们强行将一个变量 <code>v</code> 在多个线程之间的操作设为原子操作，即任何一个线程在操作完 <code>v</code> 后， 其他线程均能<strong>同步</strong>感知到 <code>v</code> 的变化，则对于变量 <code>v</code> 而言，表现为顺序执行的程序，它并没有由于引入多线程 而得到任何效率上的收益。对此有什么办法能够适当的加速呢？答案便是削弱原子操作的在进程间的同步条件。</p><p>从原理上看，每个线程可以对应为一个集群节点，而线程间的通信也几乎等价于集群节点间的通信。 削弱进程间的同步条件，通常我们会考虑四种不同的一致性模型：</p><ol><li><strong>线性一致性：又称强一致性或原子一致性。它要求任何一次读操作都能读到某个数据的最近一次写的数据，并且所有线程的操作顺序与全局时钟下的顺序是一致的。</strong></li></ol><pre><code>        x.store(1)      x.load()T1 ---------+----------------+------&gt;T2 -------------------+-------------&gt;                x.store(2)</code></pre><ol start="2"><li><strong>顺序一致性：同样要求任何一次读操作都能读到数据最近一次写入的数据，但未要求与全局时钟的顺序一致。</strong></li></ol><pre><code>       x.store(1)  x.store(3)   x.load()  T1 ---------+-----------+----------+-----&gt;  T2 ---------------+----------------------&gt;                x.store(2)  或者          x.store(1)  x.store(3)   x.load()  T1 ---------+-----------+----------+-----&gt;  T2 ------+-------------------------------&gt;        x.store(2)</code></pre><p>在顺序一致性的要求下，<code>x.load()</code> 必须读到最近一次写入的数据，因此 <code>x.store(2)</code> 与 <code>x.store(1)</code> 并无任何先后保障，即 只要 <code>T2</code> 的 <code>x.store(2)</code> 发生在 <code>x.store(3)</code> 之前即可。</p><ol start="3"><li><strong>因果一致性：它的要求进一步降低，只需要有因果关系的操作顺序得到保障，而非因果关系的操作顺序则不做要求。</strong></li></ol><pre><code>      a = 1      b = 2T1 ----+-----------+----------------------------&gt;T2 ------+--------------------+--------+--------&gt;      x.store(3)         c = a + b    y.load()或者      a = 1      b = 2T1 ----+-----------+----------------------------&gt;T2 ------+--------------------+--------+--------&gt;      x.store(3)          y.load()   c = a + b亦或者     b = 2       a = 1T1 ----+-----------+----------------------------&gt;T2 ------+--------------------+--------+--------&gt;      y.load()            c = a + b  x.store(3)</code></pre><p>上面给出的三种例子都是属于因果一致的，因为整个过程中，只有 <code>c</code> 对 <code>a</code> 和 <code>b</code> 产生依赖，而 <code>x</code> 和 <code>y</code> 在此例子中表现为没有关系（但实际情况中我们需要更详细的信息才能确定 <code>x</code> 与 <code>y</code> 确实无关）</p><ol start="4"><li><strong>最终一致性：是最弱的一致性要求，它只保障某个操作在未来的某个时间节点上会被观察到，但并未要求被观察到的时间。因此我们甚至可以对此条件稍作加强，例如规定某个操作被观察到的时间总是有界的。当然这已经不在我们的讨论范围之内了。</strong></li></ol><pre><code>    x.store(3)  x.store(4)  T1 ----+-----------+--------------------------------------------&gt;  T2 ---------+------------+--------------------+--------+--------&gt;           x.read      x.read()           x.read()   x.read()</code></pre><p>在上面的情况中，如果我们假设 x 的初始值为 0，则 <code>T2</code> 中四次 <code>x.read()</code> 结果可能但不限于以下情况：</p><pre><code>3 4 4 4 // x 的写操作被很快观察到  0 3 3 4 // x 的写操作被观察到的时间存在一定延迟  0 0 0 4 // 最后一次读操作读到了 x 的最终值，但此前的变化并未观察到  0 0 0 0 // 在当前时间段内 x 的写操作均未被观察到，          // 但未来某个时间点上一定能观察到 x 为 4 的情况</code></pre><h4 id="内存顺序"><a href="#内存顺序" class="headerlink" title="内存顺序"></a>内存顺序</h4><p>为了追求极致的性能，实现各种强度要求的一致性，C++11 为原子操作定义了六种不同的内存顺序 <code>std::memory_order</code> 的选项，表达了四种多线程间的同步模型：</p><ol><li><strong>宽松模型：在此模型下，单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间原子操作的顺序是任意的。类型通过 <code>std::memory_order_relaxed</code> 指定。我们来看一个例子：</strong></li></ol><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> counter <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>thread<span class="token operator">></span> vt<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      vt<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          counter<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vt<span class="token punctuation">)</span> <span class="token punctuation">{</span>      t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current counter:"</span> <span class="token operator">&lt;&lt;</span> counter <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>释放/消费模型：在此模型中，我们开始限制进程间的操作顺序，如果某个线程需要修改某个值，但另一个线程会对该值的某次操作产生依赖，即后者依赖前者。具体而言，线程 A 完成了三次对 <code>x</code> 的写操作，线程 <code>B</code> 仅依赖其中第三次 <code>x</code> 的写操作，与 <code>x</code> 的前两次写行为无关，则当 <code>A</code> 主动 <code>x.release()</code> 时候（即使用 <code>std::memory_order_release</code>），选项 <code>std::memory_order_consume</code> 能够确保 <code>B</code> 在调用 <code>x.load()</code> 时候观察到 <code>A</code> 中第三次对 <code>x</code> 的写操作。我们来看一个例子：</strong></li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 初始化为 nullptr 防止 consumer 线程从野指针进行读取</span>std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> v<span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>    ptr<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p <span class="token operator">=</span> ptr<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_consume<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"v: "</span> <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>producer<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 释放/获取模型：在此模型下，我们可以进一步加紧对不同线程间原子操作的顺序的限制，在释放 <code>std::memory_order_release</code> 和获取 <code>std::memory_order_acquire</code> 之间规定时序，即发生在释放（release）操作之前的</strong>所有<strong>写操作，对其他线程的任何获取（acquire）操作都是可见的，亦即发生顺序（happens-before）。</strong></p><blockquote><p>可以看到，<code>std::memory_order_release</code> 确保了它之前的写操作不会发生在释放操作之后，是一个向后的屏障（backward），而 <code>std::memory_order_acquire</code> 确保了它之前的写行为不会发生在该获取操作之后，是一个向前的屏障（forward）。对于选项 <code>std::memory_order_acq_rel</code> 而言，则结合了这两者的特点，唯一确定了一个内存屏障，使得当前线程对内存的读写不会被重排并越过此操作的前后：</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> flag <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    flag<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">acqrel</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> expected <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// must before compare_exchange_strong</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_acq_rel<span class="token punctuation">)</span><span class="token punctuation">)</span>        expected <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// must after compare_exchange_strong</span>    <span class="token comment" spellcheck="true">// flag has changed to 2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// must be 42</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>release<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>acqrel<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>acquire<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此例中我们使用了 <code>compare_exchange_strong</code> 比较交换原语（Compare-and-swap primitive），它有一个更弱的版本，即 <code>compare_exchange_weak</code>，它允许即便交换成功，也仍然返回 <code>false</code> 失败。其原因是因为在某些平台上虚假故障导致的，具体而言，当 CPU 进行上下文切换时，另一线程加载同一地址产生的不一致。除此之外，<code>compare_exchange_strong</code> 的性能可能稍差于 <code>compare_exchange_weak</code>，但大部分情况下，鉴于其使用的复杂度而言，<code>compare_exchange_weak</code> 应该被有限考虑。</p><p><strong>4. 顺序一致模型：在此模型下，原子操作满足顺序一致性，进而可能对性能产生损耗。可显式的通过 <code>std::memory_order_seq_cst</code> 进行指定。最后来看一个例子：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> counter <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>thread<span class="token operator">></span> vt<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      vt<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          counter<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vt<span class="token punctuation">)</span> <span class="token punctuation">{</span>      t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current counter:"</span> <span class="token operator">&lt;&lt;</span> counter <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子与第一个宽松模型的例子本质上没有区别，仅仅只是将原子操作的内存顺序修改为了 <code>memory_order_seq_cst</code>，有兴趣的读者可以自行编写程序测量这两种不同内存顺序导致的性能差异。</p><h2 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h2><h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>C++ 11 引入了两个新的关键字 <code>alignof</code> 和 <code>alignas</code> 来支持对内存对齐进行控制。 <code>alignof</code> 关键字能够获得一个与平台相关的 <code>std::size_t</code> 类型的值，用于查询该平台的对齐方式。 当然我们有时候并不满足于此，甚至希望自定定义结构的对齐方式，同样，C++ 11 还引入了 <code>alignas</code> 来重新修饰某个结构的对齐方式。我们来看两个例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">struct</span> Storage <span class="token punctuation">{</span>    <span class="token keyword">char</span>      a<span class="token punctuation">;</span>    <span class="token keyword">int</span>       b<span class="token punctuation">;</span>    <span class="token keyword">double</span>    c<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span>std<span class="token operator">::</span>max_align_t<span class="token punctuation">)</span> AlignasStorage <span class="token punctuation">{</span>    <span class="token keyword">char</span>      a<span class="token punctuation">;</span>    <span class="token keyword">int</span>       b<span class="token punctuation">;</span>    <span class="token keyword">double</span>    c<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>Storage<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>AlignasStorage<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>std::max_align_t</code> 要求每个标量类型的对齐方式严格一样，因此它几乎是最大标量没有差异， 进而大部分平台上得到的结果为 <code>long double</code>，因此我们这里得到的 <code>AlignasStorage</code> 的对齐要求是 8 或 16。</p><h3 id="noexcept-的修饰和操作"><a href="#noexcept-的修饰和操作" class="headerlink" title="noexcept 的修饰和操作"></a>noexcept 的修饰和操作</h3><p>C++ 相比于 C 的一大优势就在于 C++ 本身就定义了一套完整的异常处理机制。 然而在 C++11 之前，几乎没有人去使用在函数名后书写异常声明表达式， 从 C++11 开始，这套机制被弃用，所以我们不去讨论也不去介绍以前这套机制是如何工作如何使用， 你更不应该主动去了解它。</p><p>C++11 将异常的声明简化为以下两种情况：</p><ol><li>函数可能抛出任何异常</li><li>函数不能抛出任何异常</li></ol><p>并使用 <code>noexcept</code> 对这两种行为进行限制，例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">may_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可能抛出异常</span><span class="token keyword">void</span> <span class="token function">no_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不可能抛出异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 <code>noexcept</code> 修饰过的函数如果抛出异常，编译器会使用 <code>std::terminate()</code> 来立即终止程序运行。</p><p><code>noexcept</code> 还能够做操作符，用于操作一个表达式，当表达式无异常时，返回 <code>true</code>，否则返回 <code>false</code>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">may_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">auto</span> non_block_throw <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>    <span class="token function">may_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">no_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">auto</span> block_throw <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>    <span class="token function">no_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>boolalpha        <span class="token operator">&lt;&lt;</span> <span class="token string">"may_throw() noexcept? "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">may_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl        <span class="token operator">&lt;&lt;</span> <span class="token string">"no_throw() noexcept? "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">no_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl        <span class="token operator">&lt;&lt;</span> <span class="token string">"lmay_throw() noexcept? "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">non_block_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl        <span class="token operator">&lt;&lt;</span> <span class="token string">"lno_throw() noexcept? "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">block_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>noexcept</code> 修饰完一个函数之后能够起到封锁异常扩散的功效，如果内部产生异常，外部也不会触发。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">may_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"捕获异常, 来自 may_throw()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">non_block_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"捕获异常, 来自 non_block_throw()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">block_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"捕获异常, 来自 block_throw()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终输出为：</p><pre class="line-numbers language-cpp"><code class="language-cpp">捕获异常<span class="token punctuation">,</span> 来自 <span class="token function">may_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span>捕获异常<span class="token punctuation">,</span> 来自 <span class="token function">non_block_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>好了，你已经完全掌握modern cpp了，快去使用吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇笔记是&lt;a href=&quot;https://changkun.de/modern-cpp/zh-cn/00-preface/&quot;&gt;现代C++教材：告诉上手C++11/14/17/20&lt;/a&gt;的学习记录，目的是为了让cmu15445做的不那么痛苦，因为对于该实验来说，由于 Bu
      
    
    </summary>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445 2023spring环境准备</title>
    <link href="https://joytsing.github.io/posts/40555/"/>
    <id>https://joytsing.github.io/posts/40555/</id>
    <published>2023-09-26T06:59:39.000Z</published>
    <updated>2023-12-14T07:44:46.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近在做CMU15445，其实最痛苦的就是配环境，众所周知，VSCode的C/C++插件功能虽然全但是速度不怎么理想，写一点东西反应半天，非常之不友好。我们希望换到更加快速，提示更加智能的clangd上。</p><p>之前在网上看到了一大堆关于怎么配置LLVM家族的C/C++环境的教程，其中往往充斥着各种神鬼莫名的配置参数，对新手的劝退作用立竿见影。我理想的所谓新手教程应该是这样的：</p><ul><li>可控性高：偏好GUI &gt; 命令行 &gt; config</li><li>上下文完整：一步解决一个特定问题，不引入额外的负担</li><li>可复现性强：每个步骤应该立刻有可供检查的结果，易于排查错误</li></ul><p>好吧说来说去其实说的就是那些上来咣咣贴个config.json走人的。总之，今天我重走长征路，试图提出一个基本不使用配置文件的、绝对新手友好的入门教程。</p><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a><strong>环境要求</strong></h2><p>本教程基于WSL Ubuntu 20.04，理论上在其它Linux发行版以及MacOS中也是通用的。至于Windows？不想麻烦事的话就用宇宙IDE吧，反正有免费版。</p><p><img src="/posts/40555/v2-0115e06acc09c8c186b58255e2f37382_720w.png" alt></p><p>依赖的软件包，基本上就是LLVM全家桶+<code>cmake</code>：</p><ul><li><code>clang</code>：我们使用的编译器，拥有更加人性化的报错</li><li><code>clangd</code>：一个C/C++的Language Sever后端，薄纱C/C++ Tools</li><li><code>lldb</code>：调试工具，一家人就要整整齐齐</li><li><code>cmake</code>：构造工具，因为<code>clangd</code>需要读取<code>compile_commands.json</code>才能提供服务</li></ul><p>Ubuntu使用下面的指令进行安装，homebrew或者pacman同理（这也要教？）</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> clang clangd lldb cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后是VSCode中需要的插件：</p><p><img src="/posts/40555/v2-a50a07d13b0b666be35a638121a7f1bf_720w.png" alt></p><p>只需要这四个就可以了。其中<code>CodeLLDB</code>需要下载一个文件，几乎是一定会下载失败的。</p><p><img src="/posts/40555/v2-af9c9b58664856fd4ac9a61b6e707603_720w.png" alt></p><p>超时之后点击弹出来的消息，手动下载，然后再手动进行安装。</p><p><img src="/posts/40555/v2-2005e8f7f9c0d2d39143ae7a9814719f_720w.png" alt></p><p>在弹出菜单里选择你下载的那个（后缀为<code>.vsix</code>）即可。注意在WSL环境下你可以从<code>/mnt</code>文件夹下访问Windows文件，假如你直接下载在系统自带的下载文件夹里，那就是在<code>/mnt/c/Users/&lt;Username&gt;/Downloads/</code>里。装好了之后会弹出重载VSCode的窗口。</p><p><img src="/posts/40555/v2-f3c1c939f7620be1322847fe47419fff_720w.png" alt></p><p>到这里前期准备就结束啦。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a><strong>开始</strong></h2><p>随便找一个空文件夹打开，然后<code>Ctrl+Shift+P</code>或者你自定义的快捷键打开下拉菜单，搜索<code>cmake</code>，选择<code>Quick Start</code>：</p><p><img src="/posts/40555/v2-b4fa8e897c842aa3fc2fd275413a6116_720w.png" alt></p><p>给你的项目起个名字，类型选择<code>Executable</code>，第一次打开<code>cmake</code>可能还会问你一些编译套件的选择问题，选择<code>clang</code>即可，记得看清楚后缀免得用错。</p><p><img src="/posts/40555/v2-bc8f336ea7a344bc166e004c7017b23b_720w.png" alt></p><p>打开自动生成的<code>main.cpp</code>，发现<code>clangd</code>已经在运行了，就是这么简单。</p><p><img src="/posts/40555/v2-be076afa271b04531e49b4b2ceb8bd2e_720w.png" alt></p><p>打开<code>clangd</code>输出，看看<code>clangd</code>是否真的如此智能。</p><p><img src="/posts/40555/v2-b54764533865e5799920dbc5c94e788b_720w.png" alt></p><p>并没有，<code>clangd</code>抱怨说找不到编译数据库！那么这个所谓的编译数据库在哪里呢？其实就在<code>cmake</code>生成的<code>build</code>文件夹里：</p><p><img src="/posts/40555/v2-a03d685dde417dbd8bdbb754c2542f8e_720w.png" alt></p><p>我们要让<code>clangd</code>识别项目的编译数据库，于是终于到了我们第一次和配置文件的交锋。打开设置，搜索<code>clangd</code>，在<code>Arguments</code>配置项中输入参数<code>--compile-commands-dir=${workspaceFolder}/build</code>，然后点确定。</p><p><img src="/posts/40555/v2-82f2855bc27c062759338252fe69535c_720w.png" alt></p><p>这个参数相当直观，就是告知<code>clangd</code>我们的编译数据库在工作区根目录的<code>build</code>文件夹下。</p><p>重启VSCode，再次查看<code>clangd</code>输出，发现成功读入了参数，并且没有报错信息，同时能够使用<code>cmake</code>输入的编译指令即为配置成功。</p><p><img src="/posts/40555/v2-8084835575154df8603eee77c0c8982b_720w.webp" alt></p><h3 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h3><p>值得一提的是，在很多教程里面没有提到如果你下载了CMake language support这个软件，那么会需要一个.net运行环境依赖，这个依赖如果你只靠vscode同样是不能下载下来的，需要<code>apt install dotnet</code>的运行环境（或者连sdk一起下载），除此之外，如果你在vscode输出这栏打开CMake/Build这插件的输出，大概率会看见说build失败，缺乏ninja(然而实际上是构建成功的，只不过是原生cmake构建)，当然也可以不用管，但是我非常推荐安装ninja，它类似于CMake但速度比CMake快了一个数量级，并且安装并不麻烦。</p><pre class="line-numbers language-sh"><code class="language-sh">sudo apt-get install ninja-buildninja --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同时还推荐下载<code>github copilot</code>，感受人工智能帮你补充代码和注释（前提已经弄好了github pro），接下来就可以正式开始了。</p><h2 id="运行与调试"><a href="#运行与调试" class="headerlink" title="运行与调试"></a><strong>运行与调试</strong></h2><p>按一下底部菜单中的<code>build</code>键，看看我们生成的可执行文件在哪里（一般就在<code>build</code>下面）：</p><p><img src="/posts/40555/v2-27523b009d10182419ae5ac3d3549cce_720w.png" alt></p><p>按<code>F5</code>键，VSCode会报错，同时在根目录下生成一个<code>.vscode</code>文件夹以及<code>launch.json</code>。打开这个json文件，将其中唯一一个需要我们配置的（也是本文第二次跟配置文件打交道）<code>program</code>项改为<code>cmake</code>生成的可执行文件的位置（按照惯例，根目录的名字和项目的名字应该是同一个，否则就需要手动指定）。</p><p><img src="/posts/40555/v2-853b8410f04d1e7570ecb9014026d6fc_720w.png" alt></p><p>再按一次<code>F5</code>，终端返回了一句亲切的<code>Hello World</code>。</p><p><img src="/posts/40555/v2-8905258989ea496e490ea8249830d89d_720w.png" alt></p><p>上个断点试试：</p><p><img src="/posts/40555/v2-0b1065976f31d39fa3e850c1897fa0ba_720w.webp" alt></p><p>完美，到这里就算搞定了，同理在win10下也一样。</p><p>再附上一些常用的的CMakeLists：</p><h2 id="多源文件配置头文件的搜索路径"><a href="#多源文件配置头文件的搜索路径" class="headerlink" title="多源文件配置头文件的搜索路径"></a>多源文件配置头文件的搜索路径</h2><pre class="line-numbers language-cmake"><code class="language-cmake">include_directories(${PROJECT_SOURCE_DIR}/include)include_directories(${PROJECT_SOURCE_DIR}/include/server)include_directories(${PROJECT_SOURSE_DIR}/thirdparty)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/posts/40555/image-20230918211340720-1695711789505-33.png" alt></p><p>同样需要告诉编辑器怎么去寻找执行文件，对于.vscode来说则是：</p><pre class="line-numbers language-json"><code class="language-json">            <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"${workspaceFolder}/build/${fileBasenameNoExtension}"</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于该种工程结构：<br>├── <strong>build</strong><br>├── CMakeLists.txt<br>├── <strong>include</strong><br>│   └── sayHello.h<br>├── main.cpp<br>└── <strong>src</strong><br>│   └── sayHello.cpp</p><p>对应的cmake添加：</p><blockquote><p>include_directories(include)<br>add_executable(main main.cpp src/atmp.cpp)</p></blockquote><p>对应的头文件如atmp.h和atmp.cpp分别在include和src里面，则只需要下面即可：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> _ATMP_H</span><span class="token macro property">#<span class="token directive keyword">define</span> _ATMP_H</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>atmp.cpp</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"atmp.h"</span></span><span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.cpp</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"atmp.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即可成功编译运行。</p><h2 id="VPN的使用"><a href="#VPN的使用" class="headerlink" title="VPN的使用"></a>VPN的使用</h2><p><img src="/posts/40555/wsl-1695711915507-35.png" alt></p><p><img src="/posts/40555/QY_7NET0QO29D%7BYR4WC%7B$G-1695711922336-37.png" alt></p><p><a href="https://zhuanlan.zhihu.com/p/153124468">知乎有对应的脚本来开启vpn</a>，但有些细节没有说清楚。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>host_ip<span class="token operator">=</span><span class="token punctuation">$(</span>cat /etc/resolv.conf <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">"nameserver"</span> <span class="token operator">|</span><span class="token function">cut</span> -f 2 -d <span class="token string">" "</span><span class="token punctuation">)</span><span class="token function">export</span> ALL_PROXY<span class="token operator">=</span><span class="token string">"http://<span class="token variable">$host_ip</span>:7890"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当你做完这些，<strong>一定要在对应的.zsh文件里面最后对端口配置文件进行source</strong>，不然无法生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;最近在做CMU15445，其实最痛苦的就是配环境，众所周知，VSCode的C/C++插件功能虽然全但是速度
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://JoyTsing.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Cpp" scheme="https://JoyTsing.github.io/tags/Cpp/"/>
    
      <category term="数据库" scheme="https://JoyTsing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>好久不见</title>
    <link href="https://joytsing.github.io/posts/62537/"/>
    <id>https://joytsing.github.io/posts/62537/</id>
    <published>2023-09-25T12:59:48.000Z</published>
    <updated>2023-09-25T13:35:59.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先，日安"><a href="#首先，日安" class="headerlink" title="首先，日安"></a>首先，日安</h2><p>好久不见，距离上次更新竟然已经过了两年之久，很惭愧一直都没有更新，这两年发生了很多东西，一件一件来说吧。</p><h3 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h3><p>怎么说呢，我从小一直对研究生有个渴望，但我上本科四年期间我一直没有想过能够通过这么曲折的方式拿到一个保研名额，相信愿意进来这的人都知道我本人是谁（我也不喜欢隐藏自己），这个故事我也讲过太多次了，也就不再这累述了，在这大学四年我感受到了许多也体会到了许多，特别是从18年开始混迹老乡群，给各位无偿解答了四年，认识了很多很棒的人，也认识了很多优秀的学弟学妹。</p><p>其实我也不知道为什么，各位学弟学妹都挺相信我的，不胜荣幸，其实说实话我感觉我读了四年书，其实除了最后摸了个保研名额（还去西电了）也没什么特别出众的。大学四年基本上是徘徊迷茫的四年，但感谢在我最迷茫的时光遇到了张，关，杨三位学长，也遇到了后面一直跟我联系的舍友和刘，感谢你们在我人生最重要的阶段能够彼此相识。</p><h2 id="其次，晚安"><a href="#其次，晚安" class="headerlink" title="其次，晚安"></a>其次，晚安</h2><p>往事涌上心中，在后面会更新稍稍多一点，这里给各位推荐<strong>obsidian</strong>这个软件来管理自己的学习笔记。</p><p>另外，给老乡群们答应的<code>UESTCer生存指南lite</code>后面也会更新,虽然可能会有点慢，但希望能对各位大学生生活能有微薄的帮助。</p><p>大学四年，有快乐又不快乐，在那时候总是抱怨，但真回头心中还是怀念那段时间，那么就这样，晚安。</p><p><img src="/posts/62537/1.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;首先，日安&quot;&gt;&lt;a href=&quot;#首先，日安&quot; class=&quot;headerlink&quot; title=&quot;首先，日安&quot;&gt;&lt;/a&gt;首先，日安&lt;/h2&gt;&lt;p&gt;好久不见，距离上次更新竟然已经过了两年之久，很惭愧一直都没有更新，这两年发生了很多东西，一件一件来说吧。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Scheme入门教程</title>
    <link href="https://joytsing.github.io/posts/56075/"/>
    <id>https://joytsing.github.io/posts/56075/</id>
    <published>2021-03-05T12:46:36.000Z</published>
    <updated>2023-09-26T07:43:11.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然目前因为scheme过时，最新的SICP已经采用python作为系列语言，但是通过前两章的学习，可以说，Scheme（lisp方言）是一门充满魅力的语言，而且在之前有过关于用C设计lisp语言的学习，都用C写出来了lisp结果不熟悉lisp未免来说过于尴尬，因此决定恶补一下scheme。</p><h2 id="四种基本算术操作"><a href="#四种基本算术操作" class="headerlink" title="四种基本算术操作"></a>四种基本算术操作</h2><p>Scheme（以及大多数Lisp方言）都可以处理分数。</p><p>函数<code>exact-&gt;inexact</code> 用于把分数转换为浮点数。Scheme也可以处理复数。复数是形如<code>a+bi</code>的数，此处<code>a</code>称为实部，<code>b</code>称为虚部。<code>+</code>、<code>-</code>、<code>*</code>和<code>/</code>分别代表加、减、乘、除。这些函数都接受任意多的参数。</p><p>例：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">10</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">;→ 7</span><span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">10</span> <span class="token number">3</span> <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">;→ 2</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">;→ 6</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">;→ 24</span><span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">29</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">;→ 29/3</span><span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">29</span> <span class="token number">3</span> <span class="token number">7</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">;→ 29/21</span><span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">9</span> <span class="token number">6</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">;→ 3/2</span><span class="token punctuation">(</span><span class="token function">exact->inexact</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">29</span> <span class="token number">3</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 1.380952380952381</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>括号可以像下面这样嵌套：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">5</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 10</span><span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">9</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>形如这些由<strong>括号</strong>、<strong>标记（token）</strong>以及<strong>分隔符</strong>组成的式子，被称为<strong>S-表达式</strong>。</p><h3 id="其它算术操作"><a href="#其它算术操作" class="headerlink" title="其它算术操作"></a>其它算术操作</h3><h3 id="quotient，remainder，modulo和sqrt"><a href="#quotient，remainder，modulo和sqrt" class="headerlink" title="quotient，remainder，modulo和sqrt"></a>quotient，remainder，modulo和sqrt</h3><ul><li>函数<code>quotient</code>用于求<strong>商数（quotient）</strong>。</li><li>函数<code>remainder</code>和<code>modulo</code>用于求<strong>余数（remainder）</strong>。</li><li>函数<code>sqrt</code>用于求参数的<strong>平方根（square root）</strong>。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">quotient</span> <span class="token number">7</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 2</span><span class="token punctuation">(</span><span class="token function">modulo</span> <span class="token number">7</span> <span class="token number">3</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">;→ 1</span><span class="token punctuation">(</span><span class="token function">sqrt</span> <span class="token number">8</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">;→ 2.8284271247461903</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>数学上的三角函数，诸如<code>sin</code>，<code>cos</code>，<code>tan</code>，<code>asin</code>，<code>acos</code>和<code>atan</code>都可以在Scheme中使用。<code>atan</code>接受1个或2个参数。如果<code>atan</code>的参数为<code>1/2 π</code>，那么就要使用两个参数来计算。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">atan</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">;→ 0.7853981633974483</span><span class="token punctuation">(</span><span class="token function">atan</span> <span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;→ 1.5707963267948966</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="指数和对数"><a href="#指数和对数" class="headerlink" title="指数和对数"></a>指数和对数</h3><p>指数通过<code>exp</code>函数运算，对数通过<code>log</code>函数运算。<code>a</code>的<code>b</code>次幂可以通过<code>(expt a b)</code>来计算。</p><h2 id="生成表"><a href="#生成表" class="headerlink" title="生成表"></a>生成表</h2><p>作为Lisp语言大家族的一员，Scheme同样擅长于处理表。表在在后面章节中的递归函数和高阶函数中扮演重要角色。在本章中会讲解基本的表操作，例如<code>cons</code>，<code>car</code>，<code>cdr</code>，<code>list</code>和<code>quote</code>。</p><h3 id="Cons单元和表"><a href="#Cons单元和表" class="headerlink" title="Cons单元和表"></a>Cons单元和表</h3><h4 id="Cons单元"><a href="#Cons单元" class="headerlink" title="Cons单元"></a>Cons单元</h4><p>首先，让我解释一下表的元素：<strong>Cons单元（Cons cells）</strong>。Cons单元是一个存放了两个地址的内存空间。Cons单元可用函数<code>cons</code>生成。</p><p>在前端输入<code>(cons 1 2)</code></p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>系统返回<code>(1 . 2)</code>。如图一所示，函数<code>cons</code>给两个地址分配了内存空间，并把存放指向<code>1</code>的地址放在一个空间，把存放指向<code>2</code>的地址放在另一个空间。存放指向<code>1</code>的地址的内存空间被称作<code>car</code>部分，对应的，存放指向<code>2</code>的地址的内存空间被称作<code>cdr</code>部分。<code>car</code>和<code>cdr</code>分别是<strong>寄存器地址部分（Contents of the Address part of the Register）</strong>和<strong>寄存器减量部分（Contents of the Decrement part of the Register）</strong>的简称。这些名字最初来源于Lisp首次被实现所使用的硬件环境中内存空间的名字。这些名字同时也表明Cons单元的本质就是一个内存空间。<code>cons</code>这个名字是术语<strong>构造（construction）</strong>的简称。</p><p><img src="http://deathking.github.io/yast-cn/contents/figures/cons2.png" alt></p><p>Cons单元也可以被串起来。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种情况的内存空间如图2所示。</p><p><img src="http://deathking.github.io/yast-cn/contents/figures/conss2.png" alt></p><p>Cons单元可以存放不同类型的数据也可以嵌套。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">cons</span> #\a <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">3</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 17: (#\a 3 . "hello")</span><span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 23: ((0 . 1) 2 . 3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为Scheme可以通过地址操作所有的数据。（<code>#\c</code>代表了一个字符<code>c</code>。例如，<code>#\a</code>就代表字符<code>a</code>）</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>表是Cons单元通过用<code>cdr</code>部分连接到下一个<code>Cons</code>单元的开头实现的。表中包含的<code>’()</code>被称作空表。就算数据仅由一个Cons单元组成，只要它的<code>cdr</code>单元是<code>’()</code>，那它就是一个表。图3展示了表<code>(1 2 3)</code>的内存结构。</p><p><img src="http://deathking.github.io/yast-cn/contents/figures/list2.png" alt></p><p>事实上，表可以像下面这样递归地定义：</p><ol><li><code>‘()</code>是一个表</li><li>如果<code>ls</code>是一个表且<code>obj</code>是某种类型的数据，那么<code>(cons obj ls)</code>也是一个表 正因为表是一种被递归定义的数据结构，将它用在递归的函数中显然是合理的。</li></ol><p>###原子</p><p>不使用Cons单元的数据结构称为<strong>原子（atom）</strong>。数字，字符，字符串，向量和空表<code>’()</code>都是原子。<code>’()</code>既是原子，又是表。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>所有的记号都会依据Scheme的求值规则求值：所有记号都会从最内层的括号依次向外层括号求值，且最外层括号返回的值将作为S-表达式的值。一个被称为<strong>引用（quote）</strong>的形式可以用来阻止记号被求值。它是用来将符号或者表原封不动地传递给程序，而不是求值后变成其它的东西。</p><p>例如，<code>(+ 2 3)</code>会被求值为<code>5</code>，然而<code>(quote (+ 2 3))</code>则向程序返回<code>(+ 2 3)</code>本身。因为<code>quote</code>的使用频率很高，他被简写为<code>’</code>。</p><p>比如：</p><ul><li><code>’(+ 2 3)</code>代表列表<code>(+ 2 3)</code>本身；</li><li><code>’+</code>代表符号<code>+</code>本身；</li></ul><p>实际上，<code>’()</code>是对空表的引用，也就是说，尽管解释器返回<code>()</code>代表空表，你也应该用<code>’()</code>来表示空表。</p><h3 id="特殊形式"><a href="#特殊形式" class="headerlink" title="特殊形式"></a>特殊形式</h3><p>Scheme有两种不同类型的操作符：其一是函数。函数会对所有的参数求值并返回值。另一种操作符则是特殊形式。特殊形式不会对所有的参数求值。除了<code>quote</code>，<code>lambda</code>，<code>define</code>，<code>if</code>，<code>set!</code>，等都是特殊形式。</p><h3 id="car函数和cdr函数"><a href="#car函数和cdr函数" class="headerlink" title="car函数和cdr函数"></a>car函数和cdr函数</h3><p>返回一个Cons单元的<code>car</code>部分和<code>cdr</code>部分的函数分别是<code>car</code>和<code>cdr</code>函数。如果<code>cdr</code>部分串连着Cons单元，解释器会打印出整个<code>cdr</code>部分。如果Cons单元的<code>cdr</code>部分不是<code>’()</code>，那么其值稍后亦会被展示。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">car</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span><span class="token punctuation">(</span><span class="token builtin">cdr</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 18: (2 3 4)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="list函数"><a href="#list函数" class="headerlink" title="list函数"></a>list函数</h3><p><code>list</code>函数使得我们可以构建包含数个元素的表。函数<code>list</code>有任意个数的参数，且返回由这些参数构成的表。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 24: (1)</span><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 25: ((1 2) (3 4))</span><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 26: (0)</span><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 27: (1 2)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>由于Sheme是函数式编程语言，你需要通过编写小型函数来构造程序。因此，明白如何构造并组合这些函数对掌握Scheme尤为关键。</p><p>你可以使用<code>define</code>来将一个符号与一个值绑定。你可以通过这个操作符定义例如数、字符、表、函数等任何类型的全局参数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">; Hello world as a variable</span><span class="token punctuation">(</span><span class="token keyword">define</span> vhello <span class="token string">"Hello world"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">;1</span><span class="token comment" spellcheck="true">; Hello world as a function</span><span class="token punctuation">(</span><span class="token keyword">define</span> fhello <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">;2</span>         <span class="token string">"Hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作符<code>define</code>用于声明变量，它接受两个参数。<code>define</code>运算符会使用第一个参数作为全局参数，并将其与第二个参数绑定起来。因此，代码片段1的第1行中，我们声明了一个全局参数<code>vhello</code>，并将其与<code>&quot;Hello，World&quot;</code>绑定起来。</p><p>紧接着，在第2行声明了一个返回<code>“Hello World”</code>的过程。</p><p>特殊形式<code>lambda</code>用于定义过程。<code>lambda</code>需要至少一个的参数，第一个参数是由定义的过程所需的参数组成的表。因为本例<code>fhello</code>没有参数，所以参数表是空表。</p><p>在解释器中输入<code>vhello</code>，解释器返回“Hello，World”。如果你在解释器中输入<code>fhello</code>，它也会返回像下面这样的值：<code>#[compound-procedure 16 fhello]</code>，这说明了Scheme解释器把过程和常规数据类型用同样的方式对待。正如我们在前面章节中讲解的那样，Scheme解释器通过内存空间中的数据地址操作所有的数据，因此，所有存在于内存空间中的对象都以同样的方式处理。</p><p>如果把<code>fhello</code>当过程对待，你应该用括号括住这些符号，比如<code>(fhello)</code>。</p><p>然后解释器会按照第二章讲述的规则那样对它求值，并返回“Hello World”。</p><h3 id="定义有参数的函数"><a href="#定义有参数的函数" class="headerlink" title="定义有参数的函数"></a>定义有参数的函数</h3><p>可以通过在<code>lambda</code>后放一个参数表来定义有参数的函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">; hello with name</span><span class="token punctuation">(</span><span class="token keyword">define</span> hello  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">string-append</span> <span class="token string">"Hello "</span> name <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">; sum of three numbers</span><span class="token punctuation">(</span><span class="token keyword">define</span> sum3  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">a</span> b c<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">+</span> a b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数<code>hello</code>有一个参数<code>(name)</code>，并会把<code>“Hello”</code>、<code>name的值</code>、和<code>&quot;!&quot;</code>连结在一起并返回。</p><p>预定义函数<code>string-append</code>可以接受任意多个数的参数，并返回将这些参数连结在一起后的字符串。</p><p><code>sum3</code>：此函数有三个参数并返回这三个参数的和。</p><h3 id="一种函数定义的短形式"><a href="#一种函数定义的短形式" class="headerlink" title="一种函数定义的短形式"></a>一种函数定义的短形式</h3><p>用<code>lambda</code>定义函数是一种规范的方法，但你也可以使用类似于代码片段3中展示的短形式。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">; hello with name</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">hello</span> name<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">string-append</span> <span class="token string">"Hello "</span> name <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">; sum of three numbers</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sum3</span> a b c<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">+</span> a b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种形式中，函数按照它们被调用的形式被定义。代码片段2和代码片段3都是相同的。有些人不喜欢这种短形式的函数定义，但是在教程中使用这种形式，因为它可以使代码更短小。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本章会讲解如何通过条件编写过程。这个是编写使用程序很重要的一步。</p><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h3><p><code>if</code>表达式将过程分为两个部分。<code>if</code>的格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">if</span> predicate then_value else_value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果<code>predicate</code>部分为真，那么<code>then_value</code>部分被求值，否则<code>else_value</code>部分被求值，并且求得的值会返回给<code>if</code>语句的括号外。<code>true</code>是除<code>false</code>以外的任意值，<code>true</code>使用<code>#t</code>表示，<code>false</code>用<code>#f</code>表示。</p><p>在R5RS中，<code>false</code>（<code>#f</code>）和空表<code>（’()）</code>是两个不同的对象。然而，在MIT-Scheme中，这两个为同一对象。这个不同可能是历史遗留问题，在以前的标准——R4RS中，<code>#f</code>和<code>’()</code>被定义为同一对象。</p><p>因此，从兼容性角度考虑，你不应该使用表目录作为谓词。使用函数<code>null?</code>来判断表是否为空。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">null?</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token builtin">null?</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">a</span> b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()   ;#f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数<code>not</code>可用于对谓词取反。此函数只有一个参数且如果参数值为<code>#f</code>则返回<code>#t</code>，反之，参数值为<code>#t</code>则返回<code>#f</code>。<code>if</code>表达式是一个特殊形式，因为它不对所有的参数求值。因为如果<code>predicate</code>为真，则只有<code>then_value</code>部分被求值。另一方面，如果<code>predicate</code>为假，只有<code>else_value</code>部分被求值。</p><p>例：首项为<code>a0</code>，增长率<code>r</code>，项数为<code>n</code>的几何增长（geometric progression）数列之和</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sum-gp</span> a0 r n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> a0     <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> r <span class="token number">1</span><span class="token punctuation">)</span>         n         <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token function">expt</span> r n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">1</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">; !!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常来说，几何增长数列的求和公式如下：</p><pre><code>a0 * (1 - r^n) / (1 - r)                      (r ≠ 1)a0 * n                                        (r = 1)</code></pre><p>如果<code>if</code>表达式对所有参数求值的话，那么有<code>;!!</code>注释的那行就算在<code>r=1</code>时也会被求值，这将导致产生一个“除数为0”的错误。</p><p>你也可以省去<code>else_value</code>项。这样的话，当<code>predicate</code>为假时，返回值就没有被指定。如果你希望当<code>predicate</code>为假时返回<code>#f</code>，那么就要明确地将它写出来。</p><p><code>then_value</code>和<code>else_value</code>都应该是S-表达式。如果你需要副作用，那么就应该使用<code>begin</code>表达式。我们将在下一章讨论<code>begin</code>表达式。</p><h3 id="and和or"><a href="#and和or" class="headerlink" title="and和or"></a>and和or</h3><p><code>and</code>和<code>or</code>是用于组合条件的两个特殊形式。Scheme中的<code>and</code>和<code>or</code>不同于C语言中的约定。它们不返回一个布尔值（<code>#t</code>或<code>#f</code>），而是返回给定的参数之一。<code>and</code>和<code>or</code>可以使你的代码更加短小。</p><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p><code>and</code>具有任意个数的参数，并从左到右对它们求值。如果某一参数为<code>#f</code>，那么它就返回<code>#f</code>，而不对剩余参数求值。反过来说，如果所有的参数都不是<code>#f</code>，那么就返回最后一个参数的值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">and</span> <span class="token boolean">#f</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token punctuation">(</span><span class="token function">and</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span class="token punctuation">(</span><span class="token function">and</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p><code>or</code>具有可变个数的参数，并从左到右对它们求值。它返回第一个不是值<code>#f</code>的参数，而余下的参数不会被求值。如果所有的参数的值都是<code>#f</code>的话，则返回最后一个参数的值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">or</span> <span class="token boolean">#f</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 0</span><span class="token punctuation">(</span><span class="token function">or</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span><span class="token punctuation">(</span><span class="token function">or</span> <span class="token boolean">#f</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span><span class="token punctuation">(</span><span class="token function">or</span> <span class="token boolean">#f</span> <span class="token boolean">#f</span> <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cond表达式"><a href="#cond表达式" class="headerlink" title="cond表达式"></a>cond表达式</h3><p>尽管所有的分支都可以用<code>if</code>表达式表达，但当条件有更多的可能性时，你就需要使用嵌套的<code>if</code>表达式了，这将使代码变得复杂。处理这种情况可以使用<code>cond</code>表达式。<code>cond</code>表达式的格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">cond</span>  <span class="token punctuation">(</span><span class="token function">predicate_1</span> clauses_1<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">predicate_2</span> clauses_2<span class="token punctuation">)</span>    ......  <span class="token punctuation">(</span><span class="token function">predicate_n</span> clauses_n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">else</span>        clauses_else<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>cond</code>表达式中，<code>predicates_i</code>是按照从上到下的顺序求值，而当<code>predicates_i</code>为真时，<code>clause_i</code>会被求值并返回。<code>i</code>之后的<code>predicates</code>和<code>clauses</code>不会被求值。如果所有的<code>predicates_i</code>都是假的话，则返回<code>cluase_else</code>。在一个子句中，你可以写数条S-表达式，而<code>clause</code>的值是最后一条S-表达式。</p><blockquote><p>例：城市游泳池的收费。</p><p>Foo市的城市游泳池按照顾客的年龄收费：</p><p>如果 age ≤ 3 或者 age ≥ 65 则 免费；<br>如果 介于 4 ≤ age ≤ 6 则 0.5美元；<br>如果 介于 7 ≤ age ≤ 12 则 1.0美元；<br>如果 介于 13 ≤ age ≤ 15 则 1.5美元；<br>如果 介于 16 ≤ age ≤ 18 则 1.8美元；<br>其它 则 2.0美元；</p><p>那么，一个返回城市游泳池收费的函数如下：</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fee</span> age<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">cond</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token operator">&lt;=</span> age <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">>=</span> age <span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">4</span> age <span class="token number">6</span><span class="token punctuation">)</span> <span class="token number">0.5</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">7</span> age <span class="token number">12</span><span class="token punctuation">)</span> <span class="token number">1.0</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">13</span> age <span class="token number">15</span><span class="token punctuation">)</span> <span class="token number">1.5</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">16</span> age <span class="token number">18</span><span class="token punctuation">)</span> <span class="token number">1.8</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="做出判断的函数"><a href="#做出判断的函数" class="headerlink" title="做出判断的函数"></a>做出判断的函数</h3><p>将介绍一些用于做判断的函数。这些函数的名字都以<code>&#39;?&#39;</code>结尾。</p><h3 id="eq-、eqv-和equal"><a href="#eq-、eqv-和equal" class="headerlink" title="eq?、eqv?和equal?"></a>eq?、eqv?和equal?</h3><p>基本函数<code>eq?</code>、<code>eqv?</code>、<code>equal?</code>具有两个参数，用于检查这两个参数是否“一致”。这三个函数之间略微有些区别。</p><blockquote><p><code>eq?</code><br>该函数比较两个对象的地址，如果相同的话就返回<code>#t</code>。例如，<code>(eq? str str)</code>返回<code>#t</code>，因为<code>str</code>本身的地址是一致的。与此相对的，因为字符串<code>”hello”</code>和<code>”hello”</code>被储存在了不同的地址中，函数将返回<code>#f</code>。不要使用<code>eq?</code>来比较数字，因为不仅在R5RS中，甚至在MIT-Scheme实现中，它都没有指定返回值。使用<code>eqv?</code>或者<code>=</code>替代。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> str <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: str</span><span class="token punctuation">(</span><span class="token function">eq?</span> str str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token string">"hello"</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()             ← It should be #f in R5RS </span><span class="token comment" spellcheck="true">;;; comparing numbers depends on implementations</span><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token number">1.0</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>eqv?</code><br>该函数比较两个存储在内存中的对象的类型和值。如果类型和值都一致的话就返回<code>#t</code>。对于过程（<code>lambda</code>表达式）的比较依赖于具体的实现。这个函数不能用于类似于表和字符串一类的序列比较，因为尽管这些序列看起来是一致的，但它们的值是存储在不同的地址中。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token number">1.0</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token number">1</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token comment" spellcheck="true">;;; don't use it to compare sequences</span><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token string">"hello"</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token comment" spellcheck="true">;;; the following depends on implementations</span><span class="token punctuation">(</span><span class="token function">eqv?</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>equal?</code><br>该函数用于比较类似于表或者字符串一类的序列。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">equal?</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">equal?</span> <span class="token string">"hello"</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="用于检查数据类型的函数"><a href="#用于检查数据类型的函数" class="headerlink" title="用于检查数据类型的函数"></a>用于检查数据类型的函数</h3><p>下面列举了几个用于检查类型的函数。这些函数都只有一个参数。</p><ul><li><code>pair?</code> 如果对象为序对则返回<code>#t</code>；</li><li><code>list?</code> 如果对象是一个表则返回<code>#t</code>。要小心的是空表<code>’()</code>是一个表但是不是一个序对。</li><li><code>null?</code> 如果对象是空表’()的话就返回#t。</li><li><code>symbol?</code> 如果对象是一个符号则返回#t。</li><li><code>char?</code> 如果对象是一个字符则返回#t。</li><li><code>string?</code> 如果对象是一个字符串则返回#t。</li><li><code>number?</code> 如果对象是一个数字则返回#t。</li><li><code>complex?</code> 如果对象是一个复数则返回#t。</li><li><code>real?</code> 如果对象是一个实数则返回#t。</li><li><code>rational?</code> 如果对象是一个有理数则返回#t。</li><li><code>integer?</code> 如果对象是一个整数则返回#t。</li><li><code>exact?</code> 如果对象不是一个浮点数的话则返回#t。</li><li><code>inexact?</code> 如果对象是一个浮点数的话则返回#t。</li></ul><h3 id="用于比较数的函数"><a href="#用于比较数的函数" class="headerlink" title="用于比较数的函数"></a>用于比较数的函数</h3><blockquote><p><code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;=</code><br>这些函数都有任意个数的参数。如果参数是按照这些函数的名字排序的话，函数就返回<code>#t</code>。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">=</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">=</span> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">3.1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">></span> <span class="token number">4</span> <span class="token number">1</span> <span class="token number">-0.2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1.1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">>=</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">3.9</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>odd?</code>、<code>even?</code>、<code>positive?</code>、<code>negative?</code>、<code>zero?</code><br>这些函数仅有一个参数，如果这些参数满足函数名所指示的条件话就返回<code>#t</code>。</p></blockquote><h3 id="用于比较符号的函数"><a href="#用于比较符号的函数" class="headerlink" title="用于比较符号的函数"></a>用于比较符号的函数</h3><p>在比较字符的时候可以使用<code>char=?</code>、<code>char&lt;?</code>、<code>char&gt;?</code>、<code>char&lt;=?</code>以及<code>char&gt;=?</code>函数。具体的细节请参见R5RS。</p><h3 id="用于比较字符串的函数"><a href="#用于比较字符串的函数" class="headerlink" title="用于比较字符串的函数"></a>用于比较字符串的函数</h3><p>比较字符串时，可以使用<code>string=?</code>和<code>string-ci=?</code>等函数。具体细节请参见R5RS。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><h3 id="let表达式"><a href="#let表达式" class="headerlink" title="let表达式"></a>let表达式</h3><p>使用<code>let</code>表达式可以定义局部变量。格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> binds body<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>变量在<code>binds</code>定义的形式中被声明并初始化。<code>body</code>由任意多个S-表达式构成。<code>binds</code>的格式如下：</p><pre><code>[binds] → ((p1 v1) (p2 v2) ...)</code></pre><p>声明了变量<code>p1</code>、<code>p2</code>，并分别为它们赋初值<code>v1</code>、<code>v2</code>。变量的<strong>作用域（Scope）</strong>为<code>body</code>体，也就是说变量只在<code>body</code>中有效。</p><blockquote><p>例1：声明局部变量<code>i</code>和<code>j</code>，将它们与<code>1</code>、<code>2</code>绑定，然后求二者的和。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">+</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>let</code>表达式可以嵌套使用。</p><blockquote><p>例2：声明局部变量<code>i</code>和<code>j</code>，并将分别将它们与<code>1</code>和<code>i+2</code>绑定，然后求它们的乘积。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">*</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于变量的作用域仅在<code>body</code>中，下列代码会产生错误，因为在变量<code>j</code>的作用域中没有变量<code>i</code>的定义。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>let*</code>表达式可以用于引用定义在同一个绑定中的变量。实际上，<code>let*</code>只是嵌套的<code>let</code>表达式的语法糖而已。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>例3：函数<code>quadric-equation</code>用于计算二次方程。它需要三个代表系数的参数：<code>a</code>、<code>b</code>、<code>c</code> （<code>ax^2 + bx + c = 0</code>），返回一个存放答案的实数表。通过逐步地使用<code>let</code>表达式，可以避免不必要的计算。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;;The scopes of variables d,e, and f are the regions with the same background colors.</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">quadric-equation</span> a b c<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">zero?</span> a<span class="token punctuation">)</span>            <span class="token string">'error</span>                                      <span class="token comment" spellcheck="true">; 1</span>      <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">d</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">*</span> b b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> a c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">; 2</span>        <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">negative?</span> d<span class="token punctuation">)</span>            <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                      <span class="token comment" spellcheck="true">; 3</span>            <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">e</span> <span class="token punctuation">(</span><span class="token operator">/</span> b a <span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">; 4</span>              <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">zero?</span> d<span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token builtin">list</span> e<span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">f</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token function">sqrt</span> d<span class="token punctuation">)</span> a <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">; 5</span>                <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token punctuation">(</span><span class="token operator">+</span> e f<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> e f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">quadric-equation</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; solution of 3x^2+5x+2=0</span><span class="token comment" spellcheck="true">;Value 12: (-2/3 -1)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，<code>let</code>表达式只是<code>lambda</code>表达式的一个语法糖：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">p1</span> v1<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">p2</span> v2<span class="token punctuation">)</span> ...<span class="token punctuation">)</span> exp1 exp2 ...<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">p1</span> p2 ...<span class="token punctuation">)</span>    exp1 exp2 ...<span class="token punctuation">)</span> v1 v2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为<code>lambda</code>表达式用于定义函数，它为变量建立了一个作用域。也就是闭包的概念</p><h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Scheme中通常通过递归实现重复，而不是循环。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>在自己的定义中调用自己的函数叫做<strong>递归函数（Recursive Function）</strong>。虽然这听起来很奇怪，但是循环的常见方法。如果你把函数类比为机器的话，递归似乎毫无道理。然而，正因为函数是过程，函数调用自己是有意义的。比如说，让我们来考察一下文献调研吧。你可能需要去阅读你正在阅读的文献所引用的文献（cited-1）。进一步，你可能还需要去阅读文件（cite-1）所引用的其它文献。这样，文献调研就是一个递归的过程，你也可以重复这个调研过程直到满足了特定条件（比如说，你累了）。这样，将程序设计语言中的函数类比为人类活动（比如文献调研）将有助于理解递归函数。</p><p>我们通常使用计算阶乘来解释递归。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token number">1</span>      <span class="token punctuation">(</span><span class="token operator">*</span> n <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>(fact 5)</code>的计算过程如下：</p><pre><code>(fact 5)⇒ 5 * (fact 4)⇒ 5 * 4 * (fact 3)⇒ 5 * 4 * 3 * (fact 2)⇒ 5 * 4 * 3 * 2 * (fact 1)⇒ 5 * 4 * 3 * 2 * 1⇒ 5 * 4 * 3 * 2⇒ 5 * 4 * 6⇒ 5 * 24⇒ 120</code></pre><p><code>(fact 5)</code>调用<code>(fact 4)</code>，<code>(fact 4)</code>调用<code>(fact 3)</code>，最后<code>(fact 1)</code>被调用。<code>(fact 5)</code>，<code>(fact 4)</code>……以及<code>(fact 1)</code>都被分配了不同的存储空间，直到<code>(fact (- i 1))</code>返回一个值之前，<code>(fact i)</code>都会保留在内存中，由于存在函数调用的开销，这通常会占用更多地内存空间和计算时间。</p><p>然而，递归函数可以以一种简单的方式表达重复。表是被递归定义的，进而表和递归函数可以很好地配合。例如，一个让表中所有元素翻倍的函数可以像下面这样写。如果参数是空表，那么函数应该停止计算并返回一个空表。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token builtin">list</span>*2 ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span>      <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">(</span><span class="token builtin">list</span>*2 <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>普通的递归调用并不高效因为它既浪费存储空间又具有函数调用开销。与之相反，尾递归函数包含了计算结果，当计算结束时直接将其返回。特别地，由于Scheme规范要求尾递归调用转化为循环，因此尾递归调用就不存在函数调用开销。</p><p>[代码片段2]展示了[代码片段1]中函数<code>fact</code>的尾递归版本。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-tail</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">fact-rec</span> n n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-rec</span> n p<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>      p      <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">m</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">fact-rec</span> m <span class="token punctuation">(</span><span class="token operator">*</span> p m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>fact-tail</code>计算阶乘的过程像这样：</p><pre><code>(fact-tail 5)⇒ (fact-rec 5 5)⇒ (fact-rec 4 20)⇒ (fact-rec 3 60)⇒ (fact-rec 2 120)⇒ (fact-rec 1 120)⇒ 120</code></pre><p>因为<code>fact-rec</code>并不等待其它函数的计算结果，因此当它计算结束时即从内存中释放。计算通过修改<code>fact-rec</code>的参数来演进，这基本上等同于循环。如上文所述，Scheme将尾递归转化为循环，Scheme就无需提供循环的语法来实现重复。</p><h3 id="命名let"><a href="#命名let" class="headerlink" title="命名let"></a>命名let</h3><p>命名<code>let</code>（<strong>named let</strong>）可以用来表达循环。[代码片段3]中的函数<code>fact-let</code>展示了如何使用命名<code>let</code>来计算阶乘。<code>fact-let</code>函数使用了一个<strong>命名<code>let</code>表达式</strong><code>(loop)</code>，这与在[代码片段2]中展示的<code>fact-rec</code>函数是不同的。在被注释为<code>;1</code>的那行，代码将参数<code>n1</code>和<code>p</code>都初始化为<code>n</code>。再每次循环后，参数在被注释为<code>;2</code>的那行更新：将<code>n1</code>减1，而将<code>p</code>乘以<code>(n1 - 1)</code>。</p><p>在Scheme中，用命名<code>let</code>来表达循环是俗成的方法。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-let</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n1</span> n<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">p</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">; 1</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n1 <span class="token number">1</span><span class="token punctuation">)</span>                        p    <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">m</span> <span class="token punctuation">(</span><span class="token operator">-</span> n1 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">loop</span> m <span class="token punctuation">(</span><span class="token operator">*</span> p m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">; 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="letrec"><a href="#letrec" class="headerlink" title="letrec"></a>letrec</h3><p><code>letrec</code>类似于<code>let</code>，但它允许一个名字递归地调用它自己。语法<code>letrec</code>通常用于定义复杂的递归函数。[代码片段4]展示了<code>fact</code>函数的<code>letrec</code>版本。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-letrec</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">letrec</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">iter</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">n1</span> p<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n1 <span class="token number">1</span><span class="token punctuation">)</span>               p               <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">m</span> <span class="token punctuation">(</span><span class="token operator">-</span> n1 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">(</span><span class="token function">iter</span> m <span class="token punctuation">(</span><span class="token operator">*</span> p m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">; *</span>    <span class="token punctuation">(</span><span class="token function">iter</span> n n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如被注释为<code>;*</code>的那行代码所示，局部变量<code>iter</code>可以在它的定义里面引用它自己。语法<code>letrec</code>是定义局部变量的俗成方式。</p><h3 id="do表达式"><a href="#do表达式" class="headerlink" title="do表达式"></a>do表达式</h3><p>虽然并不常见，但语法<code>do</code>也可用于表达重复。它的格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">do</span> binds <span class="token punctuation">(</span><span class="token function">predicate</span> value<span class="token punctuation">)</span>    body<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>变量在<code>binds</code>部分被绑定，而如果<code>predicate</code>被求值为真，则函数从循环中<strong>逃逸（escape）</strong>出来，并返回值<code>value</code>，否则循环继续进行。</p><p><code>binds</code>部分的格式如下所示：</p><pre><code>[binds] → ((p1 i1 u1) (p2 i2 u2) ... )</code></pre><p>变量<code>p1</code>，<code>p2</code>，…被分别初始化为<code>i1</code>，<code>i2</code>，…并在循环后分别被更新为<code>u1</code>，<code>u2</code>，…。</p><p>[代码片段5]演示了<code>fact</code>的<code>do</code>表达式版本。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-do</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">do</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n1</span> n <span class="token punctuation">(</span><span class="token operator">-</span> n1 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">p</span> n <span class="token punctuation">(</span><span class="token operator">*</span> p <span class="token punctuation">(</span><span class="token operator">-</span> n1 <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">=</span> n1 <span class="token number">1</span><span class="token punctuation">)</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>变量<code>n1</code>和<code>p</code>分别被初始化为<code>n</code>和<code>n</code>，在每次循环后分别被减去1和乘以<code>(n1 - 1)</code>。当<code>n1</code>变为<code>1</code>时，函数返回<code>p</code>。</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><strong>高阶函数（Higher Order Function）</strong>是一种以函数为参数的函数。它们都被用于<strong>映射（mapping）</strong>、<strong>过滤（filtering）</strong>、<strong>归档（folding）</strong>和<strong>排序（sorting）</strong>表。高阶函数提高了程序的模块性。编写对各种情况都适用的高阶函数与为单一情况编写递归函数相比，可以使程序更具可读性。比如说，使用一个高阶函数来实现排序可以使得我们使用不同的条件来排序，这就将排序条件和排序过程清楚地划分开来。函数<code>sort</code>具有两个参数，其一是一个待排序的表，其二是<strong>定序（Ordering）</strong>函数。下面展示了按照大小将一个整数表正序排序。<code>&lt;</code>函数就是（本例中的）两数的定序函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">sort</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">7883</span> <span class="token number">9099</span> <span class="token number">6729</span> <span class="token number">2828</span> <span class="token number">7754</span> <span class="token number">4179</span> <span class="token number">5340</span> <span class="token number">2644</span> <span class="token number">2958</span> <span class="token number">2239</span><span class="token punctuation">)</span> &lt;<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (2239 2644 2828 2958 4179 5340 6729 7754 7883 9099)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另一方面，按照每个数末两位的大小排序可以按下面的方式实现：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">sort</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">7883</span> <span class="token number">9099</span> <span class="token number">6729</span> <span class="token number">2828</span> <span class="token number">7754</span> <span class="token number">4179</span> <span class="token number">5340</span> <span class="token number">2644</span> <span class="token number">2958</span> <span class="token number">2239</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">x</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token function">modulo</span> x <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">modulo</span> y <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (2828 6729 2239 5340 2644 7754 2958 4179 7883 9099)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>正如这里所演示的，像<strong>快速排序（Quick Sort）</strong>、<strong>归并排序（Merge Sort）</strong>等排序过程，将定序函数完全分离开来提高了代码的复用性。</p><p>在本节中，将讲解预定义的高阶函数，然后介绍如何定义高阶函数。由于Scheme并不区别过程和其它的数据结构，因此你可以通过将函数当作参数传递轻松的定义自己的高阶函数。</p><p>实际上，Scheme中预定义函数的本质就是高阶函数，因为Scheme并没有定义块结构的语法，因此使用<code>lambda</code>表达式作为一个块。</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>映射是将同样的行为应用于表所有元素的过程。R5RS定义了两个映射过程：其一为返回转化后的表的<code>map</code>过程，另一为注重副作用的<code>for-each</code>过程。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map</code>过程的格式如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">map</span> procedure list1 list2 ...<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>procedure</code>是个与某个过程或<code>lambda</code>表达式相绑定的符号。作为参数的表的个数视<code>procedure</code>需要的参数而定。</p><p>例：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">; Adding each item of '(1 2 3) and '(4 5 6).</span><span class="token punctuation">(</span><span class="token function">map</span> + <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (5 7 9)</span><span class="token comment" spellcheck="true">; Squaring each item of '(1 2 3)</span><span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> x x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (1 4 9)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h3><p><code>for-each</code>的格式与<code>map</code>一致。但<code>for-each</code>并不返回一个具体的值，只是用于副作用。</p><p>例：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> sum <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">set!</span> sum <span class="token punctuation">(</span><span class="token operator">+</span> sum x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sum<span class="token comment" spellcheck="true">;⇒  10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>尽管过滤函数并没有在R5RS中定义，但MIT-Scheme实现提供了<code>keep-matching-items</code>和<code>delete-matching-item</code>两个函数。其它实现中应该有类似的函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">keep-matching-items</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">-3</span> <span class="token number">-4</span> <span class="token number">5</span><span class="token punctuation">)</span> positive?<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (1 2 5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h3><p>尽管在R5RS中没有定义归档函数，但MIT-Scheme提供了<code>reduce</code>等函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">;⇒  10</span><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">;⇒  3</span><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">)</span>                       <span class="token comment" spellcheck="true">;⇒  1</span><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">;⇒  0</span><span class="token punctuation">(</span><span class="token function">reduce</span> + <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">;⇒  foo</span><span class="token punctuation">(</span><span class="token function">reduce</span> list <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">;⇒  (((1 2) 3) 4)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>尽管R5RS中没有定义排序函数，但MIT-Scheme提供了<code>sort</code>（实为<code>merge-sort</code>实现）和<code>quick-sort</code>函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">sort</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">5</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token number">-1</span><span class="token punctuation">)</span> &lt;<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (-1 1 3 4 5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h3><p><code>apply</code>函数是将一个过程应用于一个表（译注：将表展开，作为过程的参数）。此函数具有任意多个参数，但首参数和末参数分别应该是一个过程和一个表。虽然乍看之下不然，但这个函数的确非常方便。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token builtin">apply</span> max <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">3</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">;⇒   3</span><span class="token punctuation">(</span><span class="token builtin">apply</span> + <span class="token number">1</span> <span class="token number">2</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">;⇒  15</span><span class="token punctuation">(</span><span class="token builtin">apply</span> - <span class="token number">100</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">5</span> <span class="token number">12</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">;⇒  66</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="编写高阶函数"><a href="#编写高阶函数" class="headerlink" title="编写高阶函数"></a>编写高阶函数</h3><p>自己编写高阶函数非常容易。这里用<code>member-if</code>、<code>member</code>演示。</p><h3 id="member-if和member"><a href="#member-if和member" class="headerlink" title="member-if和member"></a>member-if和member</h3><p><code>member-if</code>函数使用一个谓词和一个表作为参数，返回一个子表，该子表的<code>car</code>部分即是原列表中首个满足该谓词的元素。<code>member-if</code>函数可以像下面这样定义：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">member-if</span> proc ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">cond</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> <span class="token boolean">#f</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">proc</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> ls<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">member-if</span> proc <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">member-if</span> positive? <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">0</span> <span class="token number">-1</span> <span class="token number">-2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">-7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  (3 5 -7)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，<code>member</code>函数检查特定元素是否在表中，该函数编写如下。函数需要三个参数，其一为用于比较的函数，其二为特定项，其三为待查找表。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">member</span> proc obj ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">cond</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> <span class="token boolean">#f</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">proc</span> obj <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> ls<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">member</span> proc obj <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">member</span> string=? <span class="token string">"hello"</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token string">"hi"</span> <span class="token string">"guys"</span> <span class="token string">"bye"</span> <span class="token string">"hello"</span> <span class="token string">"see you"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒  ("hello" "see you")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入/输出"></a>输入/输出</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>通过前面章节的学习，你已经可以在Scheme的交互式前端中编写并执行程序了。在本章中，我讲介绍如何输入和输出。使用这个特性，你可以从文件中读取数据或向文件中写入数据。</p><h2 id="从文件输入"><a href="#从文件输入" class="headerlink" title="从文件输入"></a>从文件输入</h2><h3 id="open-input-file，read-char和eof-object"><a href="#open-input-file，read-char和eof-object" class="headerlink" title="open-input-file，read-char和eof-object?"></a>open-input-file，read-char和eof-object?</h3><p>函数<code>(open-input-file filename)</code>可以用于打开一个文件。此函数返回一个用于输入的端口。函数<code>(read-char port)</code>用于从端口中读取一个字符。当读取到<strong>文件结尾（EOF）</strong>时，此函数返回<code>eof-object</code>，你可以使用<code>eof-object?</code>来检查。函数<code>(close-input-port port)</code>用于关闭输入端口。[代码片段1]展示了一个函数，该函数以字符串形式返回了文件内容。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-file</span> file-name<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">p</span> <span class="token punctuation">(</span><span class="token function">open-input-file</span> file-name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">read-char</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">begin</span>        <span class="token punctuation">(</span><span class="token function">close-input-port</span> p<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token builtin">list</span>->string <span class="token punctuation">(</span><span class="token function">reverse</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> c ls1<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">read-char</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如，在[范例1]中展示的结果就是将[代码片段1]应用于文件hello.txt。由于换行符是由<code>&#39;\n&#39;</code>表示的，这就很容易阅读。然而，像格式化输出[范例2]，我们也可使用<code>display</code>函数。</p><pre><code>Hello world!Scheme is an elegant programming language.</code></pre><h3 id="语法call-with-input-file和with-input-from-file"><a href="#语法call-with-input-file和with-input-from-file" class="headerlink" title="语法call-with-input-file和with-input-from-file"></a>语法call-with-input-file和with-input-from-file</h3><p>你通过使用语法<code>call-with-input-file</code>和<code>with-input-from-file</code>来打开文件以供读取输入。这些语法是非常方便的，因为它们要处理错误。</p><blockquote><pre><code>(call-with-input-file filename procedure)</code></pre><p>该函数将名为<code>filename</code>的文件打开以供读取输入。函数<code>procedure</code>接受一个输入端口作为参数。文件有可能再次使用，因此当<code>procedure</code>结束时文件不会自动关闭，文件应该显式地关闭。[代码片段1]可以按照[代码片段2]那样用<code>call-with-input-file</code>编写。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-file</span> file-name<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">call-with-input-file</span> file-name    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">read-char</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token keyword">begin</span>          <span class="token punctuation">(</span><span class="token function">close-input-port</span> p<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token builtin">list</span>->string <span class="token punctuation">(</span><span class="token function">reverse</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> c ls1<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">read-char</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>(with-input-from-file filename procedure)</code> 该函数将名为<code>filename</code>的文件作为标准输入打开。函数<code>procedure</code>不接受任何参数。当<code>procedure</code>退出时，文件自动被关闭。[代码片段3]展示了如何用<code>with-input-from-file</code>来重写[代码片段1]。</p></blockquote><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-file</span> file-name<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">with-input-from-file</span> file-name    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span>read-char<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token builtin">list</span>->string <span class="token punctuation">(</span><span class="token function">reverse</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> c ls1<span class="token punctuation">)</span> <span class="token punctuation">(</span>read-char<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>函数<code>(read port)</code>从端口<code>port</code>中读入一个S-表达式。用它来读诸如”paren.txt”中带括号的内容就很方便。</p><pre><code>&#39;(Hello world!Scheme is an elegant programming language.)&#39;(Lisp is a programming language ready to evolve.)(define (s-read file-name)  (with-input-from-file file-name    (lambda ()      (let loop ((ls1 &#39;()) (s (read)))    (if (eof-object? s)        (reverse ls1)        (loop (cons s ls1) (read)))))))</code></pre><p>下面展示了用<code>s-read</code>读取”paren.txt”的结果。</p><pre><code>(s-read &quot;paren.txt&quot;)⇒ ((quote (hello world! scheme is an elegant programming language.))(quote (lisp is a programming language ready to evolve.)))</code></pre><h3 id="输出至文件"><a href="#输出至文件" class="headerlink" title="输出至文件"></a>输出至文件</h3><h4 id="打开一个用于输出的port"><a href="#打开一个用于输出的port" class="headerlink" title="打开一个用于输出的port"></a>打开一个用于输出的port</h4><p>输出有和输入类似的函数，比如：</p><p><strong>(open-output-file filename)</strong></p><p>该函数打开一个文件用作输出，放回该输出端口。</p><p><strong>(close-output-port port)</strong></p><p>关闭用于输出的端口。</p><p><strong>(call-with-output-file filename procedure)</strong></p><p>打开文件<code>filename</code>用于输出，并调用过程<code>procedure</code>。该函数以输出端口为参数。</p><p><strong>(with-output-to-file filename procedure)</strong></p><p>打开文件<code>filename</code>作为标准输出，并调用过程<code>procedure</code>。该过程没有参数。当控制权从过程<code>procedure</code>中返回时，文件被关闭。</p><h3 id="用于输出的函数"><a href="#用于输出的函数" class="headerlink" title="用于输出的函数"></a>用于输出的函数</h3><p>下面的函数可用于输出。如果参数<code>port</code>被省略的话，则输出至标准输出。</p><p><strong>(write obj port)</strong></p><p>该函数将<code>obj</code>输出至<code>port</code>。字符串被双引号括起而字符具有前缀<code>#\</code>。</p><p><strong>(display obj port)</strong></p><p>该函数将<code>obj</code>输出至<code>port</code>。字符串<em>不被</em>双引号括起而字符<em>不</em>具有前缀<code>#\</code>。</p><p><strong>(newline port)</strong></p><p>向 <code>port</code> 输出一个换行符。</p><p><strong>(write-char char port)</strong></p><p>该函数向<code>port</code>写入一个字符。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>因为Scheme是函数式语言，通常来说，你可以编写不使用赋值的语句。然而，如果使用赋值的话，有些算法就可以轻易实现了。尤其是内部状态和<strong>继续（continuations ）</strong>需要赋值。</p><p>尽管赋值非常习见并且易于理解，但它有一些本质上的缺陷。参见《计算机程序的构造和解释》的第三章第一节“赋值和局部状态”以及《为什么函数式编程如此重要》。</p><p>R5RS中规定的用于赋值的特殊形式是<code>set!</code>、<code>set-car!</code>、<code>set-cdr!</code>、<code>string-set!</code>、<code>vector-set!</code>等。除此之外，有些实现也依赖于赋值。由于赋值改变了参数的值，因此它具有<strong>破坏性（destructive）</strong>。Scheme中，具有破坏性的方法都以<code>!</code>结尾，以警示程序员。</p><h3 id="set"><a href="#set" class="headerlink" title="set!"></a>set!</h3><p><code>set!</code>可以为一个参数赋值。与Common Lisp不同，<code>set!</code>无法给一个S-表达式赋值。</p><p>赋值前参数应被定义。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> var <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">set!</span> var <span class="token punctuation">(</span><span class="token operator">*</span> var <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>var ⇒ <span class="token number">10</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">set!</span> i <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    i<span class="token punctuation">)</span>⇒ <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="赋值和内部状态"><a href="#赋值和内部状态" class="headerlink" title="赋值和内部状态"></a>赋值和内部状态</h3><h4 id="静态作用域（词法闭包）"><a href="#静态作用域（词法闭包）" class="headerlink" title="静态作用域（词法闭包）"></a>静态作用域（词法闭包）</h4><p>Scheme中变量的作用域被限定在了源码中定义其的那个括号里。作用域与源代码书写方式一致的作用域称为<strong>“词法闭包（Lexical closure）”</strong>或<strong>“静态作用域（Static scope）”</strong>。采用静态作用域减轻了程序员的负担，因为它已经在代码中体现了，因此你可以很容易理解。另一方面，还有一种被称为<strong>“动态作用域（Dynamic scope）”</strong>的作用域。这种作用域仅在程序运行时确定。由于会在调试时带来种种问题，这种作用域现在已经不再使用。</p><p>特殊形式<code>let</code>、<code>lambda</code>、<code>letrec</code>生成闭包。lambda表达式的参数仅在函数定义内部有效。<code>let</code>只是<code>lambda</code>的语法糖，因此二者无异。</p><h4 id="使用赋值和词法闭包来实现内部状态"><a href="#使用赋值和词法闭包来实现内部状态" class="headerlink" title="使用赋值和词法闭包来实现内部状态"></a>使用赋值和词法闭包来实现内部状态</h4><p>你可以使用词法闭包来实现带有内部状态的过程。例如，用于模拟银行账户的过程可以按如下的方式编写：初始资金是10美元。函数接收一个整形参数。正数表示存入，负数表示取出。为了简单起见，这里允许存款为负数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> bank-account  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">balance</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">set!</span> balance <span class="token punctuation">(</span><span class="token operator">+</span> balance n<span class="token punctuation">)</span><span class="token punctuation">)</span>      balance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该过程将存款赋值为<code>(+ balance n)</code>。下面是调用这个过程的结果。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">bank-account</span> <span class="token number">20</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">; donating 20 dollars </span><span class="token comment" spellcheck="true">;Value: 30</span><span class="token punctuation">(</span><span class="token function">bank-account</span> <span class="token number">-25</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">; withdrawing 25 dollars</span><span class="token comment" spellcheck="true">;Value: 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为在Scheme中，你可以编写返回过程的过程，因此你可以编写一个创建银行账户的函数。这个例子喻示着使用函数式程序设计语言可以很容易实现面向对象程序设计语言。实际上，只需要在这个基础上再加一点东西就可以实现一门面向对象程序设计语言了。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">make-bank-account</span> balance<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">set!</span> balance <span class="token punctuation">(</span><span class="token operator">+</span> balance n<span class="token punctuation">)</span><span class="token punctuation">)</span>    balance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> gates-bank-account <span class="token punctuation">(</span><span class="token function">make-bank-account</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">; Gates makes a bank account by donating  10 dollars</span><span class="token comment" spellcheck="true">;Value: gates-bank-account</span><span class="token punctuation">(</span><span class="token function">gates-bank-account</span> <span class="token number">50</span><span class="token punctuation">)</span>                              <span class="token comment" spellcheck="true">; donating 50 dollars</span><span class="token comment" spellcheck="true">;Value: 60</span><span class="token punctuation">(</span><span class="token function">gates-bank-account</span> <span class="token number">-55</span><span class="token punctuation">)</span>                             <span class="token comment" spellcheck="true">; withdrawing 55 dollars</span><span class="token comment" spellcheck="true">;Value: 5</span><span class="token punctuation">(</span><span class="token keyword">define</span> torvalds-bank-account <span class="token punctuation">(</span><span class="token function">make-bank-account</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; Torvalds makes a bank account by donating 100 dollars</span><span class="token comment" spellcheck="true">;Value: torvalds-bank-account</span><span class="token punctuation">(</span><span class="token function">torvalds-bank-account</span> <span class="token number">-70</span><span class="token punctuation">)</span>                             <span class="token comment" spellcheck="true">; withdrawing 70 dollars</span><span class="token comment" spellcheck="true">;Value: 30</span><span class="token punctuation">(</span><span class="token function">torvalds-bank-account</span> <span class="token number">300</span><span class="token punctuation">)</span>                             <span class="token comment" spellcheck="true">; donating 300 dollars</span><span class="token comment" spellcheck="true">;Value: 330</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>Scheme过程的主要目的是返回一个值，而另一个目的则称为<strong>副作用（Side Effect）</strong>。赋值和IO操作就是副作用。</p><h3 id="表的破坏性操作（set-car-，set-cdr-）"><a href="#表的破坏性操作（set-car-，set-cdr-）" class="headerlink" title="表的破坏性操作（set-car!，set-cdr!）"></a>表的破坏性操作（set-car!，set-cdr!）</h3><p>函数<code>set-car!</code>和<code>set-cdr!</code>分别为一个cons单元的car部分和cdr部分赋新值。和<code>set!</code>不同，这两个操作可以为S-表达式赋值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> tree <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">set-car!</span> <span class="token punctuation">(</span><span class="token builtin">car</span> tree<span class="token punctuation">)</span> <span class="token number">100</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; changing 1 to 100 </span>tree <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">100</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">set-cdr!</span> <span class="token punctuation">(</span><span class="token function">third</span> tree<span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">a</span> b c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">; changing  '(7 8 9) to '(a b c) </span>tree⇒ <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">100</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">6</span> a b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列可以用<code>set-car!</code>和<code>set-cdr!</code>实现。队列是一种<strong>先进先出(First in first out, FIFO)</strong>的数据结构，表则是<strong>先进后出(First in last out，FILO)</strong>。图表1展示了队列的结构。<code>cons-cell-top</code>的car部分指向表（头），而（<code>cons-cell-top</code>的）cdr部分指向表末的cons单元（表尾）。</p><p>入队操作按如下步骤进行：</p><ol><li>将当前最末的cons单元（可以通过<code>cons-cell-top</code>取得）的cdr部分重定向到新的元素。</li><li>将<code>cons-cell-top</code>的cdr部分重定向到新的元素</li></ol><p>出队操作按如下步骤进行:</p><ol><li>将队首元素存放在一个局部变量里。</li><li>将<code>cons-cell-top</code>的car部分重定向到表的第二个元素</li></ol><p>[代码片段1]展示了如何实现队列。函数<code>enqueue!</code>返回将元素<code>obj</code>添加进队列<code>queue</code>后的队列。函数<code>dequeue!</code>将队列的首元素移出队列并将该元素的值作为返回值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>make-queue<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">enqueue!</span> queue obj<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">lobj</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> obj <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">begin</span>      <span class="token punctuation">(</span><span class="token function">set-car!</span> queue lobj<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">set-cdr!</span> queue lobj<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">begin</span>      <span class="token punctuation">(</span><span class="token function">set-cdr!</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> queue<span class="token punctuation">)</span> lobj<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">set-cdr!</span> queue lobj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">dequeue!</span> queue<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">obj</span> <span class="token punctuation">(</span><span class="token builtin">car</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">set-car!</span> queue <span class="token punctuation">(</span><span class="token builtin">cdr</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> q <span class="token punctuation">(</span>make-queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: q</span><span class="token punctuation">(</span><span class="token function">enqueue!</span> q <span class="token string">'a)</span><span class="token comment" spellcheck="true">;Value 12: (a)</span><span class="token punctuation">(</span><span class="token function">enqueue!</span> q <span class="token string">'b)</span><span class="token comment" spellcheck="true">;Value 12: (a b)</span><span class="token punctuation">(</span><span class="token function">enqueue!</span> q <span class="token string">'c)</span><span class="token comment" spellcheck="true">;Value 12: (a b c)</span><span class="token punctuation">(</span><span class="token function">dequeue!</span> q<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: a</span>q<span class="token comment" spellcheck="true">;Value 13: ((b c) c)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>Scheme也有像<strong>字符（Character）</strong>、<strong>字符串（String）</strong>、<strong>符号（Symbol）</strong>、<strong>向量（Vector）</strong>等的其它数据类型。</p><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>在某个字符前添加<code>#\</code>来表明该物是一个字符。例如，<code>#\a</code>表示字符a。字符<code>#\Space</code>、<code>#\Tab</code>、<code>#\Linefeed</code>和<code>#\Return</code>分别代表空格（Space）、制表符（Tab），Linefeed和返回（Return）。R5RS中定义了下面的与字符相关的函数。</p><p><strong>(char? obj)</strong></p><p>如果<code>obj</code>是一个字符则返回<code>#t</code>。</p><p><strong>(char=? c1 c2)</strong></p><p>如果<code>c1</code>和<code>c2</code>是同一个字符的话则返回<code>#t</code>。</p><p><strong>(char-&gt;integer c)</strong></p><p>将<code>c</code>转化为对应的整数（字符代码，character code）。</p><p>示例：<code>(char-&gt;integer #\a) =&gt; 97</code></p><p><strong>(integer-&gt;char n)</strong></p><p>该函数将一个整数转化为对应的字符。</p><p><strong>(char&lt;? c1 c2)</strong>，</p><p><strong>(char&lt;= c1 c2)</strong>，</p><p><strong>(char&gt; c1 c2)</strong>，</p><p><strong>(char&gt;= c1 c2)</strong></p><p>这些函数用于比较字符。实际上，这些函数比较的是字符代码的大小。</p><p>例如，<code>(char&lt;? c1 c2)</code>等同于<code>(&lt; (char-&gt;integer c1) (char-&gt;integer c2))</code></p><p><strong>(char-ci=? c1 c2)</strong>，</p><p><strong>(char-ci&lt;? c1 c2)</strong>，</p><p><strong>(char-ci&lt;=? c1 c2)</strong>，</p><p><strong>(char-ci&gt;? c1 c2)</strong>，</p><p><strong>(char-ci&gt;=? c1 c2)</strong></p><p>这些比较函数对大小写不敏感。</p><p><strong>(char-alphabetic? c)</strong>，</p><p><strong>(char-numeric? c)</strong>，</p><p><strong>(char-whitespace? c)</strong>，</p><p><strong>(char-upper-case? c)</strong>，</p><p><strong>(char-lower-case? c)</strong></p><p>这些函数分别用于检测字符<code>c</code>是否为字母、数字、空白符、大写字母或小写字母。</p><p><strong>(char-upcase c)</strong>，</p><p><strong>(char-downcase c)</strong></p><p>这些函数分别返回字符C对应的大写或小写。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串通过两个闭合的双引号表示。例如，<code>&quot;abc&quot;</code>表示字符串<code>abc</code>。R5RS定义了下面的函数。</p><p><strong>(string? s)</strong></p><p>如果<code>s</code>是一个字符则返回<code>#t</code>。</p><p><strong>(make-string n c)</strong></p><p>返回由<code>n</code>个字符<code>c</code>组成的字符串。参数<code>c</code>可选。</p><p><strong>(string-length s)</strong></p><p>返回字符串<code>s</code>的长度。</p><p><strong>(string=? s1 s2)</strong></p><p>如果字符串<code>s1</code>和<code>s2</code>相同的话则返回<code>#t</code>。</p><p><strong>(string-ref s idx)</strong></p><p>返回字符串<code>s</code>中索引为<code>idx</code>的字符（索引从0开始计数）。</p><p><strong>(string-set! s idx c)</strong></p><p>将字符串<code>s</code>中索引为<code>idx</code>的字符设置为<code>c</code>。</p><p><strong>(substring s start end)</strong></p><p>返回字符串<code>s</code>从<code>start</code>开始到<code>end-1</code>处的子串。例如<code>(substring &quot;abcdefg&quot; 1 4) =&gt; &quot;b c d&quot;</code></p><p><strong>(string-append s1 s2 …)</strong></p><p>连接两个字符串<code>s1</code>和<code>s2</code></p><p><strong>(string-&gt;list s)</strong></p><p>将字符串<code>s</code>转换为由字符构成的表。</p><p><strong>(list-&gt;string ls)</strong></p><p>将一个由字符构成的表转换为字符串。</p><p><strong>(string-copy s)</strong></p><p>复制字符串<code>s</code>。</p><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>我会在本章讲解在Lisp/Scheme程序设计语言中极具特色的数据类型——符号。符号是一种通过地址管理字符串的数据。符号可以被如<code>eq?</code>这样运行迅速地函数处理，而纯字符串需要被更慢的<code>equal?</code>处理。由于符号可以被快速比较，它们被用于做关联表和哈希表的键。</p><h3 id="有关符号的基本函数"><a href="#有关符号的基本函数" class="headerlink" title="有关符号的基本函数"></a>有关符号的基本函数</h3><p>下列都是有关符号的基本函数。</p><p><strong>(symbol? x)</strong></p><p>如果<code>x</code>是一个符号则返回#t。</p><p><strong>(string-&gt;symbol str)</strong></p><p>将<code>str</code>转换为符号。<code>str</code>应该都是小写的，否则地址系统可能无法正常工作。在MIT-Scheme中，<code>(string-&gt;symbol &quot;Hello&quot;)</code>和<code>&#39;Hello</code>是不同的。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span> <span class="token string">'Hello)</span><span class="token comment" spellcheck="true">;Value: ()</span><span class="token punctuation">(</span><span class="token function">eq?</span> <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">symbol->string</span>  <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 15: "Hello"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(symbol-&gt;string sym)</strong></p><p>将<code>sym</code>转换为字符。</p><h3 id="统计文本中的单词"><a href="#统计文本中的单词" class="headerlink" title="统计文本中的单词"></a>统计文本中的单词</h3><p>下面的代码是一段统计文本中单词个数的程序，这也是被经常用作演示如何使用符号的例子。该程序使用了<strong>哈希表（Hash table）</strong>和<strong>关联表（Association list）</strong>，这些都将在下一章中讲解。</p><pre class="line-numbers language-scheme"><code class="language-scheme">    <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>     <span class="token comment" spellcheck="true">;;;   wc.scm</span>     <span class="token comment" spellcheck="true">;;;   a scheme word-count program</span>     <span class="token comment" spellcheck="true">;;;</span>     <span class="token comment" spellcheck="true">;;;    by T.Shido</span>     <span class="token comment" spellcheck="true">;;;    on August 19, 2005</span>     <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->symbol ls0<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">string->symbol</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->string <span class="token punctuation">(</span><span class="token function">reverse!</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">char-in</span> c . ls<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls0</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls0<span class="token punctuation">)</span>             <span class="token boolean">#f</span>           <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token function">char=?</span> c <span class="token punctuation">(</span><span class="token builtin">car</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-words</span> fname<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">with-input-from-file</span> fname         <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">w</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">wls</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span>read-char<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">cond</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c<span class="token punctuation">)</span>                 <span class="token punctuation">(</span><span class="token function">reverse!</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> w<span class="token punctuation">)</span>                               <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->symbol w<span class="token punctuation">)</span> wls<span class="token punctuation">)</span>                             wls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">char-in</span> c #\Space #\Linefeed #\Tab #\, #\.  #\ #\<span class="token punctuation">(</span><span class="token function"></span> #\<span class="token punctuation">)</span> #\= #\? #\! #\<span class="token comment" spellcheck="true">; #\:)</span>                 <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> w<span class="token punctuation">)</span>                               <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->symbol w<span class="token punctuation">)</span> wls<span class="token punctuation">)</span>                             wls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token keyword">else</span>             <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token function">char-downcase</span> c<span class="token punctuation">)</span> w<span class="token punctuation">)</span> wls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sort-by-frequency</span> al<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">sort</span> al <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">x</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">wc</span> fname<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">wh</span> <span class="token punctuation">(</span>make-eq-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls</span> <span class="token punctuation">(</span><span class="token function">read-words</span> fname<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span>               <span class="token punctuation">(</span><span class="token function">sort-by-frequency</span> <span class="token punctuation">(</span><span class="token function">hash-table->alist</span> wh<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">(</span><span class="token keyword">begin</span>             <span class="token punctuation">(</span><span class="token function">hash-table/put!</span> wh <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">1+</span> <span class="token punctuation">(</span><span class="token function">hash-table/get</span> wh <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">wc</span> <span class="token string">"opensource.txt"</span><span class="token punctuation">)</span>⇒<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">the</span> . <span class="token number">208</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">to</span> . <span class="token number">142</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">a</span> . <span class="token number">104</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">of</span> . <span class="token number">103</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">and</span> . <span class="token number">83</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">that</span> . <span class="token number">75</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">is</span> . <span class="token number">73</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">in</span> . <span class="token number">65</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">i</span> . <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">you</span> . <span class="token number">55</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">it</span> . <span class="token number">54</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">they</span> . <span class="token number">48</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">for</span> . <span class="token number">46</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">what</span> . <span class="token number">38</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">work</span> . <span class="token number">37</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">but</span> . <span class="token number">35</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">have</span> . <span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">on</span> . <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">people</span> . <span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">are</span> . <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">be</span> . <span class="token number">29</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">do</span> . <span class="token number">29</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">from</span> . <span class="token number">27</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">so</span> . <span class="token number">26</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">like</span> . <span class="token number">25</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">as</span> . <span class="token number">25</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">by</span> . <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">source</span> . <span class="token number">24</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">not</span> . <span class="token number">23</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">open</span> . <span class="token number">23</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">can</span> . <span class="token number">23</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">we</span> . <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">was</span> . <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">one</span> . <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>it<span class="token string">'s</span> . <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">an</span> . <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">this</span> . <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">about</span> . <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">business</span> . <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">working</span> . <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">most</span> . <span class="token number">17</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">there</span> . <span class="token number">17</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">at</span> . <span class="token number">17</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">with</span> . <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">(</span>don<span class="token string">'t</span> . <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">just</span> . <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">their</span> . <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">something</span> . <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">than</span> . <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">has</span> . <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">if</span> . <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">when</span> . <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">because</span> . <span class="token number">14</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">more</span> . <span class="token number">14</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">were</span> . <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">office</span> . <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">own</span> . <span class="token number">13</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">or</span> . <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">online</span> . <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">now</span> . <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">blogging</span> . <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">how</span> . <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">employees</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">them</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">think</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">time</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">company</span> . <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">lot</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">want</span> . <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">companies</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">could</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">know</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">get</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">learn</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">better</span> . <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">some</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">who</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">even</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">thing</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">much</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">no</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">make</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">up</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">being</span> . <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">money</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">relationship</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>that<span class="token string">'s</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">us</span> . <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">anyone</span> . <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">average</span> . <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">bad</span> . <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">same</span> . <span class="token number">8</span><span class="token punctuation">)</span>..........<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><p><strong>(list-&gt;symbo <code>ls0</code>)</strong></p><p>将一个由字符构成的列表（<code>ls0</code>）转换为一个符号。</p><p><strong>(char-in <code>c</code> . <code>ls</code>)</strong></p><p>检查字符（<code>c</code>）是否存在表（<code>ls</code>）。如果存在返回#t，不存在返回#f。</p><p><strong>(read-words <code>fname</code>)</strong></p><p>读取一个名为<code>fname</code>的文件，并返回一个符号列表。函数将大写转换为小写，将字符表（<code>w</code>）转换为一个字符，将<code>it</code>添加到符号表（<code>wls</code>）中。</p><p><strong>(sort-by-frequency <code>al</code>)</strong></p><p>以出现频率降序排序关联表（<code>al</code>）。</p><p><strong>(wc <code>fname</code>)</strong></p><p>读取名为<code>fname</code>的文件，并返回一个以出现频率降序排序关联表。因为函数使用了符号，<code>eq-hash-table</code>是适用的，它使用执行速度很快地<code>eq?</code>比较键（第40行）。函数统计由<code>read-words</code>创建的单词表里各单词的数量，并将其存储在一个哈希表（第44-46行）。在统计完成时（第43行），将哈希表转换为关联表。</p><h2 id="关联表和哈希表"><a href="#关联表和哈希表" class="headerlink" title="关联表和哈希表"></a>关联表和哈希表</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p>本章中，我会讲解用于表示数据关联的关联表和哈希表。关联的数据是由键和值组成的序对，值由键唯一确定的。表1显示了书和作者构成的配对。书籍可以确定作者，反之由作者确定书籍则不可，这是因为一个作者可能会写很多本书。表1中，由于P. Graham和L.Carroll分别写了两本书，因此他们的书无法被作者的名字唯一确定。</p><p>表1：作者和书</p><table><thead><tr><th align="left">Author</th><th align="left">Book</th></tr></thead><tbody><tr><td align="left">P. Graham</td><td align="left">On Lisp</td></tr><tr><td align="left">P. Graham</td><td align="left">ANSI Common Lisp</td></tr><tr><td align="left">E. S. Raymond</td><td align="left">The Cathedral and the Bazaar</td></tr><tr><td align="left">K. Dybvig</td><td align="left">The Scheme Programming Language</td></tr><tr><td align="left">F. P. Brooks, Jr.</td><td align="left">The Mythical Man-Month</td></tr><tr><td align="left">L. Carroll</td><td align="left">Alice’s Adventures in Wonderland</td></tr><tr><td align="left">L. Carroll</td><td align="left">Through the Looking-Glass, and What Alice Found There</td></tr></tbody></table><p>R5RS定义了关联表，因此它在所有Scheme实现中都可用。但是使用关联表搜索速度较慢（O(n)的时间复杂度）。使用哈希表在速度方面更好一些（O(1)的时间复杂度），但是哈希表并未在R5RS中定义而是依赖于相关实现。MIT-Scheme实现了哈希表。如果你喜欢的Scheme实现没有哈希表，你可以自己实现一个（见 <a href="http://www.math.grin.edu/~stone/events/scheme-workshop/hash-tables.html）。">http://www.math.grin.edu/~stone/events/scheme-workshop/hash-tables.html）。</a></p><h3 id="关联表"><a href="#关联表" class="headerlink" title="关联表"></a>关联表</h3><p>关联表是一个由序对组成的表，它是一个用于表达关联的基本数据类型。符号，字符，和数字常被作为键使用，因为它们可以使用诸如<code>eq?</code>或者<code>eqv?</code>的快速比较函数被比较。在作为键被使用前，字符串应该被转换为符号，从而获得更好的性能。</p><p>下面是一个关联表的例子。关联表应该要么由点序对要么由普通表组成。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">hi</span> . <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">everybody</span> . <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">nice</span> . <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">to</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">meet</span> . <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">you</span> . <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>函数<code>assq</code>，<code>assv</code>，和<code>assoc</code>从关联表中搜寻一个项。这些函数从开始一步步搜索关联表。如果它们找到序对的<code>car</code>等于给定的<code>key</code>，就返回该序对。如果找不到函数返回<code>#f</code>。这些函数分别使用<code>eq?</code>，<code>eqv?</code>，和<code>equal?</code>比较键，这意味着<code>assq</code>最快，<code>assoc</code>最慢。这表示作为键的话，字符串，向量和表应该转化为符号或者数字（如果可能的话）以提高性能。</p><p>一般来说，<a href="http://www.shido.info/lisp/scheme_ah_e.html#hash">哈希表</a>在大量数据中搜索表现得更好一些。</p><p>下面展示在关联表中进行搜索的例子。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> wc <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">hi</span> . <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">everybody</span> . <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">nice</span> . <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">to</span> . <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">meet</span> . <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">you</span> . <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>⇒ wc<span class="token punctuation">(</span><span class="token function">assq</span> <span class="token string">'hi</span> wc<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token function">hi</span> . <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">assq</span> <span class="token string">'you</span> wc<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token function">you</span> . <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">assq</span> <span class="token string">'i</span> wc<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> n <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>⇒  n<span class="token punctuation">(</span><span class="token function">assv</span> <span class="token number">1</span> n<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">assv</span> <span class="token number">8</span> n<span class="token punctuation">)</span>⇒  <span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a href="http://en.wikipedia.org/wiki/Hash-table">哈希表</a>是一种数据类型，它使用哈希函数将键转化为整数，并将值存储在由该整数所指示的位置。当表足够稀疏时，搜索，插入，更新都能以O(1)完成。下面展示了MIT-Scheme里哈希表的一些基本函数。查询<a href="http://www.swiss.ai.mit.edu/projects/scheme/documentation/scheme_12.html#SEC119">MIT-Scheme Manul</a>获取更详细的信息。</p><p><strong>(make-eq-hash-table size),</strong></p><p><strong>(make-eqv-hash-table size),</strong></p><p><strong>(make-equal-hash-table size),</strong></p><p><strong>(make-string-hash-table size)</strong></p><p>这些函数创建哈希表。这些函数分别使用<code>eq?</code>，<code>eqv?</code>，<code>equal?</code>，和<code>string=?</code>比较键的值。哈希表的初始大小（<code>size</code>）可以选择性指定（optional）。由于只比较键的地址，所以<code>eq-hash-table</code>是最快的。由于键是序列，所以<code>equal-hash-table</code>和<code>string-hash-table</code>比较慢。</p><p><strong>(hash-table/put! hash-table key datum)</strong></p><p>将<code>hash-table</code>中<code>key</code>对应的值设为<code>datum</code>。</p><p><strong>(hash-table/get hash-table key default)</strong></p><p>返回<code>hash-table</code>中的<code>key</code>对应的值。如果<code>key</code>不存在于<code>hash-table</code>中，返回<code>default</code>。</p><p><strong>(hash-table-&gt;alist hash-table)</strong></p><p>将<code>hash-table</code>转换为关联表。</p><h3 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h3><p>让我们写一个密码创建程序作为关联表和哈希表的例子。</p><p>从字典里得到的密码很容易被破解，但另一方面，完全随机的密码又很难记忆和输入。程序使用无规则的拼写创建10个密码。密码应该尽可能频繁更改，但是我懒于自己创建密码。使用这个程序，我可以简单地改变密码。</p><p>程序由两部分构成。一部分用于创建连续字符出现频率的数据（stat-spell.scm），另一个用于基于这个数据创建密码（make-pw.scm）。</p><h3 id="stat-spell-scm"><a href="#stat-spell-scm" class="headerlink" title="stat-spell.scm"></a>stat-spell.scm</h3><p>这个程序可以阅读英语句子，数据存在哈希表里，并转换为关联表输出到一个文件（stat-spell.data）。[代码1]显示了源代码。</p><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; make an alist of probable spelling from a given English text</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">skip-char?</span> c<span class="token punctuation">)</span><span class="token number">04</span>:       <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token function">char-graphic?</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">memv</span> c <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">#\:</span> #\<span class="token comment" spellcheck="true">; #\' #\" #\`))))</span><span class="token number">05</span>:     <span class="token number">06</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">ss-make-alist</span> c alist<span class="token punctuation">)</span><span class="token number">07</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">p</span> <span class="token punctuation">(</span><span class="token function">assv</span> c alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">08</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> p<span class="token number">09</span>:             <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">10</span>:              <span class="token punctuation">(</span><span class="token function">set-cdr!</span> p <span class="token punctuation">(</span><span class="token function">1+</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">11</span>:              alist<span class="token punctuation">)</span><span class="token number">12</span>:           <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> c <span class="token number">1</span><span class="token punctuation">)</span> alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:     <span class="token number">14</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">ss-make-dat</span> filename<span class="token punctuation">)</span><span class="token number">15</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">char-hash</span> <span class="token punctuation">(</span>make-eqv-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">16</span>:         <span class="token punctuation">(</span><span class="token function">with-input-from-file</span> filename<span class="token number">17</span>:           <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">18</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">c</span> #\Space<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">19</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">c1</span> <span class="token punctuation">(</span>read-char<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">20</span>:                      <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token builtin">eof-object?</span> c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">21</span>:                          <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">skip-char?</span> c1<span class="token punctuation">)</span><span class="token number">22</span>:                              <span class="token punctuation">(</span><span class="token function">loop</span> c<span class="token punctuation">)</span><span class="token number">23</span>:                              <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">c1</span> <span class="token punctuation">(</span><span class="token function">char-downcase</span> c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">24</span>:                    <span class="token punctuation">(</span><span class="token function">hash-table/put!</span> char-hash c<span class="token number">25</span>:                             <span class="token punctuation">(</span><span class="token function">ss-make-alist</span> c1 <span class="token punctuation">(</span><span class="token function">hash-table/get</span> char-hash c <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">26</span>:                    <span class="token punctuation">(</span><span class="token function">loop</span> c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">27</span>:         <span class="token punctuation">(</span><span class="token function">with-output-to-file</span> <span class="token string">"stat-spell.dat"</span><span class="token number">28</span>:           <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">29</span>:         <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">"(define *stat-spell* \'("</span><span class="token punctuation">)</span><span class="token number">30</span>:         <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">31</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alst</span> <span class="token punctuation">(</span><span class="token function">sort</span> <span class="token punctuation">(</span><span class="token function">hash-table->alist</span> char-hash<span class="token punctuation">)</span> <span class="token number">32</span>:                        <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">x</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">char33:</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> alst<span class="token punctuation">)</span><span class="token number">34</span>:               <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">35</span>:             <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token builtin">car</span> alst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">36</span>:             <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">37</span>:             <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> alst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:             <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">"))"</span><span class="token punctuation">)</span><span class="token number">39</span>:             <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(skip-char? c)</strong></p><p>如果<code>c</code>不是图像字符或者<code>c</code>是 #:, #;, #&#39;, or #&quot;，就返回#t。读取文本时，这些字符会被跳过。</p><p><strong>(ss-make-alist c alist)</strong></p><p>有两个参数；字符的频率的关联表（<code>alist</code>）和字符（<code>c</code>）。如果<code>c</code>在<code>alist</code>中，在序对的cdr部分增加一。如果不在，返回 (cons (cons c 1) alist)。这个函数使用了set-cdr!。</p><p><strong>(ss-make-dat filename)</strong></p><p>从名为<code>filename</code>的文件中读取字符，并使用跟随字符的频率的关联表来关联这些读出的字符。结果以关联表形式存储在文件<a href="http://www.shido.info/lisp/stat-spell.dat">stat-spell.dat</a>。在34和35行，它在哈希表中更新了频率的关联表。存储在stat-spell.dat的最终数据是一个关联表的关联表。例如：</p><p>(#\v (#\y . 1) (#\a . 3) (#\o . 7) (#\e . 51) (#\i . 15))</p><p>表示 #\y, #\a, #\o, #\e, 和 #\i 跟随 #\v 之后出现的次数分别是1, 3, 7, 51, 和15次。</p><h3 id="make-pw-scm"><a href="#make-pw-scm" class="headerlink" title="make-pw.scm"></a>make-pw.scm</h3><p>基于 stat-spell.dat 创建十个密码。过程如下：</p><ol><li>基于频率数据创建由9到13个随机字符组成字符串表。字符 #\Space 被添加在表结尾。</li><li>添加一个00到99之间的随机数在随机选取的字符串表的结尾。</li><li>随机地将 #\Space 转换为 #-, #_, #/, #\Space, #., 或者 #,。</li><li>随机地将30%的字母字符变为大写。</li></ol><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; make password from the alist of probable spelling</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token punctuation">(</span><span class="token function">load</span> <span class="token string">"stat-spell.dat"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">; *stat-spell* (alist for following characters) is in.</span><span class="token number">04</span>:     <span class="token number">05</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">alist->hash</span> al mode<span class="token punctuation">)</span><span class="token number">06</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">h</span> <span class="token punctuation">(</span><span class="token function">case</span> mode<span class="token number">07</span>:                  <span class="token punctuation">(</span><span class="token punctuation">(</span>eq<span class="token punctuation">)</span> <span class="token punctuation">(</span>make-eq-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">08</span>:                  <span class="token punctuation">(</span><span class="token punctuation">(</span>eqv<span class="token punctuation">)</span> <span class="token punctuation">(</span>make-eqv-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">09</span>:                  <span class="token punctuation">(</span><span class="token punctuation">(</span>equal<span class="token punctuation">)</span> <span class="token punctuation">(</span>make-equal-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:                  <span class="token punctuation">(</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span> <span class="token punctuation">(</span>make-string-hash-table<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">11</span>:         <span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token number">12</span>:                     <span class="token punctuation">(</span><span class="token function">hash-table/put!</span> h <span class="token punctuation">(</span><span class="token builtin">car</span> p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:                   al<span class="token punctuation">)</span><span class="token number">14</span>:         h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">15</span>:     <span class="token number">16</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> *stat-spell-hash* <span class="token punctuation">(</span><span class="token function">alist->hash</span> *stat-spell* <span class="token string">'eqv))</span><span class="token number">17</span>:     <span class="token number">18</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">pw-random-select</span> vec<span class="token punctuation">)</span><span class="token number">19</span>:       <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec <span class="token punctuation">(</span><span class="token function">random</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> vec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">20</span>:     <span class="token number">21</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>random00<span class="token punctuation">)</span><span class="token number">22</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">acc</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">23</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">2</span><span class="token punctuation">)</span><span class="token number">24</span>:             <span class="token punctuation">(</span><span class="token builtin">list</span>->string acc<span class="token punctuation">)</span><span class="token number">25</span>:           <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token function">pw-random-select</span> <span class="token string">'#</span><span class="token punctuation">(</span><span class="token function">#\0</span> #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9<span class="token punctuation">)</span><span class="token punctuation">)</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">26</span>:     <span class="token number">27</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">occasional-upcase</span> c<span class="token punctuation">)</span><span class="token number">28</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token function">random</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token number">29</span>:           <span class="token punctuation">(</span><span class="token function">char-upcase</span> c<span class="token punctuation">)</span><span class="token number">30</span>:         c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">31</span>:     <span class="token number">32</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">pw-enhance</span> ls<span class="token punctuation">)</span><span class="token number">33</span>:       <span class="token punctuation">(</span><span class="token builtin">list</span>->string<span class="token number">34</span>:        <span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token number">35</span>:               <span class="token punctuation">(</span><span class="token keyword">cond</span><span class="token number">36</span>:                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">char=?</span> c #\Space<span class="token punctuation">)</span><span class="token number">37</span>:                 <span class="token punctuation">(</span><span class="token function">pw-random-select</span>  <span class="token string">'#</span><span class="token punctuation">(</span><span class="token function">#\-</span> #\_ #\/  #\Space  #\. #\, #\@ #\? #\<span class="token punctuation">(</span><span class="token function"></span> #\<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">char-alphabetic?</span> c<span class="token punctuation">)</span><span class="token number">39</span>:                 <span class="token punctuation">(</span><span class="token function">occasional-upcase</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">40</span>:                <span class="token punctuation">(</span><span class="token keyword">else</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">41</span>:             <span class="token punctuation">(</span><span class="token builtin">cdr</span> <span class="token punctuation">(</span><span class="token function">reverse!</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">42</span>:         <span class="token number">43</span>:     <span class="token number">44</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">random-following</span> alist<span class="token punctuation">)</span><span class="token number">45</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n</span> <span class="token punctuation">(</span><span class="token function">random</span> <span class="token punctuation">(</span><span class="token builtin">apply</span> + <span class="token punctuation">(</span><span class="token function">map</span> cdr alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">46</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">alist</span> alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">47</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> alist<span class="token punctuation">)</span><span class="token number">48</span>:           <span class="token punctuation">(</span><span class="token keyword">let*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">pair</span> <span class="token punctuation">(</span><span class="token builtin">car</span> alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">49</span>:              <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">+</span> j <span class="token punctuation">(</span><span class="token builtin">cdr</span> pair<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">50</span>:             <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">></span> k n<span class="token punctuation">)</span><span class="token number">51</span>:             <span class="token punctuation">(</span><span class="token builtin">car</span> pair<span class="token punctuation">)</span><span class="token number">52</span>:             <span class="token punctuation">(</span><span class="token function">loop</span> k <span class="token punctuation">(</span><span class="token builtin">cdr</span> alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">53</span>:     <span class="token number">54</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">make-pw</span> h n<span class="token punctuation">)</span><span class="token number">55</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">c</span> #\Space<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">acc</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">56</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i n<span class="token punctuation">)</span><span class="token number">57</span>:             <span class="token punctuation">(</span><span class="token function">string-append</span><span class="token number">58</span>:              <span class="token punctuation">(</span><span class="token function">pw-enhance</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> #\Space <span class="token punctuation">(</span><span class="token builtin">cons</span> c acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">59</span>:              <span class="token punctuation">(</span>random00<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">60</span>:           <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token number">61</span>:             <span class="token punctuation">(</span><span class="token function">random-following</span> <span class="token punctuation">(</span><span class="token function">hash-table/get</span> h c <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">#\Space</span> . <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">62</span>:             <span class="token punctuation">(</span><span class="token builtin">cons</span> c acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">63</span>:         <span class="token number">64</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>pw-candidates<span class="token punctuation">)</span><span class="token number">65</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">66</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">10</span><span class="token punctuation">)</span><span class="token number">67</span>:             <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">68</span>:              <span class="token punctuation">(</span><span class="token function">display</span> i<span class="token punctuation">)</span><span class="token number">69</span>:              <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">": "</span><span class="token punctuation">)</span><span class="token number">70</span>:              <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token function">make-pw</span> *stat-spell-hash* <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">9</span> <span class="token punctuation">(</span><span class="token function">random</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">71</span>:              <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">72</span>:              <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">73</span>:           <span class="token string">'done)))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="向量和结构体"><a href="#向量和结构体" class="headerlink" title="向量和结构体"></a>向量和结构体</h2><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>本章中，我将讲解向量和结构体。</p><p>向量是一组通过整数索引的数据。与C语言中的数组不同，一个向量可以储存不同类型的数据。与表相比，向量更加紧凑且存取时间更短。但从另外一方面来说，向量是通过副作用来操作的，这样会造成负担。</p><p>Scheme中的结构体与C语言中的结构体类似。但Scheme中的结构体比C语言中的更容易使用，因为Scheme为结构体自动创建了读取函数和写入函数，这受益于Lisp/Scheme中的宏。</p><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><h4 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h4><p>向量通过闭合的<code>#(</code>和<code>)</code>表示，例如<code>#(1 2 3)</code>。作为字面值（literals）时，它们应该被引用（be quoted），例如：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token string">'#</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">; 整数向量</span><span class="token string">'#</span><span class="token punctuation">(</span><span class="token function">a</span> <span class="token number">0</span> #\a<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">; 由符号、整数和字符构成的向量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="向量函数"><a href="#向量函数" class="headerlink" title="向量函数"></a>向量函数</h4><p>下面的函数都是R5RS规定的函数：</p><p><strong>(vector? obj)</strong></p><p>如果obj是一个向量则返回#t。</p><p><strong>(make-vector k)</strong></p><p><strong>(make-vector k fill)</strong></p><p>返回有<code>k</code>个元素的向量。如果指定了第二个参数(<code>fill</code>)，那么所有的元素都会被初始化为<code>fill</code>。</p><p><strong>(vector obj …)</strong></p><p>返回由参数列表构成的向量。</p><p><strong>(vector-length vector)</strong></p><p>返回向量<code>vector</code>的长度。</p><p><strong>(vector-ref vector k)</strong></p><p>返回向量<code>vector</code>的索引为<code>k</code>的元素。（译注：和C语言类似，向量从0开始索引。）</p><p><strong>(vector-set! vector k obj)</strong></p><p>将向量<code>vector</code>的索引为<code>k</code>的元素修改为<code>obj</code>。</p><p><strong>(vector-&gt;list vector)</strong></p><p>将<code>vector</code>转换为表。</p><p><strong>(list-&gt;vector list)</strong></p><p>将<code>list</code>转换为向量。</p><p><strong>(vector-fill! vector fill)</strong></p><p>将向量<code>vector</code>的所有元素设置为<code>fill</code>。</p><p>例：一个对向量中元素求和的函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">vector-add</span> v1 v2<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">lenv1</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> v1<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">lenv2</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> lenv1 lenv2<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">v</span> <span class="token punctuation">(</span><span class="token function">make-vector</span> lenv1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i lenv1<span class="token punctuation">)</span>                    v                    <span class="token punctuation">(</span><span class="token keyword">begin</span>                      <span class="token punctuation">(</span><span class="token function">vector-set!</span> v i <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> v1 i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> v2 i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token function">error</span> <span class="token string">"different dimensions."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>练习1</p><p>编写一个用于计算两向量内积的函数。</p></blockquote><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="大体功能"><a href="#大体功能" class="headerlink" title="大体功能"></a>大体功能</h3><p>虽然R5RS中没有定义结构体，但是在很多Scheme实现中，都实现了类似于Common Lisp中的结构体。</p><p>这些结构体本质上来说都是向量。每一个槽（slot）都通过使用一个宏来命名，我将会在下一章（十五章）中讲解这个问题。结构体通过不同的属性清楚地表示数据。定义结构体的宏自动为结构体创建<strong>取值器（accessor）</strong>和<strong>赋值器（setter）</strong>。你可以通过“程序”来写程序，这被认为是Lisp/Scheme最好之处之一。通过这个功能，你可以很快写出漂亮的程序。</p><h3 id="MIT-Scheme中的结构体"><a href="#MIT-Scheme中的结构体" class="headerlink" title="MIT-Scheme中的结构体"></a>MIT-Scheme中的结构体</h3><p>在MIT-Scheme中，结构体通过函数<code>define-structure</code>来定义。为了使你更加容易理解，我会用一个实例来讲解。请考虑书籍。书籍都有下列属性：</p><ul><li>标题</li><li>作者</li><li>出版商</li><li>出版年份</li><li>ISBN号</li></ul><p>因此结构体book就可以像下面这样定义：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span>-structure book title authors publisher year isbn<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面演示了如何注册<a href="http://www.oreilly.com/catalog/cathbazpaper/">“大教堂与市集（The Cathedral and Bazaar）”</a>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> bazaar   <span class="token punctuation">(</span><span class="token function">make-book</span>    <span class="token string">"The Cathedral and the Bazaar"</span>   <span class="token string">"Eric S. Raymond"</span>   <span class="token string">"O'Reilly"</span>   <span class="token number">1999</span>   <span class="token number">0596001088</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而，这样做多少有点不便，因为属性与值的关联并不清楚。参量<code>keyword-constructor</code>可以用于解决这个问题。下面的代码就是使用这个参量的重写版，这个版本中，属性与值的关联就非常清楚了。此外，制定这个参量后，参数的顺序就不重要了。参量<code>copier</code>可用于为结构体创建一个拷贝（copier）函数。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span>-structure <span class="token punctuation">(</span><span class="token function">book</span> keyword-constructor copier<span class="token punctuation">)</span>   title authors publisher year isbn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> bazaar   <span class="token punctuation">(</span><span class="token function">make-book</span>    <span class="token string">'title</span> <span class="token string">"The Cathedral and the Bazaar"</span>   <span class="token string">'authors</span> <span class="token string">"Eric S. Raymond"</span>   <span class="token string">'publisher</span> <span class="token string">"O'Reilly"</span>   <span class="token string">'year</span> <span class="token number">1999</span>       <span class="token string">'isbn</span> <span class="token number">0596001088</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>一个名字形如<code>[the name of structure]?</code>的函数用于检查某对象是否为特定结构体。例如，可使用函数<code>book?</code>来检查<code>bazaar</code>是否为<code>book</code>结构体的一个实例。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">book?</span> bazaar<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>一个名字形如<code>copy-[structure name]</code>的函数用于拷贝结构体。例如，下面的代码演示了将<code>bazaar</code>拷贝到<code>cathedral</code>。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> cathedral <span class="token punctuation">(</span><span class="token function">copy-book</span> bazaar<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>一个名字形如<code>[structure name]-[attribute name]</code>的函数用于读取结构体某属性的值。例如，下面的代码演示了如何读取<code>bazaar</code>的<code>title</code>属性。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">book-title</span> bazaar<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 18: "The Cathedral and the Bazaar"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>一个名字形如<code>set-[结构体名称]-[属性名称]!</code>用于将某属性设定为特定值。下面的代码演示了如何将<code>bazaar</code>的<code>year</code>字段更新到2001（《大教堂与市集》2001年再版）。</li></ul><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">set-book-year!</span> bazaar <span class="token number">2001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token punctuation">(</span><span class="token function">book-year</span> bazaar<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 2001</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请参阅<a href="http://deathking.github.io/yast-cn/contents/www.gnu.org/software/mit-scheme/documentation/scheme_3.html#SEC41">MIT/GNU Scheme Reference: 2.10 Structure Definitions</a>以获得关于结构体的跟多信息。</p><h3 id="The-Mastermind-—-一个简单的密码破解游戏"><a href="#The-Mastermind-—-一个简单的密码破解游戏" class="headerlink" title="The Mastermind — 一个简单的密码破解游戏"></a>The Mastermind — 一个简单的密码破解游戏</h3><p>作为向量的示例，我会演示一个简单的密码破解游戏。这是一个猜对手密码的游戏。密码是由0到9中四个不同的数组成的四位数。对手要通过使用<code>bulls</code>和<code>cows</code>的数量告知猜谜者猜测的准确程度。</p><ol><li>bull的数量（Nbull）是指值和位置都正确的数字的数量。</li><li>cow的数量（Ncow）是指值正确但位置错误的数字的数量。</li></ol><p>例如，密码是5601，猜测是1685，那么<code>bull</code>和<code>cow</code>和数分别是1和2。</p><p>计算机和用户相互猜测对方的密码。更少尝试次数的选手为胜利者。如果用户和电脑在相同的尝试次数中破解了密码就是平局。</p><h3 id="表示四个数字"><a href="#表示四个数字" class="headerlink" title="表示四个数字"></a>表示四个数字</h3><p>四位数字可以通过向量和计算<code>bull</code>以及<code>cow</code>的数量高效地表示。这种表达方法需要构成密码的数字都不相同。</p><p>创建长度为10的向量，每个索引（<code>k</code>）的值被设为<code>k</code>在密码中的数位。四个数位从低到高被计为1，2，3和4。如果数字没有出现，索引的值为0。例如，5601和1685可以表示如下：</p><pre><code>5601 → #(2 1 0 0 0 4 3 0 0 0)1685 → #(0 4 0 0 0 1 3 0 2 0)</code></pre><p>5601这个例子中，数字0，1，5，和6分别出现在第2，第1，第4和第3位，那么在这个密码的向量表达式里索引0，1，5，6的值分别2是2，1，4和3，其他索引位都是0。</p><p>这种表达可以快速比较两个数字。如果两个向量的相同索引位的值都是正数情况下，如果值相等，就计为<code>bull</code>，如果值不相等，就计为<code>cow</code>。5601和1685这个例子的情况下，索引位6的值都为3，索引位1和索引位5的值都是正数，<code>bull</code>和<code>cow</code>的值为1和2。</p><h3 id="程序的设计"><a href="#程序的设计" class="headerlink" title="程序的设计"></a>程序的设计</h3><p>程序的设计如下：</p><ol><li>程序生成一个表，该表包含了所有不同四位数的向量表示。</li><li>程序从表中随机选取一个数字。</li><li>重洗步骤（1）产生的表。</li><li>程序首次猜用户的密码，用户给出bull和cow的数量。然后用户猜程序的密码，程序给出Nnull和Ncow。</li><li>重复步骤（3）直到电脑或者程序的bull数量变为4为止。如果在同一次双方的数量都变为4，就是平局。</li></ol><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>[代码1]展示了源代码。代码很长但并不十分复杂。游戏由一个递归函数<code>mastermind-rec</code>执行。</p><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"> <span class="token number">01</span>:     <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span> <span class="token number">02</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; mastermind.scm</span> <span class="token number">04</span>:     <span class="token comment" spellcheck="true">;;; by T.Shido</span> <span class="token number">05</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">06</span>:     <span class="token comment" spellcheck="true">;;; User and computer try to locate the four-digit integer set by the opponents each other.</span> <span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; One who locates the integer with fewer question is the winner.</span> <span class="token number">08</span>:     <span class="token comment" spellcheck="true">;;; The four-digit integer contains four of numerals 0--9, like 0123, 3749 etc.</span> <span class="token number">09</span>:     <span class="token comment" spellcheck="true">;;; The opponents should tell the guesser</span> <span class="token number">10</span>:     <span class="token comment" spellcheck="true">;;; (1) number of numerals that are shared by the guessed and set numbers</span> <span class="token number">11</span>:     <span class="token comment" spellcheck="true">;;; at wrong position (cows)</span> <span class="token number">12</span>:     <span class="token comment" spellcheck="true">;;; and (2) number of numerals at collect position (bulls).</span> <span class="token number">13</span>:     <span class="token comment" spellcheck="true">;;; </span> <span class="token number">14</span>:     <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span> <span class="token number">15</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">16</span>:     <span class="token comment" spellcheck="true">;;; The four-digit integers are represented by 10-cell vectors in the program</span> <span class="token number">17</span>:     <span class="token comment" spellcheck="true">;;; The value of n-th cell is the number of column that n appears in the integer.</span> <span class="token number">18</span>:     <span class="token comment" spellcheck="true">;;; in n is not appears the value is 0.</span> <span class="token number">19</span>:     <span class="token comment" spellcheck="true">;;; for example, 1234 is represented as #(0 4 3 2 1 0 0 0 0 0) and</span> <span class="token number">20</span>:     <span class="token comment" spellcheck="true">;;; 3916 as #(0 2 0 4 0 0 1 0 0 3).</span> <span class="token number">21</span>:     <span class="token comment" spellcheck="true">;;; With this inner representation, the score of the guess can be calculated faster.</span> <span class="token number">22</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">23</span>:     <span class="token comment" spellcheck="true">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span> <span class="token number">24</span>:      <span class="token number">25</span>:      <span class="token number">26</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">27</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">1-</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> x <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">28</span>:      <span class="token number">29</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">30</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">char2int</span> c<span class="token punctuation">)</span> <span class="token number">31</span>:       <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token function">char->integer</span> c<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">char->integer</span> #\0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">32</span>:      <span class="token number">33</span>:     <span class="token comment" spellcheck="true">;;; converting a list of 4 numbers to the vector notation</span> <span class="token number">34</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">ls2nvec</span> ls<span class="token punctuation">)</span> <span class="token number">35</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">vec</span> <span class="token punctuation">(</span><span class="token function">make-vector</span> <span class="token number">10</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">36</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token punctuation">(</span><span class="token function">length</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ls</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">37</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">></span> i <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">38</span>:           <span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token number">39</span>:                <span class="token punctuation">(</span><span class="token function">vector-set!</span> vec <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> i<span class="token punctuation">)</span> <span class="token number">40</span>:                <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1-</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">41</span>:             vec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">42</span>:      <span class="token number">43</span>:     <span class="token comment" spellcheck="true">;;; converting the vector notation to string</span> <span class="token number">44</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">nvec2int</span> vec<span class="token punctuation">)</span> <span class="token number">45</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">n</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">46</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">10</span><span class="token punctuation">)</span> <span class="token number">47</span>:             n <span class="token number">48</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">49</span>:           <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> n <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">></span> j <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">50</span>:                                     <span class="token punctuation">(</span><span class="token operator">*</span> i <span class="token punctuation">(</span><span class="token function">expt</span> <span class="token number">10</span> <span class="token punctuation">(</span><span class="token function">1-</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">51</span>:                                   <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">52</span>:      <span class="token number">53</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">54</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">int2str</span> i<span class="token punctuation">)</span> <span class="token number">55</span>:       <span class="token punctuation">(</span><span class="token function">string-append</span> <span class="token number">56</span>:        <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token string">"0"</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token number">57</span>:        <span class="token punctuation">(</span><span class="token function">number->string</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">58</span>:      <span class="token number">59</span>:     <span class="token comment" spellcheck="true">;;; reading integer from stdin</span> <span class="token number">60</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-integer</span> str<span class="token punctuation">)</span> <span class="token number">61</span>:       <span class="token punctuation">(</span><span class="token function">string->number</span> <span class="token punctuation">(</span><span class="token function">read-from-stdin</span> str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">62</span>:      <span class="token number">63</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">64</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-from-stdin</span> str<span class="token punctuation">)</span> <span class="token number">65</span>:       <span class="token punctuation">(</span><span class="token function">display</span> str<span class="token punctuation">)</span> <span class="token number">66</span>:       <span class="token punctuation">(</span>newline<span class="token punctuation">)</span> <span class="token number">67</span>:       <span class="token punctuation">(</span>read-line<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">68</span>:      <span class="token number">69</span>:     <span class="token comment" spellcheck="true">;;;</span> <span class="token number">70</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> . ls<span class="token punctuation">)</span> <span class="token number">71</span>:       <span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">display</span> obj<span class="token punctuation">)</span><span class="token punctuation">)</span> ls<span class="token punctuation">)</span> <span class="token number">72</span>:       <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">73</span>:      <span class="token number">74</span>:     <span class="token comment" spellcheck="true">;;; convert numeral string to the vector representation.</span> <span class="token number">75</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">str2nvec</span> str<span class="token punctuation">)</span> <span class="token number">76</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">vec</span> <span class="token punctuation">(</span><span class="token function">make-vector</span> <span class="token number">10</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">77</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token punctuation">(</span><span class="token function">string-length</span> str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ls</span> <span class="token punctuation">(</span><span class="token function">string->list</span> str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">78</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> ls<span class="token punctuation">)</span> <span class="token number">79</span>:           <span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token number">80</span>:                <span class="token punctuation">(</span><span class="token function">vector-set!</span> vec <span class="token punctuation">(</span><span class="token function">char2int</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span> <span class="token number">81</span>:                <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1-</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">82</span>:             vec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">83</span>:      <span class="token number">84</span>:     <span class="token comment" spellcheck="true">;;; calculating the score of guess</span> <span class="token number">85</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">scoring</span> vec0 vec1<span class="token punctuation">)</span> <span class="token number">86</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> vec0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">87</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">score</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">88</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i n<span class="token punctuation">)</span> <span class="token number">89</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">d0</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec0 i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">90</span>:                    <span class="token punctuation">(</span><span class="token function">d1</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec1 i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">91</span>:                 <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span> <span class="token number">92</span>:               <span class="token punctuation">(</span><span class="token operator">+</span> score <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">and</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">0</span> d0<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">0</span> d1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">93</span>:                                    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> d0 d1<span class="token punctuation">)</span> <span class="token number">5</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">94</span>:                                    <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">95</span>:             score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">96</span>:      <span class="token number">97</span>:     <span class="token comment" spellcheck="true">;;; show bulls and cows calculated from the score of user's guess</span> <span class="token number">98</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">show-user-score</span> score<span class="token punctuation">)</span> <span class="token number">99</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"Number of bulls and cows in your guess:"</span> <span class="token punctuation">)</span><span class="token number">100</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"bulls: "</span> <span class="token punctuation">(</span><span class="token function">quotient</span> score <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">101</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"cows: "</span> <span class="token punctuation">(</span><span class="token function">modulo</span> score <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">102</span>:       <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">103</span>:     <span class="token number">104</span>:     <span class="token comment" spellcheck="true">;;; calculating the score of computer's guess from bulls and cows</span><span class="token number">105</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">read-my-score</span> gu0<span class="token punctuation">)</span><span class="token number">106</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"My guess is: "</span> <span class="token punctuation">(</span><span class="token function">int2str</span> <span class="token punctuation">(</span><span class="token function">nvec2int</span> gu0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">107</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span> <span class="token string">"Give number of bulls and cows in my guess."</span> <span class="token punctuation">)</span><span class="token number">108</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">na5</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">5</span> <span class="token punctuation">(</span><span class="token function">read-integer</span> <span class="token string">"bulls: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">109</span>:         <span class="token punctuation">(</span><span class="token operator">+</span> na5 <span class="token punctuation">(</span><span class="token function">read-integer</span> <span class="token string">"cows: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">; the score is calculated by (5 * bull + cow)</span><span class="token number">110</span>:     <span class="token number">111</span>:     <span class="token comment" spellcheck="true">;;; reading the user guess</span><span class="token number">112</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>read-user-guess<span class="token punctuation">)</span><span class="token number">113</span>:       <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">114</span>:       <span class="token punctuation">(</span><span class="token function">str2nvec</span> <span class="token punctuation">(</span><span class="token function">read-from-stdin</span> <span class="token string">"Give your guess."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">115</span>:     <span class="token number">116</span>:     <span class="token comment" spellcheck="true">;;; shuffling the list of four-digit numbers</span><span class="token number">117</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">shuffle-numbers</span> ls0<span class="token punctuation">)</span><span class="token number">118</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">vec</span> <span class="token punctuation">(</span><span class="token builtin">list</span>->vector ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">119</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">n</span> <span class="token punctuation">(</span><span class="token function">vector-length</span> vec<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">120</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">0</span><span class="token punctuation">)</span><span class="token number">121</span>:               ls1<span class="token number">122</span>:           <span class="token punctuation">(</span><span class="token keyword">let*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">r</span> <span class="token punctuation">(</span><span class="token function">random</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">123</span>:              <span class="token punctuation">(</span><span class="token function">v</span> <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">124</span>:             <span class="token punctuation">(</span><span class="token function">vector-set!</span> vec r <span class="token punctuation">(</span><span class="token function">vector-ref</span> vec <span class="token punctuation">(</span><span class="token function">1-</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">125</span>:             <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1-</span> n<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> v ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">126</span>:     <span class="token number">127</span>:     <span class="token comment" spellcheck="true">;;; making a list of four-digit numbers in which numeral 0--9 appear once</span><span class="token number">128</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>make-numbers<span class="token punctuation">)</span><span class="token number">129</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">130</span>:         <span class="token punctuation">(</span><span class="token keyword">letrec</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">rec</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">i</span> num ls<span class="token punctuation">)</span><span class="token number">131</span>:                 <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">4</span><span class="token punctuation">)</span><span class="token number">132</span>:                 <span class="token punctuation">(</span><span class="token keyword">set!</span> ls1 <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token function">ls2nvec</span> ls<span class="token punctuation">)</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">133</span>:                 <span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token number">134</span>:                  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token number">135</span>:                    <span class="token punctuation">(</span><span class="token function">rec</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">delv</span> n num<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> n ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">136</span>:                  num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">137</span>:           <span class="token punctuation">(</span><span class="token function">rec</span> <span class="token number">0</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">138</span>:         ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">139</span>:     <span class="token number">140</span>:     <span class="token comment" spellcheck="true">;;;</span><span class="token number">141</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">game-over</span> sc0 sc1<span class="token punctuation">)</span><span class="token number">142</span>:       <span class="token punctuation">(</span><span class="token function">write-to-stdout</span><span class="token number">143</span>:        <span class="token punctuation">(</span><span class="token keyword">cond</span><span class="token number">144</span>:         <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">=</span> sc0 sc1<span class="token punctuation">)</span> <span class="token string">"Draw"</span><span class="token punctuation">)</span><span class="token number">145</span>:         <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">></span> sc0 sc1<span class="token punctuation">)</span> <span class="token string">"I won."</span><span class="token punctuation">)</span><span class="token number">146</span>:         <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token string">"You won."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">147</span>:       <span class="token string">'game-over)</span><span class="token number">148</span>:     <span class="token number">149</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">scoring-user-guess</span> an0 gu1<span class="token punctuation">)</span><span class="token number">150</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">sc1</span> <span class="token punctuation">(</span><span class="token function">scoring</span> an0 gu1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">151</span>:         <span class="token punctuation">(</span><span class="token function">show-user-score</span> sc1<span class="token punctuation">)</span><span class="token number">152</span>:         sc1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">153</span>:     <span class="token number">154</span>:     <span class="token comment" spellcheck="true">;;; Practical main function. tail recursive.</span><span class="token number">155</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">mastermind-rec</span> an0 candidates<span class="token punctuation">)</span><span class="token number">156</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> candidates<span class="token punctuation">)</span><span class="token number">157</span>:           <span class="token punctuation">(</span><span class="token function">error</span> <span class="token string">"Error. You gave wrong score for my guess, probably."</span><span class="token punctuation">)</span><span class="token number">158</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">gu0</span> <span class="token punctuation">(</span><span class="token builtin">car</span> candidates<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">159</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">sc1</span> <span class="token punctuation">(</span><span class="token function">scoring-user-guess</span> an0 <span class="token punctuation">(</span>read-user-guess<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">160</span>:               <span class="token punctuation">(</span><span class="token function">sc0</span> <span class="token punctuation">(</span><span class="token function">read-my-score</span> gu0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">161</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token operator">=</span> sc0 <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> sc1 <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">162</span>:               <span class="token punctuation">(</span><span class="token function">game-over</span> sc0 sc1<span class="token punctuation">)</span><span class="token number">163</span>:               <span class="token punctuation">(</span><span class="token function">mastermind-rec</span> an0 <span class="token number">164</span>:                    <span class="token punctuation">(</span><span class="token function">keep-matching-items</span> <span class="token number">165</span>:                     <span class="token punctuation">(</span><span class="token builtin">cdr</span> candidates<span class="token punctuation">)</span><span class="token number">166</span>:                     <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">scoring</span> gu0 x<span class="token punctuation">)</span> sc0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">167</span>:     <span class="token number">168</span>:     <span class="token comment" spellcheck="true">;;; The main function called from the top-level</span><span class="token number">169</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>mastermind<span class="token punctuation">)</span><span class="token number">170</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls0</span> <span class="token punctuation">(</span>make-numbers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">171</span>:         <span class="token punctuation">(</span><span class="token function">mastermind-rec</span> <span class="token punctuation">(</span><span class="token builtin">list</span>-ref ls0 <span class="token punctuation">(</span><span class="token function">random</span> <span class="token punctuation">(</span><span class="token function">length</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">shuffle-numbers</span> ls0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">行数</th><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">27</td><td align="left"><code>(1- x)</code></td><td align="left"><code>x</code>减一</td></tr><tr><td align="left">30</td><td align="left"><code>(char2int c)</code></td><td align="left">将字符<code>c</code>(#\0 – #\9)转换为整数（0 – 9）。</td></tr><tr><td align="left">34</td><td align="left"><code>(ls2nvec ls)</code></td><td align="left">将四个数字的表（<code>ls</code>）转换为向量表达式。<code>&#39;(5 3 6 0)-&gt;#(1 0 0 3 0 4 2 0 0 0)</code></td></tr><tr><td align="left">44</td><td align="left"><code>(nvec2int vec)</code></td><td align="left">将向量表达式<code>vec</code>转换为普通整数。</td></tr><tr><td align="left">54</td><td align="left"><code>(int2str i)</code></td><td align="left">将一个四位数<code>i</code>转换为字符串。如果<code>i</code>小于1000，’0’被置于高位。</td></tr><tr><td align="left">64</td><td align="left"><code>(read-from-stdin str)</code></td><td align="left">将<code>str</code>显示于标准输出，并返回用户从标准输入输入的字符串。</td></tr><tr><td align="left">70</td><td align="left"><code>(write-to-stdout . ls)</code></td><td align="left">将<code>ls</code>的每个元素都输出到标准输出，并在行尾插入行结束符。</td></tr><tr><td align="left">75</td><td align="left"><code>(str2nvec str)</code></td><td align="left">将用户输入的表示四位数的字符串<code>str</code>转换为向量表达式。</td></tr><tr><td align="left">86</td><td align="left"><code>(scoring vec0 vec1)</code></td><td align="left">以（5*Nnull + Ncow）计算两个整数（向量表达式）<code>vec0</code>和<code>vec1</code>的相似程度。</td></tr><tr><td align="left">98</td><td align="left"><code>(show-user-score score)</code></td><td align="left">通过相似度<code>score</code>计算Nbull和Ncow，并将它们显示在标准输出。</td></tr><tr><td align="left">105</td><td align="left"><code>(read-my-score gu0)</code></td><td align="left">显示计算机的猜测（gu0），让用户输入Nnull和Ncow，返回相似度score。</td></tr><tr><td align="left">112</td><td align="left"><code>(read-user-guess)</code></td><td align="left">返回用户猜测的向量表达式。</td></tr><tr><td align="left">116</td><td align="left"><code>(shuffle-numbers ls0)</code></td><td align="left">随机排序<code>ls0</code>。由于有随机读取的需求，将<code>ls0</code>转换为向量，然后随机读取向量的元素，以创建一个重排过的表。</td></tr><tr><td align="left">128</td><td align="left"><code>(make-numbers)</code></td><td align="left">返回由所有不同四位数构成的表。</td></tr><tr><td align="left">141</td><td align="left"><code>(game-over sc0 sc1)</code></td><td align="left">通过比较计算机的得分（sc0）和用户的得分(sc1)确定胜利者。</td></tr><tr><td align="left">149</td><td align="left"><code>(scoring-user-guess an0 gu1)</code></td><td align="left">计算计算机的密码（an0）和用户的猜测（gu1）的相似度，使用show-uuser-score输出Nbull和Ncow。</td></tr><tr><td align="left">155</td><td align="left"><code>(mastermind-rec an0 candidates)</code></td><td align="left">实际的主程序，它有两个参数；计算机密码（an0）和 猜测的表（candidate）。它计算计算机的得分（sc0）和用户的得分（sc1），如果<code>sc0</code>或者<code>sc1</code>为20，调用 (game-over sc0 sc1)。如果没有值为20，它根据<code>sc0</code>过滤猜测的表（candidate），并继续游戏。</td></tr><tr><td align="left">169</td><td align="left"><code>(mastermind)</code></td><td align="left">在控制台调用该函数以开始游戏。</td></tr></tbody></table><h3 id="如何玩"><a href="#如何玩" class="headerlink" title="如何玩"></a>如何玩</h3><p>输入如下代码启动游戏。最好在玩之前编译（你需要编译一次）。即使程序很简单，也很难取胜。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">compile-file</span> <span class="token string">"mastermind.scm"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">load</span> <span class="token string">"mastermind"</span><span class="token punctuation">)</span><span class="token punctuation">(</span>mastermind<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这一章，我通过玩<code>mastermind</code>游戏讲解了向量和结构体。附上<a href="http://www.shido.info/lisp/scheme_vec.zip"><code>mastermind</code>的源代码</a>。</p><p>我将在下一章讲自定义语法。自定义语法是Lisp/Scheme的一个优点。</p><h2 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><p>本章中，我会讲解如何自定义语法。用户定义语法称作<strong>宏（Macro）</strong>。Lisp/Scheme中的宏比C语言中的宏更加强大。宏可以使你的程序优美而紧凑。</p><p><strong>宏是代码的变换</strong>。代码在被求值或编译前进行变换，程序会继续执行就像变换后的代码一开始就写好了一样。</p><p>你可以在Scheme中通过用符合R5RS规范的<code>syntax-rules</code>轻易地定义简单宏，相比之下，在Common Lisp中自定义语法就复杂多了。使用<code>syntax-rules</code>可以直接定义宏而不用担心<strong>变量捕获（Variable Capture）</strong>。另一方面，Scheme中定义那些无法用<code>syntax-rules</code>定义的复杂的宏就比Common Lisp要困难。</p><h3 id="简单宏的实例"><a href="#简单宏的实例" class="headerlink" title="简单宏的实例"></a>简单宏的实例</h3><p>我将以一个简单的宏作为例子。</p><p>[代码1]一个将变量赋值为<code>&#39;()</code>的宏。</p><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> nil!  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> x<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">set!</span> x <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>syntax-reuls</code>的第二个参数是变换前和变化后的表达式的序对所构成的表。<code>_</code>代表宏的名字。简言之，[代码1]表示表达式<code>(nil! x)</code>会变换为<code>(set! x &#39;())</code>.</p><p>这类程序不能通过函数来实现，这是因为由于闭包性，函数不能影响外部变量。让我们来用函数版本来实现[代码1]，并观察效果。</p><p>[代码’1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">f-nil!</span> x<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token keyword">set!</span> x <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> a <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: a</span><span class="token punctuation">(</span><span class="token function">f-nil!</span> a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span>a<span class="token comment" spellcheck="true">;Value: 1           ; the value of a dose not change</span><span class="token punctuation">(</span><span class="token function">nil!</span> a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span>a<span class="token comment" spellcheck="true">;Value: ()          ; a becomes '()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我会演示另外一个例子。我们编写宏<code>when</code>，其语义为：当谓词求值为真时，求值相应语句。</p><p>[代码2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> when  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> pred b1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">if</span> pred <span class="token punctuation">(</span><span class="token keyword">begin</span> b1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>[代码2]中的<code>...</code>代表了任意多个数的表达式（包括0个表达式）。[代码2]揭示了表达式<code>(when pred b1 ...)</code>变换为<code>(if pred (begin b1 ...))</code>。</p><p>由于这个宏是将表达式变换为<code>if</code>特殊形式，因此它不能使用函数来实现。下面的例子演示了如何使用<code>when</code>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">when</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">"i == 0"</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>i == <span class="token number">0</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我会演示两个实际的宏：<code>while</code>和<code>for</code>（已在Scheme中实现）。只要谓词部分求值为真，<code>while</code>就会对语句体求值。而数字在指定的范围中，<code>for</code>就会对语句体求值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> while  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> pred b1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">when</span> pred b1 ... <span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> for  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> <span class="token punctuation">(</span><span class="token function">i</span> from to<span class="token punctuation">)</span> b1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> loop<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> from<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">when</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i to<span class="token punctuation">)</span>      b1 ...      <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面演示了如何使用它们：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">while</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">10</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">display</span> i<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">display</span> #\Space<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">set!</span> i <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token punctuation">(</span><span class="token function">for</span> <span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span> <span class="token number">10</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> i<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> #\Space<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="syntax-rule的更多细节"><a href="#syntax-rule的更多细节" class="headerlink" title="syntax-rule的更多细节"></a>syntax-rule的更多细节</h3><h4 id="多个定义模式"><a href="#多个定义模式" class="headerlink" title="多个定义模式"></a>多个定义模式</h4><p><code>syntax-rule</code>可以定义一系列模式。比如，一个让变量增加的宏，如果给定了变量名，那么宏<code>incf</code>使该变量增加1。可以通过编写如[代码4]这样的模式转换来实现宏<code>incf</code>。</p><p>[代码4]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> incf  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token punctuation">(</span><span class="token keyword">set!</span> x <span class="token punctuation">(</span><span class="token operator">+</span> x <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> x i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">begin</span> <span class="token punctuation">(</span><span class="token keyword">set!</span> x <span class="token punctuation">(</span><span class="token operator">+</span> x i<span class="token punctuation">)</span><span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">incf</span> i<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">incf</span> j <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'i</span> <span class="token string">'=</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>newline<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'j</span> <span class="token string">'=</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">i</span> = <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">j</span> = <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="宏的递归定义"><a href="#宏的递归定义" class="headerlink" title="宏的递归定义"></a>宏的递归定义</h4><p>代码形式<code>or</code>和<code>and</code>是通过像下面这样递归定义的宏：</p><p>[代码5]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> my-and  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token boolean">#t</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> e<span class="token punctuation">)</span> e<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> e1 e2 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">if</span> e1     <span class="token punctuation">(</span><span class="token function">my-and</span> e2 ...<span class="token punctuation">)</span>     <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> my-or  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token boolean">#f</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> e<span class="token punctuation">)</span> e<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> e1 e2 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">t</span> e1<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">if</span> t t <span class="token punctuation">(</span><span class="token function">my-or</span> e2 ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用递归定义来编写复杂的宏。</p><h4 id="使用保留字"><a href="#使用保留字" class="headerlink" title="使用保留字"></a>使用保留字</h4><p><code>syntax-rule</code>的第一个参数是保留字的表。比如，<code>cond</code>的定义如[代码6]所示，其中，<code>else</code>是保留字。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> my-cond  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token keyword">else</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> <span class="token punctuation">(</span><span class="token keyword">else</span> e1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">begin</span> e1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> <span class="token punctuation">(</span><span class="token function">e1</span> e2 ...<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">when</span> e1 e2 ...<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> <span class="token punctuation">(</span><span class="token function">e1</span> e2 ...<span class="token punctuation">)</span> c1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">if</span> e1      <span class="token punctuation">(</span><span class="token keyword">begin</span> e2 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">cond</span> c1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="局部语法"><a href="#局部语法" class="headerlink" title="局部语法"></a>局部语法</h3><p>在Scheme中，可以使用<code>let-syntax</code>和<code>letrec-syntax</code>来定义<strong>局部语法（Local Syntax）</strong>。这种形式的用法和<code>define-syntax</code>是相似的。</p><h3 id="取决于宏定义的实现"><a href="#取决于宏定义的实现" class="headerlink" title="取决于宏定义的实现"></a>取决于宏定义的实现</h3><p>有些宏无法使用<code>syntax-rules</code>来定义。定义这些宏的实现方法已经在Scheme实现中准备好了。由于这种行为严重依赖于实现，因此你可以跳过此节。</p><p>在MIT-Scheme中，<code>sc-macro-transformer</code>就可用于这种情况，它允许用户用与Common Lisp中相似的方式来编写宏。关于<code>,</code>、<code>,@</code>的介绍，请参见<a href="http://deathking.github.io/yast-cn/contents/www.lispworks.com/documentation/HyperSpec/Body/02_df.htm">The Common Lisp HyperSpec</a>。关于<code>sc-macro-transformer</code>和<code>make-syntactic-closuer</code>请参见MIT-Scheme手册。[代码7]演示了一个简单的例子。</p><p>[代码 7]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> show-vars  <span class="token punctuation">(</span><span class="token function">sc-macro-transformer</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">exp</span> env<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">vars</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           `<span class="token punctuation">(</span><span class="token keyword">begin</span>              <span class="token punctuation">(</span><span class="token function">display</span>                <span class="token punctuation">(</span><span class="token builtin">list</span>                  ,@<span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>v<span class="token punctuation">)</span>                            <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">w</span> <span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 `<span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">',w</span> ,w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                          vars<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> random-choice  <span class="token punctuation">(</span><span class="token function">sc-macro-transformer</span>   <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">exp</span> env<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       `<span class="token punctuation">(</span><span class="token function">case</span> <span class="token punctuation">(</span><span class="token function">random</span> ,<span class="token punctuation">(</span><span class="token function">length</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      ,@<span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>           `<span class="token punctuation">(</span><span class="token punctuation">(</span>,<span class="token punctuation">(</span><span class="token function">incf</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> ,<span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token builtin">cdr</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> aif  <span class="token punctuation">(</span><span class="token function">sc-macro-transformer</span>   <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">exp</span> env<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">test</span> <span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">second</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">cthen</span> <span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">third</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">celse</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">pair?</span> <span class="token punctuation">(</span><span class="token function">cdddr</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token punctuation">(</span><span class="token function">make-syntactic-closure</span> env <span class="token string">'</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">fourth</span> exp<span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       `<span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">it</span> ,test<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">if</span> it ,cthen ,celse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个宏<code>show-vars</code>用于显示变量的值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">show-vars</span> i j k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">j</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>代码形式<code>(show-vars i j k)</code>被展开成下面这样。因为宏只能返回一个表达式，所以需要用<code>begin</code>返回表达式的集合。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">begin</span>  <span class="token punctuation">(</span><span class="token function">display</span>   <span class="token punctuation">(</span><span class="token builtin">list</span>    <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'i</span> i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'j</span> j<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">'k</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个宏<code>random-choice</code>被用于从参数中随机选择一个值或者过程。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>turn-right<span class="token punctuation">)</span> <span class="token string">'right)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>turn-left<span class="token punctuation">)</span> <span class="token string">'left)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>go-ahead<span class="token punctuation">)</span> <span class="token string">'straight)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>stop<span class="token punctuation">)</span> <span class="token string">'stop)</span><span class="token punctuation">(</span><span class="token function">random-choice</span> <span class="token punctuation">(</span>turn-right<span class="token punctuation">)</span> <span class="token punctuation">(</span>turn-left<span class="token punctuation">)</span> <span class="token punctuation">(</span>go-ahead<span class="token punctuation">)</span> <span class="token punctuation">(</span>stop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: right</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码形式被展开如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">case</span> <span class="token punctuation">(</span><span class="token function">random</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span> <span class="token punctuation">(</span>turn-right<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span> <span class="token punctuation">(</span>turn-left<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span> <span class="token punctuation">(</span>go-ahead<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span> <span class="token punctuation">(</span>stop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三个宏<code>aif</code>是一个回指宏（ anaphoric macro）。谓词的结果可以被指为<code>it</code>。变量<code>it</code>被捕获，以使得第二个参数<code>make-syntactic-closure</code>变为<code>&#39;(it)</code>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">aif</span> <span class="token punctuation">(</span><span class="token function">memv</span> i <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token builtin">car</span> it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面显示了扩展结果。</p><p>````scheme<br>(let ((it (memv i ‘(2 4 6 8))))<br>  (if it<br>      (car it)<br>      #f))</p><pre><code>### 结构体的原始实现结构体（structure）可以通过[代码8]中的简单宏实现。这里定义的结构体的本质是一个向量（vector）和由宏自动创建的取值以及赋值函数。如果你喜欢的Scheme版本没有结构体的实现，你可以自己实现它们。[代码8]```scheme01:     ;;; simple structure definition02:     03:     ;;; lists of symbols -&gt; string04:     (define (append-symbol . ls)05:       (let loop ((ls (cdr ls)) (str (symbol-&gt;string (car ls))))06:         (if (null? ls)07:         str08:         (loop (cdr ls) (string-append str &quot;-&quot; (symbol-&gt;string (car ls)))))))09:     10:     ;;; obj -&gt; ls -&gt; integer11:     ;;; returns position of obj in ls12:     (define (position obj ls)13:       (letrec ((iter (lambda (i ls)14:                (cond15:                 ((null? ls) #f)16:                 ((eq? obj (car ls)) i)17:                 (else (iter (1+ i) (cdr ls)))))))18:         (iter 0 ls)))19:                          20:     21:     ;;; list -&gt; integer -&gt; list22:     ;;; enumerate list items23:     (define (slot-enumerate ls i)24:       (if (null? ls)25:           &#39;()26:         (cons `((,(car ls)) ,i) (slot-enumerate (cdr ls) (1+ i)))))27:     28:     ;;; define simple structure 29:     (define-syntax defstruct30:       (sc-macro-transformer31:        (lambda (exp env)32:          (let ((struct (second exp))33:                (slots  (map (lambda (x) (if (pair? x) (car x) x)) (cddr exp)))34:            (veclen (- (length exp) 1)))35:            36:            `(begin   37:           (define ,(string-&gt;symbol (append-symbol &#39;make struct))   ; making instance38:             (lambda ls39:                   (let ((vec (vector &#39;,struct ,@(map (lambda (x) (if (pair? x) (second x) #f)) (cddr exp)))))40:             (let loop ((ls ls))41:               (if (null? ls)42:                   vec43:                   (begin44:                            (vector-set! vec (case (first ls) ,@(slot-enumerate slots 1)) (second ls))45:                 (loop (cddr ls))))))))46:     47:           (define ,(string-&gt;symbol (string-append (symbol-&gt;string struct) &quot;?&quot;))  ; predicate48:             (lambda (obj)49:               (and50:                (vector? obj)51:                (eq? (vector-ref obj 0) &#39;,struct))))52:     53:           ,@(map54:              (lambda (slot)55:                (let ((p (1+ (position slot slots))))56:              `(begin57:                 (define ,(string-&gt;symbol (append-symbol struct slot))    ; accessors58:                   (lambda (vec)59:                 (vector-ref vec ,p)))60:     61:                 (define-syntax ,(string-&gt;symbol                           ; modifier62:                          (string-append63:                           (append-symbol &#39;set struct slot) &quot;!&quot;))64:                   (syntax-rules ()65:                 ((_ s v) (vector-set! s ,p v)))))))66:              slots)67:     68:           (define ,(string-&gt;symbol (append-symbol &#39;copy struct))      ; copier69:             (lambda (vec)70:               (let ((vec1 (make-vector ,veclen)))71:             (let loop ((i 0))72:               (if (= i ,veclen)73:                   vec174:                   (begin75:                 (vector-set! vec1 i (vector-ref vec i))76:                 (loop (1+ i)))))))))))))</code></pre><p>下面演示了如何使用：</p><p>你可以定义一个结构体，要么只给出槽（slot）的名字，要么给出槽（slot）的名字和缺省值。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; Defining a structure point having 3 slots whose defaults are 0.0.</span><span class="token punctuation">(</span><span class="token function">defstruct</span> point <span class="token punctuation">(</span><span class="token function">x</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">y</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">z</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token punctuation">(</span><span class="token keyword">define</span> p1 <span class="token punctuation">(</span><span class="token function">make-point</span> <span class="token string">'x</span> <span class="token number">10</span> <span class="token string">'y</span> <span class="token number">20</span> <span class="token string">'z</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: p1</span><span class="token punctuation">(</span><span class="token function">point?</span> p1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">point-x</span> p1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 10</span><span class="token comment" spellcheck="true">;;; Default values are used for unspecified values when an instance is made.</span><span class="token punctuation">(</span><span class="token keyword">define</span> p2 <span class="token punctuation">(</span><span class="token function">make-point</span> <span class="token string">'z</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: p2</span><span class="token punctuation">(</span><span class="token function">point-x</span> p2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 0.</span><span class="token punctuation">(</span><span class="token function">point-z</span> p2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 20</span><span class="token comment" spellcheck="true">;;; Changing a slot value</span><span class="token punctuation">(</span><span class="token function">set-point-y!</span> p2 <span class="token number">12</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token comment" spellcheck="true">;;; The reality of the structure definde by [code 8] is a vector</span>p2<span class="token comment" spellcheck="true">;Value 14: #(point 0. 12 20)</span><span class="token comment" spellcheck="true">;;; Defining a structure 'book' with no default values.</span><span class="token punctuation">(</span><span class="token function">defstruct</span> book title authors publisher year isbn<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Unspecified return value</span><span class="token punctuation">(</span><span class="token keyword">define</span> mon-month   <span class="token punctuation">(</span><span class="token function">make-book</span> <span class="token string">'title</span>           <span class="token string">"The Mythical Man-Month: Essays on Software Engineering"</span>         <span class="token string">'authors</span>         <span class="token string">"F.Brooks"</span>         <span class="token string">'publisher</span>         <span class="token string">"Addison-Wesley"</span>         <span class="token string">'year</span>         <span class="token number">1995</span>         <span class="token string">'isbn</span>         <span class="token number">0201835959</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: mon-month</span>mon-month<span class="token comment" spellcheck="true">;Value 15: #(book </span><span class="token string">"The Mythical Man-Month: Essays on Software Engineering"</span> <span class="token string">"F.Brooks"</span> <span class="token string">"Addison-Wesley"</span> <span class="token number">1995</span> <span class="token number">201835959</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">book-title</span> mon-month<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 13: "The Mythical Man-Month: Essays on Software Engineering"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>我简要介绍了Scheme里的宏。宏可以使你的代码更优雅。</p><p><code>syntax-rules</code>使得编写宏很容易。另一方面，编写Common Lisp的宏，则要求特点的技巧。</p><h2 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h2><h3 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h3><p>本章介绍的是Scheme中特有的数据类型——<strong>继续（Continuation）</strong>。由于其他程序设计语言并没有这种数据类型，因此它难于理解。当下，你并不需要彻底理解清楚，只需要大致了解。</p><p>我会讲解广义的继续和简短地介绍<strong>Continuation-Passing-Style(CPS)</strong>，然后再讲解Scheme中的继续。我认为通过这种方式理解继续会比较容易。</p><h3 id="广义继续"><a href="#广义继续" class="headerlink" title="广义继续"></a>广义继续</h3><p>继续是在返回到<strong>顶层（Top level）</strong>之前所需要执行的计算。实际上，继续存在于计算的每时每刻。以<code>(* 3 (+ 1 2))</code>为例，在求值完<code>(+ 1 2)</code>后，应该计算<code>{ (* 3 []) }</code>乘以3。然而，大多数语言都不显式地这么做，程序员对此并不熟悉。</p><h3 id="Continuation-Passing-Style-CPS"><a href="#Continuation-Passing-Style-CPS" class="headerlink" title="Continuation-Passing-Style(CPS)"></a>Continuation-Passing-Style(CPS)</h3><h4 id="简单的CPS"><a href="#简单的CPS" class="headerlink" title="简单的CPS"></a>简单的CPS</h4><p>CPS是一种编程风格，在这种风格中，把依赖于当前函数结果的后续函数作为参数传递给当前函数。[代码1]展示了以CPS编写的加法和乘法。在<code>k+</code>和<code>k*</code>中，<code>k</code>是后续函数。</p><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">return</span> x<span class="token punctuation">)</span>  x<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">k+</span> a b k<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">+</span> a b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">k*</span> a b k<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">*</span> a b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例1]演示了如何使用CPS计算<code>(* 3 (+ 1 2))</code>。</p><p>[例1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">k+</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k*</span> x <span class="token number">3</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Scheme的普通形式中，值在括号内被计算并向括号外传递。与此相反，CPS中，值向括号内传递。如[例1]中，<code>k+</code>把<code>(+ 1 2)</code>的值传递给<code>(lambda (x) (k* x 3 return))</code>，而<code>k*</code>把<code>(* (+ 1 2) 3)</code>的结果传给<code>return</code>。</p><h4 id="以CPS编写递归函数"><a href="#以CPS编写递归函数" class="headerlink" title="以CPS编写递归函数"></a>以CPS编写递归函数</h4><p>递归函数同样可以以CPS编写。[代码2]展示了计算阶乘的函数如何用普通方式编写（<code>fact</code>）和以CPS编写(<code>kfact</code>)。</p><p>[代码2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; normal factorial</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>       <span class="token number">1</span>      <span class="token punctuation">(</span><span class="token operator">*</span> n <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; CPS factorial</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">kfact</span> n k<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">1</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">kfact</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">*</span> n x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例2]将3与4的阶乘相加。</p><p>[例2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; normal</span><span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; CPS</span><span class="token punctuation">(</span><span class="token function">kfact</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k+</span> x <span class="token number">3</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[代码3]演示了如何分别用普通方式和CPS编写计算表中元素之积的函数。在CPS函数中，后继函数存储在局部变量<code>break</code>中，因此当元素乘以0时，可以立即退出。</p><p>[代码3]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; normal</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">product</span> ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">acc</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">cond</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> acc<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">zero?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; CPS</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">kproduct</span> ls k<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">break</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">cond</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">zero?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">break</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例3]将100与<code>&#39;(2 4 7)</code>的积相加。</p><p>[例3]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; normal</span><span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">100</span> <span class="token punctuation">(</span><span class="token function">product</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; CPS</span><span class="token punctuation">(</span><span class="token function">kproduct</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k+</span> x <span class="token number">100</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管CPS在这样简单的情况中并不实用，但在一些像是自然语言解析和逻辑编程等复杂程序中非常有用，因为与通常的编程风格相比，CPS可以更灵活地改变后续过程。</p><p><strong>异常处理（Exception handling）</strong>就是这种情况的简单例子。[代码4]演示了<code>kproduct</code>的错误处理版本，程序中当非数字值出现在输入表中，在其被打印时，计算就会终止。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">non-number-value-error</span> x<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">"Value error: "</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span>  x<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">" is not number."</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>newline<span class="token punctuation">)</span>  <span class="token string">'error)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">kproduct</span> ls k k-value-error<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">break</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ls</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">cond</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token builtin">number?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k-value-error</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">zero?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">break</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; valid</span><span class="token punctuation">(</span><span class="token function">kproduct</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">7</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k+</span> x <span class="token number">100</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span>       non-number-value-error<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 156</span><span class="token comment" spellcheck="true">;;; invalid</span><span class="token punctuation">(</span><span class="token function">kproduct</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">4</span> <span class="token number">7</span> hoge<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k+</span> x <span class="token number">100</span> return<span class="token punctuation">)</span><span class="token punctuation">)</span>       non-number-value-error<span class="token punctuation">)</span>Value error: hoge is not number.<span class="token comment" spellcheck="true">;Value: error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Scheme中的继续"><a href="#Scheme中的继续" class="headerlink" title="Scheme中的继续"></a>Scheme中的继续</h3><p>通过上面的讲解，你应该掌握了继续（continuation）。继续有下面的性质：</p><ol><li>存在于整个计算过程中；</li><li>函数式程序设计语言和CPS可以显式地处理它。</li></ol><p>另外，上面例子展示的是<strong>闭包链（Chain of closure）</strong>。</p><p>然而，阅读和编写CPS程序是痛苦的，以常规方式来处理继续会更方便一点。</p><p>因此，Scheme中将继续实现为<strong>一级对象（first class object）</strong>（这意味这Scheme中的继续是个普通数据类型），任何时候都可以通过名为<code>call-with-current-continuation</code>来调用。由于继续是普通数据类型，你可以随心所欲地重用。考虑到<code>call-with-current-continuation</code>名字过长，通常使用其缩略名<code>call/cc</code>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> call/cc call-with-current-continuation<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数<code>call-with-current-continuation (call/cc)</code>接受一个参数。该参数是一个函数，函数的参数接收当前继续。</p><p>下面是例子：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">;⇒ 9      ; [1]</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;⇒ 6      ; [2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在<strong>情况[1]</strong>中，继续并没有被调用，语句的行为与普通S-表达式相同。另一方面，在<strong>情况[2]</strong>中，继续以2作为参数被调用。在这种情况中，继续的参数跳过了<code>call/cc</code>的处理，并逃逸至<code>call/cc</code>的外部。这种情况中，<code>k</code>是一个一元函数，等价于<code>(lambda (x) (* 3 x))</code>。</p><p>大体来说，当前继续存储了从<code>call/cc</code>调用点到顶层的处理过程。当前继续可以像其它数据类型那样被存储起来，并随心所欲地重用。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> cc<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span>                  <span class="token punctuation">(</span><span class="token keyword">set!</span> cc k<span class="token punctuation">)</span>                  <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于当前继续是回到顶层的处理过程，它的返回会忽略周围的S-表达式。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">100</span> <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">;⇒ 9 </span><span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">100</span> <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;⇒ 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="使用call-cc抛出值"><a href="#使用call-cc抛出值" class="headerlink" title="使用call/cc抛出值"></a>使用<code>call/cc</code>抛出值</h4><p>从一个计算过程中逃逸出来，是使用当前继续的最容易的方法。[代码5]演示了搜索树（嵌套表）的函数。如果函数在树中找到<code>obj</code>，那么它返回该对象，否则返回<code>#f</code>。一旦找到<code>obj</code>，函数直接将其抛出至最外部。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">find-leaf</span> obj tree<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token builtin">call/cc</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>cc<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">letrec</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">iter</span>                   <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>tree<span class="token punctuation">)</span>                      <span class="token punctuation">(</span><span class="token keyword">cond</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span>  tree<span class="token punctuation">)</span> <span class="token boolean">#f</span><span class="token punctuation">)</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">pair?</span> tree<span class="token punctuation">)</span>                           <span class="token punctuation">(</span><span class="token function">iter</span> <span class="token punctuation">(</span><span class="token builtin">car</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span>                           <span class="token punctuation">(</span><span class="token function">iter</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token punctuation">(</span><span class="token keyword">else</span>                          <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">eqv?</span> obj tree<span class="token punctuation">)</span>                            <span class="token punctuation">(</span><span class="token function">cc</span> obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token function">iter</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">find-leaf</span> <span class="token number">7</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token function">5</span> <span class="token punctuation">(</span><span class="token function">6</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒ 7</span><span class="token punctuation">(</span><span class="token function">find-leaf</span> <span class="token number">8</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token punctuation">(</span><span class="token function">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token function">5</span> <span class="token punctuation">(</span><span class="token function">6</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒ ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例6]演示了一个支持抛出的语法<code>block</code>。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> block  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> tag e1 ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token builtin">call-with-current-continuation</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>tag<span class="token punctuation">)</span>          e1 ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[例7]演示了如何使用它。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">block</span> break   <span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">positive?</span> x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token function">sqrt</span> x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token function">break</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒ (1 1.4142135623730951 1.7320508075688772)</span><span class="token punctuation">(</span><span class="token function">block</span> break   <span class="token punctuation">(</span><span class="token function">map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">positive?</span> x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token function">sqrt</span> x<span class="token punctuation">)</span>           <span class="token punctuation">(</span><span class="token function">break</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">-2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;⇒ -2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>我会讲解如何用<code>call/cc</code>实现一个树匹配的生成器。生成器以一个树为参数返回一个函数，每次调用这个返回的函数时，它会返回后续的叶子。你可以在<a href="http://ds26gte.github.io/tyscheme/index-Z-H-15.html#node_sec_13.3">Teach Yourself Scheme in Fixnum Days的第13.3节</a>中找到这个函数的原始版本。生成器的使用方法如下：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> tr <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">1</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">3</span> <span class="token punctuation">(</span><span class="token function">4</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> p <span class="token punctuation">(</span><span class="token function">leaf-generator</span> tr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 3</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 4</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> 5</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">;=> ()  ; finally it returns '()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[代码6]给出了生成器的定义。这个和原始版本基本上相同，但有略微的修改。</p><p>[代码6]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">leaf-generator</span> tree<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">return</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                               <span class="token comment" spellcheck="true">; 1</span>    <span class="token punctuation">(</span><span class="token keyword">letrec</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">continue</span>                                              <span class="token comment" spellcheck="true">; 2</span>      <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token keyword">let</span> rec <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">tree</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span>                                      <span class="token comment" spellcheck="true">; 3</span>          <span class="token punctuation">(</span><span class="token keyword">cond</span>                                                     <span class="token comment" spellcheck="true">; 4</span>           <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> tree<span class="token punctuation">)</span> <span class="token string">'skip)</span>                                     <span class="token comment" spellcheck="true">; 5</span>           <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">pair?</span> tree<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">rec</span> <span class="token punctuation">(</span><span class="token builtin">car</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">rec</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">; 6</span>           <span class="token punctuation">(</span><span class="token keyword">else</span>                                                    <span class="token comment" spellcheck="true">; 7</span>            <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>lap-to-go<span class="token punctuation">)</span>                            <span class="token comment" spellcheck="true">; 8</span>                   <span class="token punctuation">(</span><span class="token keyword">set!</span> continue <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">lap-to-go</span> <span class="token string">'restart)))</span> <span class="token comment" spellcheck="true">; 9</span>                   <span class="token punctuation">(</span><span class="token function">return</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                               <span class="token comment" spellcheck="true">;10</span>        <span class="token punctuation">(</span><span class="token function">return</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                             <span class="token comment" spellcheck="true">;11</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>                                                  <span class="token comment" spellcheck="true">;12</span>      <span class="token punctuation">(</span><span class="token builtin">call/cc</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>where-to-go<span class="token punctuation">)</span>                            <span class="token comment" spellcheck="true">;13</span>                 <span class="token punctuation">(</span><span class="token keyword">set!</span> return where-to-go<span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true">;14</span>                 <span class="token punctuation">(</span>continue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(译者注：原文中05，08行中命名let中的<code>rec</code>被写为<code>loop</code>，结合上下文，改为<code>rec</code>)</p><p>注释解释</p><p>编号 解释</p><ul><li>1.定义本地变量<code>return</code>。</li><li>2.使用<code>letrec</code>定义<code>continue</code>。<code>continue</code>将当前叶子返回到前面，将当前继续赋给<code>continue</code>，并停止。</li><li>3.用<code>rec</code>定义命名let。</li><li>4.使用<code>cond</code>实现分支</li><li>5.如果是空表，什么也不做</li><li>6.如果是序对，递归地将序对的car和cdr应用于rec。</li><li>7.如果是叶子，</li><li>8.调用<code>call/cc</code>以获取当前状态(lap-to-go)</li><li>9.接着将当前状态赋给<code>continue</code>。所以除了原有的<code>continue</code>，<code>lap-to-go</code>也包含了当前状态。简而言之，它可以被如下的S-表达式中的<strong>[ ]</strong>表示。</li></ul><pre class="line-numbers language-Scheme"><code class="language-Scheme">(lambda ()   (let rec ((tree tree0))        (cond                          ((null? tree) '())             ((pair? tree) (rec (car tree)) (rec (cdr tree)))          (else                                                       [ ]    (return '()))))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用<code>lap-to-go</code>意味着<code>(car tree)</code>是叶子，且过程结束了，<code>(rec (cdr tree))</code>在下一次函数调用时开始运行。如果过程在<strong>[ ]</strong>之后结束，继续的参数将不起作用。</p><ul><li>10.接着函数将找到的叶子返回到函数的调用处。<code>(return tree)</code>应该在<code>call/cc</code>中以重启过程。</li><li>11.在搜索了全部叶子之后返回空表。</li><li>12.这是一个返回叶子生成器的生成器。</li><li>13.首次调用<code>call/cc</code></li><li>14.将表示返回值的当前状态赋给<code>return</code>。</li><li>15.然后调用<code>continue</code>。</li></ul><p>由<code>leaf-generator</code>生成的函数的行为可以通过函数<code>tree-traverse</code>的行为来估计。过程停止在轨迹的’*’的注释处，并使得过程存储在<code>continue</code>。</p><p>一个常规的遍历函数：</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> tree-traverse  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>tree<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">cond</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">null?</span> tree<span class="token punctuation">)</span> <span class="token string">'_)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">pair?</span> tree<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">tree-traverse</span> <span class="token punctuation">(</span><span class="token builtin">car</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">tree-traverse</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">else</span>      <span class="token punctuation">(</span><span class="token function">write</span> tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当树为<code>&#39;((1 2) 3)</code>时，<code>tree-traverse</code>的轨迹。</p><pre><code>&gt; (tree-traverse &#39;((1 2) 3))|(tree-traverse ((1 2) 3))| (tree-traverse (1 2))| |(tree-traverse 1)           1| |#&lt; void&gt;               ; *| (tree-traverse (2))| |(tree-traverse 2)           2| |&lt; void&gt;                ; *| (tree-traverse &#39;())| _|(tree-traverse (3))| (tree-traverse 3)            3| #&lt; void&gt;                ; *|(tree-traverse &#39;())|__</code></pre><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>因为继续记录了后续计算过程，因此，用于多任务同时执行的<strong>协程（Coroutine）</strong>可以使用继续来实现。</p><p><strong>代码片段7</strong>展示了一段交替打印数字和字母的程序。5 - 22行是队列的实现。<code>(enqueue! queue obj)</code>将一个<code>obj</code>添加在队列的末尾。<code>(dequeue! queue)</code>返回队列第一个元素并将它删除。</p><p>26 - 38行是协程的实现。</p><p><strong>process-queue</strong></p><p>过程的队列。</p><p><strong>(coroutine thunk)</strong></p><p>在<code>process-queue</code>末尾添加<code>thunk</code>。</p><p><strong>(start)</strong></p><p>取得<code>process-queue</code>的第一个过程并执行它。</p><p><strong>(pause)</strong></p><p>将当前继续添加到<code>process-queue</code>的末尾并执行队列里的第一个过程。这个函数将控制权交给另外一个协程。</p><p>42 - 61行显示如何使用它。一个显示数字例程和一个显示字母例程相互调用对方，结果显示在<strong>例7</strong></p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; abbreviation</span><span class="token number">02</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> call/cc call-with-current-continuation<span class="token punctuation">)</span><span class="token number">03</span>:     <span class="token number">04</span>:     <span class="token comment" spellcheck="true">;;; queue</span><span class="token number">05</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>make-queue<span class="token punctuation">)</span><span class="token number">06</span>:       <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">07</span>:     <span class="token number">08</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">enqueue!</span> queue obj<span class="token punctuation">)</span><span class="token number">09</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">lobj</span> <span class="token punctuation">(</span><span class="token builtin">list</span> obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">11</span>:         <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">12</span>:           <span class="token punctuation">(</span><span class="token function">set-car!</span> queue lobj<span class="token punctuation">)</span><span class="token number">13</span>:           <span class="token punctuation">(</span><span class="token function">set-cdr!</span> queue lobj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:         <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">15</span>:           <span class="token punctuation">(</span><span class="token function">set-cdr!</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> queue<span class="token punctuation">)</span> lobj<span class="token punctuation">)</span><span class="token number">16</span>:           <span class="token punctuation">(</span><span class="token function">set-cdr!</span> queue lobj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">17</span>:         <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:     <span class="token number">19</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">dequeue!</span> queue<span class="token punctuation">)</span><span class="token number">20</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">obj</span> <span class="token punctuation">(</span><span class="token builtin">car</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">21</span>:         <span class="token punctuation">(</span><span class="token function">set-car!</span> queue <span class="token punctuation">(</span><span class="token builtin">cdr</span> <span class="token punctuation">(</span><span class="token builtin">car</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">22</span>:         obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">23</span>:     <span class="token number">24</span>:     <span class="token number">25</span>:     <span class="token comment" spellcheck="true">;;; coroutine   </span><span class="token number">26</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> process-queue <span class="token punctuation">(</span>make-queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">27</span>:     <span class="token number">28</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">coroutine</span> thunk<span class="token punctuation">)</span><span class="token number">29</span>:       <span class="token punctuation">(</span><span class="token function">enqueue!</span> process-queue thunk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">30</span>:     <span class="token number">31</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token number">32</span>:        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">dequeue!</span> process-queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">33</span>:        <span class="token number">34</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>pause<span class="token punctuation">)</span><span class="token number">35</span>:       <span class="token punctuation">(</span><span class="token builtin">call/cc</span><span class="token number">36</span>:        <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token number">37</span>:          <span class="token punctuation">(</span><span class="token function">coroutine</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">k</span> <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:          <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">39</span>:     <span class="token number">40</span>:     <span class="token number">41</span>:     <span class="token comment" spellcheck="true">;;; example</span><span class="token number">42</span>:     <span class="token punctuation">(</span><span class="token function">coroutine</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">43</span>:              <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">44</span>:                <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">10</span><span class="token punctuation">)</span><span class="token number">45</span>:                <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">46</span>:                  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">47</span>:                  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">" "</span><span class="token punctuation">)</span> <span class="token number">48</span>:                  <span class="token punctuation">(</span>pause<span class="token punctuation">)</span> <span class="token number">49</span>:                  <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">50</span>:                <span class="token number">51</span>:     <span class="token punctuation">(</span><span class="token function">coroutine</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">52</span>:              <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">53</span>:                <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> i <span class="token number">10</span><span class="token punctuation">)</span><span class="token number">54</span>:                <span class="token punctuation">(</span><span class="token keyword">begin</span><span class="token number">55</span>:                  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token punctuation">(</span><span class="token function">integer->char</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">56</span>:                  <span class="token punctuation">(</span><span class="token function">display</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token number">57</span>:                  <span class="token punctuation">(</span>pause<span class="token punctuation">)</span> <span class="token number">58</span>:                  <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">59</span>:     <span class="token number">60</span>:     <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token number">61</span>:     <span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">load</span> <span class="token string">"cor2.scm"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Loading "cor2.scm"</span><span class="token number">1</span> a <span class="token number">2</span> b <span class="token number">3</span> c <span class="token number">4</span> d <span class="token number">5</span> e <span class="token number">6</span> f <span class="token number">7</span> g <span class="token number">8</span> h <span class="token number">9</span> i <span class="token number">10</span> j  -- done<span class="token comment" spellcheck="true">;Unspecified return value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>本章中，我讲解了继续。</p><p>理解这些概念可能比较困难。但不要担心，有朝一日你终会明白。</p><p>下一章中，我将介绍惰性求值。</p><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><h3 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h3><p>惰性求值（Lazy evaluation）是在需要时才进行求值的计算方式。惰性求值自然地在数据结构中包含递归，可以以简单的方式表示无限的概念，这种方式有利于程序的模块化。</p><p>你可以从<a href="http://deathking.github.io/yast-cn/contents/www.md.chalmers.se/~rjmh/Papers/whyfp.html">《Why Functional Programming Matters》</a>中知晓惰性计算可以带来哪些好处。</p><p><a href="http://deathking.github.io/yast-cn/contents/www.haskell.org">Haskell</a>语言以采用惰性求值而广为人熟知。Scheme也部分采用了惰性求值。</p><h3 id="用于惰性求值的函数"><a href="#用于惰性求值的函数" class="headerlink" title="用于惰性求值的函数"></a>用于惰性求值的函数</h3><p>下面这些用于处理惰性求值的函数是在R5RS中定义的。中间状态被称为延时对象（<code>promise</code>），它表示求值方法已经定义好了，但求值还未执行。最终的值通过对延时对象（<code>promise</code>）调用force被计算出来。</p><p><strong>(delay <code>proc</code>)</strong></p><p>以<code>proc</code>创建一个延时对象（<code>promise</code>）。</p><p><strong>(promise? <code>obj</code>)</strong></p><p>如果<code>obj</code>是一个延时对象就返回 #t。</p><p><strong>(force <code>promise</code>)</strong></p><p>对延时对象求值，执行求值操作。</p><h3 id="惰性求值的简单例子"><a href="#惰性求值的简单例子" class="headerlink" title="惰性求值的简单例子"></a>惰性求值的简单例子</h3><p>[例1]展示一个惰性求值的简单例子。在这个例子中，延时对象（<code>promise</code>）通过对(1 + 2)调用<code>delay</code>产生，然后通过函数<code>force</code>对延时对象求值。</p><p>[例1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> laz <span class="token punctuation">(</span><span class="token keyword">delay</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: laz</span>laz<span class="token comment" spellcheck="true">;Value 11: #[promise 11]</span><span class="token punctuation">(</span><span class="token function">promise?</span> laz<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: #t</span><span class="token punctuation">(</span><span class="token function">force</span> laz<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">10</span> <span class="token punctuation">(</span><span class="token function">force</span> laz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意延时对象并没有被<code>force</code>消费掉，这意味着函数<code>force</code>没有副作用。因此，你可以重复使用延时对象。</p><h3 id="使用惰性求值表示无限序列"><a href="#使用惰性求值表示无限序列" class="headerlink" title="使用惰性求值表示无限序列"></a>使用惰性求值表示无限序列</h3><p>现在，让我们使用惰性求值创建无限序列。首先，我将定义一些用于处理无限序列的基本函数。然后，我会使用这些函数创建无限序列，并将无限序列用于数值计算。</p><p>无限序列可以用如表达式（1）的cons单元（cons cell）的嵌套结构表示。cons单元的<code>car</code>和<code>cdr</code>分别是最终值和延时对象（promise）。另一个表达式（1）结构的cons单元通过强制求值<code>cdr</code>部分产生，你可以无限重复这个过程，就像图 1。这个和cons单元的嵌套结构和普通表类似，只是使用延时对象作为<code>cdr</code>部分使其可以表示无限序列。</p><pre><code>    (&lt;val&gt; . &lt;promise&gt;)    (1)</code></pre><p><img src="http://deathking.github.io/yast-cn/contents/figures/lazy_fig_1.png" alt="infiity sequence"></p><p>图 1. 无限序列的实现，使用了<code>car</code>和<code>cdr</code>分别为最终值和延时对象的cons单元。</p><h3 id="无限序列的基本函数和宏"><a href="#无限序列的基本函数和宏" class="headerlink" title="无限序列的基本函数和宏"></a>无限序列的基本函数和宏</h3><p>[代码 1]展示了无限序列的基本函数和宏。其中最重要的是<code>lazy-map</code>，被用于操作无限序列。</p><p>由于<code>lazy-map</code>包含一个特殊delay构造用于延迟求值，所以它需要被定义为宏。</p><p>[代码 1]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;;;; basic functions and a macro</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; car for lazy evaluation</span><span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> lazy-car car<span class="token punctuation">)</span><span class="token number">05</span>:     <span class="token number">06</span>:     <span class="token comment" spellcheck="true">;;; cdr for lazy evaluation</span><span class="token number">07</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token number">08</span>:       <span class="token punctuation">(</span><span class="token function">force</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">09</span>:     <span class="token number">10</span>:     <span class="token comment" spellcheck="true">;;; lazy cons</span><span class="token number">11</span>:     <span class="token punctuation">(</span><span class="token keyword">define-syntax</span> lazy-cons<span class="token number">12</span>:        <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">13</span>:           <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> a b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cons</span> a <span class="token punctuation">(</span><span class="token keyword">delay</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:     <span class="token number">15</span>:     <span class="token comment" spellcheck="true">;;; lazy map</span><span class="token number">16</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-map</span> fn . lss<span class="token punctuation">)</span><span class="token number">17</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">memq</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span> lss<span class="token punctuation">)</span><span class="token number">18</span>:           <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">19</span>:         <span class="token punctuation">(</span><span class="token function">lazy-cons</span> <span class="token punctuation">(</span><span class="token builtin">apply</span> fn <span class="token punctuation">(</span><span class="token function">map</span> lazy-car lss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">20</span>:                    <span class="token punctuation">(</span><span class="token builtin">apply</span> lazy-map fn <span class="token punctuation">(</span><span class="token function">map</span> lazy-cdr lss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">21</span>:     <span class="token number">22</span>:     <span class="token comment" spellcheck="true">;;; lazy filter</span><span class="token number">23</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-filter</span> pred ls<span class="token punctuation">)</span><span class="token number">24</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span><span class="token number">25</span>:           <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">26</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">obj</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">27</span>:           <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pred</span> obj<span class="token punctuation">)</span><span class="token number">28</span>:               <span class="token punctuation">(</span><span class="token function">lazy-cons</span> obj  <span class="token punctuation">(</span><span class="token function">lazy-filter</span> pred <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">29</span>:             <span class="token punctuation">(</span><span class="token function">lazy-filter</span> pred <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">30</span>:     <span class="token number">31</span>:     <span class="token comment" spellcheck="true">;;; returns n-th item of the lazy list</span><span class="token number">32</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-ref</span> ls n<span class="token punctuation">)</span><span class="token number">33</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">0</span><span class="token punctuation">)</span><span class="token number">34</span>:           <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token number">35</span>:         <span class="token punctuation">(</span><span class="token function">lazy-ref</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">36</span>:     <span class="token number">37</span>:     <span class="token comment" spellcheck="true">;;; returns first n items of the ls</span><span class="token number">38</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">head</span> ls n<span class="token punctuation">)</span><span class="token number">39</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">0</span><span class="token punctuation">)</span><span class="token number">40</span>:           <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">41</span>:          <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">head</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(lazy-car ls)</strong></p><p>和<code>(car ls)</code>一样，因为<code>car</code>部分是最终值。</p><p><strong>(lazy-cdr ls)</strong></p><p>计算<code>ls</code>的<code>cdr</code>部分（延时对象）的‘最终’值。</p><p><strong>(lazy-cons a b)</strong></p><p>这是一个扩展了<code>(cons a (delay b))</code>的宏。如果这个操作被定义为一个函数，<code>b</code>将立刻求值，这样delay就没有任何意义了。</p><p><strong>(lazy-map fn . lss)</strong></p><p>这是一个惰性求值的<code>map</code>函数，是在[代码 1]中最重要的函数。注意它返回一个包含最终值（<code>car</code>部分）和延时对象（<code>cdr</code>部分）的cons单元。</p><p><strong>(lazy-filter pred ls)</strong></p><p>这是一个惰性求值的<code>filter</code>函数。它过滤<code>ls</code>并返回一个由包含满足<code>pred</code>条件的元素组成的‘无限序列’。</p><p><strong>(lazy-ref ls n)</strong></p><p>返回‘无限序列’<code>ls</code>的第n个元素。</p><p><strong>(head ls n)</strong></p><p>返回<code>ls</code>（惰性求值表）的前n个元素。</p><h3 id="无限序列"><a href="#无限序列" class="headerlink" title="无限序列"></a>无限序列</h3><p>无限序列可以简洁地用<code>lazy-cons</code>和<code>lazy-map</code>表示。我会展示两个例子：</p><ul><li>下一项由前一项定义的序列，如等差数列和等比数列。</li><li>菲波那契数列。</li></ul><h4 id="下一个项由前一项定义的序列"><a href="#下一个项由前一项定义的序列" class="headerlink" title="下一个项由前一项定义的序列"></a>下一个项由前一项定义的序列</h4><p>下一个项由前一项定义的序列可以有如下形式的函数（f）定义：</p><p>[{a}_{i+1} = f({a}_i) ]</p><p>可以表示为[代码2]里的<code>(inf-seq a0 f)</code>，<code>a0</code>和<code>f</code>分别是初始项和用于计算随后项的函数。</p><p><code>(inf-seq a0 f)</code>是递归定义的，它的定义清晰表明初始项是a0，第二项是<code>(f a0)</code>，<code>(n+1)</code>项由<code>(f an)</code>表示。</p><p>等差和等比数列分别被定义为<code>(ari a0 d)</code>和<code>(geo a0 r)</code>，其中<code>a0</code>，<code>d</code>和<code>r</code>分别是初始值，公差，公比。这些函数使用函数<code>inf-seq</code>定义。</p><p>[代码2]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;;;  sequences</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; infinite sequences represented by a_(n+1) = f(a_n)</span><span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">inf-seq</span> a0 f<span class="token punctuation">)</span><span class="token number">05</span>:       <span class="token punctuation">(</span><span class="token function">lazy-cons</span> a0 <span class="token punctuation">(</span><span class="token function">inf-seq</span> <span class="token punctuation">(</span><span class="token function">f</span> a0<span class="token punctuation">)</span> f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">06</span>:     <span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; arithmetic sequence</span><span class="token number">08</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">ari</span> a0 d<span class="token punctuation">)</span><span class="token number">09</span>:       <span class="token punctuation">(</span><span class="token function">inf-seq</span> a0 <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span> x d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:     <span class="token number">11</span>:     <span class="token comment" spellcheck="true">;;; geometric sequence</span><span class="token number">12</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">geo</span> a0 r<span class="token punctuation">)</span><span class="token number">13</span>:       <span class="token punctuation">(</span><span class="token function">inf-seq</span> a0 <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> x r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们检查一下<code>inf-seq</code>所产生的无限序列（例2）。创建两个等比数列：</p><ol><li><code>g1</code>，初始值1，公比为2。</li><li><code>g2</code>，初始值1，公比为1/2。</li></ol><p>然后使用<code>head</code>求值前10项。你将看到正确产生了两个等比数列。</p><p>接下来，使用<code>lazy-map</code>计算<code>g1</code>和<code>g2</code>的乘积，并使用<code>head</code>求值前10项。你将看到一个全是1的序列，这表明计算被正确地执行了。</p><p>现在，让我们用等差数列和<code>lazy-filter</code>娱乐一番。首先，用<code>(ari 1 1)</code>创建一个等比数列<code>ar1</code>。<code>(head ar1 10)</code>的结果显示等比数列 <code>(1 2 3 ....)</code> 是由 <code>(ari 1 1)</code> 产生的。然后使用<code>lazy-filter</code>取出<code>ar1</code>里的偶数，并使用<code>head</code>求值前10项。你将看到<code>(2 4 6 8 10 12 14 16 18 20)</code>，这表明<code>lazy-filter</code>正常工作。</p><p>[例2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> g1 <span class="token punctuation">(</span><span class="token function">geo</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: g1</span><span class="token punctuation">(</span><span class="token keyword">define</span> g2 <span class="token punctuation">(</span><span class="token function">geo</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: g2</span><span class="token punctuation">(</span><span class="token function">head</span> g1 <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 12: (1 2 4 8 16 32 64 128 256 512)</span><span class="token punctuation">(</span><span class="token function">head</span> g2 <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 13: (1 1/2 1/4 1/8 1/16 1/32 1/64 1/128 1/256 1/512)</span><span class="token punctuation">(</span><span class="token function">head</span> <span class="token punctuation">(</span><span class="token function">lazy-map</span> * g1 g2<span class="token punctuation">)</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 14: (1 1 1 1 1 1 1 1 1 1)</span><span class="token punctuation">(</span><span class="token keyword">define</span> ar1 <span class="token punctuation">(</span><span class="token function">ari</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;Value: ar1</span><span class="token punctuation">(</span><span class="token function">head</span> ar1 <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;Value 15: (1 2 3 4 5 6 7 8 9 10)</span><span class="token punctuation">(</span><span class="token function">head</span> <span class="token punctuation">(</span><span class="token function">lazy-filter</span> even? ar1<span class="token punctuation">)</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;Value 16: (2 4 6 8 10 12 14 16 18 20)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="菲波那切数列"><a href="#菲波那切数列" class="headerlink" title="菲波那切数列"></a>菲波那切数列</h4><p>菲波那切数列定义如下：</p><pre><code>fib(1) = 1fib(2) = 1fib(n+1) = fib(n) + fib(n-1)</code></pre><p>代码3展示了Scheme实现的菲波那切数列，用到了<code>lazy-cons</code>和<code>lazy-map</code>。如代码所示，Scheme里的定义和数学上的定义很相似。此外，各个项的计算的复杂度为<em>O(n)</em>。</p><p>[例3]中，值被立刻计算出来了。</p><p>[代码 3]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token punctuation">(</span><span class="token keyword">define</span> fib<span class="token number">02</span>:       <span class="token punctuation">(</span><span class="token function">lazy-cons</span> <span class="token number">1</span><span class="token number">03</span>:                  <span class="token punctuation">(</span><span class="token function">lazy-cons</span> <span class="token number">1</span><span class="token number">04</span>:                             <span class="token punctuation">(</span><span class="token function">lazy-map</span> + fib <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> fib<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>[例 3]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">head</span> fib <span class="token number">20</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 12: (1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)</span><span class="token punctuation">(</span><span class="token function">lazy-ref</span> fib <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 573147844013817084101</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将惰性求值用于数值计算"><a href="#将惰性求值用于数值计算" class="headerlink" title="将惰性求值用于数值计算"></a>将惰性求值用于数值计算</h3><p>下面是<a href="http://deathking.github.io/yast-cn/contents/www.md.chalmers.se/~rjmh/Papers/whyfp.html">《Why Functional Programming Matters》</a>里相关代码的Schme版本。也可以查看<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5">SICP 3.5. Stream</a>惰性计算在数值计算中的应用。</p><h4 id="牛顿-拉夫逊法求平方根"><a href="#牛顿-拉夫逊法求平方根" class="headerlink" title="牛顿-拉夫逊法求平方根"></a>牛顿-拉夫逊法求平方根</h4><p>牛顿-拉夫逊法可以使用初始值a0和等式（2）计算N的平方根。</p><pre><code>     a(n+1) =  (a(n) + N/a(n)) / 2                   (2)</code></pre><p>如果等式（2）收敛到最终值 a，</p><pre><code>      a =  (a +  N/a) / 2⇒      2a = a +  N/a      a =  N/a      a*a = N      a =  √N</code></pre><p>，这表明最终值a是N的平方根。序列的下一项是前一项的函数（如等式（2）所示），这些序列可用<code>inf-seq</code>表示。</p><p>代码4展示了一个计算平方根的程序。在代码4中，初始值被定为1，由于序列收敛很快，所以这没问题。</p><p>[代码4]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; Newton-Raphson method</span><span class="token number">02</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">newton-raphson</span> n<span class="token punctuation">)</span><span class="token number">03</span>:       <span class="token punctuation">(</span><span class="token function">inf-seq</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> x <span class="token punctuation">(</span><span class="token operator">/</span> n x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">04</span>:     <span class="token number">05</span>:     <span class="token comment" spellcheck="true">;;; returning a reasonable answer.</span><span class="token number">06</span>:     <span class="token comment" spellcheck="true">;;; If the ratio of successive terms is in (1 - eps) and (1 + eps),</span><span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; or the following term is zero,</span><span class="token number">08</span>:     <span class="token comment" spellcheck="true">;;; the function returns it.</span><span class="token number">09</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazylist->answer</span> ls eps<span class="token punctuation">)</span><span class="token number">10</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">e1</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token number">1.0</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">11</span>:             <span class="token punctuation">(</span><span class="token function">e2</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1.0</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">12</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">val</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:                    <span class="token punctuation">(</span><span class="token function">ls1</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">val2</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">15</span>:             <span class="token punctuation">(</span><span class="token keyword">if</span>  <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token function">zero?</span> val2<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> e1 <span class="token punctuation">(</span><span class="token operator">/</span> val val2<span class="token punctuation">)</span> e2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">16</span>:                 <span class="token punctuation">(</span><span class="token function">exact->inexact</span> val2<span class="token punctuation">)</span><span class="token number">17</span>:               <span class="token punctuation">(</span><span class="token function">loop</span> val2 <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:     <span class="token number">19</span>:     <span class="token comment" spellcheck="true">;;;</span><span class="token number">20</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">my-sqrt</span> n eps<span class="token punctuation">)</span><span class="token number">21</span>:       <span class="token punctuation">(</span><span class="token function">lazylist->answer</span> <span class="token punctuation">(</span><span class="token function">newton-raphson</span> n<span class="token punctuation">)</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(newton-raphson n)</strong></p><p>一个函数，创建平方根近似值的表。</p><p><strong>(lazylist-&gt;answer ls eps)</strong></p><p>检查收敛是否满足条件了。如果是的，返回数值计算的结果。</p><p>如果<code>(1 - eps) &lt; t2/t1 &lt; (1 + eps)</code> 或者 <code>t2 = 0</code>，函数返回 <code>ls</code> 的后续项（即 <code>t1</code> 和 <code>t2</code>）的第二项。</p><p><strong>(my-sqrt n eps)</strong></p><p>在相对误差eps下，计算n的平方根。</p><pre><code>(my-sqrt 9 0.0000001);Value: 3.</code></pre><h4 id="数值微分"><a href="#数值微分" class="headerlink" title="数值微分"></a>数值微分</h4><p>[代码5]中的<code>easydiff</code>是一种计算数字积分的简单方式，其中<code>f</code>，<code>x</code>，和<code>h</code>分别是被积分的函数，x值，和Δx。理论上，如果<code>h</code>越趋于0，获得的近似值越好。但在实践中，由于数值在计算机里的精度是有限的，微小的<code>h</code>值会导致错误。</p><p>为了解决这个问题，我们用<code>lazylist-diff</code>创建<code>h</code>的惰性表。这个惰性表是初始值为<code>h0</code>，公比为0.5的等比数列。然后我们创建一个对应于<code>h</code>的惰性表的近似值的惰性表。</p><p>可以通过如下代码加快收敛速度，更快得到答案：</p><pre><code>(lazylist-&gt;answer (lazylist-diff h0 f x) eps)</code></pre><p>函数<code>super</code>是收敛加速函数。可以查看<a href="http://deathking.github.io/yast-cn/contents/www.md.chalmers.se/~rjmh/Papers/whyfp.html">《Why Functional Programming Matters》</a>的关于加速技术部分。如果你使用了传统编程语言，加速计算会相当复杂。相反，使用惰性求值可以以简单的方式实现。此外，因为高度的模块化，你可以在其他问题中复用代码，例如数值积分（4.3.3节）。代码6复用了代码5中的加速函数。</p><p>[代码5]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; differentiation</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; primitive function for differentiation</span><span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">easydiff</span> f x h<span class="token punctuation">)</span><span class="token number">05</span>:       <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token function">f</span> <span class="token punctuation">(</span><span class="token operator">+</span> x h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">f</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">06</span>:     <span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; create a lazy list of approximation for differentiation</span><span class="token number">08</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazylist-diff</span> h0 f x<span class="token punctuation">)</span><span class="token number">09</span>:       <span class="token punctuation">(</span><span class="token function">lazy-map</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">easydiff</span> f x h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">geo</span> h0 <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:     <span class="token number">11</span>:     <span class="token comment" spellcheck="true">;;; eliminate error from the approximation</span><span class="token number">12</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">elimerror</span> n ls<span class="token punctuation">)</span><span class="token number">13</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">a</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:             <span class="token punctuation">(</span><span class="token function">b</span> <span class="token punctuation">(</span><span class="token function">lazy-second</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">15</span>:             <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">fix:lsh</span> <span class="token number">1</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">; (expt 2 n)</span><span class="token number">16</span>:         <span class="token punctuation">(</span><span class="token function">lazy-cons</span><span class="token number">17</span>:          <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">*</span> b c<span class="token punctuation">)</span> a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> c <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:          <span class="token punctuation">(</span><span class="token function">elimerror</span> n <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">19</span>:     <span class="token number">20</span>:     <span class="token comment" spellcheck="true">;;; estimate `n' in elimerror</span><span class="token number">21</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">order</span> ls<span class="token punctuation">)</span><span class="token number">22</span>:       <span class="token punctuation">(</span><span class="token keyword">let*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">a</span> <span class="token punctuation">(</span><span class="token function">lazy-car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">23</span>:              <span class="token punctuation">(</span><span class="token function">b</span> <span class="token punctuation">(</span><span class="token function">lazy-second</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">24</span>:              <span class="token punctuation">(</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">lazy-ref</span> ls <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">25</span>:              <span class="token punctuation">(</span><span class="token function">d</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">-</span> a c<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> b c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">26</span>:         <span class="token punctuation">(</span><span class="token keyword">cond</span><span class="token number">27</span>:          <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> d <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token number">28</span>:          <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;=</span> <span class="token number">2</span> d <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">inexact->exact</span> <span class="token punctuation">(</span><span class="token function">round</span> <span class="token punctuation">(</span><span class="token function">log2</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">29</span>:          <span class="token punctuation">(</span><span class="token keyword">else</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">30</span>:     <span class="token number">31</span>:     <span class="token comment" spellcheck="true">;;;</span><span class="token number">32</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">log2</span> x<span class="token punctuation">)</span><span class="token number">33</span>:       <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token function">log</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">log</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">34</span>:     <span class="token number">35</span>:     <span class="token comment" spellcheck="true">;;; improve convergence of the lazy list of the approximation</span><span class="token number">36</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">improve</span> ls<span class="token punctuation">)</span><span class="token number">37</span>:       <span class="token punctuation">(</span><span class="token function">elimerror</span> <span class="token punctuation">(</span><span class="token function">order</span> ls<span class="token punctuation">)</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:     <span class="token number">39</span>:     <span class="token comment" spellcheck="true">;;; return the second value of the lazy list</span><span class="token number">40</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazy-second</span> ls<span class="token punctuation">)</span><span class="token number">41</span>:       <span class="token punctuation">(</span><span class="token function">lazy-car</span> <span class="token punctuation">(</span><span class="token function">lazy-cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">42</span>:     <span class="token number">43</span>:     <span class="token comment" spellcheck="true">;;; further improve the convergence of the list</span><span class="token number">44</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">super</span> ls<span class="token punctuation">)</span><span class="token number">45</span>:       <span class="token punctuation">(</span><span class="token function">lazy-map</span> lazy-second <span class="token punctuation">(</span><span class="token function">inf-seq</span> ls improve<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">46</span>:                 <span class="token number">47</span>:     <span class="token number">48</span>:     <span class="token comment" spellcheck="true">;;; calculate the differentiation of function `f' at x within error eps</span><span class="token number">49</span>:     <span class="token comment" spellcheck="true">;;; h0 is initial window width</span><span class="token number">50</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">diff</span> f x h0 eps<span class="token punctuation">)</span><span class="token number">51</span>:       <span class="token punctuation">(</span><span class="token function">lazylist->answer</span> <span class="token punctuation">(</span><span class="token function">super</span> <span class="token punctuation">(</span><span class="token function">lazylist-diff</span> h0 f x<span class="token punctuation">)</span><span class="token punctuation">)</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">diff</span> sin <span class="token number">0.0</span> <span class="token number">0.1</span> <span class="token number">0.0000001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: .9999999999999516</span><span class="token punctuation">(</span><span class="token function">diff</span> exp <span class="token number">0.0</span> <span class="token number">0.1</span> <span class="token number">0.000001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: .9999999991733471</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h4><p>收敛加速函数无需任何修改即可被用于数值积分。最开始，我们使用<code>easyintegrate</code>创建一个粗略的近似。函数<code>lazylist-integrate</code>使用惰性表，通过递归地调用<code>easyintegrate</code>在中间点切分区间，来改进近似值。函数可以用lazy-map以简单的方式定义。最终，收敛被加速，收敛值由函数<code>integrate</code>返回。</p><p>[代码6]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; integration</span><span class="token number">02</span>:     <span class="token number">03</span>:     <span class="token comment" spellcheck="true">;;; primitive integration</span><span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">easyintegrate</span> f a b<span class="token punctuation">)</span><span class="token number">05</span>:       <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">f</span> a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">f</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span> b a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">06</span>:     <span class="token number">07</span>:     <span class="token comment" spellcheck="true">;;; create the lazy list of approximation for integration</span><span class="token number">08</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">lazylist-integrate</span> f a b<span class="token punctuation">)</span><span class="token number">09</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">mid</span> <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> a b<span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:         <span class="token punctuation">(</span><span class="token function">lazy-cons</span> <span class="token punctuation">(</span><span class="token function">easyintegrate</span> f a b<span class="token punctuation">)</span><span class="token number">11</span>:                    <span class="token punctuation">(</span><span class="token function">lazy-map</span> + <span class="token punctuation">(</span><span class="token function">lazylist-integrate</span> f a mid<span class="token punctuation">)</span><span class="token number">12</span>:                                <span class="token punctuation">(</span><span class="token function">lazylist-integrate</span> f mid b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:     <span class="token number">14</span>:     <span class="token comment" spellcheck="true">;;; integrate function `f' in a range of `a' and `b' within error `eps'</span><span class="token number">15</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">integrate</span> f a b eps<span class="token punctuation">)</span><span class="token number">16</span>:       <span class="token punctuation">(</span><span class="token function">lazylist->answer</span> <span class="token punctuation">(</span><span class="token function">super</span> <span class="token punctuation">(</span><span class="token function">lazylist-integrate</span> f a b<span class="token punctuation">)</span><span class="token punctuation">)</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> pi <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token function">atan</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: pi</span><span class="token punctuation">(</span><span class="token function">integrate</span> sin <span class="token number">0</span> pi <span class="token number">0.0000001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 2.000000002272428</span><span class="token punctuation">(</span><span class="token function">integrate</span> exp <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0.0000001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1.7182818277724858</span><span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token function">exp</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1.718281828459045</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>惰性求值允许我们以简洁的方式将重复包含在数据结构中。这个功能有利于程序的模块化，可使代码更为紧凑。</p><p>查看网页<a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>可以了解更多关于惰性求值的内容。</p><p>你可以在<a href="http://www.shido.info/lisp/scheme_lazy.zip">这儿</a>下载本页中出现代码。</p><h2 id="非确定性"><a href="#非确定性" class="headerlink" title="非确定性"></a>非确定性</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>非确定性是一种通过仅定义问题来解决问题的算法。非确定性程序自动选择符合条件的选项。这项技术很适合逻辑编程。</p><p>例如，以下代码返回一对数，其和是一个质数。其中一个数从<code>&#39;(4 6 7)</code>选取，另一个从<code>&#39;(5 8 11)</code>选取。</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token punctuation">(</span><span class="token function">amb</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">j</span> <span class="token punctuation">(</span><span class="token function">amb</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">prime?</span> <span class="token punctuation">(</span><span class="token operator">+</span> i j<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token builtin">list</span> i j<span class="token punctuation">)</span>      <span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 23: (6 5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>(amb 4 6 7)</code> 从4，6和7中返回一个合适的数，<code>(amb 5 8 11)</code>从5，8和11中返回一个合适的数。如果没有选出合适的值，(amb)返回假。</p><p>实际上，amb做了深度优先搜索。<code>(amb c1 c2 c3 ...)</code>创建了搜索路径依次检查<code>c1</code>，<code>c2</code>，<code>c3</code>，…并回溯。因此，非确定性是一种帮程序隐藏搜索的抽象。一旦我们有了amb，我们可以很容易地编写程序而无需思考计算机做了什么。</p><h3 id="非确定性的实现"><a href="#非确定性的实现" class="headerlink" title="非确定性的实现"></a>非确定性的实现</h3><p>使用在非确定性中的回溯被实现为连接到继续（continuation）的闭包链。这个链被一个全局参数<code>fail</code>表示，该参数是一个复写自己的函数。</p><h4 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h4><p>第一步，我使用函数（名为<code>choose</code>）实现非确定性，演示于[代码1]。我首先定义一个全局参数<code>fail</code>，它的初始值是一个将返回<code>no-choice</code>到顶层的函数（22-26行）。然后通过在函数choose中重新定义<code>fail</code>实现闭包链。回溯通过调用之前的<code>fail</code>实现。</p><p>函数<code>choose</code>有如下行为：</p><ol><li>如果没有选项，调用(fail)。</li><li>如果有任何选项，<ol><li>将fail储存为fail0，并调用当前继续（continuation）。</li><li>在继续（continuation）中重新定义fail。fail重新被赋值回存在fail0里的原值，并对余下的选项应用（apply）choose。</li><li>返回第一个选项到继续（continuation）外面。</li></ol></li></ol><p>[代码1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; abbreviation for call-with-current-continuation</span><span class="token punctuation">(</span><span class="token keyword">define</span> call/cc call-with-current-continuation<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; This function is re-assigned in `choose` and `fail` itself.</span><span class="token punctuation">(</span><span class="token keyword">define</span> fail <span class="token boolean">#f</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; function for nondeterminism</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">choose</span> . ls<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span>     <span class="token punctuation">(</span>fail<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">fail0</span> fail<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token builtin">call/cc</span>        <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>cc<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token keyword">set!</span> fail <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>                       <span class="token punctuation">(</span><span class="token keyword">set!</span> fail fail0<span class="token punctuation">)</span>                       <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token punctuation">(</span><span class="token builtin">apply</span> choose <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;;; write following at the end of file</span><span class="token comment" spellcheck="true">;;; initial value for fail</span><span class="token punctuation">(</span><span class="token builtin">call/cc</span>   <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>cc<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">set!</span> fail <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token string">'no-choice)))))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们看看<code>choose</code>是否可以找到毕达哥拉斯三元组。函数<code>pythag</code>用于寻找三元组。如果找到了，它返回一个表。如果没有找到，调用无参数的<code>choose</code>，以回溯。</p><p>[例1]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sq</span> x<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token operator">*</span> x x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: sq</span><span class="token comment" spellcheck="true">;;; Pythagorean triples</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">pythag</span> a b c<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">sq</span> a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">sq</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">sq</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token builtin">list</span> a b c<span class="token punctuation">)</span>      <span class="token punctuation">(</span>choose<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: pythag</span><span class="token punctuation">(</span><span class="token function">pythag</span> <span class="token punctuation">(</span><span class="token function">choose</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">choose</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">choose</span>  <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 16: (3 4 5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="宏实现"><a href="#宏实现" class="headerlink" title="宏实现"></a>宏实现</h4><p>为了对S-表达式使用非确定性操作，必须把操作定义为宏。例如，[例2]中所示函数<code>an-integer-starting-from</code>应该返回一个大于或等于<code>n</code>的整数，但是如果<code>choose</code>被以函数形式定义，它将不能正常工作，因为参数会立即求值。</p><p>[例2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">choose</span> n <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token punctuation">(</span><span class="token function">1+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: an-integer-starting-from</span><span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Aborting!: maximum recursion depth exceeded</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了解决这一点，我们定义了一个和[代码1]中定义一致但使用非确定性宏<code>amb</code>实现的<code>choose</code>。这个宏<code>amb</code>有和<code>choose</code>一样的递归调用自己的结构。</p><p>[代码1]中的1-5行和20-26行在下面的代码中得以重用。</p><p>[代码2]使用MIT-Scheme编译时，编译器给出如下警告：</p><pre><code>;Warning: Possible inapplicable operator ()</code></pre><p>但是代码可以正常工作。这些代码在<a href="http://www.scheme.com/petitechezscheme.html">Petite Chez Scheme</a>下也可以运行。即使我没有试过其他Scheme实现，我认为<code>amb</code>的定义可以工作，只要它们遵守R5RS。你可以在<a href="http://www.shido.info/lisp/scheme_amb.zip">这里</a>下载一个为MIT-Scheme做的专门实现。MIT-Scheme编译器不会对这个专门实现提出警告。</p><p>[代码2]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token comment" spellcheck="true">;;; nondeterminism macro operator</span><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> amb  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token punctuation">(</span>fail<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> a<span class="token punctuation">)</span> a<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> a b ...<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">fail0</span> fail<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token builtin">call/cc</span>    <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>cc<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token keyword">set!</span> fail        <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token keyword">set!</span> fail fail0<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">cc</span> <span class="token punctuation">(</span><span class="token function">amb</span> b ...<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">cc</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>宏定义，<code>amb</code>，在参数为S-表达式时也和其他值一样正常工作。</p><p>[例3]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token function">amb</span> n <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token punctuation">(</span><span class="token function">1+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: an-integer-starting-from</span><span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 1</span><span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 2</span><span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<a href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-16.html#node_sec_14.2">Teach Yourself Scheme in Fixnum Days</a> 和<a href="http://www.ccs.neu.edu/home/dherman/code/amb.ss">Dave Hername Code</a>中的amb实现使用<code>&#39;,@(map ...)&#39;</code>展开参数。即使它们是直截了当的定义，但由于使用了两次<code>call/cc</code>，它们某种程度上仍很复杂。[代码2]所示的递归定义更简单，即使展开的S-表达式会很复杂。</p><h4 id="应用于逻辑编程，使程序更简洁"><a href="#应用于逻辑编程，使程序更简洁" class="headerlink" title="应用于逻辑编程，使程序更简洁"></a>应用于逻辑编程，使程序更简洁</h4><p>[代码3]演示了非确定性应用逻辑编程，使得程序更简洁</p><p>[代码3]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token comment" spellcheck="true">;;; returning all possibilities</span><span class="token number">02</span>:     <span class="token punctuation">(</span><span class="token keyword">define-syntax</span> set-of<span class="token number">03</span>:       <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">04</span>:         <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> s<span class="token punctuation">)</span> <span class="token number">05</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">acc</span> <span class="token string">'</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">06</span>:             <span class="token punctuation">(</span><span class="token function">amb</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">v</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">07</span>:                    <span class="token punctuation">(</span><span class="token keyword">set!</span> acc <span class="token punctuation">(</span><span class="token builtin">cons</span> v acc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">08</span>:                    <span class="token punctuation">(</span>fail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">09</span>:                  <span class="token punctuation">(</span><span class="token function">reverse!</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">10</span>:     <span class="token number">11</span>:     <span class="token comment" spellcheck="true">;;; if not pred backtrack</span><span class="token number">12</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">assert</span> pred<span class="token punctuation">)</span><span class="token number">13</span>:       <span class="token punctuation">(</span><span class="token function">or</span> pred <span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:     <span class="token number">15</span>:     <span class="token comment" spellcheck="true">;;; returns arbitrary number larger or equal to n</span><span class="token number">16</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> n<span class="token punctuation">)</span><span class="token number">17</span>:       <span class="token punctuation">(</span><span class="token function">amb</span> n <span class="token punctuation">(</span><span class="token function">an-integer-starting-from</span> <span class="token punctuation">(</span><span class="token function">1+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:     <span class="token number">19</span>:     <span class="token comment" spellcheck="true">;;; returns arbitrary number between a and b</span><span class="token number">20</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">number-between</span> a b<span class="token punctuation">)</span><span class="token number">21</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">22</span>:         <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">></span> i b<span class="token punctuation">)</span><span class="token number">23</span>:             <span class="token punctuation">(</span>amb<span class="token punctuation">)</span><span class="token number">24</span>:           <span class="token punctuation">(</span><span class="token function">amb</span> i <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token function">1+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(set-of <code>s</code>)</strong></p><p>返回满足<code>s</code>的所有可能性。宏的行为如下：</p><ol><li>（第5行）一个表（acc）被定义，它有所欲哦满足<code>s</code>的结果。</li><li>（第6行）<code>s</code>的结果被赋给<code>v</code>，并加入到<code>acc</code>。如果结果没有带上<code>v</code>而直接被加入（如 (set! acc (cons s acc))），则会因为<code>s</code>使用了继续（continuation）而只在acc中存储了最后一个值。<code>s</code>改了了fail的值。</li><li>（第7，8行）在这之后，调用fail回溯。因为使用了继续（continuation），函数fail行为就像在第6行被调用。</li><li>（第9行）当所有可能的选项被找到时，调用<code>(reverse! acc)</code>并返回所有的可能选项。</li></ol><p>定义假设amb从最左边参数开始搜索。</p><p><strong>(assert <code>pred</code>)</strong></p><p>如果谓词为假,就回溯。</p><p><strong>(an-integer-starting-from <code>n</code>)</strong></p><p>非确定性地返回从<code>n</code>开始的整数。</p><p><strong>(number-between <code>a</code> <code>b</code>)</strong></p><p>非确定性地返回<code>a</code>和<code>b</code>之间的整数</p><p>[例4]演示了如何使用<code>set-of</code>。得到了所有小于20的质数。</p><p>[例4]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">prime?</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">m</span> <span class="token punctuation">(</span><span class="token function">sqrt</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> m i<span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">and</span> <span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token function">zero?</span> <span class="token punctuation">(</span><span class="token function">modulo</span> n i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token operator">+</span> i <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> i <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">gen-prime</span> n<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">i</span> <span class="token punctuation">(</span><span class="token function">number-between</span>  <span class="token number">2</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">prime?</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>    i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">set-of</span> <span class="token punctuation">(</span><span class="token function">gen-prime</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value 12: (2 3 5 7 11 13 17 19)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逻辑编程的例子"><a href="#逻辑编程的例子" class="headerlink" title="逻辑编程的例子"></a>逻辑编程的例子</h3><p>让我们来解决<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3.2">SICP中的习题4.42</a>作为例子。问题如下：</p><p>五位女同学参加一场考试。她们的家长对考试结果过分关心。为此她们约定，在给家里写信谈到考试时，每个姑娘都要写一句真话和一句假话。下面是从她们的信中摘出的句子：</p><p>贝蒂：“凯迪考第二，我只考了第三。” 艾赛尔：“你们应该高兴地听到我考了第一，琼第二。” 琼：“我考第三，可怜的艾赛尔考得最差。” 凯蒂：“我第二，玛丽只考了第四。” 玛丽：“我是第四，贝蒂的成绩最高。”</p><p>这五位姑娘的实际排名是什么？</p><p>[代码4]给出了这个问题的解法。</p><p>[代码4]</p><pre class="line-numbers language-scheme"><code class="language-scheme">01:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">xor</span> a b<span class="token punctuation">)</span><span class="token number">02</span>:       <span class="token punctuation">(</span><span class="token keyword">if</span> a <span class="token punctuation">(</span><span class="token function">not</span> b<span class="token punctuation">)</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">03</span>:     <span class="token number">04</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">all-different?</span> . ls<span class="token punctuation">)</span><span class="token number">05</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> loop <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">obj</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">ls</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">06</span>:         <span class="token punctuation">(</span><span class="token function">or</span> <span class="token punctuation">(</span><span class="token builtin">null?</span> ls<span class="token punctuation">)</span><span class="token number">07</span>:             <span class="token punctuation">(</span><span class="token function">and</span> <span class="token punctuation">(</span><span class="token function">not</span> <span class="token punctuation">(</span><span class="token function">memv</span> obj ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">08</span>:                  <span class="token punctuation">(</span><span class="token function">loop</span> <span class="token punctuation">(</span><span class="token builtin">car</span> ls<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">cdr</span> ls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">09</span>:     <span class="token number">10</span>:     <span class="token comment" spellcheck="true">;;; SICP Exercise 4.42</span><span class="token number">11</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>girls-exam<span class="token punctuation">)</span><span class="token number">12</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">kitty</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">13</span>:             <span class="token punctuation">(</span><span class="token function">betty</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">14</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> kitty <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> betty <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">15</span>:         <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">mary</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">16</span>:           <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> kitty <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> mary <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">17</span>:           <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> mary <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> betty <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">18</span>:           <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">ethel</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">19</span>:                 <span class="token punctuation">(</span><span class="token function">joan</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">20</span>:             <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> ethel <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> joan <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">21</span>:             <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> joan <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> ethel <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">22</span>:             <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">all-different?</span> kitty betty ethel joan mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">23</span>:             <span class="token punctuation">(</span><span class="token function">map</span> list <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">kitty</span> betty ethel joan mary<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> kitty betty ethel joan mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">24</span>:     <span class="token number">25</span>:     <span class="token comment" spellcheck="true">;;; Bad answer for ex 4.42</span><span class="token number">26</span>:     <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>girls-exam-x<span class="token punctuation">)</span><span class="token number">27</span>:       <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">kitty</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">28</span>:             <span class="token punctuation">(</span><span class="token function">betty</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">29</span>:             <span class="token punctuation">(</span><span class="token function">mary</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">30</span>:             <span class="token punctuation">(</span><span class="token function">ethel</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">31</span>:             <span class="token punctuation">(</span><span class="token function">joan</span> <span class="token punctuation">(</span><span class="token function">number-between</span> <span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">32</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> kitty <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> betty <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">33</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> kitty <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> mary <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">34</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> mary <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> betty <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">35</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> ethel <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> joan <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">36</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">xor</span> <span class="token punctuation">(</span><span class="token operator">=</span> joan <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">=</span> ethel <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">37</span>:         <span class="token punctuation">(</span><span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">all-different?</span> kitty betty ethel joan mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">38</span>:         <span class="token punctuation">(</span><span class="token function">map</span> list <span class="token string">'</span><span class="token punctuation">(</span><span class="token function">kitty</span> betty ethel joan mary<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">list</span> kitty betty ethel joan mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(xor a b)</strong>以下条件满足，返回#t:</p><ul><li>a是#t，b是#f，或者</li><li>a是#f，b是#t。</li></ul><p><strong>(all-different? , ls)</strong></p><p>当<code>ls</code>的所有元素都不相同时，返回#t。</p><p><strong>(girls-exam)</strong></p><p>是解决谜题的主要函数。它返回名字和排名的表。每次参数赋值后都调用了<code>assert</code>是为了有效地减少死分支的运行时间。<code>(girls-exam-x)</code>则是一个坏例子。它在为所有参数赋值之后调用<code>assert</code>。这种情况下，无谓地搜索了大量的死分支。[例5]显示<code>(girl-exam-x)</code>的运行时间是<code>(girl-exam)</code>的10倍。</p><p>[例5]</p><pre class="line-numbers language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define-syntax</span> cpu-time/sec  <span class="token punctuation">(</span><span class="token keyword">syntax-rules</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">_</span> s<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">with-timings</span>     <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> s<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token function">run-time</span> gc-time real-time<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token function">internal-time/ticks->seconds</span> run-time<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write-char</span> #\space<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token function">internal-time/ticks->seconds</span> gc-time<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write-char</span> #\space<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token function">write</span> <span class="token punctuation">(</span><span class="token function">internal-time/ticks->seconds</span> real-time<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">(</span>newline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;Value: cpu-time/sec</span><span class="token punctuation">(</span><span class="token function">cpu-time/sec</span> <span class="token punctuation">(</span>girls-exam<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">.03</span> <span class="token number">0</span>. <span class="token number">.03</span><span class="token comment" spellcheck="true">;Value 14: ((kitty 1) (betty 3) (ethel 5) (joan 2) (mary 4))</span><span class="token punctuation">(</span><span class="token function">cpu-time/sec</span> <span class="token punctuation">(</span>girls-exam-x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">.341</span> <span class="token number">.29</span> <span class="token number">.631</span><span class="token comment" spellcheck="true">;Value 15: ((kitty 1) (betty 3) (ethel 5) (joan 2) (mary 4))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>当你使用了非确定性和用于逻辑编程分析技术时，你就可以写出看起来具有先见之明的程序。注意如果搜索路径里有循环我们就不能使用本章的代码。关于这一点，查看<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3">SICP 4.3</a>以获取更多信息。</p><p>写这一章时，我参考了<a href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-16.html">Teach Yourself Scheme in Fixnum Days</a>。</p><p>你可以在<a href="http://www.shido.info/lisp/scheme_amb.zip">这儿</a>下载本章代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;虽然目前因为scheme过时，最新的SICP已经采用python作为系列语言，但是通过前两章的学习，可以说，Scheme（lisp方言）是一
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Scheme" scheme="https://JoyTsing.github.io/tags/Scheme/"/>
    
  </entry>
  
  <entry>
    <title>计算机病毒原理与防范</title>
    <link href="https://joytsing.github.io/posts/41006/"/>
    <id>https://joytsing.github.io/posts/41006/</id>
    <published>2021-03-03T08:30:53.000Z</published>
    <updated>2023-12-14T07:44:45.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章-概述"></a>第一章-概述</h2><h3 id="计算机病毒的定义"><a href="#计算机病毒的定义" class="headerlink" title="计算机病毒的定义"></a>计算机病毒的定义</h3><p>编制或者在计算机程序中<strong>插入</strong>的破坏计算机功能或者毁坏数据，影响计算机使用，并能自我复制的一组计算机指令或者程序代码。</p><h3 id="计算机病毒的本质属性"><a href="#计算机病毒的本质属性" class="headerlink" title="计算机病毒的本质属性"></a>计算机病毒的本质属性</h3><p><strong>人为</strong>的特制<strong>程序</strong>是<strong>任何</strong>计算机病毒的<strong>固有本质属性</strong></p><p><strong>程序性</strong>的<strong>客观性</strong>决定了计算机病毒的可防治性和可清除性</p><p><strong>人为性</strong>的<strong>主观性</strong>导致计算机病毒各异多变</p><h4 id="基本特征-传染性"><a href="#基本特征-传染性" class="headerlink" title="基本特征-传染性"></a>基本特征-传染性</h4><p>传染性是判别一个程序是否为计算机病毒的<code>首要条件</code>,传染性也即指计算机病毒把自身复制到其他程序的能力，把自身的代码强行传染到一切符合其传染条件的程序之上</p><h4 id="基本特征-隐蔽性"><a href="#基本特征-隐蔽性" class="headerlink" title="基本特征-隐蔽性"></a>基本特征-隐蔽性</h4><p>传染过程与存在的隐蔽性，用户不知道病毒的存在</p><h4 id="基本特征-可触发性"><a href="#基本特征-可触发性" class="headerlink" title="基本特征-可触发性"></a>基本特征-可触发性</h4><p>因某个事件或数值的出现，触发病毒实施感染或攻击破坏即隐藏又保持破坏力</p><h4 id="其他特征"><a href="#其他特征" class="headerlink" title="其他特征"></a>其他特征</h4><ul><li>欺骗性：欺骗用户触发、激活病毒</li><li>非授权性：窃取系统控制权</li><li>寄生性：依附于宿主程序</li><li>衍生性：病毒变种</li><li>持久性：数据恢复困难、病毒清除困难</li><li><strong>破坏性</strong>：数据破坏、计算机功能破坏、经济损失</li><li><strong>针对性</strong>：特定软件、操作系统、硬件平台（也反映了其程序性的客观事实）</li><li><strong>不可预见性</strong>：对未知病毒的预测难度（反病毒软件预防措施和技术手段往往滞后于病毒产生速度）</li></ul><h3 id="病毒的分类"><a href="#病毒的分类" class="headerlink" title="病毒的分类"></a>病毒的分类</h3><p><img src="/posts/41006/1_1.png" alt></p><p><img src="/posts/41006/1_2.png" alt></p><h3 id="恶意程序"><a href="#恶意程序" class="headerlink" title="恶意程序"></a>恶意程序</h3><p>未经授权便干扰或破坏计算机系统/网络的程序或代码，早期恶意代码的主要形式是计算机病毒</p><h4 id="蠕虫"><a href="#蠕虫" class="headerlink" title="蠕虫"></a>蠕虫</h4><p>独立的可执行程序，不需要寄生在宿主程序中，通过网络分发自己的副本</p><p>病毒与蠕虫的区别：</p><table><thead><tr><th></th><th><strong>病    毒</strong></th><th><strong>蠕    虫</strong></th></tr></thead><tbody><tr><td><strong>存在形式</strong></td><td><strong>寄生</strong></td><td><strong>独立个体</strong></td></tr><tr><td><strong>复制机制</strong></td><td><strong>插入到宿主程序</strong>(文件)中</td><td><strong>自身的拷贝</strong></td></tr><tr><td><strong>传染机制</strong></td><td><strong>宿主程序运行</strong></td><td><strong>系统存在漏洞</strong>(Vulnerability)</td></tr><tr><td><strong>搜索机制</strong>(传染目标)</td><td>主要是针对<strong>本地文件</strong></td><td><strong>主要针对网络上的其它计算机</strong></td></tr><tr><td><strong>触发传染</strong></td><td>计算机使用者</td><td><strong>程序自身</strong></td></tr><tr><td><strong>影响重点</strong></td><td><strong>文件系统</strong></td><td><strong>网络性能、系统性能</strong></td></tr><tr><td><strong>计算机使用者角色</strong></td><td>病毒传播中的关键环节</td><td><strong>无关</strong></td></tr><tr><td><strong>防治措施</strong></td><td>从宿主程序中摘除</td><td>为系统打补丁(Patch)</td></tr></tbody></table><h3 id="特洛伊木马"><a href="#特洛伊木马" class="headerlink" title="特洛伊木马"></a>特洛伊木马</h3><p>在远程计算机之间建立连接，使得远程计算机能通过网络控制本地计算机的非法程序。</p><p>木马系统软件一般由木马配置程序、控制程序和<strong>木马程序(服务端)</strong>三部分组成，其入侵的方式与一般病毒存在区别，而且，自身一般没有传染性。</p><h3 id="计算机病毒的危害"><a href="#计算机病毒的危害" class="headerlink" title="计算机病毒的危害"></a>计算机病毒的危害</h3><ul><li><p>计算机病毒的蓄意破坏：来自于病毒制造者<strong>目的</strong>，对数据信息的<strong>直接破坏</strong></p></li><li><p>计算机病毒的偶然性破坏：<strong>自身错误</strong>与不可预见性、<strong>兼容性</strong></p></li><li><p>计算机病毒的附带性破坏：抢占资源、影响计算机运行</p></li><li><p>计算机病毒造成的心理及社会的危害：<strong>声誉损失</strong> 、商业风险、心理反应 </p></li></ul><h3 id="计算机病毒的传播途径"><a href="#计算机病毒的传播途径" class="headerlink" title="计算机病毒的传播途径"></a>计算机病毒的传播途径</h3><ul><li><p>通过不可移动的计算机<strong>硬件设备</strong>进行传播</p></li><li><p>通过<strong>移动存储设备</strong>来传播</p></li><li><p>通过<strong>有线网络系统进行传播</strong></p></li><li><p>通过<strong>无线通讯系统</strong>传播</p></li></ul><h3 id="计算机病毒的生命周期"><a href="#计算机病毒的生命周期" class="headerlink" title="计算机病毒的生命周期"></a>计算机病毒的生命周期</h3><p>计算机病毒的<strong>产生过程</strong>可分为：</p><p>程序设计→传播→潜伏→触发、运行→实施攻击</p><p>计算机病毒的<strong>生命周期</strong>：生成开始到完全根治</p><ul><li>开发期：较短、没有经过严格的测试</li><li>传染期：感染流行程序，网络共享，被动到主动</li><li>潜伏期：静态潜伏（文件拷贝）和动态潜伏（占据内存）</li><li>发作期：触发，实施破坏，取决于编写者意图和编程技术</li><li>发现期：被检测隔离，反病毒厂家，病毒通报和描述</li><li>消化期：反病毒软件，检测和发现病毒</li><li>消亡期：升级杀毒软件，杀毒</li></ul><p>计算机病毒的产生是必然的，<strong>软硬件脆弱性</strong>是根本原因，<strong>计算机普及</strong> 是必要环境。</p><h2 id="第二章-代码初始"><a href="#第二章-代码初始" class="headerlink" title="第二章-代码初始"></a>第二章-代码初始</h2><p>小端机：最低字节放在内存的最低地址，次低字节放内存的次低地址，依次存放。比如，0x12345678放在内存中就是78 56 34 12（最左边为内存低位）</p><p>大端机：0x12345678放在内存中就是12 34 56 78</p><h3 id="病毒的基本能力和执行特点"><a href="#病毒的基本能力和执行特点" class="headerlink" title="病毒的基本能力和执行特点"></a>病毒的基本能力和执行特点</h3><ul><li>执行（最为重要）</li><li>潜伏</li><li>破坏</li><li>传染</li></ul><p>执行的特点：</p><blockquote><p>病毒执行并非简单执行自己的指令，它还需要执行被感染对象正常的指令，否则无法潜伏。简单说，在正常指令执行时，需要修改执行流程获得一个执行病毒指令的能力</p></blockquote><h3 id="JMP指令解析"><a href="#JMP指令解析" class="headerlink" title="JMP指令解析"></a>JMP指令解析</h3><pre><code>地址1        Jmp offset -&gt; Offset=地址3-地址2地址2        Push eas    ...地址3        Mov xxx</code></pre><p>JMP跳转的偏移量是：<strong>目的地址-JMP的下一条指令地址</strong>，同时JMP跳转指令占1个字节，偏移量4个字节，一共5个字节</p><h2 id="第三章-文件系统"><a href="#第三章-文件系统" class="headerlink" title="第三章-文件系统"></a>第三章-文件系统</h2><h3 id="硬盘的物理结构"><a href="#硬盘的物理结构" class="headerlink" title="硬盘的物理结构"></a>硬盘的物理结构</h3><p>初级格式化的主要目的：划分成<strong>磁道、扇区和柱面</strong></p><p><strong>CHS参数</strong>：磁道/盘片/扇区</p><p><strong>INT 13H</strong>：寻址范围为8GB</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统就是组织文件的一种方式，文件管理包括文件生成，删除，目录查询等。下面介绍的FAT12主要用来管理软盘</p><p><img src="/posts/41006/1.png" alt></p><p>1个FAT有9个扇区，引导扇区1个扇区，根目录区有224条记录（一个记录32字节）</p><ul><li>数据区中存放用户数据,是文件和子目录数据真正存放的区域</li><li>根目录区中存放的是文件目录表,为记录根目录文件项的表，文件项包括文件，目录。通过它可以查找到根目录下的文件和目录信息，比名称，大小，日期等</li><li>FAT12为<strong>文件分配表</strong>（FAT（File Allocation Table））：记录已分配的扇区和可用扇区，并通过链表依序记录一个文件占用的扇区,另外一个FAT12为备用的FAT表</li><li><strong>引导扇区</strong>（DBR （DOS Boot Record））：记录磁盘和文件系统相关的各种参数，比如扇区大小，一簇的扇区数等</li></ul><p><strong>引导记录格式</strong></p><table><thead><tr><th>名称</th><th>偏移</th><th>长度</th><th>内容</th><th>软盘参考值</th></tr></thead><tbody><tr><td>BS_jmpBoot</td><td>0</td><td>3</td><td></td><td>jmp LABEL_START  nop</td></tr><tr><td>BS_OEMName</td><td>3</td><td>8</td><td>厂商名</td><td>‘ForrestY’</td></tr><tr><td>BPB_BytsPerSec</td><td>11</td><td>2</td><td>每扇区字节数</td><td>0x200（即十进制512）</td></tr><tr><td>BPB_SecPerClus</td><td>13</td><td>1</td><td>每<a href="http://baike.baidu.com/subview/241650/12503090.htm">簇</a>扇区数</td><td>0x01</td></tr><tr><td>BPB_RsvdSecCnt</td><td>14</td><td>2</td><td>Boot记录占用多少扇区</td><td>0x01</td></tr><tr><td>BPB_NumFATs</td><td>16</td><td>1</td><td>共有多少FAT表</td><td>0x02</td></tr><tr><td>BPB_RootEntCnt</td><td>17</td><td>2</td><td><strong>根目录文件数最大值</strong></td><td>0xE0 （224）</td></tr><tr><td>BPB_TotSec16</td><td>19</td><td>2</td><td>扇区总数</td><td>0xB40（2880）</td></tr><tr><td>BPB_Media</td><td>21</td><td>1</td><td>介质描述符</td><td>0xF0</td></tr><tr><td>BPB_FATSz16</td><td>22</td><td>2</td><td>每FAT扇区数</td><td>0x09</td></tr><tr><td>BPB_SecPerTrk</td><td>24</td><td>2</td><td>每磁道扇区数</td><td>0x12</td></tr></tbody></table><table><thead><tr><th>BPB_NumHeads</th><th>26</th><th>2</th><th>磁头数</th><th>0x02</th></tr></thead><tbody><tr><td>BPB_HiddSec</td><td>28</td><td>4</td><td>隐藏扇区数</td><td>0</td></tr><tr><td>BPB_TotSec32</td><td>32</td><td>4</td><td>如果BPB_TotSec16是0，由这个值记录扇区数</td><td>0xB40（2880）</td></tr><tr><td>BS_DrvNum</td><td>36</td><td>1</td><td>中断13的驱动器号</td><td>0</td></tr><tr><td>BS_Reserved1</td><td>37</td><td>1</td><td>未使用</td><td>0</td></tr><tr><td>BS_BootSig</td><td>38</td><td>1</td><td>扩展引导标记</td><td>0x29</td></tr><tr><td>BS_VolD</td><td>39</td><td>4</td><td>卷序列号</td><td>0</td></tr><tr><td>BS_VolLab</td><td>43</td><td>11</td><td>卷标</td><td>‘OrangeS0.02’</td></tr><tr><td>BS_FileSysType</td><td>54</td><td>8</td><td>文件系统类型</td><td>‘FAT12’</td></tr><tr><td>引导代码</td><td>62</td><td>448</td><td>引导代码、数据及其他填充字符等</td><td></td></tr><tr><td><strong>结束标志</strong></td><td>510</td><td>2</td><td></td><td><strong>0xAA55</strong></td></tr></tbody></table><p>从开始偏移510个字节处有两个字节55 AA代表是引导区，小端机整数表示是0xAA 55</p><p>注意到有BS_jmpBoot这个引导记录最开始的JMP指令，反汇编后的机械码为<strong>EB 3C 90</strong>，机器码EB表示JMP，后面1个字节是偏移量，偏移是指从JMP的后条指令开始，到转跳到的指令的差。这里EB 3C表示偏移为60字节（3CH），例如：JMP指令写入内存的地址是0x4011F0，验证一下：0x4011F0 + 2(JMP长2) + 3C= 0x40122E</p><h3 id="如何定位一个文件"><a href="#如何定位一个文件" class="headerlink" title="如何定位一个文件"></a>如何定位一个文件</h3><p>文件分配的最小单位是簇，哪怕只有一个字节也会分配一簇，簇由几个扇区组成在引导扇区的引导记录中定义。在FAT12文件系统中，FAT表以3个<strong>半字节</strong>（3*0.5 Byte = 1.5 Byte = 12 bit）来记录一个簇的相关情况，这也是“FAT12“文件系统中命名12的原因。</p><p>FAT表的本质是磁盘簇分配情况的数据表示，FAT表中每3个半字节为一个元素，这个元素就代表一个簇，簇号从0开始，这个元素中存放的整数值表示其链接的下一簇的簇号</p><h3 id="查找和遍历"><a href="#查找和遍历" class="headerlink" title="查找和遍历"></a>查找和遍历</h3><p>类似于链表的查找，以FFF为结尾，FAT12默认设置引导区占一个扇区，FAT1于其后，同时FAT表开始的3个字节没用于用户文件分配，3字节有2组12bits所以，占用了0,1两个簇号，用户的数据从簇2开始分配。</p><p>随后FAT表从头开始按3字节分成一组，但是有一点需要特别注意：</p><p><strong>在这3个字节中，用第2字节的低半字节和第1字节形成整数表示一个簇号，用第2字节的高半字节和第3字节形成的整数来表示另一个簇号</strong></p><p>由上面学习的内容知道，在FAT表中想要开始遍历就必须知道首簇号，而首簇号位于根目录区域中。</p><h3 id="根目录表中的记录格式"><a href="#根目录表中的记录格式" class="headerlink" title="根目录表中的记录格式"></a>根目录表中的记录格式</h3><p>根目录表包含多条记录，每条记录占32字节，其结构如下表所示。目前我们关注<strong>文件名</strong>（查找需要）和<strong>首簇</strong>（遍历需要）</p><table><thead><tr><th>名称</th><th>偏移</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td><strong>DIR_Name</strong></td><td><strong>0</strong></td><td><strong>0xB　(11)</strong></td><td><strong>文件名8字节，扩展名3字节</strong></td></tr><tr><td>DIR_Attr</td><td>0xB</td><td>1</td><td>文件属性</td></tr><tr><td>保留</td><td>0xC</td><td>10</td><td></td></tr><tr><td>DIR_WrtTime</td><td>0x16</td><td>2</td><td>最后修改时间</td></tr><tr><td>DIR_WrtDate</td><td>0x18</td><td>2</td><td>最后修改日期</td></tr><tr><td><strong>DIR_FstClus</strong></td><td><strong>0x1A　(26)</strong></td><td><strong>2</strong></td><td><strong>此条目对应的开始簇号</strong></td></tr><tr><td>DIR_FileSize</td><td>0x1C　(28)</td><td>4</td><td>文件大小</td></tr></tbody></table><ul><li><p>文件名字段，在该记录首部偏移0开始，共11字节，其中8个给<strong>文件名</strong>，3个给<strong>扩展名</strong>（不需要记录点号 “.”）</p></li><li><p><strong>名字</strong>的结束以<strong>空格</strong>表示，即0x20</p></li></ul><h3 id="查找根目录表的算法"><a href="#查找根目录表的算法" class="headerlink" title="查找根目录表的算法"></a>查找根目录表的算法</h3><p>从磁盘0头0道1扇区读出引导区（Boot）512字节，从其中引导记录获取相关信息：<strong>Boot区占用扇区数，FAT表数目，每个FAT表的扇区数，1个扇区的字节数</strong>。</p><p>计算根目录区的起始位置为：</p><p><strong>[ 1（Boot区扇区数）+2（FAT数目）*9（FAT扇区数）] * 512 = 0x2600</strong></p><p>即2600h为根目录区起始位置，从引导记录获取根区记录数，缺省224条，按每条记录32字节读出所有记录。每条记录开始11个字节为文件名，比较文件名匹配则找到记录，从首簇字段（从该记录开始偏移1Ah处）获得首簇号。</p><h3 id="系统如何区分卷标项和文件项"><a href="#系统如何区分卷标项和文件项" class="headerlink" title="系统如何区分卷标项和文件项"></a>系统如何区分卷标项和文件项</h3><table><thead><tr><th>名称</th><th>偏移</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>DIR_Attr</td><td>0xB</td><td>1</td><td>文件属性</td></tr><tr><td><strong>DIR_FstClus</strong></td><td>0x1A　(26)</td><td>2</td><td>此条目对应的开始簇号</td></tr></tbody></table><p>每一条记录，从该记录开始偏移0xB处有个字节指示出文件的类型，对于多级目录来说，则是存放在数据区内，原理和根目录查找目录类似，只不过是多层嵌套，查找到的是另一个目录表。</p><p>查找<strong>a:\tem\tem.txt</strong></p><p><img src="/posts/41006/2.png" alt></p><h3 id="总结文件查找算法"><a href="#总结文件查找算法" class="headerlink" title="总结文件查找算法"></a><strong>总结文件查找算法</strong></h3><ul><li><p>STEP1. 根据文件路径的第一项（1），先查看<strong>根目录表</strong> ，是否有匹配的项，如果有，通过对应项的<strong>首簇段（0x1A）</strong> 获取该<strong>子目录表（1）</strong> 的首簇号</p></li><li><p>STEP2. 通过首簇号和FAT表获得<strong>子目录表（1）</strong> 的全部内容，根据文件路径的第二项（2），遍历子目录表（1），一次偏移32字节用<strong>名字匹配</strong> 的方法查找记录项（2）, 如果找到，则类似STEP1和STEP2继续查找<strong>文件路径中的下一项</strong> ，否则说明找不到，结束</p></li><li><p>如果在最后一层目录表（路径的倒数第二项，最后一项是文件名）中找到了被查文件的项，从中获取首簇号，即可通过FAT表访问该文件整个相关簇</p></li></ul><h2 id="第四章-硬盘数据结构"><a href="#第四章-硬盘数据结构" class="headerlink" title="第四章-硬盘数据结构"></a>第四章-硬盘数据结构</h2><p>学习完之前有关文件的管理之后，学习有关硬盘的分区信息。</p><h3 id="主引导扇区"><a href="#主引导扇区" class="headerlink" title="主引导扇区"></a>主引导扇区</h3><ul><li>主引导记录（Master Boot Record, MBR）446字节为<strong>主引导记录</strong></li><li>分区表（ Disk Partition Table, DPT）后面存放了一个<strong>分区表</strong></li></ul><p><strong>相对</strong>扇区数，是相对于引导记录头部的偏移扇区数</p><p>主引导扇区中有主引导记录（其中存放了启动时的引导代码）,分区表项, 如何根据分区表项定位到分区入口, 对于放在硬盘头部的MBR和拓展分区与EBR中的计算有所不同.</p><p>分区表项的第一个字节表示是否被激活。</p><p><img src="/posts/41006/3.png" alt></p><h3 id="扩展分区"><a href="#扩展分区" class="headerlink" title="扩展分区"></a>扩展分区</h3><p><strong>虚拟扩展分区</strong>（Extended MBR，即EBR）的目的是为了增加更多的分区,核心想法是形成一个分区链，如图所示的分区中，MBR定义的主分区表本来有4条分区记录，用第一条描述自己分区的信息，用第2条指向下一个分区。下一分区也如此处理，形成链。</p><p><img src="/posts/41006/4.png" alt></p><p>扩展分区的引导记录没有内容,而主分区开始之前有MBR和保留扇区，主分区的相对扇区相对于MBR，通过MBR和相对扇区就可以定位每一个主分区</p><p>注意：</p><blockquote><p>为了完全兼容MBR的格式，EBR完全复用了引导扇区的格式，即起始446字节给引导记录EBR，但在EBR中，这些内容全为0。同样的，从446偏移开始为分区表，16字节为一项，共4项，后两条无效（但占空间），EBR定义的扇区最后两字节也是结束标识55 AA。主分区表中最后一个有效主分区记录指向的磁盘空间（也叫主扩展分区）将用EBR进行划分，分成N个逻辑盘，形成EBR链。</p></blockquote><p><img src="/posts/41006/5.png" alt></p><p><img src="/posts/41006/6.png" alt></p><p>在实际中，则像下图一样：</p><p><img src="/posts/41006/7.png" alt></p><p>主分区表项的偏移量，就是相对物理盘开始（MBR）的偏移，且这些主分区前面没有EBR，根据偏移得到的直接就是盘区（开始就是该分区的引导扇区和文件系统），除了主分区表项中的最后一项偏移指向的是扩展分区的开始处</p><p>扩展分区表项的偏移量，是相对于包含该分区表的扩展区开始处而言（扩展分区开始处为其EBR）</p><p>在扩展分区的分区表中，第一项的偏移指向的是盘区，第二项的偏移指向的是下一个扩展分区开始处（也就是下一个扩展分区的EBR）</p><h3 id="硬盘的引导过程"><a href="#硬盘的引导过程" class="headerlink" title="硬盘的引导过程"></a>硬盘的引导过程</h3><ul><li><p>开机加电自检：开机，CPU跳到内存FFFF:0000处，由该处的一条JMP指令跳到BIOS的自检程序（POST），自检通过后，加载引导程序（与操作系统无关的MBR，按用户在BIOS中的指定顺序，硬盘、软盘、光驱或U盘等</p></li><li><p>读主引导扇区：将主引导扇区MBR读入到内存的0000:7C00，扫描主分区表，搜索激活分区，分区表项第一个字节为0x80表示激活分区</p></li><li><p>读激活分区引导扇区 ：如果有多个激活分区或没有，报错结束。否则读取激活分区引导扇区到0000:7c00</p></li><li><p>操作系统引导代码引导系统并读取操作系统初始化文件</p></li></ul><p>注意的是MBR中硬盘数据结构是与操作系统无关，操作系统相关的引导代码在激活分区的引导扇区，而MBR的引导程序选择激活分区。</p><h2 id="第五章-Dos下的病毒寄生"><a href="#第五章-Dos下的病毒寄生" class="headerlink" title="第五章-Dos下的病毒寄生"></a>第五章-Dos下的病毒寄生</h2><h3 id="病毒的关键问题"><a href="#病毒的关键问题" class="headerlink" title="病毒的关键问题"></a>病毒的关键问题</h3><ul><li>寄生，没有寄生就没有执行和传播的可能</li><li>执行，如果只是文件，没有得以执行的机会，则永远都无法去破坏和感染</li><li>反检查，包括隐藏病毒等</li></ul><h3 id="寄生机制与执行机制"><a href="#寄生机制与执行机制" class="headerlink" title="寄生机制与执行机制"></a>寄生机制与执行机制</h3><ul><li><p>文件型病毒</p><ul><li>头插入</li><li>尾插入</li><li>逆插入</li></ul></li><li><p>直接面向文件系统的病毒</p><ul><li>引导型病毒</li></ul></li><li><p>执行机制</p><ul><li>对于com文件，头、尾和逆插入寄生都相当于入口点修改，病毒可以执行，就不做另行说明</li><li>中断替换</li></ul></li></ul><h3 id="DOS下的内存"><a href="#DOS下的内存" class="headerlink" title="DOS下的内存"></a>DOS下的内存</h3><p>保护模式带来的最大优点不是单纯的扩大了内存寻址范围，而是对内存寻址从机制上提供了保护，将系统的执行空间按权限进行了划分，防止应用程序非法访问其他应用程序的地址空间(任务间保护)，防止应用程序非法访问操作系统地址空间(系统保护)。</p><h3 id="DOS下四种基本可执行文件"><a href="#DOS下四种基本可执行文件" class="headerlink" title="DOS下四种基本可执行文件"></a>DOS下四种基本可执行文件</h3><ul><li>批处理文件，以.BAT结尾的文件</li><li>设备驱动文件，是以.SYS结尾的文件，如CONFIG.SYS</li><li>COM文件，是以.COM结尾的纯代码文件。没有文件头部分，缺省情况下总是从0x100H处开始执行，没有重定位项，所有代码和数据必须控制在64K以内</li><li>EXE文件，是以.EXE结尾的文件。文件以英文字母“MZ”开头，有一个文件头，用来指出每个段的定义等信息，EXE文件摆脱了代码大小最多不能超过64K的限制</li></ul><h3 id="COM文件"><a href="#COM文件" class="headerlink" title="COM文件"></a>COM文件</h3><p>COM文件不存在文件头，由机器码和数据的集合组成，COM文件就是直接读到内存，文件会被加载器加载到段内位置。</p><h3 id="头插入"><a href="#头插入" class="headerlink" title="头插入"></a>头插入</h3><p>头插入病毒是三种病毒之中比较直接的方式</p><p>选择直接插入的话需要注意的是一般函数调用完成后会有ret指令，将执行权交还给DOS，因此后续的代码没有执行就返回了。需要通过JMP指令跳转，不能够直接将RET指令去除，去除的话就将程序段和数据段混合，同时需要注意跳转指令的地址。</p><blockquote><p>源码中的地址信息在编译后会直接被预加载地址代替，从而形成可执行文件的机器码。但因为病毒感染占据了原先com文件的头部，所以原来的机器码后移了这个改动加载器是完全不知道的，它只会把文件加载到预先处，从而导致原先部分的机器码在加载后的实际内存位置后移了，后移长度就是病毒程序的机器码长度</p></blockquote><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>纠正这个问题一般依靠重定位，但COM文件只是简单地被加载到段内原先位置处，本身是没有重定位需要的相关机制，且我们想通过编程来更正错误的地址也是不太可能的。解决方法其实很简单，将原先挤占的程序挪回去原先的位置，</p><p>要拷贝原来的正常程序需要知道它的大小，采取手动的方法，在病毒程序的最后加上两字节的数据存储正常程序的大小，生成感染文件后再在该两字节的位置填入正常程序的大小。</p><p>需要注意的是，如果被拷贝文件过大，会存在覆盖的问题：拷贝指令本身所在的内存部分就是被覆盖的部分。当某次拷贝覆盖了拷贝指令所占的那个字节时，拷贝指令本身就被破坏了，当然它就不能再完成拷贝。那么如何解决这个问题？</p><p>必须让病毒的执行指令本身不会在原文件的拷贝过程中被自我覆盖，最好的方法就是把这些指令放到一个肯定不会被覆盖的安全区域哪里是安全的区域，这里，我们可以选择感染程序最后面的内存区域,也就是原先程序段之外的位置。</p><h3 id="尾部寄生"><a href="#尾部寄生" class="headerlink" title="尾部寄生"></a>尾部寄生</h3><p>在正常代码头部，将原先正常的头部代码修改为jmp覆盖的字节，然后将病毒代码放到正常代码之后，同时注意将被覆盖的正常代码放在病毒代码的后面，确保先执行病毒代码再执行jmp覆盖的字节。但同样具有加载偏差的问题，因此需要使用<code>重定位技术</code>。</p><p>只需要获得任意一条指令的加载偏差就可以知道整个程序的实际偏差地址，也就是将运行时的地址值和编译时的地址值相减就行了，因此关键在于获得IP指向指令的地址值。获取IP寄存器的地址有一个技巧：</p><blockquote><p>Call指令会将下一条指令的IP压栈！然后再跳转执行</p><pre class="line-numbers language-asm"><code class="language-asm">call here <-Call指令的下一条指令是pop ax，call执行时，首先会把pop ax指令的IP（即pop ax这条指令的实际地址）压栈，然后根据相对偏移跳到标号here处here:pop ax <-标号here处就是pop ax指令，执行这条出栈指令会把栈中数据放入ax中，也就是pop ax指令的IP，我们巧妙地利用栈获得了IP的值sub ax, here <-Sub语句中的标号here在编译时就生成了地址，但是是预期地址，实际地址-预期地址，ax中放的就是加载偏差了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>计算出pop的实际地址和预期地址here的差。这样只要将编译期要用的的地址，比如字串的首址加上ax就是字串实际地址了。</p><h4 id="JMP指令长度和格式"><a href="#JMP指令长度和格式" class="headerlink" title="JMP指令长度和格式"></a>JMP指令长度和格式</h4><p>因为JMP要覆盖头部，所以必须分配对应长度的空间在病毒的数据区，用以保存覆盖的内容，在DOS中<code>JMP 地址</code>指令只有两个字节，如果偏移量过长的话则有多个字节，DOS下一般为小端机顺序。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>构造一个打印的正常程序normal.com</li><li>构造一个将粘贴到normal尾部的病毒程序endvirus.com</li><li>用DOS的拷贝命令:用<code>copy /b normal.com + virus.com infected.com完成手动感染</code>, 将两个编译好的程序粘起来，手动完成寄生</li><li>将normal开始的3字节保存到virus.com的数据部分，用UE将normal开始的3字节手动修改为跳转指令，该JMP的机器码格式是E9 XX XX，其中XX XX是2字节，代表偏移这条手动插入的JMP将跳到virus.com处。偏移量如何计算？就是normal.com的size – 3，其中3是因为偏移量从JMP下一条指令开始算，JMP是3字节，所以减3</li><li>virus.com部分指令执行后，将恢复程序开始被覆盖的3字节，还原现场，并JMP到程序开始，将执行权限交给normal.com部分</li></ul><h4 id="手动完成的工作"><a href="#手动完成的工作" class="headerlink" title="手动完成的工作"></a>手动完成的工作</h4><ol><li>寄生感染</li></ol><p>用copy /b normal.com + virus.com infected.com完成手动感染</p><ol start="2"><li>填写OverridedCode字段，保存将被覆盖的头3字节</li></ol><p>用UE打开Infected.com</p><p> 将文件头3个字节内容填入文件<strong>倒数第5个字节开始处</strong></p><ol start="3"><li>填写InfectedFileSize字段，保存被感染文件本身的大小</li></ol><p>查看normal.com文件大小为26字节，即0x001A，该值应该保存到最后两字节，根据小端机原理，我们将倒数第2个字节(InfectedFileSize)修改为0x1A</p><ol start="4"><li>修改第一条JMP指令</li></ol><p>normal.com有26字节，第一条JMP指令自身占3字节，那么跳到virus部分的偏移量是26-3=23，即0x17，那么第一条JMP指令为E9 17 00，修改程序头部3字节为E9 17 00</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>自定位是针对病毒本身出现了加载偏差，而解决原文件加载偏差时，我们是将原文件通过拷贝回预加载地址来解决的。</p><h3 id="逆插入感染"><a href="#逆插入感染" class="headerlink" title="逆插入感染"></a>逆插入感染</h3><p>逆插入感染，实际就是一部分病毒代码在原程序的头部，一部分在尾部，将整个原来的程序给包裹起来。因为即在病毒头部也在病毒尾部，因此需要将程序后移，头粘贴尾粘贴都要使用到。</p><p><img src="/posts/41006/8.png" alt></p><p>与之前手工设计不同的是，需要将感染寄生的代码放在病毒代码中，这段完成感染寄生的代码需要完成：</p><ul><li>把正常程序向后拷贝头病毒的长度</li><li>把头病毒部分拷贝到前面</li><li>把尾病毒部分拷贝到后面</li></ul><p><img src="/posts/41006/9.png" alt></p><h4 id="感染代码部分"><a href="#感染代码部分" class="headerlink" title="感染代码部分"></a>感染代码部分</h4><p>(1)获取原文件大小供后面写入使用 </p><p>(2)原文件扩容,增加头病毒部分长度的字节,在原文件的尾部写字节完成</p><p>(3)原文件向后拷贝头病毒长度部分长度,腾出头部的空间给头病毒,同时要从尾部到头部拷贝,不然会有数据覆盖。</p><p>(4)将头病毒部分写入头部</p><p>(5)将尾病毒部分写入尾部,直接写即可</p><h4 id="头病毒部分"><a href="#头病毒部分" class="headerlink" title="头病毒部分"></a>头病毒部分</h4><p>头病毒部分因为存在加载偏差,需要重定位,并且需要为尾病毒拷贝设置参数.</p><h4 id="尾病毒部分"><a href="#尾病毒部分" class="headerlink" title="尾病毒部分"></a>尾病毒部分</h4><p>重定位有关的代码在头病毒部分已经设置完成,因此不需要额外设置.</p><h2 id="第六章-函数调用"><a href="#第六章-函数调用" class="headerlink" title="第六章-函数调用"></a>第六章-函数调用</h2><p>栈（Stack）是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。</p><h3 id="函数调用对栈的影响"><a href="#函数调用对栈的影响" class="headerlink" title="函数调用对栈的影响"></a>函数调用对栈的影响</h3><ul><li><p>首先把指令寄存器EIP（它指向当前CPU将要运行的下一条指令的地址）中的内容压入栈，作为程序的返回地址（一般用RET表示）；</p></li><li><p>之后放入栈的是基址寄存器EBP（保持之前的值，调用后恢复）；</p></li><li><p>然后把EBP设为栈顶指针ESP，作为新的基地址；</p></li><li><p>最后为动态存储分配留出一定空间，即把ESP减去一个适当的数值</p></li></ul><p>调用函数时,CALL指令干了两件事情,一件事情是将返回地址入栈,另外一件事情是JMP跳转至调用被函数.  在使用call指令前,需要将实参入栈。</p><p><img src="/posts/41006/10.png" alt></p><p>栈的顶部地址存放在ESP寄存器中，而栈的大小变化是以4字节为单位（32位机），因此我们只需要做如下计算就可以访问存储参数2的栈单元，例如 mov eax, [esp + cell*4]。但是之后的函数体如果使用了局部变量进行压栈，那么就无法正确访问参数。因此才需要在call之后先把EBP中的内容压栈，ESP放入到EBP中，此时EBP和ESP同样都是指向原EBP的位置。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>只要在一个函数的开始部分执行:</p><pre class="line-numbers language-asm"><code class="language-asm"> push ebp; mov ebp, esp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>之后相对ebp 进行正向偏移就可以访问它的主调函数传入的参数了</p><h3 id="局部变量的访问"><a href="#局部变量的访问" class="headerlink" title="局部变量的访问"></a>局部变量的访问</h3><p>栈布局如之前图所示，因此局部变量分配在哪，如何访问？因为栈是由高地址向低地址增长，因此如何低地址部分就为局部变量的存储位置，与访问实参相同，都是通过ebp偏移访问。</p><p>可以简单记作：在使用了EBP寻址的函数中，EBP+偏移量就是参数的地址，EBP-偏移量就是局部变量的地址</p><h3 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h3><p>通过调用ret指令，将当前栈顶存放的内容作为返回的地址，而call的时候，就将返回地址存入栈了。</p><p>而被调函数的ret语句进行了如下操作：</p><p>将返回地址从栈中弹出，并放入EIP寄存器。所以每个被调函数的结尾处都是一句ret，这是函数的返回地址，那么函数返回值如何传递？首先调用ret后，EBP已经还原，对于局部变量来说无法通过EBP-偏移量来访问。</p><p>对于被调函数来说，则是将局部变量放入eax或者edx这种通用寄存器中，而对于调用者来说，则是把对应通用寄存器中的值放入到其对应的局部变量中。</p><p>对于返回值过多或者过大（如结构体）寄存器无法存储怎么办？解决办法即传地址即可。但是需要注意的是，如果EAX存了返回值，那么调用结束后进行请栈，EAX中存储的地址在逻辑上已经无效了。因此需要分配一段内存来存储这个返回值。这段空间就是在主调函数call背调函数之前完成。</p><p><img src="/posts/41006/11.png" alt></p><p>然后，当被调函数传递返回值时：</p><p>（1）通过[EBP+偏移]获得这个返回值的存放位置</p><p>（2）把返回值写入到这个内存</p><p>（3）把返回值的地址写入到EAX，mov eax, [ebp+偏移]</p><p><img src="/posts/41006/12.png" alt></p><h3 id="栈清除"><a href="#栈清除" class="headerlink" title="栈清除"></a>栈清除</h3><p>平衡栈，函数返回需要清除参数传递消耗的栈空间，参数传递使用了栈空间，那么函数完成了工作就不需要这些空间了，必须清除。清除栈上的空间很简单，只需要将ESP寄存器向反方向移动就可以了。清栈的工作可以由被调函数完成，也可以由主调函数清除。</p><h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p>即分配的临时变量空间不足以容下临时变量，导致覆盖了堆栈的高位元素，EBP，RET这些指令和数据被覆盖，将溢出的数据视为了指令，出现了错误。</p><h2 id="第七章-DOS下的引导-中断"><a href="#第七章-DOS下的引导-中断" class="headerlink" title="第七章-DOS下的引导+中断"></a>第七章-DOS下的引导+中断</h2><p>接下来学习面向文件系统的病毒：</p><h3 id="引导型病毒"><a href="#引导型病毒" class="headerlink" title="引导型病毒"></a>引导型病毒</h3><p>引导型病毒感染引导区，替换引导区原始的引导代码，从而获得执行。之后还原被修改的引导区，并将执行权限交给原来的引导代码，从而保持正常的工作。</p><p>接下来学习的引导型病毒是面向软盘上引导区的，软盘和硬盘所不同的是，硬盘分区（激活分区）的起始位置需要访问所对应的分区表项，找到分区表项，才能知道自己分区从哪里开始等信息，随后才能找到引导扇区的引导代码</p><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>病毒感染时替换0头0道1扇区（512个字节），并将原引导扇区内容保存到用户数据区第一个扇区，也即簇2。病毒执行完打印字串的动作后，从簇2对应扇区读出原引导扇区内容，将其恢复到内存7c00h处，并跳到7c00h将执行权限交给原来的引导程序</p><p>插入被感染软盘，启动虚拟机设置为软盘引导，将先打印病毒的消息，然后进入原来的引导程序（原引导程序将打印非系统盘）</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p><strong>执行过程：</strong>病毒先把自己加载到7C00h，然后又把原引导程序拷贝到7C00h，这个过程会出现什么问题？就是前面遇见的<strong>自我覆盖</strong>问题，所以需要将病毒中执行拷贝的指令段移出被覆盖的区域。我们可以将它后移一个扇区7e00h处</p><p><strong>感染过程：</strong>感染会将原引导扇区的内容一直放到簇2，如何避免后续使用占用簇2，破坏了病毒的逻辑？可以修改FAT1和FAT2表，将簇2的项改成不可使用，如果改为已占用FFF，但却没有对应的目录项，是可疑的，因此，可以改为坏簇FF7，从而防止别人使用它。这些感染，为了简单，没有采用汇编访问硬盘的方式，而是采用C语言来直接修改软盘文件。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>复位磁盘系统</li></ul><pre><code>Xor ah, ah        ;ah=0为磁盘复位int 13h            ;13h为磁盘中断</code></pre><p>读指定从磁头，道，扇区起始，n个扇区到内存缓冲</p><p>AH = 02h是读扇区功能号</p><p>AL = 将读入多少个扇区</p><p>CL = 起始扇区号</p><p>CH = 磁道</p><p>DH = 磁头</p><p>DL = 磁盘，0代表a盘</p><p><strong>ES:BX = 读缓冲的地址，一般只填写BX</strong></p><pre><code>Mov ah, 02Mov al, 5        ;读5个扇区Mov cl, 1        ;从1扇区开始Mov ch, 0    ;读0道Mov dh，0    ;读0头Mov dl, 0        ;读a盘Mov bx,7c00h    ;读到7c00h处int 13h</code></pre><p>Int 13h采用的是CHS的硬盘寻址方式，而我们习惯上采用绝对扇区号为0,1,2,3,…的线性方式。</p><h4 id="绝对扇区号如何转换为磁头-道-扇区号"><a href="#绝对扇区号如何转换为磁头-道-扇区号" class="headerlink" title="绝对扇区号如何转换为磁头/道/扇区号"></a>绝对扇区号如何转换为磁头/道/扇区号</h4><p>软盘的扇区磁头道一个道18个扇区。</p><ul><li>道内扇区号（从1开始计数）：给定绝对扇区号，除以18（软盘一道有18个扇区），则<strong>余数+1是道内扇区号</strong> （道内扇区从1开始），<strong>商为N则N+1为绝对道</strong>（比如，绝对扇区19，商1，余数1，道内扇区2，绝对道2）</li><li><strong>磁道</strong>(从0开始计数)：不同头的相同道是连续存放的，假定磁头数目为m（m=2），则<strong>N/m去掉小数为磁道，也即对应的磁道号</strong>。软盘m=2，即N右移一位是磁道号（<strong>N &gt;&gt;1</strong>）</li><li><strong>磁头</strong>：对于软盘，有两个头，因为绝对道=N+1。当绝对道为奇，N为偶，对应头0当绝对道为偶，N为奇，对应头1。绝对道6（N=5）对应头1因此，采用运算<strong>N &amp; 1</strong>获得磁头号。N为奇数 and 1 = 1，N为偶数 and 1 = 0。</li></ul><blockquote><p>绝对扇区号/18 得到余数和商N</p><p>扇区号：余数+1，磁道：N&gt;&gt;1，磁头：N &amp; 1</p></blockquote><p><img src="/posts/41006/13.png" alt></p><h3 id="执行部分程序设计"><a href="#执行部分程序设计" class="headerlink" title="执行部分程序设计"></a>执行部分程序设计</h3><p><img src="/posts/41006/14.png" alt></p><p>执行的时候发现存在引导原先系统盘失败的问题。病毒把引导区全部覆盖了，导致DOS无法识别a盘。在引导扇区，其实还有很多重要的引导记录（包括FAT有多少扇区，磁盘的介质类型等），因为病毒只是简单地覆盖了整个扇区，从而破坏了这些引导记录，导致DOS无法识别盘。</p><p>因此只要保留引导记录即可，引导扇区的头3个字节吗？是一条JMP指令和一个NOP，它会跳过引导记录，跳到引导程序处，因此，我们的病毒指令可以只覆盖引导记录后面的部分。</p><p>同样的，在加载时它实际加载的地址是引导记录，不是指定的地址，因此加载的位置与实际有偏差，需要使用到重定位。</p><ul><li><p>解决1：写自定位代码</p></li><li><p>解决2：让病毒代码前面加入偏移</p></li></ul><p>为了真正执行的病毒代码不发生加载偏差，在病毒指令之前加入了填充字节（字节数为引导记录占用的字节数），需要定位到引导记录后才拷贝，并且从写入时从引导记录后开始复制，复制长度减少了引导记录的长度（即仅仅复制病毒执行部分的长度）。修改后结果，在非引导下，可以正常识别被感染的软盘了。</p><h3 id="中断替换"><a href="#中断替换" class="headerlink" title="中断替换"></a>中断替换</h3><h4 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h4><p>中断引发后，就会去调用一段处理程序，叫<strong>中断处理程序</strong>（<strong>例程</strong>），系统找到中断处理程序的<strong>入口地址</strong>，从而执行中断，系统通过<code>中断向量表</code>找到中断处理程序的入口地址，中断向量表存放在内存的最低处，即00:00处，每4个字节为1个项，这个作为索引的项就是<code>中断向量号</code>， 其中存放一个中断处理程序的入口地址，高2字节是段地址，低2字节是段内偏移。</p><p>一个中断触发指令<code>int xxh</code>，其中的xx就是中断向量号，4 * xx就是中断xx的入口地址在中断向量表中存放的位置。比如int 10h其入口地址就存放在中断向量表中的4*10h = 40h的位置。</p><h4 id="非驻留式中断向量修改"><a href="#非驻留式中断向量修改" class="headerlink" title="非驻留式中断向量修改"></a>非驻留式中断向量修改</h4><p>驻留程序就是一直在内存中不退出，系统的<code>中断处理程序</code>要为所有程序服务，所以它的特点就是不退出一直驻留在内存中。</p><p>病毒为了获得执行，会修改<code>中断处理程序的入口地址</code>（即修改中断向量表）指向病毒提供的一段程序，这样，只要调用相应的中断，就会去执行这段程序。但是，这段病毒程序必须也是驻留程序，否则病毒结束后，内存回收，这段程序也不在了，导致中断向量表指向无效。因此，在非驻留式的中断替换中，我们还需要在病毒程序调用后恢复中断向量表。</p><p><img src="/posts/41006/15.png" alt></p><p>结合之前，段寄存器和中断向量表是在不同的段的。段寄存器需要根据实际访问情况变化，先从低2字节处取出中断程序的<strong>段内偏移</strong> ，约定放在AX寄存器中，再放到数据区的Offset处，再从高2字节处取出中断程序的<strong>段地址</strong>，约定放在CX寄存器中，再放到数据区Seg处。</p><p>病毒需要由自己段跳到原中断向量程序所在的段。要跨段跳转，就要采用JMP XX:YY的形式，但是JMP CX:AX的语法是不支持的，即JMP XX:YY的指令不支持两个间接性，XXYY总有一个是立即数，而程序里面Seg和Offset都不是立即数，怎么解决？我们可以先采用两个立即数来确定JMP指令的形式（比如JMP 00:00），然后我们再来定位到JMP指令的机器码，进行按字节的细粒度修改。</p><p><img src="/posts/41006/16.png" alt></p><h2 id="第八章-链式病毒"><a href="#第八章-链式病毒" class="headerlink" title="第八章-链式病毒"></a>第八章-链式病毒</h2><p>链式病毒只保留一份病毒拷贝，利用文件目录项，将受感染文件的头簇指向病毒。</p><p>复习之前获取文件的内容知识</p><p><img src="/posts/41006/17.png" alt></p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><strong>感染过程：</strong></p><ol><li><p>如首次感染，将病毒保存在某个空闲扇区</p></li><li><p>将被感染文件（COM文件）首簇存目录项保留段</p></li><li><p>修改首簇号指向病毒的首簇</p></li></ol><p><strong>执行过程：</strong></p><ol><li><p>执行被感染文件则启动病毒，加载的是病毒的首簇，并执行</p></li><li><p>病毒获取当前执行程序的名字，获取对应目录项。从其中保留字段获取原文件首簇号，并遍历FAT簇链加载它们。</p></li><li><p>跳到加载的原文件内存中执行</p></li></ol><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p><strong>一、感染部分</strong></p><ul><li>被感染文件的真实起始扇区号写到<code>目录表项的保留区</code>（目录项的保留区从目录项头第13个字节即偏移0ch开始，共10字节）</li><li>修改被感染文件的目录项的<code>起始扇区字段</code>指向病毒文件的首簇</li><li>目录项中的<code>文件大小字段</code>也要修改成病毒的真实大小，这样才能保证病毒能被完整加载</li><li>将原来病毒文件的目录项全部32字节改为0，这样从外部看就不存在这个病毒文件，也没有对应的目录项了</li></ul><p><strong>二、执行部分</strong></p><ul><li><p>病毒运行后，先获取被<code>感染程序的名字</code></p></li><li><p>然后从根目录寻找<code>被感染程序的目录项</code></p></li><li><p>找到后从该目录项的保留区获取<code>被感染程序的首簇号</code></p></li><li><p>找到被感染程序所在簇（即扇区），加载该扇区到内存</p><blockquote><p>因为被感染文件是COM文件，将其加载到内存100h处，并将执行权交还给被感染文件</p><p>注意的细节：当把原文件加载到100h时，会产生<code>自我覆盖</code>的问题，和头感染相似，因此，病毒代码需要把执行拷贝功能的代码段移到一个安全区域（即不会被覆盖的区域）。因为本病毒是针对被感染文件大小 &lt; 1扇区的文件，因此，只需要移动到100h（加载地址） + 200h（1个扇区大小）的位置即可（即300h）</p></blockquote></li></ul><p><img src="/posts/41006/18.png" alt></p><h3 id="如何获取执行文件名"><a href="#如何获取执行文件名" class="headerlink" title="如何获取执行文件名"></a>如何获取执行文件名</h3><p>原理：</p><p>从COM文件的DS:2c处获得<strong>环境块首址的段地址</strong>，环境块就在<strong>段地址：0000</strong> 处。</p><p>环境块内容：PATH=……COMSPEC=C:\COMMAND.COM\0….0 0 xxxx。环境块开始是PATH等0字符结尾的串，最后是两个00字符。然后有两个字节，可能是数目，之后就是执行程序的名字。</p><h2 id="第九章-Win病毒-虚拟地址"><a href="#第九章-Win病毒-虚拟地址" class="headerlink" title="第九章-Win病毒-虚拟地址"></a>第九章-Win病毒-虚拟地址</h2><h3 id="动态链接库DLL"><a href="#动态链接库DLL" class="headerlink" title="动态链接库DLL"></a>动态链接库DLL</h3><p>动态链接库（Dynamic Link Libraries）为模块化应用程序提供了一种方式，使得<strong>更新和重用</strong>程序更加方便。</p><p>1）动态链接库是应用程序的一部分，作为<strong>模块</strong>被进程加载到<strong>自己的空间地址</strong></p><p>2）动态链接库在程序编译时并不会被插入到可执行文件中，在程序运行时整个库的代码才会调入内存，这就是所谓的“动态链接”</p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><blockquote><p>Windows系统下程序是如何被加载执行的？</p></blockquote><p>而执行首先需要加载到内存，这又涉及到<strong>保护模式下内存管理</strong>的问题。下面我们将先学习<strong>内存管理和程序加载的相关机制</strong></p><h4 id="Windows内存管理和程序加载"><a href="#Windows内存管理和程序加载" class="headerlink" title="Windows内存管理和程序加载"></a>Windows内存管理和程序加载</h4><ul><li><p>DOS的内存管理，是实模式，我们可以随意改动甚至系统的内存（比如修改中断向量表）</p></li><li><p>Windows是工作在x86的保护模式。每个进程都有自己<strong>独立的线性地址空间</strong>（0-4GB，32位CPU的寻址能力为2^32=4GB），互不干扰，这4GB空间会按某个固定的大小（如4KB）分成N个页</p></li><li><p>同时，内存又分为<strong>用户空间</strong>和<strong>内核空间</strong>，用户空间的代码（我们编写的exe）无法直接访问内核空间内存的。这些限制让我们无法像DOS那样随便涂改内存了</p></li><li><p>保护模式最大优点是对内存寻址从机制上提供了保护，将系统的执行空间按权限进行了划分，防止应用程序非法访问其他应用程序的地址空间(<strong>任务间保护</strong>)，防止应用程序非法访问操作系统地址空间(<strong>系统保护</strong>)。</p></li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul><li><p>在Windows系统下，现在是保护模式，我们看见的内存地址，是逻辑地址，并非真正的物理地址。实模式下，看见的内存地址就是真实的物理地址。</p></li><li><p>同一逻辑地址的值对应不同物理上的内存地址正是保护模式的能力。</p></li><li><p>虽然逻辑地址相同，但具有不同的映射对应，从而使得大家的物理地址各不相同，但是却隐藏了真正的物理地址，起到保护作用。</p></li></ul><h3 id="虚拟地址转换过程"><a href="#虚拟地址转换过程" class="headerlink" title="虚拟地址转换过程"></a>虚拟地址转换过程</h3><p>32位虚拟地址分成3部分(详情请见操作系统)：</p><blockquote><p>CR3寄存器给出<strong>页目录地址</strong></p><p>CR3寄存器: </p><ul><li><p>PDE 页表目录：每一项4个字节，保存了页表的地址</p></li><li><p>PTE 页表，里面包含每一页的物理地址和页属性</p></li></ul><p>在分页系统中，为每个进程配置了一张页表)</p><p>前面10位用于在页目录中查找<strong>页表地址</strong></p><p>中间10位用于在页表中查找<strong>页表项</strong></p><p>后面12位给出相对页表项地址的<strong>偏移</strong></p></blockquote><h3 id="PE如何解决COM加载的缺点"><a href="#PE如何解决COM加载的缺点" class="headerlink" title="PE如何解决COM加载的缺点"></a>PE如何解决COM加载的缺点</h3><ul><li>DLL模块加载的真实内存地址不可能是相同的，相同则产生覆盖。这和COM死板的约定加载到100h不同，既然这个加载地址不是固定的了，那么可执行程序应该有地方存储了<strong>约定的加载地址</strong></li><li>COM约定了加载的地方就是程序开始执行的地方（100h必然是第一条指令），但这个也太死板（想像一下我们将子函数写在main函数之前），所以我们可能需要在执行程序中存储<strong>真正代码开始的地方</strong>（即存储第一条指令到头部的偏移即可）</li><li>如果确实加载不到约定地址，而代码自身又不具有自定位代码（很不方便），那么我们可以需要一种重定位机制，这又可能需要借助一种新的数据结构，比如<strong>重定位表</strong></li><li>这些都导致了执行程序需要一种格式来描述信息，除了指令和数据外，还应该有相应的格式或结构来存储上面这些东西</li></ul><h2 id="第十章-PE结构和末节寄生"><a href="#第十章-PE结构和末节寄生" class="headerlink" title="第十章-PE结构和末节寄生"></a>第十章-PE结构和末节寄生</h2><p>在Win32位平台可执行文件命名为可移植的可执行文件(Portable Executable File)，该文件的格式就是PE格式</p><p><img src="/posts/41006/19.png" alt></p><h3 id="映像"><a href="#映像" class="headerlink" title="映像"></a>映像</h3><blockquote><p>PE文件的加载要完成<code>虚拟地址（内存）</code>和<code>PE文件（硬盘）</code>之间的映射关系，所以又被称为映像文件。当真正执行某个内存页中的指令或访问某一个页的数据时，这个页面才会真正读入内存。</p></blockquote><p>在学习PE文件的时候，一定要区分<code>文件位置</code>和<code>虚拟地址</code>的概念，而在内存定位时，除了虚拟地址（Virtual Address，VA）的概念，还有<code>相对虚拟地址（RVA）</code>的重要概念</p><h3 id="RVA-相对虚拟地址（Relative-Virtual-Addresses）"><a href="#RVA-相对虚拟地址（Relative-Virtual-Addresses）" class="headerlink" title="RVA-相对虚拟地址（Relative Virtual Addresses）"></a>RVA-相对虚拟地址（Relative Virtual Addresses）</h3><ul><li><p>第一，<strong>虚拟</strong>，说明它不是一个真实地址，因此，它应该就是前面我们提到的逻辑地址，既然是逻辑地址，应该就是指的就是内存了（注意和硬盘上文件中的位置相区分）</p></li><li><p>第二，<strong>相对</strong>，相对说明这个地址很有可能是对某一个逻辑地址的偏移，而这个逻辑地址很有可能就是我们PE文件加载到内存时，所占用的最开始的那个内存单元的逻辑地址（或称之为基地址）</p></li></ul><h3 id="RVA和FOA的联系与区别"><a href="#RVA和FOA的联系与区别" class="headerlink" title="RVA和FOA的联系与区别"></a>RVA和FOA的联系与区别</h3><ul><li>RVA是内存的相对位置，相对的是加载到内存的基地地址</li><li>FOA是文件中的相对位置，相对的是文件开始位置（即0）</li></ul><p><img src="/posts/41006/20.png" alt></p><p><strong>文件在硬盘存储时的对齐方式和在内存加载时的对齐方式是不同的</strong>，在文件中，每一个<strong>节</strong>往往按512B（200H）的粒度对齐。而在内存中，通常以4096B（1000H）的粒度对齐，由于对齐的方式不同，有些节，它在内存的RVA就和它在文件的FOA就不一致。</p><p><img src="/posts/41006/21.png" alt></p><h3 id="如何让病毒被加载、执行？"><a href="#如何让病毒被加载、执行？" class="headerlink" title="如何让病毒被加载、执行？"></a>如何让病毒被加载、执行？</h3><p>PE文件格式字段：</p><p>e_magic：两个字符MZ代表DOS文件</p><p>e_lfanew：偏移量，就是从文件开始到PE文件头（NT头）的偏移量</p><p>通过“MZ”和后面的“PE”标志，来初步判断文件是否为PE文件，从而确定是否进行感染寄生</p><h3 id="PE头（NT头）"><a href="#PE头（NT头）" class="headerlink" title="PE头（NT头）"></a>PE头（NT头）</h3><p>nPE文件头的结构是IMAGE_NT_HEADERS，又称之为NT头，它是存放了整个PE文件的相关重要信息</p><pre><code>IMAGE_NT_HEADERS STRUCT        Signature  dd ?         FileHeader IMAGE_FILE_HEADER &lt;&gt;         OptionalHeader IMAGE_OPTIONAL_HEADER32 &lt;&gt;IMAGE_NT_HEADERS ENDS</code></pre><p>它包含3部分：</p><ul><li>PE文件标志（Signature）:字段头两个字节是“PE”，表明该文件是PE格式的文件。</li><li>映像文件头（IMAGE_FILE_HEADER）:NumberOfSections字段存储文件中节的个数</li><li>可选映像文件头（IMAGE_OPTIONAL_HEADER32）：<ul><li>AddressOfEntryPoint表示代码入口RVA，第一条指令的RAV</li><li>ImageBase: Cardinal; //载入程序的首选RAV</li><li>SectionAlignment: Cardinal; //节在内存中对齐方式</li><li>FileAlignment: Cardinal; //节在文件中对齐方式</li><li>SizeOfImage: Cardinal;     //内存中整个PE文件的总大小，按内存对齐</li><li>DataDirectory: array[0..IMAGE_NUMBEROF_DIRECTORY_ENTRIES - 1] of  TImage_Data_Directory; //数据目录表</li></ul></li></ul><p>病毒判断一个文件是否是PE格式往往可以通过：</p><ol><li><p>先判断文件头2字节是否为“MZ”</p></li><li><p>判断NT头的Signature是否为“PE”</p></li></ol><h3 id="利用入口RVA实现病毒执行的问题"><a href="#利用入口RVA实现病毒执行的问题" class="headerlink" title="利用入口RVA实现病毒执行的问题"></a>利用入口RVA实现病毒执行的问题</h3><p>知道执行程序的入口代码地址如何确定的，如果找到了，将它指向病毒代码，找到了<strong>AddressOfEntryPoint</strong>，它表示入口RAV，也是第一条指令的RAV，程序从这里开始执行。</p><p>我们需要通过RAV来找到该指令在文件中的FOA以便修改开始的机器码，利用RVA找到所属的节,如果该节的起始RVA和该节的起始文件偏移相等，那么就直接用作文件偏移。如果有差别：</p><blockquote><p>入口点的RVA（AddressOfEntryPoint）- 节的RVA =入口点的FOA - 节的起始文件位置（PointerToRawData）</p></blockquote><h3 id="PE描述文件大小的字段"><a href="#PE描述文件大小的字段" class="headerlink" title="PE描述文件大小的字段"></a>PE描述文件大小的字段</h3><p>1）节表紧跟在PE文件头后，节表中的每一个结构ImageSectionHeader （28H）都对应一个节，其中，有两个字段描述了对应节的文件大小（SizeOfRawData）和加载到内存的大小（VirtualSize）（两者可能不同，文件大小可以大于内存也可以小于内存。小于内存时，将在内存补0）</p><p>2）在PE头的可选映像头ImageOptionalHeader中，SizeOfImage给出了整个程序包括所有头部加载到内存后的大小其大小应该是SectionAlignment的整数倍</p><p>简单说，就是PE文件总大小和每个节的大小都有参数：</p><ul><li>每一个节都有一个对应的节表项SectionHeader结构</li><li>VirtualSize表明本节加载到内存后的大小即加载到内存的实际字节数（未对齐）</li><li>SizeOfRawData字段表明本节在文件中的大小（对齐后）因此，必须是FileAlignment（在可选映像头中）的整数倍</li></ul><p>回到可选映像头ImageOptionalHeader中观察：</p><ul><li><p>SizeOfImage给出了整个文件在内存中对齐后的大小</p></li><li><p>SectionAlignment是内存对齐的粒度</p></li><li><p>FileAlignment是文件对齐的粒度</p></li></ul><h3 id="用程序完成末段大小不变的寄生"><a href="#用程序完成末段大小不变的寄生" class="headerlink" title="用程序完成末段大小不变的寄生"></a>用程序完成末段大小不变的寄生</h3><ol><li><p>生成需要寄生的病毒代码</p></li><li><p>获得被感染文件的NT头</p><ol><li>利用DOS头的e_lfanew字段（文件定位）</li><li>定位NT头，读到ntHrds（文件定位读）</li></ol></li><li><p>找到最后一个节判断是否具有空洞</p><ol><li><p>如何判断节是否有空洞？</p><p><strong>virtualSize &lt; SizeofRawData</strong></p></li><li><p>这些信息在哪里？</p><p><strong>最后一个节的节表项中</strong></p></li><li><p>当前的文件指针在什么地方？</p><p><strong>之前读了NT头，现在在NT头的后面也就是节表的起始文件位置</strong></p></li></ol></li><li><p>修改最后一个节VirtualSize写入病毒</p></li><li><p>修改SizeofImage和EntryPoint</p></li></ol><h2 id="第十一章-EPO入口点不在代码节的问题"><a href="#第十一章-EPO入口点不在代码节的问题" class="headerlink" title="第十一章-EPO入口点不在代码节的问题"></a>第十一章-EPO入口点不在代码节的问题</h2><h3 id="入口点模糊技术-Entry-Point-Obscuring"><a href="#入口点模糊技术-Entry-Point-Obscuring" class="headerlink" title="入口点模糊技术(Entry Point Obscuring)"></a>入口点模糊技术(Entry Point Obscuring)</h3><p>每个节的节表项有一个characteristics属性,说明了该节是干什么的,当IMAGE_SCN_CNT_CODE为20时说明是代码节. EPO技术能够让病毒代码隐藏自己入口点，避免被查杀,使得被病毒修改后的入口点看起来依然就像是正常的入口点.</p><p>解决入口点不在代码段的问题，我们可以采用下2种解决方法：</p><blockquote><p>1）不感染最后一节，直接感染代码节，病毒代码附着在代码节的尾部，再修改入口点。这样虽然修改了入口点，但让入口点处于代码节</p><p>2）不修改入口点，但将入口点所在的指令替换成一条JMP指令，跳往到寄生的病毒代码</p></blockquote><h3 id="EPO1-感染在代码节的空洞"><a href="#EPO1-感染在代码节的空洞" class="headerlink" title="EPO1 感染在代码节的空洞"></a>EPO1 感染在代码节的空洞</h3><p>本方法有个缺陷，真正的入口一般都在代码节的前部，而我们感染的是尾部，这样修改后的入口点太靠代码节的后部，这也会使得入口点看起来异常，从而被一些杀毒软件查杀</p><p>比如，我们正常软件入口是1690h，代码节.text的起始RVA是1000h，正常入口在节内偏移只有690h，如果感染到本节尾，则修改后的入口点在节内偏移将是212B0-1000=202B0h，远远大于690。基本就是节尾了，这就会引起怀疑。</p><p>此外，感染代码节时，代码节往往不是最后节，如果代码节空洞不够，就必须增加代码节的节长，则后续节都要修改RVA，文件偏移等字段，非常麻烦</p><h4 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h4><ol><li><p>生成需要寄生的病毒代码</p></li><li><p>获得被感染文件的NT头</p></li><li><p>找到代码节并判断是否具有空洞</p><p>如何找到代码节？遍历所有节表项并判断节表项的属性是否有20属性</p></li><li><p>修改VirtualSize写入病毒</p></li><li><p>修改SizeofImage和EntryPoint</p></li></ol><h3 id="EPO2感染最后节并替换入口指令"><a href="#EPO2感染最后节并替换入口指令" class="headerlink" title="EPO2感染最后节并替换入口指令"></a>EPO2感染最后节并替换入口指令</h3><p>感染时，先将原入口5字节保存，替换成JMP跳到寄生代码。病毒执行后，将入口5字节还原，然后跳回到原入口</p><h4 id="如何生成寄生的病毒代码"><a href="#如何生成寄生的病毒代码" class="headerlink" title="如何生成寄生的病毒代码"></a>如何生成寄生的病毒代码</h4><p>病毒代码需要进行恢复跳转等细致的操作，所以我们把病毒代码采用C中内嵌汇编的方式编写，生成病毒代码code后，然后利用C语言来完成病毒代码的寄生拷贝</p><p>思考：病毒要做的事有哪些</p><ol><li><p>修改原入口点的数据为JMP指令</p></li><li><p>保存被覆盖的5个字节</p></li><li><p>执行逻辑</p></li><li><p>恢复这5个字节</p><ul><li><p>源地址就是被覆盖的5个字节，放在数据区，所以我们把可以把<strong>数据区的起始地址</strong>也作为数据放入数据区</p></li><li><p>目的地址是原程序的<strong>入口点地址</strong>，寄生后，病毒的main函数就结束了，所以这个<strong>入口点地址</strong>也需要写入数据区时</p></li></ul></li><li><p>最后一条JMP跳回原入口点</p></li></ol><blockquote><p>因此，寄生代码的数据区应该有5+4+4=13个字节</p></blockquote><p>寄生代码生成的时候，这些重要的地址信息是根据PE文件的预期加载地址ImageBase来生成的，所以说是预期地址。然后寄生代码会放到原文件中，如果原文件加载到预期的ImageBase，寄生代码中的地址信息就是正确的。但是！ImageBase是程序<strong>预期</strong>加载的基地址，win7系统和vs编译器往往都采用了随机地址空间技术，使得程序即每次加载的<strong>实际</strong>地址并不是ImageBase，原文件有重定位表这样的机制帮助重定位，但病毒只能利用前面我们学到的<strong>自定位</strong>技术原理。</p><p><img src="/posts/41006/22.png" alt></p><p><strong>关键在于：</strong></p><ul><li>找到入口点所在的节</li><li>然后将入口点（内存位置）转变为文件位置</li></ul><p>实际中会遇到内存区只可读不可改的情况，因此我们把characteristics的值改为我们想要的可写即可，80000000h代表写，为避免类似情况，我们选择在循环搜索入口点所在的节时，一旦找到该节，就将该节的索引（后面写入时需要利用这个索引值找到该节）和属性字段保存，然后，在文件中定位到该节的节头，计算新的属性值并写入到节头的属性字段。</p><h2 id="第十二章-DDL-导出表"><a href="#第十二章-DDL-导出表" class="headerlink" title="第十二章-DDL+导出表"></a>第十二章-DDL+导出表</h2><h3 id="如何让病毒调用函数"><a href="#如何让病毒调用函数" class="headerlink" title="如何让病毒调用函数"></a>如何让病毒调用函数</h3><p>我们需要在病毒数据区存放调用函数所需的参数。如何访问这些参数呢？用我们已经熟悉的自定位代码即可，call后再pop到eax，eax就指向了参数的地址。</p><p><strong>操作系统通过动态链接库（DLL）来对外提供API</strong> </p><p>   1）动态链接库是应用程序的一部分，动态链接库在本质上是作为模块被进程加载到自己的空间地址的。</p><p>   2）动态链接库在程序运行时整个库的代码才会调入内存，这就是所谓的“动态链接”</p><h4 id="如何获取API的入口地址"><a href="#如何获取API的入口地址" class="headerlink" title="如何获取API的入口地址"></a>如何获取API的入口地址</h4><p>只有获取了API函数入口地址（模块DLL – &gt; 函数），我们才能跳过去调用它，没有操作系统和编译器的帮忙，就只有自力更生：</p><p>  （1）找到提供这个API函数的<strong>DLL的加载基址</strong> </p><p>  （2）从DLL的导出表中拿到<strong>API函数地址</strong> ，理解DLL的导出表机制，可简单想象成一张表，然后在这个表中根据函数名找到函数入口地址。我们的操作系统通过kernel32中的GetProcAddress来实现的，但是我们病毒，还是只能自力更生</p><p>想要快速拿到一个API的入口地址，有一个简陋但快速的办法，它基于如下事实：一个系统中，所有进程加载的同一个DLL的加载基址是相同的。在Windows的设计中，因为某种原因（可能是共享代码段，避免重定位等），每个进程中，系统DLL都被加载在一个地址。</p><h4 id="如何利用DLL基址相同让病毒获取API首址？"><a href="#如何利用DLL基址相同让病毒获取API首址？" class="headerlink" title="如何利用DLL基址相同让病毒获取API首址？"></a>如何利用DLL基址相同让病毒获取API首址？</h4><p>只需要在C写的病毒代码中获取MessageBox的首址，然后把这个首址写入到我们病毒的数据区，这样病毒代码寄生到了原文件上时，就可以在自己的数据区获得MessageBox的首址。</p><p><img src="/posts/41006/23.png" alt></p><h3 id="如何判断是否是控制台程序"><a href="#如何判断是否是控制台程序" class="headerlink" title="如何判断是否是控制台程序"></a>如何判断是否是控制台程序</h3><p>在PE文件的可选映像头中，有一个字段可能能够用于识别PE文件是否为控制台程序，就是subsystem，对于大多数Win32程序，只有Windows GUI和Windows CUI两类值。G - Graphic的头字母，C - Console的头字母，因此，我们只需要判断subsystem字段的值，当其为2时才感染即可。</p><h3 id="病毒真正获取API函数地址的方法"><a href="#病毒真正获取API函数地址的方法" class="headerlink" title="病毒真正获取API函数地址的方法"></a>病毒真正获取API函数地址的方法</h3><h5 id="一、获取DLL基址"><a href="#一、获取DLL基址" class="headerlink" title="一、获取DLL基址"></a>一、获取DLL基址</h5><p>只有找到DLL基地址，我们才能找到它的导出表，才能找到所要调用函数的地址。以获取kernel32.dll的基址为例，其他dll模块的方法类似，这里介绍一个简单的获取kernel32.dll基址的方法，主要利用PEB结构（Process Environment Block，进程环境块）查找，每个进程都对应一个PEB。</p><p>首先，FS寄存器在偏移0x30处保存一个指针，指向PEB结构，<strong>FS:[0x30]</strong> -&gt; PEB。</p><p>然后，在PEB结构的偏移0x0C处保存着另外一个指针，该指针指向一个叫PEB_LDR_DATA的结构</p><p>这个PEB_LDR_DATA 偏移0C处是<strong>加载模块链表</strong>的头指针，由8个字节组成，前4个字节指向一个LDR_MODULE结构体（LDR_MDOULE代表一个模块，每一个模块（exe,dll）都对应一个这样的结构体），在该LDR_MODULE中，头4字节又指向下一个加载的LDR_MODULE结构体，由此组成链表。</p><p>在win7下，第一个加载的模块是是执行程序本身，第2个是NTDll，第3个就是kernel32，在结构体偏移0x18处就是所对应模块的基址。</p><p><strong>那如何在遍历的过程中识别模块呢？</strong> </p><p>在LDR_MODULE结构体偏移0x2C的地方，有一个成员BaseDllName，它有8个字节，其中后4字节为地址，指向一个unicode串（每个字符占2个字节），这个unicode串就是不包含路径的纯模块名。</p><p>遍历的结束条件是什么？Next指针为0或者ffffffff么？都不是，过调试我们可以发现，在win7下，加载模块链形成了一个循环链表，因此只要发现next块的头4字节是头块地址就停止遍历。</p><h5 id="二、获取DLL中的函数地址"><a href="#二、获取DLL中的函数地址" class="headerlink" title="二、获取DLL中的函数地址"></a>二、获取DLL中的函数地址</h5><p>找到基址后，我们必须手动完成由函数名获取其所在DLL中地址的过程，我们需要从DLL的实际基址入手，解析DLL的导出表，获取相关函数的入口地址。</p><h3 id="导出表—DLL对外暴露函数地址的机制"><a href="#导出表—DLL对外暴露函数地址的机制" class="headerlink" title="导出表—DLL对外暴露函数地址的机制"></a>导出表—DLL对外暴露函数地址的机制</h3><p>DLL对外暴露自己的函数有两种方式：</p><ul><li>函数名</li><li>序号</li></ul><p>可以通过函数名查找某函数入口，也可通过序号查找，但是，需要注意的是，函数名和序号并非一 一对应！</p><h4 id="序号查找"><a href="#序号查找" class="headerlink" title="序号查找"></a>序号查找</h4><p>序号查找的好处：快！高效！</p><p>我们可以用一个简单的hash完成，而不需要遍历，如果我们用一个数组（funcEntryTb）存储函数的入口地址。第0号函数的入口地址就存入数组的第一个元素funcEntryTb[0]，第1号函数的就存入数组的第2个元素funcEntryTb[1]。这样获取入口地址非常简单 ，即funcEntryTb[n]，n是函数的序号，也就是拿到数组首址funcEntryTb加偏移n*4（每个地址4个字节）即可。类似DOS下的中断向量表。</p><p>如果序号不是从0开始，而是从n开始，我们依然是将n对应函数的入口地址存入第一个元素，依次类推。获取第M（M肯定大于n，因为n最小）号函数的地址如下： funcEntryTb[m - n]。依然非常快速，计算次数固定，即拿到首址funcEntryTb，做一次减法m-n，再做一次乘法(m - n)*4就获取到元素的地址，取出其值保存值即可。这其实也是c语言switch语句出来case中序号和case分支入口地址的方法，所以一般switch比if else嵌套快</p><p>但是序号查找不够直观，同时也不够稳定</p><h4 id="用函数名查找"><a href="#用函数名查找" class="headerlink" title="用函数名查找"></a>用函数名查找</h4><p>用函数名查找：直观！具体！</p><p>最简单的办法就是一个一个函数名字串比较，找到相同的串。下面给出一个简单实现：函数名表的索引和函数地址表的索引是一一对应的。如果查找func2函数地址，我们先遍历函数名表，每遇到\0就是一个串，自然，在第2串处找到了字串func2，fun2是函数名表第2项，索引为1，然后我们用索引1在函数地址表中获得了address2，函数地址表4字节一个元素<strong>通过两个表相同的索引建立关联</strong>。</p><h4 id="两种机制结合"><a href="#两种机制结合" class="headerlink" title="两种机制结合"></a>两种机制结合</h4><p>如果用序号导出对应一个函数地址表，用名字导出也对应一个函数地址表，两个函数地址表显然会造成存储浪费，能否合成在一个函数地址表？</p><p>要实现合并需要满足：</p><ul><li>所有函数都有即有函数名又有序号</li><li>函数名表的索引和序号都是按1递增的</li><li>函数名表的排序还必须按照序号值排序，也就是说，如果一个函数的序号是x，它的函数名就必须排在函数名表的第x-1项</li></ul><p>限制太多，而且最重要的是，<strong>并不是每一个函数都向外暴露函数名！有的函数是没有暴露函数名的！</strong>实际上，DLL中有些函数是只有序号暴露，而没有函数名暴露的。而函数地址表是和序号对应的！这样，就导致函数名表索引是无法和函数地址表索引形成一一对应的关系。</p><p>若要解决类似的问题，就只能通过增加一个表描述对应关系。增加一个函数地址索引表，用它来记录函数名表索引到函数地址表索引的对应关系。</p><p>而按序号查找时，直接根据序号计算其在函数地址表的索引：<code>i=函数序号-最小的序号（n）</code>，然后在函数地址表中找到索引为i的项，取出地址即可。</p><p>导出表有表头（IMAGE_EXPORT_DIRECTORY）描述了导出表相关重要信息：</p><ol><li>Address Table RVA就是函数地址表的RVA</li><li>Ordinal Table RVA就是函数地址索引表的RVA，PE格式叫它序号表</li><li>Ordinal Base就是最小的序号，Number of names就是函数名表的条数</li></ol><p>PE格式将函数名表做了些变化，用了一个函数名指针表，Name Pointer Table RVA，它每项4个字节，存放了一个RVA，指向一个函数名的字符串</p><p><img src="/posts/41006/24.png" alt></p><h4 id="如何获取导出表的表头"><a href="#如何获取导出表的表头" class="headerlink" title="如何获取导出表的表头"></a>如何获取导出表的表头</h4><p>在模块的可选头中，最后有一个数据目录表<code>EXPORT Table</code>：数据目录表中的每一项都是一个重要的元素，包括导出表、导入表、重定位表等…每一个项都给出了相应元素的入口RVA和大小，其中，第一项就是重要的导出表。根据这个就能找到导出表的表头。</p><h4 id="导出函数查找算法"><a href="#导出函数查找算法" class="headerlink" title="导出函数查找算法"></a>导出函数查找算法</h4><ol><li><p>从DLL加载的<strong>实际基址</strong>获取可选头，从其中<strong>数据目录表</strong>的第一项找到导出表入口RVA</p></li><li><p>从导出表的表头获取Number of names，即查找的最大循环次数</p></li><li><p>循环遍历<strong>函数名指针表</strong>，比对每项RVA指向的字串是否为要找的函数名</p><p><code>函数名指针表1项4字节 à 对应的字符串地址</code></p></li><li><p>如果找到，记下此时函数名指针表项的索引，设为 i</p></li><li><p>根据索引 i，在<strong>序号表</strong>中找到对应项，获取其内容为n</p><p><code>序号表1项2字节</code></p></li><li><p>以n为索引在<strong>函数地址表</strong>中找到函数入口的RVA，加上DLL的实际基址即为函数的实际入口地址</p><p><code>地址表1项4字节</code></p></li></ol><p>注：以上算法中，所有访问实际地址的地方，就用<code>DLL的实际加载基址+RVA</code>即可</p><h2 id="第十三章-EPO技术指令Patch和导入表机制"><a href="#第十三章-EPO技术指令Patch和导入表机制" class="headerlink" title="第十三章-EPO技术指令Patch和导入表机制"></a>第十三章-EPO技术指令Patch和导入表机制</h2><h3 id="利用Patch指令的方式实现EPO"><a href="#利用Patch指令的方式实现EPO" class="headerlink" title="利用Patch指令的方式实现EPO"></a>利用Patch指令的方式实现EPO</h3><p><strong>核心问题：</strong></p><ol><li>找到一条指令，并知道其起始边界</li><li>最好这条指令必然执行，否则patch了，病毒代码也不会必然执行。</li></ol><p><strong>解决思路：</strong></p><ol><li>对一些常见特殊指令识别，比如PUSH EBP；MOV EBP, ESP等，这是很多函数的开始设定基址寄存器的组合。简单，方便。缺点：由于指令长度过短，可能和数据相同，因此不见得一定是指令；同时，不见得该代码一定会被执行</li><li>对导入函数的调用指令进行Patch，这些指令的可靠度很高，可以选择某些必然被调用的函数指令去Patch</li><li>病毒自带反汇编器（如一些开源反汇编器），静态分析宿主程序，随机找一条指令Patch，隐蔽度极高，复杂，但Patch的指令不一定会必然执行</li><li>自带调试功能（相当一个调试器），将宿主程序隐藏启动，单步调试运行，自然得到每条指令的边界</li></ol><h4 id="为什么Call要用相对偏移"><a href="#为什么Call要用相对偏移" class="headerlink" title="为什么Call要用相对偏移"></a>为什么Call要用相对偏移</h4><p>在前面，我们已经知道了加载可能出现与约定地址不吻合的问题（回想下PE头中的ImageBase字段），如果Call指令采用了绝对地址, 那么这条Call指令就会失效。</p><p>因此采用相对偏移Call就不会出问题，虽然加载基址变化，但整个模块是整体搬迁，call和被call之间的偏移却不变！所以无影响。</p><p>相对偏移的优点只能运用到同一个模块中（DLL，EXE），如果跨越了模块，调用DLL中的函数时，并不知道该模块会加载到哪里，因此，是不可能事先算出转跳偏移的，那怎么办？</p><p>这是在编译器和系统协助下，利用导入表机制完成了这个工作。简单说，就像为每个被调用的DLL函数都设定一个邮箱，系统加载了DLL后，利用导出表机制获得函数的地址（这个我们前面已经学习过了），然后将函数地址放到各自的邮箱中，这样，需要调某函数时，就从邮箱里拿到这个地址。</p><h3 id="理解导入表机制"><a href="#理解导入表机制" class="headerlink" title="理解导入表机制"></a>理解导入表机制</h3><p>在可选头的数据目录的第2项就是是导入表的描述，其中有导入表的RVA</p><p>RVA指向导入表（IMPORT DICTORY TABLE）起始，在这个地方，每一项是一个IMAGE_IMPORT_DESCRIPTOR结构，代表一个导入的DLL的相关信息。在这个结构中，又有：</p><blockquote><p> INT表（Import Name Table）和IAT表（Import Address Table）的RVA</p></blockquote><p><img src="/posts/41006/25.png" alt></p><p><img src="/posts/41006/26.png" alt></p><p>在一般情况下，INT（OriginalFirstThunk）和IAT（FirstThunk）的内容确实是相同的，因此，是冗余的。正是这个原因，为了节约空间，一些编译器（如Borland）不会生成INT，其RVA值为0。但是，这是在没有使用预先绑定导入地址的情况下，如果有预先绑定，则必须要有INT表，此时RVA不等于0。</p><p>由于程序在加载时，需要在IAT表中填入函数的加载地址入口，因此，往往会比较耗时，为了减少加载时间，于是有了预先绑定技术。</p><p>预先绑定技术是在编译时就向IAT表中填入导入地址（即函数的入口地址，而不是指向IMAGE_IMPORT_BY_NAME表项的RVA），它是直接根据系统DLL的预期基址（ImageBase）计算出来的。</p><p>通过预先绑定，在实际加载时，只要系统DLL的基址没有发生改变，那么IAT表的内容就不需要再次填充，因此，加载时速度更块。</p><p>所以，采用预先绑定，在实际加载时，需要验证DLL是否被加载到预期地址。如果，引用的DLL没加载到预期地址，那就必须再次填充IAT表为实际的函数地址。</p><p>这时，已经不能使用IAT表来指向IMAGE_IMPORT_BY_NAME表项了（编译时RVA已经被覆盖为函数预期入口地址），但INT表可以，通过INT表再次执行导入机制，从而使得IAT表内容更新。</p><p>这也就是为什么预先绑定时必须要有INT表的原因！</p><h2 id="第十四章-指令Patch实现与重定位表"><a href="#第十四章-指令Patch实现与重定位表" class="headerlink" title="第十四章-指令Patch实现与重定位表"></a>第十四章-指令Patch实现与重定位表</h2><h3 id="如何找到需要Patch的指令"><a href="#如何找到需要Patch的指令" class="headerlink" title="如何找到需要Patch的指令"></a>如何找到需要Patch的指令</h3><p>整体思路：</p><p>  为了找到需要Patch的指令，病毒可以采取以下的动作：</p><ol><li>首先指定一个会被大概率调用的函数名（也包括函数所在DLL的名字），如Kernel32中的GetCommandLineX，X=A/W</li><li>然后通过被寄生文件（exe）的导入表找到该函数的导入表项（即IAT中的对应项地址）的地址XXXX</li><li>最后去exe文件的代码中搜索所有可能的Call [XXXX] 或 JMP [XXXX]后，即 FF 15 XXXX 或 FF 25 XXXX </li></ol><p>详细来说：</p><ol><li>在文件中找到导入表的位置：先找到导入表的RVA，将RVA转换为导入表的文件位置</li><li>找到指定API函数在IAT表中的表项地址。先要找到API所在DLL对应的项，然后才能找到这个DLL所对应的INT和IAT表，比较dll的名字，判断是否是API函数所在DLL的导出表目录项，然后根据预先绑定，如果有INT就用INT表来找函数名，没有就用IAT表找函数名，获得INT表（或IAT表）的RVA，并将其转换为文件位置，遍历INT表（或IAT表）的每一项，查找指定的API函数名。</li><li>找到符合的指令进行Patch，先找到代码所在的节，判断节的属性是否有0x20，找到后开始循环遍历每个字节进行替换，并写入patch指令。</li></ol><h3 id="病毒执行部分的设计"><a href="#病毒执行部分的设计" class="headerlink" title="病毒执行部分的设计"></a>病毒执行部分的设计</h3><ol><li>我们准备patch调用GetCommandLineA或GetCommandLineW的函数，因为它们基本在入口处会被调用，这样可以保证病毒一开始就执行</li><li>为了防止函数再次调用时病毒再次执行，我们增加了一个标记</li><li>另外，感染时到底patch的是W还是A版的GetCommandLine，也有一个标记来告诉寄生的病毒代码，从而寄生病毒执行时才知道去找哪个函数的实际入口地址</li><li>寄生病毒执行时，找到函数地址后需要存储一下，因此，并分配了4字节存储GetCommandLineX（W/A）的入口地址。为了不修改老代码，数据区开始的原来13个字节没有删减，用于存放这3个信息。</li><li>在数据段增加了“GetCommandLineA”和” GetCommandLineW”串，因为要用getproc动态查找到其首址跳过去</li><li>增加了获取kernel32基址和获取GetCommandLineW/A的代码</li><li>最后用JMP指令跳到GetCommandLineW/A去</li></ol><p>关于最后跳转的问题，因为JMP跳转包含的地址是绝对地址（这是函数所对应的IAT表项的地址），如果在exe可重定位的情况下，这个xxxx地址是需要重定位的。然而，病毒尾部的这条Jmp [xxxx]是病毒添加的，因此，在重定位表中没有重定位项的，所以会出错。</p><blockquote><p> 解决的方法：添加重定位项或让exe不会重定位</p></blockquote><h3 id="利用IAT表项查找函数入口"><a href="#利用IAT表项查找函数入口" class="headerlink" title="利用IAT表项查找函数入口"></a>利用IAT表项查找函数入口</h3><p>除了修改节头的相关信息数据外，还要填充节直到长度达到要求</p><p>感染时填充数据区的预期加载地址，数据区的预期加载地址是：imagebase + 被感染节的起始RVA+virtualSize+5（自定位的call指令长度），数据区在call指令后</p><p>被调函数的IAT项的地址,Patch函数调用时，将获得IAT项地址返回，并将其作为参数传递给getCode函数，getCode函数将IAT项地址填入此处.</p><p>因为exe可能被重定位，所以IAT的地址可能变化，需利用病毒数据区的信息来定位IAT的实际地址。算法如下：</p><ol><li>call..pop自定位代码获取了数据区的地址A</li><li>数据区的预期加载地址=B= [A+1] </li><li>IAT表项的预期地址是[A+5]</li><li>IAT表项重定位后的实际地址是 IAT_addr – [A+5] = A – B</li><li>通过[IAT_addr]获得函数入口地址</li></ol><p>如此，则不需用再去调getproc查询函数入口地址</p><h3 id="PE文件的重定位机制"><a href="#PE文件的重定位机制" class="headerlink" title="PE文件的重定位机制"></a>PE文件的重定位机制</h3><p>程序因加载到非编译期约定地址时，就必需修改那些包含了绝对地址的指令（因为这些绝对地址已经不是原来的地址了），这称为程序重定位，由加载器（loader）完成</p><p>本来，exe是不需要重定位的，它是用户模块第一个进入进程空间的，它的约定加载基址，只要不过分（和系统DLL抢），都可以被满足</p><p>但因为为了对抗攻击和安全考虑，从VS2003开始，微软编译器缺省会将exe编译成可重定位模式</p><p>理解PE文件重定位的关键在于要解决两个问题：</p><ol><li>如何进行重定位呢？</li><li>加载器如何知晓哪些地方需要被重定位呢？</li></ol><h4 id="如何进行重定位"><a href="#如何进行重定位" class="headerlink" title="如何进行重定位"></a>如何进行重定位</h4><p>算法：</p><ol><li>实际和预期加载地址的差x = A – B。</li><li>找到需要修改的位置y</li><li>读出y开始4字节的值 + x = 新地址值z</li><li>将z写入y开始的4字节</li></ol><h4 id="如何知道哪些地方需要重定位"><a href="#如何知道哪些地方需要重定位" class="headerlink" title="如何知道哪些地方需要重定位"></a>如何知道哪些地方需要重定位</h4><ul><li>在可选头的数据目录中，有一项（第6项）就是重定位表，而重定位表中就记录了所有需要进行重定位修改的位置</li><li>因为被修改的都是地址值（32位机上4字节），所以在重定位表中，我们不需要记录每个修改位置要改多少字节，只需要记录被修改的位置即可，那么Loader每次就根据这个位置定位4字节进行修改（加上加载偏差）</li><li>需要重定位的区域以4096（2^12）字节（即16进制0x1000h）进行划分，在每个区域（Page）里面，每个需要重定位的位置都有相应的重定位项纪录了该位置离这个区域起始位置的偏移</li><li>针对每个区域，在重定位表中都有8字节的头部，其中前4个字节的值是这个<strong>重定位内存页的起始RVA</strong>，后4个字节是<strong>重定位块的长度</strong>（包括头和所有表项在内的字节数）</li><li>划分为区域后，重定位表中的每一项就只需要12位（1.5个字节）来表示地址，另外有0.5字节为属性（通常我们只能看见属性3，表示所指向的32位地址都需要修正）,即如300F，则00F为偏移。</li></ul><p>在我们Patch指令的过程中，我们将该指令修改为了不包含绝对地址的指令形式(即：Call 偏移，Jmp 偏移)，但并没有删除针对该指令的重定向项，那么重定位后，就会对这个重定位项指向的位置（即指向了我们Patch后的指令）进行修改，那么我们Patch后的指令就会被篡改！</p><blockquote><p>解决方法，让exe重定位项失效，或删除这些被Patch指令的重定位项</p></blockquote><h2 id="第十五章-反病毒技术简介"><a href="#第十五章-反病毒技术简介" class="headerlink" title="第十五章-反病毒技术简介"></a>第十五章-反病毒技术简介</h2><h3 id="反病毒技术的发展历程"><a href="#反病毒技术的发展历程" class="headerlink" title="反病毒技术的发展历程"></a>反病毒技术的发展历程</h3><p> <strong>第一代反病毒技术</strong></p><ul><li>采用单纯的病毒特征代码分析，清除染毒文件中的病毒</li></ul><p><strong>第二代反病毒技术</strong></p><ul><li>采用静态广谱特征扫描技术检测病毒，可以检测变形病毒，但是误报率高</li></ul><p><strong>第三代反病毒技术</strong></p><ul><li>将静态扫描技术和动态仿真跟踪技术结合起来，将查找病毒和清除病毒合二为一</li></ul><p><strong>第四代反病毒技术</strong></p><ul><li>基于病毒家族体系的命名规则、基于多位校验和扫描机理、启发式智能代码分析模块、动态数据还原模块、内存解毒模块、自身免疫模块等先进的解毒技术，较好的解决了以前防毒技术顾此失彼、此消彼长的状态，能够较好地完成查毒、解毒的任务</li></ul><h4 id="计算机病毒防治技术的划分"><a href="#计算机病毒防治技术的划分" class="headerlink" title="计算机病毒防治技术的划分"></a>计算机病毒防治技术的划分</h4><ul><li>病毒预防，防止病毒进入内存或阻止病毒对磁盘的操作</li><li>病毒检测，计算机病毒的判定</li><li>病毒消除，计算机病毒感染的逆过程，恢复被感染程序原有的结构信息</li><li>病毒免疫，可能并不存在通用的病毒免疫方法</li></ul><h4 id="病毒防治技术从被动到主动"><a href="#病毒防治技术从被动到主动" class="headerlink" title="病毒防治技术从被动到主动"></a>病毒防治技术从被动到主动</h4><ul><li>主动内核(Active K)技术，是在操作系统和网络的内核中嵌入反病毒功能，使反病毒成为系统本身的底层模块，实现各种反毒模块与操作系统和网络无缝连接，而不是一个系统外部的应用软件</li><li>主动内核技术能够实时监控整个系统的运行，并在病毒突破计算机系统软、硬件的瞬间发生作用</li></ul><h4 id="计算机病毒防范的概念"><a href="#计算机病毒防范的概念" class="headerlink" title="计算机病毒防范的概念"></a>计算机病毒防范的概念</h4><ul><li>计算机病毒的防范，就是要在<strong>病毒执行之前</strong>进行阻断，需要监视、跟踪系统内类似的操作，提供对系统的保护，最大限度地避免各种计算机病毒的传染破坏，往往需要基于全系统的<strong>内核级行为监控</strong></li></ul><h4 id="计算机病毒的预防措施"><a href="#计算机病毒的预防措施" class="headerlink" title="计算机病毒的预防措施"></a>计算机病毒的预防措施</h4><p>计算机病毒的预防措施可概括为两点</p><ul><li>勤备份</li><li>严防守</li></ul><h4 id="计算机检测技术分类"><a href="#计算机检测技术分类" class="headerlink" title="计算机检测技术分类"></a>计算机检测技术分类</h4><p>检测计算机病毒的方法通常有两种：</p><ol><li><p>手工检测</p><p>优点：可以剖析病毒、可以检测一些自动检测工具不能识别的新病毒</p><p>缺点：费时费力，复杂</p></li><li><p>自动检测</p><p>优点：可方便地检测大量的病毒</p><p>缺点：自动检测工具的发展总是滞后于病毒的发展</p></li></ol><h3 id="常见计算机病毒的诊断方法及原理"><a href="#常见计算机病毒的诊断方法及原理" class="headerlink" title="常见计算机病毒的诊断方法及原理"></a>常见计算机病毒的诊断方法及原理</h3><p><strong>一、比较诊断法</strong></p><p>用原始的正常备份与被检测的内容进行比较</p><p><strong>优点</strong>：比较法不需要专用的反病毒软件，且可以检测未知病毒</p><p><strong>缺点：</strong></p><p>- 该方法依赖与未染病毒时的原始系统的备份</p><p>- 且无法知道病毒的种类名称</p><p>- 易于误报</p><p><strong>二、校验和诊断法</strong></p><p>根据正常文件的信息计算其校验和（checksum），计算新的校验和与原来保存的校验和是否一致</p><p>运用校验和法查病毒一般采用三种方式：</p><ol><li>对被查的对象文件计算其正常状态的校验和，将校验和值写入被查文件中或检测工具中，而后进行比较</li><li>在应用程序中，放入校验和法自我检查功能，实现应用程序的自检测</li><li>将校验和检查程序常驻内存，每当应用程序开始运行时，自动比较检查应用程序内部或其他文件中预先保存的校验和</li></ol><p><strong>优点：</strong>校验和法既能发现已知病毒，也能发现未知病毒</p><p><strong>缺点</strong>：不能识别病毒种类与名称，对某些对文件信息影响不大的病毒效果较差，如链式病毒；同比较法一样，病毒感染并不是文件改变的唯一原因，所以此法会产生误报</p><p><strong>三、扫描诊断法</strong></p><p><strong>原理</strong>：扫描法是用每一种病毒体含有的特定病毒码(Virus Pattern)对被检测的对象进行扫描。如果在被检测对象内部发现了某一种特定病毒码，就表明发现了该病毒码所代表的病毒</p><p> - 特征代码扫描法</p><p> - 特征字扫描法</p><p>特定病毒码：当杀毒软件公司收集到新病毒中，就会从病毒程序中截取一小段独一无二且足以标记该病毒的二进制程序码（就好比犯人的指纹）</p><p>扫描法的软件通常由两部分组成：</p><p> - 病毒代码库，库中特征码的数量决定了扫描程序的识别能力</p><p> - 扫描程序（Scanner）</p><p>扫描法是当前最普遍的病毒检测方法，扫描法的核心——病毒特征码的选择</p><p>特征码选择的原则：</p><p>1.具有代表性：小的病毒一百多字节，长的10KB</p><p>2.不应包含数据区，数据区是可变的</p><p>3.特征码的长度：过长带来扫码时间和空间的开销过大，过短则不易具有代表性（两个相互矛盾的目标）</p><p>4.具有区分性：能区别该病毒和其他病毒，更重要的是要能区分病毒和正常程序，避免误报！</p><p><strong>优点</strong>：</p><p>使用方便；特征码选择好则误报率低、选择不好则误报率高</p><p>不用专门查毒软件；可识别病毒名称和类别；可做扫毒处理</p><p><strong>缺点</strong>：</p><p>特征码的生成难度很大；扫描需要开销；需要不断更新病毒特征码库</p><p>不易识别多态变形病毒、不能检测未知病毒等</p><p><strong>四、行为监测诊断法</strong></p><p><strong>原理</strong>：利用病毒的特有行为特性监测病毒的方法，称为行为监测法</p><p><strong>优点</strong>：即能发现已知病毒，也能发现未知病毒</p><p><strong>缺点</strong>：误报，不能识别病毒名称和种类，需要病毒运行以后才能进行分析</p><p><strong>五、感染实验诊断法</strong></p><p><strong>原理</strong>：利用病毒最基本的特征——感染特征，所有病毒都会进行感染，如果不感染，就不称其为病毒</p><p>当系统中出现了异常行为，最新版的检测工具也查不出病毒时，就可以做感染实验，其方法是：</p><p>将正常的文件放入异常的系统中去运行，看这些正常文件是否会被感染，如果被感染，则文件内容会发生变化（通过校验和等检测），则断言系统中存在病毒</p><p><strong>优点</strong>：可以发现未知的病毒</p><p><strong>缺点</strong>：实验开销大，实用性较差</p><p><strong>六、软件模拟诊断法</strong></p><p>多态病毒每次感染都变化其病毒代码，对付这种病毒，特征码扫描法失效。我们把使用通常特征码扫描法无法检测（或几乎很难检测）的病毒称之为多态病毒。但是，每一个多态病毒在执行时都需要还原，如先执行一段解密代码进行解密，再执行解密后的病毒代码。</p><p>通过在一个模拟的虚拟环境下运行计算机病毒，等待计算机病毒自身进行解密完成后，再对解密后的病毒代码实施特征码的识别，识别病毒种类后再进行有相关的清除和查杀工作。</p><p><strong>七、分析诊断法</strong></p><p>分析法一般只被专业反病毒技术人员使用，使用分析法的目的在于：</p><p> - 确认被观察的引导扇区和程序中是否含有病毒 </p><p> - 确认病毒的类型和种类，判定其是否是一种新病毒</p><p> - 搞清楚病毒体的大致结构，提取特征识别用的字符串或特征字，并增添到病毒代码库供病毒扫描和识别程序使</p><p> - 详细分析病毒代码，为制定相应的反病毒措施制定方案</p><p>分析法是任何一个性能优良的反病毒系统研发所必须的，它是对病毒进行详尽认真的分析，专业人员需要了解PE文件格式、病毒的核心技术原理、汇编语言、Windows程序设计、软件调试方法等相关知识，还需要进行病毒样本收集、系统漏洞分析等工作。</p><p>分析法通常包括静态分析和动态调试两个步骤，Windows上一般的调试工具主要有OD、WinDBG、X64DBG等，对复杂的病毒程序，必须采用动、静结合的分析方法。</p><h3 id="启发式代码扫描技术"><a href="#启发式代码扫描技术" class="headerlink" title="启发式代码扫描技术"></a>启发式代码扫描技术</h3><p>启发式代码扫描技术是对传统的特征码扫描技术的改进，来源于人工智能技术</p><p><strong>原理</strong>：启发式代码扫描技术基于给定的判断规则和定义的扫描技术，若发现被扫描程序中存在可疑的程序功能指令，则作出存在病毒的预警或判断。</p><ol><li>可疑程序功能的权值定义</li><li>可疑程序的报警标准</li><li>可疑功能的标志</li></ol><h3 id="虚拟机查毒技术"><a href="#虚拟机查毒技术" class="headerlink" title="虚拟机查毒技术"></a>虚拟机查毒技术</h3><p>全虚拟化技术：虚拟的操作系统，与底层的硬件完全隔离，完全由中间的Hypervisor层（VMM）完成指令转换和资源映射，典型的代表有Vmware，WorkStation，Microsoft Virtual Server等</p><p>半虚拟化技术：需要在虚拟机的操作系统中加入特定的虚拟化指令（Hypercalls），通过这些加入的指令来调用硬件资源，免除了一部分Hypervisor层转换指令的开销。典型的代表有Xen等。</p><p>查毒的虚拟机是一个软件模拟的CPU，它可以象真正CPU一样取指令、译码、执行，可以模拟一段代码在真正CPU上运行得到的结果</p><p><strong>原理</strong>：虚拟机查毒实际上是自动跟踪病毒入口的解密代码，当其将加密的病毒体按其解密算法进行解密后，就可以得到解密后的病毒明文，虚拟执行技术使用范围远不止脱壳解密，它还可以应用在跨平台高级语言解释器、恶意代码分析、调试器等</p><p>目前有两种方法可以跟踪控制病毒的每一步执行，并能够在病毒循环解密结束后从内存中读出病毒体明文</p><ol><li>单步和断点跟踪法，和目前一些程序调试器相类似：易于被病毒发觉</li><li>虚拟执行法：  控制权永远掌握在虚拟机手中，但完全模拟CPU的运行并非易事，虚拟执行法的意味必须在虚拟机内部处理所有指令的执行，这就需要具有大量的特定指令处理函数来模拟每种指令的执行效果，因此，虚拟机必须要保证模拟结果的正确性，但同时不可能被病毒察觉，且做到了完全虚拟执行</li></ol><p>虚拟机模拟指令执行的设计方案：</p><ol><li>自含代码虚拟机(SCCE)：类似真正的CPU</li><li>缓冲代码虚拟机(BCE)：进行了特殊指令和非特殊指令的区分</li><li>有限代码虚拟机(LCE)：只简单地跟踪一段代码的寄存器内容</li></ol><h4 id="反虚拟执行技术"><a href="#反虚拟执行技术" class="headerlink" title="反虚拟执行技术"></a>反虚拟执行技术</h4><p>1.<strong>插入特殊指令技术</strong></p><p><strong>原理</strong>：虚拟机是模拟CPU的执行，并不是真正的CPU，所以不可以能对整个Intel的指令集进行支持，遇到不认识的指令就会停止工作</p><p><strong>应对</strong>：不需要针对每个特殊指令写专门的模拟函数，只需要构建特殊指令的指令长度表，当EIP指向特殊指令时，就跳过特殊指令长度，或者发现这些特殊指令时，交由CPU去真正执行</p><p>2.<strong>结构化异常处理技术</strong></p><p><strong>原理</strong>：虚拟机仅仅模拟了CPU的工作过程，而对于异常处理等系统机制没有进行处理，虚拟机会在遇到非法指令、进入异常处理函数前停止工作</p><p><strong>应对</strong>：为虚拟机赋予发现和记录异常的功能，并在引发异常时将控制转向异常处理函数</p><p><strong>3.</strong> <strong>入口点模糊技术（EPO）</strong></p><p><strong>原理</strong>：即便是虚拟执行，也不可能查找文件的所有代码，虚拟执行通常会在规定步数内，检查待查文件是否具有解密循环，如果没有，就会判定该文件没有携带加密变形病毒，产生漏报</p><p><strong>应对</strong>：合理的增加检查的规定步数，如果规定步数较小，极易产生漏报，但规定步数也不能盲目增加，否则会无谓增加检测时间，如何确定规定步数的大小实在是件难事</p><p><strong>4.</strong> <strong>多线程技术</strong></p><p><strong>原理</strong>：虚拟对于模拟启动多线程的工作很难与真实效果一致，多线程切换需要交由下层操作系统负责管理，虚拟机只能在被执行线程独占CPU时间</p><p><strong>应对</strong>：改进虚拟机，支持这些特定的操作系统机制</p><h3 id="病毒实时监控技术"><a href="#病毒实时监控技术" class="headerlink" title="病毒实时监控技术"></a><strong>病毒实时监控技术</strong></h3><p>病毒实时监控本质上是一个文件监视器：</p><p><strong>原理</strong>：在文件打开、关闭、清除、写入等操作时检查文件是否是病毒携带者，如果是则根据用户的决定选择不同的处理方案，如清除病毒、禁止访问该文件、删除该文件或简单地忽略，从而有效地避免病毒在本地计算机上的感染传播</p><p>可执行文件装入器在装入一个文件执行时首先会要求打开该文件，而这个请求又一定会被实时监控在第一时间截获到，它确保了每次执行的都是干净的不带毒的文件从而不给病毒以任何执行和发作的机会</p><h3 id="计算机病毒的清除"><a href="#计算机病毒的清除" class="headerlink" title="计算机病毒的清除"></a>计算机病毒的清除</h3><p>引导型病毒感染时常攻击计算机的如下部位：</p><ol><li><p>硬盘主引导扇区</p></li><li><p>硬盘或软盘的BOOT扇区</p><p>为保存原主引导扇区、BOOT扇区，病毒可能随意地将它们写入其他扇区，而彻底毁坏这些扇区中的信息</p><p>引导型病毒发作时，执行破坏行为造成种种损失</p><p>由于引导型病毒一般是常驻内存的，因此，清除病毒之前必须先清除内存中的病毒(或采用修复中断向量表等方法将其灭活)，否则难以清除干净</p></li></ol><h3 id="计算机病毒免疫技术"><a href="#计算机病毒免疫技术" class="headerlink" title="计算机病毒免疫技术"></a>计算机病毒免疫技术</h3><p><strong>重入检测和病毒免疫</strong></p><p>  大部分驻留内存的病毒会在加载病毒代码之前，检查系统的内存状态，判断内存中是否有病毒，若存在(自身已被加载)，则不再加载病毒代码</p><p>  感染文件之前，查看文件的状态(一般是查看感染标志)，检查该文件是否已被感染，如果被感染了则不再重复感染</p><p>   病毒的这种重入检测机制导致了一种反病毒技术的出现，也就是形形色色的免疫程序：利用免疫程序设置内存的状态、设置CPU的状态或者设置文件的一些特征，从而防止某种特定的病毒进入系统</p><p>目前常用的免疫方法有两种：</p><ol><li><p>针对某一种病毒进行的计算机病毒免疫</p></li><li><p>基于自我完整性检查的计算机病毒免疫</p></li></ol><h2 id="不负责猜题"><a href="#不负责猜题" class="headerlink" title="不负责猜题"></a>不负责猜题</h2><p>计算机病毒的定义?</p><blockquote><p>编制或者在计算机程序中<strong>插入</strong>的破坏计算机功能或者毁坏数据，影响计算机使用，并能自我复制的一组计算机指令或者程序代码。</p></blockquote><p>病毒的基本特征？</p><ul><li>传染性</li><li>隐蔽性</li><li>可触发性</li><li>其他一些基本特性<ul><li>破坏性</li><li>针对性</li><li>不可预见性</li><li>寄生性</li><li>衍生性</li><li>持久性</li></ul></li></ul><p>计算机病毒的本质属性?</p><blockquote><p>人为的<strong>特制程序</strong>是任何计算机病毒的<strong>固有本质属性</strong></p><p>程序性的<strong>客观性</strong>决定了计算机病毒的可防治性和可清除性</p><p><strong>人为性</strong>的<strong>主观性</strong>导致计算机病毒各异多变</p></blockquote><p>木马和蠕虫的概念：</p><blockquote><p>蠕虫:独立的可执行程序, 不需要寄生在宿主程序中，通过网络分发自己的副本，工作方式为：漏洞扫描、远程攻击、迁移传染、现场处理</p><p>木马：在远程计算机之间建立连接，使得远程计算机能通过网络控制本地计算机的非法程序。木马系统软件一般由木马配置程序、控制程序和木马程序(服务端)三部分组成。</p></blockquote><p>小端机和大端机？</p><blockquote><p>整数逻辑上的最低字节放在内存的最低地址，次低字节放内存的次低地址，依次存放。比如，0x12345678（12为高位）放在内存中就是78 56 34 12(最左边为低字节)。大端机则相反</p></blockquote><p>JMP指令计算偏移量？</p><blockquote><p>从JMP指令的开始计算，直接加5。或者说是从JMP的下一条开始的指令算起被减数。</p></blockquote><p>文件系统（重点）</p><blockquote><p>一个FAT9个扇区，引导扇区1个，根目录区有224条记录，一个记录32字节，一个表项1.5字节</p><ul><li>数据区中存放用户数据,是文件和子目录数据真正存放的区域</li><li>根目录区中存放的是文件目录表,为记录根目录文件项的表，文件项包括文件，目录。通过它可以查找到根目录下的文件和目录信息，比名称，大小，日期等</li><li>FAT12为<strong>文件分配表</strong>（FAT（File Allocation Table））：记录已分配的扇区和可用扇区，并通过链表依序记录一个文件占用的扇区,另外一个FAT12为备用的FAT表</li><li><strong>引导扇区</strong>（DBR （DOS Boot Record））：记录磁盘和文件系统相关的各种参数，比如扇区大小，一簇的扇区数等</li></ul></blockquote><p><strong>如何定位一个文件？</strong></p><blockquote><p>FAT12文件系统中，FAT表以3个<strong>半字节</strong>（3*0.5 Byte = 1.5 Byte = 12 bit）来记录一个簇的相关情况，这也是“FAT12“文件系统中命名12的原因。</p><p>FAT表的本质是磁盘簇分配情况的数据表示，FAT表中每3个半字节为一个元素，这个元素就代表一个簇，簇号从0开始，这个元素中存放的整数值表示其链接的下一簇的簇号</p></blockquote><ul><li>查找和遍历</li></ul><blockquote><p>类似于链表的查找，以FFF为结尾，FAT12默认设置引导区占一个扇区，FAT1于其后，同时FAT表开始的3个字节没用于用户文件分配，3字节有2组12bits所以，占用了0,1两个簇号，用户的数据从簇2开始分配。</p><p>随后FAT表从头开始按3字节分成一组，但是有一点需要特别注意：</p><p>在这3个字节中，用第2字节的低半字节和第1字节形成整数表示一个簇号，用第2字节的高半字节和第3字节形成的整数来表示另一个簇号</p><p>由上面学习的内容知道，在FAT表中想要开始遍历就必须知道首簇号，而首簇号位于根目录区域中。</p></blockquote><blockquote><p>计算根目录区的起始位置为：<strong>[ 1（Boot区扇区数）+2（FAT数目）*9（FAT扇区数）] * 512 = 0x2600</strong></p><p>每一条记录，从该记录开始偏移0xB处有个字节指示出文件的类型，对于多级目录来说，则是存放在数据区内，原理和根目录查找目录类似，只不过是多层嵌套，查找到的是另一个目录表。</p></blockquote><p>查找<strong>a:\tem\tem.txt</strong>为例：</p><p><img src="/posts/41006/2.png" alt></p><p>如何恢复只有一个簇的文件？</p><blockquote><p>文件内容不会因删除而改动。而对应文件的项只是将第一个字节改成E5，其首簇段的值也不会该动</p><p>在目录表中找到E5开始的相关文件名，从该项的首簇字段（0x1A）获得首簇，然后，在FAT表中对应的簇项改成FFF即可</p></blockquote><p><strong>FAT12和FAT32的区别</strong></p><blockquote><ul><li>FAT32的一个重要不同在于<strong>取消了根目录区</strong>，根目录在用户区，且FAT32引导记录中有一个指向根目录区的首簇字段</li><li>fat32支持长文件名而fat12不支持(FAT12文件名固定11字节，其中3字节用于后缀)</li><li>fat12一个表项占1.5个字节而fat32一个表项占4个字节</li><li>fat32有保留区而fat12没有</li><li>FAT32的记录项中的首簇号，由两个字段构成，分别代表高位两字节和低位两字节</li></ul></blockquote><p>硬盘数据结构</p><p>MBR和EBR</p><blockquote><p><strong>扩展分区</strong>核心思想是：形成一个分区链，MBR定义的主分区表本来有4条分区记录，用一条描述自己分区的信息，用剩余的指向下一个分区。</p><p>为了完全兼容MBR的格式，EBR完全复用了引导扇区的格式，即起始446字节给引导记录EBR，但在EBR中，这些内容全为0。</p><p>主分区的相对扇区相对于MBR，通过MBR和相对扇区就可以定位每一个主分区</p></blockquote><p><img src="/posts/41006/7.png" alt></p><blockquote><p>首先找到C盘，找到主引导扇区的分区表，找到分区的相对偏移扇区数，扩展分区1是MBR的主扩展分区，它的EBR放在主扩展分区的开始处</p><p>找到扩展分区1的EBR。</p><p>随后查找扩展分区1上的基本分区E盘，</p><p>同理查找扩展分区2的EBR和分区表</p><p>最后利用相对偏移字段和首部偏移查找F盘的起始位置</p><p>注意EBR是相对于包含该分区表的扩展区开始处而言（扩展分区开始处为其EBR），在扩展分区的分区表中，第一项的偏移指向的是盘区，第二项的偏移指向的是下一个扩展分区开始处（也就是下一个扩展分区的EBR）</p></blockquote><p>硬盘的引导过程</p><p>分区表项的第一个字节0x80表示激活</p><blockquote><ul><li>开机加电自检：开机，CPU跳到内存FFFF:0000处，由该处的一条JMP指令跳到BIOS的自检程序（POST），自检通过后，加载引导程序（与操作系统无关的MBR，按用户在BIOS中的指定顺序，硬盘、软盘、光驱或U盘等</li><li>读主引导扇区：将主引导扇区MBR读入到内存的0000:7C00，扫描主分区表，搜索激活分区，分区表项第一个字节为0x80表示激活分区</li><li>读激活分区引导扇区 ：如果有多个激活分区或没有，报错结束。否则读取激活分区引导扇区到0000:7c00</li><li>操作系统引导代码引导系统并读取操作系统初始化文件</li></ul></blockquote><p>MBR代码拷贝的问题</p><blockquote><p>MBR的这段代码会被加载到7C00处，这段代码的主要任务是什么呢？是找到激活分区（如C盘）并将真正C盘的引导扇区加载到7C00处（也就是拷贝），这必然覆盖已经在内存7C00处的MBR自己，当自己正在拷贝的另外的指令覆盖自己时，必然破坏了自己的指令执行逻辑。</p><p> 所以，要错开<strong>MBR引导程序</strong>和<strong>激活分区引导程序</strong>占用的内存空间范围，让MBR的引导程序在600h执行，而它拷贝的激活分区引导程序将在7C00h执行</p></blockquote><p>头插入病毒遇到的问题</p><blockquote><p>需要去掉病毒代码最后的RET指令，否则原本的COM文件得不到执行机会</p><p>病毒代码执行结束后需用一条JMP指令跳过病毒数据区</p><p>加载后的实际内存位置后移, 后移长度就是virus.com的机器码长度</p><p>将源程序复制到原先的位置时候需要避免自我覆盖</p></blockquote><p>尾插入中的思路</p><blockquote><p>1） 构造一个打印的正常代码normal.com</p><p>2）构造一个寄生在normal.com尾部的病毒代码virus.com</p><p>3）用DOS的拷贝命令将两个编译好的程序粘起来</p><p>4）将normal.com开始的3字节作为数据保存到virus.com的代码某部分，然后将normal.com开始的3字节修改（先用UE手动修改）为JMP XXXX（跳到virus.com指令处）。</p><p>5）virus.com打印“I am virus”后，将normal.com开始的3字节进行还原，并JMP到normal.com开始，将执行权限交给normal.com</p></blockquote><p>为什么计算机病毒往往需要重定位技术？病毒重定位技术的关键技术原理是什么？以下重定位代码中，语句（1）-（4）在变量Message重定位过程中发挥的作用分别是什么？</p><pre><code>（1） call base base:（2） pop bp（3） sub bp, base​     mov ax, bp（4） add ax, Message</code></pre><blockquote><p>病毒的寄生会导致指令所在位置发生变化，从而导致预期加载地址和实际地址不一致的情况；知道一条指令<strong>运行时的地址值</strong>和<strong>编译时的地址值</strong>，相减即可；</p><p>Call指令的下一条指令是pop ax，call执行时，首先会把pop ax指令的IP（即pop ax这条指令的实际地址）<strong>压栈</strong>，然后根据<strong>相对偏移</strong>跳到标号here处；</p><p>标号base处就是pop bp指令，执行这条<strong>出栈</strong>指令会把栈中数据放入bp中，也就是pop bp指令的IP，利用栈获得了IP的值</p><p>Sub语句中的标号base在编译时就生成了地址，但是是<strong>预期地址</strong>,现在，实际地址-预期地址，ax中放的就是加载偏差了</p><p>将编译期要用的的地址，比如字串的首址加上ax就是字串实际地址了</p></blockquote><p>逆插入病毒</p><blockquote><p>与前面不同，我们需要添加一段完成感染寄生的代码，但这段代码自身不寄生在原文件上，它只需要完成以下功能：</p><p>1.把正常程序向后拷贝HdrVirus长度</p><p>2.把HdrVirus部分拷贝到前面</p><p>3.把EndVirus部分拷贝到后面</p></blockquote><p><img src="/posts/41006/9.png" alt></p><blockquote><p>头病毒部分因为存在加载偏差,需要重定位,并且需要为尾病毒拷贝设置参数.</p><p>重定位有关的代码在头病毒部分已经设置完成,因此不需要额外设置.</p></blockquote><p>感染部分思路</p><blockquote><p>1 ）获取原文件大小，后续写入需要</p><p>-———————————————</p><p>2 ）将原文件扩容，增加hdrvirusSize（头病毒部分长度）个字节，通过在原文件的尾部写字节完成</p><p>-———————————————</p><p>3 ）原文件向后拷贝hdrvirusSize长度，腾出空间给头病毒部分。注意：原文件应从尾至头完成拷贝，如果采取从头至尾的拷贝，则当原文件大小&gt;移动长度时，就会产生覆盖</p><p>-———————————————</p><p>4）将HdrVirus部分写入头部</p><p>-———————————————</p><p>5）将EndVirus部分写入尾部</p><p>不用事先扩容，写直接完成扩容</p></blockquote><p>引导型病毒</p><blockquote><p><strong>执行过程：</strong>病毒先把自己加载到7C00h，然后又把原引导程序拷贝到7C00h，这个过程会出现什么问题？就是前面遇见的<strong>自我覆盖</strong>问题，所以需要将病毒中执行拷贝的指令段移出被覆盖的区域。我们可以将它后移一个扇区7e00h处</p><p><strong>感染过程：</strong>感染会将原引导扇区的内容一直放到簇2，如何避免后续使用占用簇2，破坏了病毒的逻辑？可以修改FAT1和FAT2表，将簇2的项改成不可使用，如果改为已占用FFF，但却没有对应的目录项，是可疑的，因此，可以改为坏簇FF7，从而防止别人使用它。这些感染，为了简单，没有采用汇编访问硬盘的方式，而是采用C语言来直接修改软盘文件。</p></blockquote><p>中断替换</p><blockquote><p>病毒篡改中断向量表内容指向Hook，Hook函数执行完自己的逻辑后在正常跳回到中断处理程序处，并将原地址协会中断向量表中，当病毒和中断向量表在<strong>不同的段</strong>时，约定AX放段内偏移，CX放段地址。若需要内存驻留则直接调用DOS提供的驻留退出中断int 27h</p></blockquote><p>链式病毒思路</p><blockquote><p>病毒在感染时，完全不改变宿主程序本体，而是改动或利用与宿主程序相关的信息，将病毒程序与宿主程序连成一体。</p><p><strong>一、感染部分</strong></p><ul><li>被感染文件的真实起始扇区号写到<code>目录表项的保留区</code>（目录项的保留区从目录项头第13个字节即偏移0ch开始，共10字节）</li><li>修改被感染文件的目录项的<code>起始扇区字段</code>指向病毒文件的首簇</li><li>目录项中的<code>文件大小字段</code>也要修改成病毒的真实大小，这样才能保证病毒能被完整加载</li><li>将原来病毒文件的目录项全部32字节改为0，这样从外部看就不存在这个病毒文件，也没有对应的目录项了</li></ul><p><strong>二、执行部分</strong></p><ul><li>病毒运行后，先获取被<code>感染程序的名字</code></li><li>然后从根目录寻找<code>被感染程序的目录项</code></li><li>找到后从该目录项的保留区获取<code>被感染程序的首簇号</code></li><li>找到被感染程序所在簇（即扇区），加载该扇区到内存</li></ul></blockquote><p>PE结构，如何从一个PE文件中找到程序入口的文件地址的方法</p><p><img src="/posts/41006/19.png" alt></p><blockquote><p>寻找可选头中的 AddressOfEntryPoint，利用RVA找到该值所属的节，如果该节的起始RVA和该节的起始文件偏移相等则直接作为偏移，否则利用偏移量计算出新的值</p><p>（入口点的RVA（AddressOfEntryPoint）- 节的RVA = 入口点的FOA - 节的起始文件位置（PointerToRawData） )</p><p>随后寻找可选头中另外一个字段<strong>ImageBase</strong>，即程序约定加载地址，该地址加上入口点偏移</p><p>程序入口地址VA：ImageBase+AddressOfEntryPoint</p></blockquote><p>RVA和FOA的联系与区别</p><blockquote><ul><li>RVA是内存的相对位置，相对的是加载到内存的基地地址</li><li>FOA是文件中的相对位置，相对的是文件开始位置（即0）</li></ul></blockquote><p>用程序完成末段大小不变的寄生</p><blockquote><ol><li><p>生成需要寄生的病毒代码</p></li><li><p>获得被感染文件的NT头</p><ol><li>利用DOS头的e_lfanew字段（文件定位）</li><li>定位NT头，读到ntHrds（文件定位读）</li></ol></li><li><p>找到最后一个节判断是否具有空洞</p><ol><li><p>如何判断节是否有空洞？</p><p><strong>virtualSize &lt; SizeofRawData</strong></p></li><li><p>这些信息在哪里？</p><p><strong>最后一个节的节表项中</strong></p></li><li><p>当前的文件指针在什么地方？</p><p><strong>之前读了NT头，现在在NT头的后面也就是节表的起始文件位置</strong></p></li></ol></li><li><p>修改最后一个节VirtualSize写入病毒</p></li><li><p>修改SizeofImage和EntryPoint</p></li></ol></blockquote><p>入口点模糊技术(Entry Point Obscuring)</p><blockquote><p>每个节的节表项有一个characteristics属性,说明了该节是干什么的,当IMAGE_SCN_CNT_CODE为20时说明是代码节. EPO技术能够让病毒代码隐藏自己入口点，避免被查杀,使得被病毒修改后的入口点看起来依然就像是正常的入口点.</p><p>解决入口点不在代码段的问题，我们可以采用下2种解决方法：</p><p>1）不感染最后一节，直接感染代码节，病毒代码附着在代码节的尾部，再修改入口点。这样虽然修改了入口点，但让入口点处于代码节</p><p>2）不修改入口点，但将入口点所在的指令替换成一条JMP指令，跳往到寄生的病毒代码</p></blockquote><p>感染在代码节的空洞</p><blockquote><ol><li><p>生成需要寄生的病毒代码</p></li><li><p>获得被感染文件的NT头</p></li><li><p>找到代码节并判断是否具有空洞</p><p>如何找到代码节？遍历所有节表项并判断节表项的属性是否有20属性</p></li><li><p>修改VirtualSize写入病毒</p></li><li><p>修改SizeofImage和EntryPoint</p></li></ol></blockquote><p>感染最后节并替换入口指令</p><blockquote><ol><li>修改原入口点的数据为JMP指令</li><li>保存被覆盖的5个字节</li><li>执行逻辑</li><li>恢复这5个字节<ul><li>源地址就是被覆盖的5个字节，放在数据区，所以我们把可以把<strong>数据区的起始地址</strong>也作为数据放入数据区</li><li>目的地址是原程序的<strong>入口点地址</strong>，寄生后，病毒的main函数就结束了，所以这个<strong>入口点地址</strong>也需要写入数据区时</li></ul></li><li>最后一条JMP跳回原入口点</li></ol></blockquote><p>ImageBase是程序<strong>预期</strong>加载的基地址，win7系统和vs编译器往往都采用了随机地址空间技术，使得程序即每次加载的<strong>实际</strong>地址并不是ImageBase，原文件有重定位表这样的机制帮助重定位，但病毒只能利用前面我们学到的<strong>自定位</strong>技术原理。</p><p>病毒真正获取API函数地址的方法</p><blockquote><p>一、获取DLL基址</p><p>只有找到DLL基地址，我们才能找到它的导出表，才能找到所要调用函数的地址,利用PEB结构（Process Environment Block，进程环境块）查找，每个进程都对应一个PEB。然后，PEB结构保存着另外一个指针，该指针指向一个叫PEB_LDR_DATA的结构</p><p>这个PEB_LDR_DATA 偏移0C处是<strong>加载模块链表</strong>的头指针，由8个字节组成，前4个字节指向一个LDR_MODULE结构体（LDR_MDOULE代表一个模块，每一个模块（exe,dll）都对应一个这样的结构体），在该LDR_MODULE中，头4字节又指向下一个加载的LDR_MODULE结构体，由此组成链表。</p><p>在win7下，第一个加载的模块是是执行程序本身，第2个是NTDll，第3个就是kernel32，在结构体偏移0x18处就是所对应模块的基址。</p><p><strong>那如何在遍历的过程中识别模块呢？</strong></p><p>在LDR_MODULE结构体偏移0x2C的地方，有一个成员BaseDllName，它有8个字节，其中后4字节为地址，指向一个unicode串（每个字符占2个字节），这个unicode串就是不包含路径的纯模块名。</p><p>遍历的结束条件是什么？Next指针为0或者ffffffff么？都不是，过调试我们可以发现，在win7下，加载模块链形成了一个循环链表，因此只要发现next块的头4字节是头块地址就停止遍历。</p><p> 二、获取DLL中的函数地址</p><p>找到基址后，我们必须手动完成由函数名获取其所在DLL中地址的过程，我们需要从DLL的实际基址入手，解析DLL的导出表，获取相关函数的入口地址。</p></blockquote><p>导出表—DLL对外暴露函数地址的机制</p><blockquote><p>序号查找</p><p>序号查找的好处：快！高效！</p><p>我们可以用一个简单的hash完成，而不需要遍历，如果我们用一个数组（funcEntryTb）存储函数的入口地址。第0号函数的入口地址就存入数组的第一个元素funcEntryTb[0]，第1号函数的就存入数组的第2个元素funcEntryTb[1]。这样获取入口地址非常简单 ，即funcEntryTb[n]，n是函数的序号，也就是拿到数组首址funcEntryTb加偏移n*4（每个地址4个字节）即可。类似DOS下的中断向量表。</p><p>如果序号不是从0开始，而是从n开始，我们依然是将n对应函数的入口地址存入第一个元素，依次类推。获取第M（M肯定大于n，因为n最小）号函数的地址如下： funcEntryTb[m - n]。依然非常快速，计算次数固定，即拿到首址funcEntryTb，做一次减法m-n，再做一次乘法(m - n)*4就获取到元素的地址，取出其值保存值即可。这其实也是c语言switch语句出来case中序号和case分支入口地址的方法，所以一般switch比if else嵌套快</p><p>但是序号查找不够直观，同时也不够稳定</p><p>用函数名查找</p><p>用函数名查找：直观！具体！</p><p>最简单的办法就是一个一个函数名字串比较，找到相同的串。下面给出一个简单实现：函数名表的索引和函数地址表的索引是一一对应的。如果查找func2函数地址，我们先遍历函数名表，每遇到\0就是一个串，自然，在第2串处找到了字串func2，fun2是函数名表第2项，索引为1，然后我们用索引1在函数地址表中获得了address2，函数地址表4字节一个元素<strong>通过两个表相同的索引建立关联</strong>。</p></blockquote><p>导出函数查找算法</p><blockquote><ol><li><p>从DLL加载的<strong>实际基址</strong>获取可选头，从其中<strong>数据目录表</strong>的第一项找到导出表入口RVA</p></li><li><p>从导出表的表头获取Number of names，即查找的最大循环次数</p></li><li><p>循环遍历<strong>函数名指针表</strong>，比对每项RVA指向的字串是否为要找的函数名</p><p><code>函数名指针表1项4字节 à 对应的字符串地址</code></p></li><li><p>如果找到，记下此时函数名指针表项的索引，设为 i</p></li><li><p>根据索引 i，在<strong>序号表</strong>中找到对应项，获取其内容为n</p><p><code>序号表1项2字节</code></p></li><li><p>以n为索引在<strong>函数地址表</strong>中找到函数入口的RVA，加上DLL的实际基址即为函数的实际入口地址</p><p><code>地址表1项4字节</code></p></li></ol><p>注：以上算法中，所有访问实际地址的地方，就用<code>DLL的实际加载基址+RVA</code>即可</p></blockquote><p>导入表机制</p><p>RVA指向导入表（IMPORT DICTORY TABLE）起始，在这个地方，每一项是一个IMAGE_IMPORT_DESCRIPTOR结构，代表一个导入的DLL的相关信息。在这个结构中，又有：</p><blockquote><p>INT表（Import Name Table）和IAT表（Import Address Table）的RVA</p></blockquote><p><img src="/posts/41006/25.png" alt></p><p><img src="/posts/41006/26.png" alt></p><p>如何找到需要Patch的指令</p><blockquote><ol><li>在文件中找到导入表的位置：先找到导入表的RVA，将RVA转换为导入表的文件位置</li><li>找到指定API函数在IAT表中的表项地址。先要找到API所在DLL对应的项，然后才能找到这个DLL所对应的INT和IAT表，比较dll的名字，判断是否是API函数所在DLL的导出表目录项，然后根据预先绑定，如果有INT就用INT表来找函数名，没有就用IAT表找函数名，获得INT表（或IAT表）的RVA，并将其转换为文件位置，遍历INT表（或IAT表）的每一项，查找指定的API函数名。</li><li>找到符合的指令进行Patch，先找到代码所在的节，判断节的属性是否有0x20，找到后开始循环遍历每个字节进行替换，并写入patch指令。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章-概述&quot;&gt;&lt;a href=&quot;#第一章-概述&quot; class=&quot;headerlink&quot; title=&quot;第一章-概述&quot;&gt;&lt;/a&gt;第一章-概述&lt;/h2&gt;&lt;h3 id=&quot;计算机病毒的定义&quot;&gt;&lt;a href=&quot;#计算机病毒的定义&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="UESTC" scheme="https://JoyTsing.github.io/categories/UESTC/"/>
    
    
      <category term="UESTC" scheme="https://JoyTsing.github.io/tags/UESTC/"/>
    
      <category term="计算机病毒原理与防范" scheme="https://JoyTsing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>[漫语]葬送的芙莉莲</title>
    <link href="https://joytsing.github.io/posts/52979/"/>
    <id>https://joytsing.github.io/posts/52979/</id>
    <published>2021-01-07T12:20:05.000Z</published>
    <updated>2023-09-25T13:07:34.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="葬送的芙莉莲"><a href="#葬送的芙莉莲" class="headerlink" title="葬送的芙莉莲"></a>葬送的芙莉莲</h2><p>整个故事是建立在寿命论上的，表面上是披着“剑与魔法”外皮的日常故事，但是开头却讲的是勇者队伍在打倒魔王后迎来的长久和平中，衰老致死。</p><p>唯独芙莉莲是拥有漫长生命的精灵，勇者离世后，她继续着她的旅行，从故事的开头就知道，主线就是一个再简单不过的异世界日常，但是这份日常中却透露着一股忧伤，勇者在整个漫画的开始之时就已经离世，但是他却时刻活在芙莉莲的记忆之中，芙莉莲与勇者共度的时光不过20余载，这段漫长的时间不过是芙莉莲千年岁月中的五十分之一。</p><p> 在盛大的庆贺典礼中，打败了魔王的勇者向国王提出了一个要求——想让国家建造勇者一行人的雕像，当晚恰好是五十年一遇的流星划过之时，仿佛象征着和平时代的到来，而四个人一起约定，下一个五十年也要相聚，找个更好的地方观赏观赏流星。讨伐魔王的冒险结束后，卸下了拯救世界职责的他们，该干什么？</p><p><img src="https://pic2.zhimg.com/v2-646af59450a4efbdade04649a9bd3519_r.jpg" alt></p><p>他们开心地享受着他们亲手赢来的和平，一直幸福平静地活到了晚年。</p><p>——除了芙莉莲之外。</p><p><img src="https://pic2.zhimg.com/v2-2a2494c577b69cd31c7b8ca7ed1d4ab1_r.jpg" alt></p><p>她打算先随便旅游个一百年。</p><p>没过多久，冬去秋来，人来人往，仅仅两页纸不到——</p><p>五十年就过去了。</p><p>芙莉莲偶然想到，好像正好差不多是时候回来和大家一起看看流星了。</p><p>她回到勇者居住的城镇，四处寻找曾经的伙伴——</p><p>勇者四人，时隔五十年再度重聚。</p><p>五十年过去了，只有芙莉莲依然保持着当年的样子，丝毫未变。</p><p>他们闲聊着当年冒险的往事，为了前往最佳的流星观景点跋山涉水，仿佛找回了当年一起冒险的兴奋劲。</p><p>目前为止，如你所见，并没有什么称得上是剧情的剧情。四人仅仅是平淡幸福地度过了这段人生，老朋友们时隔五十年叙叙旧，仅此而已。没有波澜壮阔的变动，也没有暗流蠢动的阴谋——<strong>但漫画仅仅用十来页的篇幅，就将这番时隔五十年的两次流星之间、物是人非的变化与怀念刻画得淋漓尽致。</strong></p><p><img src="https://pic4.zhimg.com/v2-52d3534f24ed43966d82e02a7462ad83_r.jpg?source=1940ef5c" alt></p><p>我们以芙莉莲的视角，静静地，用一分钟体验完了长达五十年、又仅有短短五十年的沧桑与转瞬。</p><p>不久后，勇者辛美尔寿终正寝。</p><p>他抱着他的爱剑，静静躺在灵柩中。这个男人的一生伟大而平凡，无数受过他帮助的人前来参加他的送别仪式。牧师说，辛美尔的这一生大概是幸福的。</p><p>但芙莉莲却无法理解。</p><p><strong>因为，对她而言，她认识勇者的时间实在太短暂了。</strong></p><p>对常人而言，十年的相处可能会让彼此连屁股上有几根毛都清清楚楚。但对寿命数千数万年的精灵族来说，仅仅十年的相识，根本短到远远不足够让她了解一个人的为人。</p><p>因此，她一滴眼泪都掉不出来。</p><p><strong>“……因为我、对那个人简直是一无所知……”</strong></p><p><img src="https://pic2.zhimg.com/v2-48ab535f02a32da514134291f99bed21_r.jpg" alt></p><p>不是因为勇者的死而悲伤，也不是因为自己的冷血而自责。</p><p>芙莉莲在这瞬间会落泪，仅仅是因为——明明和他一起旅行了这么多年年，自己却对他一点也不了解。</p><p>明明她十分清楚人类就是短命的生物，但自己为什么没有趁他还在世时去多了解他一些呢。</p><p><strong>于是，本漫画的故事终于正式开始。</strong></p><p>没有刻意去渲染五十年社会变迁沧海桑田，也没有夸张形容勇者们的功绩与影响。所有的画面都仅仅是简单、冷静地展现了时间观念钝感的芙莉莲眼中的见闻，却深刻让人体会到了人类五十年的分量。</p><p>明明芙莉莲才是那个五十年间毫无变化的人，她这些一个一个离去的伙伴们却仿佛比她更豁达，更无变化。这些人类远胜于精灵的冷静与一如既往的态度，并未让时间溜走得像假的一样，反而让这段五十年的短暂光阴逝去得更为真实、残酷。</p><p>勇者为什么在一开始要求国家建造的雕像吗？</p><p>他们的雕像不仅仅建在了首都广场。全世界各地城镇和村落，都有他们的雕像。</p><p>而芙莉莲直到很久以后，才终于猜到了勇者辛美尔建立这些雕像的意图。</p><p>这是因为，勇者早就知道人类生命短暂，也比任何人都了解芙莉莲。对于人类来说，十年的相处足以把一个人彻头彻尾了解干净了——因此，他建立雕像，希望民众能庆祝勇者解放人类——这一切仅仅是因为——</p><p><img src="https://pic2.zhimg.com/v2-fb20a564bb898b65c274773391f65e79_r.jpg" alt></p><p><strong>他希望，他和伙伴们死去的百年后、千年后——芙莉莲看到大家的雕像时，能稍微减轻一些寂寞。因为这个世界还记得他们，他们确实存在过。</strong></p><p><strong>那么，芙莉莲就能够活在这个充满他们存在痕迹的世界中。</strong></p><p><strong>仅此而已。</strong></p><p>这些仅仅是漫画的开头，但已经足够表现漫画的张力，类似的作品还有很多，之后会慢慢更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;葬送的芙莉莲&quot;&gt;&lt;a href=&quot;#葬送的芙莉莲&quot; class=&quot;headerlink&quot; title=&quot;葬送的芙莉莲&quot;&gt;&lt;/a&gt;葬送的芙莉莲&lt;/h2&gt;&lt;p&gt;整个故事是建立在寿命论上的，表面上是披着“剑与魔法”外皮的日常故事，但是开头却讲的是勇者队伍在打倒魔王后迎来
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://JoyTsing.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>可执行ELF文件的编写</title>
    <link href="https://joytsing.github.io/posts/58644/"/>
    <id>https://joytsing.github.io/posts/58644/</id>
    <published>2020-12-24T12:00:25.000Z</published>
    <updated>2023-12-14T07:44:39.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文从减少可执行文件大小的角度分析了 <code>ELF</code> 文件，期间通过经典的 <code>Hello World</code> 实例逐步演示如何通过各种常用工具来分析 <code>ELF</code> 文件，并逐步精简代码。</p><p>为了能够尽量减少可执行文件的大小，我们必须了解可执行文件的格式，以及链接生成可执行文件时的后台细节（即最终到底有哪些内容被链接到了目标代码中）。通过选择合适的可执行文件格式并剔除对可执行文件的最终运行没有影响的内容，就可以实现目标代码的裁减。因此，通过探索减少可执行文件大小的方法，就相当于实践性地去探索了可执行文件的格式以及链接过程的细节。</p><p>当然，算法的优化和编程语言的选择可能对目标文件的大小有很大的影响，在本文最后我们会去探求一个打印 <code>Hello World</code> 的可执行文件能够小到什么样的地步。</p><h2 id="可执行文件格式的选取"><a href="#可执行文件格式的选取" class="headerlink" title="可执行文件格式的选取"></a>可执行文件格式的选取</h2><p>可执行文件格式的选择要满足的一个基本条件是：目标系统支持该可执行文件格式， <code>UNIX</code> 平台下的三种可执行文件格式实际上代表着可执行文件的一个发展过程：</p><ul><li>a.out 文件格式非常紧凑，只包含了程序运行所必须的信息（文本、数据、 <code>BSS</code>），而且每个 <code>section</code> 的顺序是固定的。</li><li>coff 文件格式虽然引入了一个节区表以支持更多节区信息，从而提高了可扩展性，但是这种文件格式的重定位在链接时就已经完成，因此不支持动态链接（不过扩展的 <code>coff</code> 支持）。</li><li>elf 文件格式不仅支持动态链接，而且有很好的扩展性。它可以描述可重定位文件、可执行文件和可共享文件（动态链接库）三类文件。</li></ul><p>下面来看看 <code>ELF</code> 文件的结构图：</p><pre><code>文件头部(ELF Header)程序头部表(Program Header Table)节区1(Section1)节区2(Section2)节区3(Section3)...节区头部表(Section Header Table)</code></pre><p>无论是文件头部、程序头部表、节区头部表还是各个节区，都是通过特定的结构体 <code>(struct)</code> 描述的，这些结构在 <code>elf.h</code> 文件中定义。文件头部用于描述整个文件的类型、大小、运行平台、程序入口、程序头部表和节区头部表等信息。例如，我们可以通过文件头部查看该 <code>ELF</code> 文件的类型。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> hello.c   <span class="token comment" spellcheck="true">#典型的hello, world程序</span><span class="token comment" spellcheck="true">#include &lt;stdio.h></span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">{</span>    printf<span class="token punctuation">(</span><span class="token string">"hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span>$ gcc -c hello.c   <span class="token comment" spellcheck="true">#编译，产生可重定向的目标代码</span>$ readelf -h hello.o <span class="token operator">|</span> <span class="token function">grep</span> Type   <span class="token comment" spellcheck="true">#通过readelf查看文件头部找出该类型</span>  Type:                              REL <span class="token punctuation">(</span>Relocatable file<span class="token punctuation">)</span>$ gcc -o hello hello.o   <span class="token comment" spellcheck="true">#生成可执行文件</span>$ readelf -h hello <span class="token operator">|</span> <span class="token function">grep</span> Type  Type:                              EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span>$ gcc -fpic -shared -Wl,-soname,libhello.so.0 -o libhello.so.0.0 hello.o  <span class="token comment" spellcheck="true">#生成共享库</span>$ readelf -h libhello.so.0.0 <span class="token operator">|</span> <span class="token function">grep</span> Type  Type:                              DYN <span class="token punctuation">(</span>Shared object file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那节区头部表（将简称节区表）和程序头部表有什么用呢？实际上前者只对可重定向文件有用，而后者只对可执行文件和可共享文件有用。</p><p>节区表是用来描述各节区的，包括各节区的名字、大小、类型、虚拟内存中的位置、相对文件头的位置等，这样所有节区都通过节区表给描述了，这样连接器就可以根据文件头部表和节区表的描述信息对各种输入的可重定位文件进行合适的链接，包括节区的合并与重组、符号的重定位（确认符号在虚拟内存中的地址）等，把各个可重定向输入文件链接成一个可执行文件（或者是可共享文件）。如果可执行文件中使用了动态连接库，那么将包含一些用于动态符号链接的节区。我们可以通过 <code>readelf -S</code> （或 <code>objdump -h</code>）查看节区表信息。</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -S hello  <span class="token comment" spellcheck="true">#可执行文件、可共享库、可重定位文件默认都生成有节区表</span><span class="token punctuation">..</span>.Section Headers:  <span class="token punctuation">[</span>Nr<span class="token punctuation">]</span> Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  <span class="token punctuation">[</span> 0<span class="token punctuation">]</span>                   NULL            00000000 000000 000000 00      0   0  0  <span class="token punctuation">[</span> 1<span class="token punctuation">]</span> .interp           PROGBITS        08048114 000114 000013 00   A  0   0  1  <span class="token punctuation">[</span> 2<span class="token punctuation">]</span> .note.ABI-tag     NOTE            08048128 000128 000020 00   A  0   0  4  <span class="token punctuation">[</span> 3<span class="token punctuation">]</span> .hash             HASH            08048148 000148 000028 04   A  5   0  4<span class="token punctuation">..</span>.    <span class="token punctuation">[</span> 7<span class="token punctuation">]</span> .gnu.version      VERSYM          0804822a 00022a 00000a 02   A  5   0  2<span class="token punctuation">..</span>.  <span class="token punctuation">[</span>11<span class="token punctuation">]</span> .init             PROGBITS        08048274 000274 000030 00  AX  0   0  4<span class="token punctuation">..</span>.  <span class="token punctuation">[</span>13<span class="token punctuation">]</span> .text             PROGBITS        080482f0 0002f0 000148 00  AX  0   0 16  <span class="token punctuation">[</span>14<span class="token punctuation">]</span> .fini             PROGBITS        08048438 000438 00001c 00  AX  0   0  4<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三种类型文件的节区可能不一样，但是有几个节区，例如 <code>.text</code>，<code>.data</code>，<code>.bss</code> 是必须的，特别是 <code>.text</code>，因为这个节区包含了代码。如果一个程序使用了动态链接库（引用了动态连接库中的某个函数），那么需要 <code>.interp</code> 节区以便告知系统使用什么动态连接器程序来进行动态符号链接，进行某些符号地址的重定位。通常，<code>.rel.text</code> 节区只有可重定向文件有，用于链接时对代码区进行重定向，而 <code>.hash</code>，<code>.plt</code>，<code>.got</code> 等节区则只有可执行文件（或可共享库）有，这些节区对程序的运行特别重要。还有一些节区，可能仅仅是用于注释，比如 <code>.comment</code>，这些对程序的运行似乎没有影响，是可有可无的，不过有些节区虽然对程序的运行没有用处，但是却可以用来辅助对程序进行调试或者对程序运行效率有影响。</p><p>虽然三类文件都必须包含某些节区，但是节区表对可重定位文件来说才是必须的，而程序的执行却不需要节区表，只需要程序头部表以便知道如何加载和执行文件。不过如果需要对可执行文件或者动态连接库进行调试，那么节区表却是必要的，否则调试器将不知道如何工作。下面来介绍程序头部表，它可通过 <code>readelf -l</code>（或 <code>objdump -p</code>）查看。</p><pre class="line-numbers language-bash"><code class="language-bash">$ readelf -l hello.o <span class="token comment" spellcheck="true">#对于可重定向文件，gcc没有产生程序头部，因为它对可重定向文件没用</span>There are no program headers <span class="token keyword">in</span> this file.$  readelf -l hello  <span class="token comment" spellcheck="true">#而可执行文件和可共享文件都有程序头部</span><span class="token punctuation">..</span>.Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1      <span class="token punctuation">[</span>Requesting program interpreter: /lib/ld-linux.so.2<span class="token punctuation">]</span>  LOAD           0x000000 0x08048000 0x08048000 0x00470 0x00470 R E 0x1000  LOAD           0x000470 0x08049470 0x08049470 0x0010c 0x00110 RW  0x1000  DYNAMIC        0x000484 0x08049484 0x08049484 0x000d0 0x000d0 RW  0x4  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4 Section to Segment mapping:  Segment Sections<span class="token punctuation">..</span>.   00   01     .interp   02     .interp .note.ABI-tag .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss   04     .dynamic   05     .note.ABI-tag   06$ readelf -l libhello.so.0.0  <span class="token comment" spellcheck="true">#节区和上面类似，这里省略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面可看出程序头部表描述了一些段（<code>Segment</code>），这些段对应着一个或者多个节区，上面的 <code>readelf -l</code> 很好地显示了各个段与节区的映射。这些段描述了段的名字、类型、大小、第一个字节在文件中的位置、将占用的虚拟内存大小、在虚拟内存中的位置等。这样系统程序解释器将知道如何把可执行文件加载到内存中以及进行动态链接等动作。</p><p>该可执行文件包含 7 个段，<code>PHDR</code> 指程序头部，<code>INTERP</code> 正好对应 <code>.interp</code> 节区，两个 <code>LOAD</code> 段包含程序的代码和数据部分，分别包含有 <code>.text</code> 和 <code>.data</code>，<code>.bss</code> 节区，<code>DYNAMIC</code> 段包含 <code>.daynamic</code>，这个节区可能包含动态连接库的搜索路径、可重定位表的地址等信息，它们用于动态连接器。 <code>NOTE</code> 和 <code>GNU_STACK</code> 段貌似作用不大，只是保存了一些辅助信息。因此，对于一个不使用动态连接库的程序来说，可能只包含 <code>LOAD</code> 段，如果一个程序没有数据，那么只有一个 <code>LOAD</code> 段就可以了。</p><p>总结一下，Linux 虽然支持很多种可执行文件格式，但是目前 <code>ELF</code> 较通用，所以选择 <code>ELF</code> 作为我们的讨论对象。通过上面对 <code>ELF</code> 文件分析发现一个可执行的文件可能包含一些对它的运行没用的信息，比如节区表、一些用于调试、注释的节区。如果能够删除这些信息就可以减少可执行文件的大小，而且不会影响可执行文件的正常运行。</p><h2 id="链接优化"><a href="#链接优化" class="headerlink" title="链接优化"></a>链接优化</h2><p>从上面的讨论中已经接触了动态连接库。 <code>ELF</code> 中引入动态连接库后极大地方便了公共函数的共享，节约了磁盘和内存空间，因为不再需要把那些公共函数的代码链接到可执行文件，这将减少了可执行文件的大小。</p><p>与此同时，静态链接可能会引入一些对代码的运行可能并非必须的内容。从那篇 Blog 中似乎可以得出这样的结论：仅仅从是否影响一个 C 语言程序运行的角度上说，<code>GCC</code> 默认链接到可执行文件的几个可重定位文件 （<code>crt1.o</code>，<code>rti.o</code>，<code>crtbegin.o</code>，<code>crtend.o</code>，<code>crtn.o</code>）并不是必须的，不过值得注意的是，如果没有链接那些文件但在程序末尾使用了 <code>return</code> 语句，<code>main</code> 函数将无法返回，因此需要替换为 <code>_exit</code> 调用；另外，既然程序在进入 <code>main</code> 之前有一个入口，那么 <code>main</code> 入口就不是必须的。因此，如果不采用默认链接也可以减少可执行文件的大小。</p><h2 id="可执行文件“减肥”实例（从6442到708字节）"><a href="#可执行文件“减肥”实例（从6442到708字节）" class="headerlink" title="可执行文件“减肥”实例（从6442到708字节）"></a>可执行文件“减肥”实例（从6442到708字节）</h2><p>这里主要是根据上面两点来介绍如何减少一个可执行文件的大小。以 <code>Hello World</code> 为例。</p><p>首先来看看默认编译产生的 <code>Hello World</code> 的可执行文件大小。</p><h3 id="系统默认编译"><a href="#系统默认编译" class="headerlink" title="系统默认编译"></a>系统默认编译</h3><p>代码同上，下面是一组演示，</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">uname</span> -r   <span class="token comment" spellcheck="true">#先查看内核版本和gcc版本，以便和你的结果比较</span>2.6.22-14-generic$ gcc --versiongcc <span class="token punctuation">(</span>GCC<span class="token punctuation">)</span> 4.1.3 20070929 <span class="token punctuation">(</span>prerelease<span class="token punctuation">)</span> <span class="token punctuation">(</span>Ubuntu 4.1.2-16ubuntu2<span class="token punctuation">)</span><span class="token punctuation">..</span>.$ gcc -o hello hello.c   <span class="token comment" spellcheck="true">#默认编译</span>$ <span class="token function">wc</span> -c hello   <span class="token comment" spellcheck="true">#产生一个大小为6442字节的可执行文件</span>6442 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不采用默认编译"><a href="#不采用默认编译" class="headerlink" title="不采用默认编译"></a>不采用默认编译</h3><p>可以考虑编辑时就把 <code>return 0</code> 替换成 <code>_exit(0)</code> 并包含定义该函数的 <code>unistd.h</code> 头文件。下面是之前博客中总结出的 <code>Makefile</code> 文件。</p><pre class="line-numbers language-makefile"><code class="language-makefile"><span class="token comment" spellcheck="true">#file: Makefile</span><span class="token comment" spellcheck="true">#functin: for not linking a program as the gcc do by default</span>MAIN <span class="token operator">=</span> helloSOURCE <span class="token operator">=</span>OBJS <span class="token operator">=</span> hello.oTARGET <span class="token operator">=</span> helloCC <span class="token operator">=</span> gcc-3.4 -m32LD <span class="token operator">=</span> ld -m elf_i386CFLAGSs <span class="token operator">+=</span> -SCFLAGSc <span class="token operator">+=</span> -cLDFLAGS <span class="token operator">+=</span> -dynamic-linker /lib/ld-linux.so.2 -L /usr/lib/ -L /lib -lcRM <span class="token operator">=</span> rm -fSEDc <span class="token operator">=</span> sed -i -e <span class="token string">'/\#include[ "&lt;]*unistd.h[ ">]*/d;'</span> \    -i -e <span class="token string">'1i \#include &lt;unistd.h>'</span> \    -i -e <span class="token string">'s/return 0;/_exit(0);/'</span>SEDs <span class="token operator">=</span> sed -i -e <span class="token string">'s/main/_start/g'</span><span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span class="token symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span>    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>SEDc<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MAIN<span class="token punctuation">)</span>.c    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGSs<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MAIN<span class="token punctuation">)</span>.c    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>SEDs<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MAIN<span class="token punctuation">)</span>.s    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGSc<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MAIN<span class="token punctuation">)</span>.s <span class="token variable">$</span><span class="token punctuation">(</span>SOURCE<span class="token punctuation">)</span>    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>LD<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span><span class="token symbol">clean</span><span class="token punctuation">:</span>    <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>RM<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>MAIN<span class="token punctuation">)</span>.s <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把上面的代码复制到一个Makefile文件中，并利用它来编译hello.c。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span>   <span class="token comment" spellcheck="true">#编译</span>$ ./hello   <span class="token comment" spellcheck="true">#这个也是可以正常工作的</span>Hello World$ <span class="token function">wc</span> -c hello   <span class="token comment" spellcheck="true">#但是大小减少了4382个字节，减少了将近 70%</span>2060 hello$ <span class="token keyword">echo</span> <span class="token string">"6442-2060"</span> <span class="token operator">|</span> <span class="token function">bc</span>4382$ <span class="token keyword">echo</span> <span class="token string">"(6442-2060)/6442"</span> <span class="token operator">|</span> <span class="token function">bc</span> -l.68022353306426575597<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于一个比较小的程序，能够减少将近 70% “没用的”代码。</p><h3 id="删除对程序运行没有影响的节区"><a href="#删除对程序运行没有影响的节区" class="headerlink" title="删除对程序运行没有影响的节区"></a>删除对程序运行没有影响的节区</h3><p>使用上述 <code>Makefile</code> 来编译程序，不链接那些对程序运行没有多大影响的文件，实际上也相当于删除了一些“没用”的节区，可以通过下列演示看出这个实质。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">make</span> clean$ <span class="token function">make</span>$ readelf -l hello <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"0[0-9]\ \ "</span>   00   01     .interp   02     .interp .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.plt .plt .text .rodata   03     .dynamic .got.plt   04     .dynamic   05$ <span class="token function">make</span> clean$ gcc -o hello hello.c$ readelf -l hello <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"0[0-9]\ \ "</span>   00   01     .interp   02     .interp .note.ABI-tag .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r      .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss   04     .dynamic   05     .note.ABI-tag   06<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过比较发现使用自定义的 <code>Makefile</code> 文件，少了这么多节区： <code>.bss .ctors .data .dtors .eh_frame .fini .gnu.hash .got .init .jcr .note.ABI-tag .rel.dyn</code> 。 再看看还有哪些节区可以删除呢？通过之前的分析发现有些节区是必须的，那 <code>.hash?.gnu.version?</code> 呢，通过 <code>strip -R</code>（或 <code>objcop -R</code>）删除这些节区试试。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wc</span> -c hello   <span class="token comment" spellcheck="true">#查看大小，以便比较</span>2060$ <span class="token function">time</span> ./hello    <span class="token comment" spellcheck="true">#我们比较一下一些节区对执行时间可能存在的影响</span>Hello Worldreal    0m0.001suser    0m0.000ssys     0m0.000s$ strip -R .hash hello   <span class="token comment" spellcheck="true">#删除.hash节区</span>$ <span class="token function">wc</span> -c hello1448 hello$ <span class="token keyword">echo</span> <span class="token string">"2060-1448"</span> <span class="token operator">|</span> <span class="token function">bc</span>   <span class="token comment" spellcheck="true">#减少了612字节</span>612$ <span class="token function">time</span> ./hello           <span class="token comment" spellcheck="true">#发现执行时间长了一些（实际上也可能是进程调度的问题）</span>Hello Worldreal    0m0.006suser    0m0.000ssys     0m0.000s$ strip -R .gnu.version hello   <span class="token comment" spellcheck="true">#删除.gnu.version还是可以工作</span>$ <span class="token function">wc</span> -c hello1396 hello$ <span class="token keyword">echo</span> <span class="token string">"1448-1396"</span> <span class="token operator">|</span> <span class="token function">bc</span>      <span class="token comment" spellcheck="true">#又减少了52字节</span>52$ <span class="token function">time</span> ./helloHello Worldreal    0m0.130suser    0m0.004ssys     0m0.000s$ strip -R .gnu.version_r hello   <span class="token comment" spellcheck="true">#删除.gnu.version_r就不工作了</span>$ <span class="token function">time</span> ./hello./hello: error <span class="token keyword">while</span> loading shared libraries: ./hello: unsupported version 0 of Verneed record<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过删除各个节区可以查看哪些节区对程序来说是必须的，不过有些节区虽然并不影响程序的运行却可能会影响程序的执行效率，这个可以上面的运行时间看出个大概。 通过删除两个“没用”的节区，我们又减少了 <code>52+612</code>，即 664 字节。</p><h3 id="删除可执行文件的节区表"><a href="#删除可执行文件的节区表" class="headerlink" title="删除可执行文件的节区表"></a>删除可执行文件的节区表</h3><p>用普通的工具没有办法删除节区表，但你可以从<a href="http://www.muppetlabs.com/~breadbox/software/elfkickers.html">这里</a>下载到那个工具，它是一序列工具 <code>ELFkickers</code> 中的一个。</p><p>下载并编译（<strong>注</strong>：1.0 之前的版本才支持 32 位和正常编译，新版本在代码中明确限定了数据结构为 <code>Elf64</code>）：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/BR903/ELFkickers$ <span class="token function">cd</span> ELFkickers/sstrip/$ <span class="token function">git</span> checkout f0622afa    <span class="token comment" spellcheck="true"># 检出 1.0 版</span>$ <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后复制到 <code>/usr/bin</code> 下，下面用它来删除节区表。</p><pre class="line-numbers language-bash"><code class="language-bash">$ sstrip hello      <span class="token comment" spellcheck="true">#删除ELF可执行文件的节区表</span>$ ./hello           <span class="token comment" spellcheck="true">#还是可以正常运行，说明节区表对可执行文件的运行没有任何影响</span>Hello World$ <span class="token function">wc</span> -c hello       <span class="token comment" spellcheck="true">#大小只剩下708个字节了</span>708 hello$ <span class="token keyword">echo</span> <span class="token string">"1396-708"</span> <span class="token operator">|</span> <span class="token function">bc</span>  <span class="token comment" spellcheck="true">#又减少了688个字节。</span>688<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过删除节区表又把可执行文件减少了 688 字节。现在回头看看相对于 <code>gcc</code> 默认产生的可执行文件，通过删除一些节区和节区表到底减少了多少字节？减幅达到了多少？</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"6442-708"</span> <span class="token operator">|</span> <span class="token function">bc</span>   <span class="token comment" spellcheck="true">#</span>5734$ <span class="token keyword">echo</span> <span class="token string">"(6442-708)/6442"</span> <span class="token operator">|</span> <span class="token function">bc</span> -l.89009624340266997826<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>减少了 5734 多字节，减幅将近 <code>90%</code>，这说明：对于一个简短的 <code>hello.c</code> 程序而言，<code>gcc</code> 引入了将近 <code>90%</code> 的对程序运行没有影响的数据。虽然通过删除节区和节区表，使得最终的文件只有 708 字节，但是打印一个 <code>Hello World</code> 真的需要这么多字节么？事实上未必，因为：</p><ul><li>打印一段 <code>Hello World</code> 字符串，我们无须调用 <code>printf</code>，也就无须包含动态连接库，因此 <code>.interp</code>，<code>.dynamic</code> 等节区又可以去掉。为什么？我们可以直接使用系统调用 `(sys_write)来打印字符串。</li><li>另外，我们无须把 <code>Hello World</code> 字符串存放到可执行文件中？而是让用户把它当作参数输入。</li></ul><p>下面，继续进行可执行文件的“减肥”。</p><h2 id="用汇编语言来重写”Hello-World”（76字节）"><a href="#用汇编语言来重写”Hello-World”（76字节）" class="headerlink" title="用汇编语言来重写”Hello World”（76字节）"></a>用汇编语言来重写”Hello World”（76字节）</h2><h3 id="采用默认编译"><a href="#采用默认编译" class="headerlink" title="采用默认编译"></a>采用默认编译</h3><p>先来看看 <code>gcc</code> 默认产生的汇编代码情况。通过 <code>gcc</code> 的 <code>-S</code> 选项可得到汇编代码。</p><pre class="line-numbers language-c"><code class="language-c">$ cat hello<span class="token punctuation">.</span>c  #这个是使用_exit和printf函数的版本<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>     </span><span class="token comment" spellcheck="true">/* _exit */</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>$ gcc <span class="token operator">-</span>S hello<span class="token punctuation">.</span>c    #生成汇编$ cat hello<span class="token punctuation">.</span>s       #这里是汇编代码    <span class="token punctuation">.</span>file   <span class="token string">"hello.c"</span>    <span class="token punctuation">.</span>section        <span class="token punctuation">.</span>rodata<span class="token punctuation">.</span>LC0<span class="token punctuation">:</span>    <span class="token punctuation">.</span>string <span class="token string">"Hello World"</span>    <span class="token punctuation">.</span>text<span class="token punctuation">.</span>globl main    <span class="token punctuation">.</span>type   main<span class="token punctuation">,</span> @functionmain<span class="token punctuation">:</span>    leal    <span class="token function">4</span><span class="token punctuation">(</span><span class="token operator">%</span>esp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>ecx    andl    $<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token operator">%</span>esp    pushl   <span class="token operator">-</span><span class="token function">4</span><span class="token punctuation">(</span><span class="token operator">%</span>ecx<span class="token punctuation">)</span>    pushl   <span class="token operator">%</span>ebp    movl    <span class="token operator">%</span>esp<span class="token punctuation">,</span> <span class="token operator">%</span>ebp    pushl   <span class="token operator">%</span>ecx    subl    $<span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">%</span>esp    movl    $<span class="token punctuation">.</span>LC0<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">%</span>esp<span class="token punctuation">)</span>    call    puts    movl    $<span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">%</span>esp<span class="token punctuation">)</span>    call    _exit    <span class="token punctuation">.</span>size   main<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token operator">-</span>main    <span class="token punctuation">.</span>ident  <span class="token string">"GCC: (GNU) 4.1.3 20070929 (prerelease) (Ubuntu 4.1.2-16ubuntu2)"</span>    <span class="token punctuation">.</span>section        <span class="token punctuation">.</span>note<span class="token punctuation">.</span>GNU<span class="token operator">-</span>stack<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span>@progbits$ gcc <span class="token operator">-</span>o hello hello<span class="token punctuation">.</span>s   #看看默认产生的代码大小$ wc <span class="token operator">-</span>c hello<span class="token number">6523</span> hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除掉汇编代码中无关紧要内容"><a href="#删除掉汇编代码中无关紧要内容" class="headerlink" title="删除掉汇编代码中无关紧要内容"></a>删除掉汇编代码中无关紧要内容</h3><p>现在对汇编代码 <code>hello.s</code> 进行简单的处理得到，</p><pre class="line-numbers language-assembly"><code class="language-assembly">.LC0:    .string "Hello World"    .text.globl main    .type   main, @functionmain:    leal    4(%esp), %ecx    andl    $-16, %esp    pushl   -4(%ecx)    pushl   %ebp    movl    %esp, %ebp    pushl   %ecx    subl    $4, %esp    movl    $.LC0, (%esp)    call    puts    movl    $0, (%esp)    call    _exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再编译看看，</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -o hello.o hello.s$ <span class="token function">wc</span> -c hello6443 hello$ <span class="token keyword">echo</span> <span class="token string">"6523-6443"</span> <span class="token operator">|</span> <span class="token function">bc</span>   <span class="token comment" spellcheck="true">#仅仅减少了80个字节</span>80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不默认编译并删除掉无关节区和节区表"><a href="#不默认编译并删除掉无关节区和节区表" class="headerlink" title="不默认编译并删除掉无关节区和节区表"></a>不默认编译并删除掉无关节区和节区表</h3><p>如果不采用默认编译呢并且删除掉对程序运行没有影响的节区和节区表呢？</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sed</span> -i -e <span class="token string">"s/main/_start/g"</span> hello.s   <span class="token comment" spellcheck="true">#因为没有初始化，所以得直接进入代码，替换main为_start</span>$ as --32 -o  hello.o hello.s$ ld -melf_i386 -o hello hello.o --dynamic-linker /lib/ld-linux.so.2 -L /usr/lib -lc$ ./hellohello world<span class="token operator">!</span>$ <span class="token function">wc</span> -c hello1812 hello$ <span class="token keyword">echo</span> <span class="token string">"6443-1812"</span> <span class="token operator">|</span> <span class="token function">bc</span> -l   <span class="token comment" spellcheck="true">#和之前的实验类似，也减少了4k左右</span>4631$ readelf -l hello <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"\ [0-9][0-9]\ "</span>   00   01     .interp   02     .interp .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.plt .plt .text   03     .dynamic .got.plt   04     .dynamic$ strip -R .hash hello$ strip -R .gnu.version hello$ <span class="token function">wc</span> -c hello1200 hello$ sstrip hello$ <span class="token function">wc</span> -c hello  <span class="token comment" spellcheck="true">#这个结果比之前的708（在删除所有垃圾信息以后）个字节少了708-676，即32个字节</span>676 hello$ ./helloHello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容易发现这 32 字节可能跟节区 <code>.rodata</code> 有关系，因为刚才在链接完以后查看节区信息时，并没有 <code>.rodata</code> 节区。</p><h3 id="用系统调用取代库函数"><a href="#用系统调用取代库函数" class="headerlink" title="用系统调用取代库函数"></a>用系统调用取代库函数</h3><p>前面提到，实际上还可以不用动态连接库中的 <code>printf</code> 函数，也不用直接调用 <code>_exit</code>，而是在汇编里头使用系统调用，这样就可以去掉和动态连接库关联的内容。使用系统调用重写以后得到如下代码，</p><pre class="line-numbers language-assembly"><code class="language-assembly">.LC0:    .string "Hello World\xa\x0"    .text.global _start_start:    xorl   %eax, %eax    movb   $4, %al                  #eax = 4, sys_write(fd, addr, len)    xorl   %ebx, %ebx    incl   %ebx                     #ebx = 1, standard output    movl   $.LC0, %ecx              #ecx = $.LC0, the address of string    xorl   %edx, %edx    movb   $13, %dl                 #edx = 13, the length of .string    int    $0x80    xorl   %eax, %eax    movl   %eax, %ebx               #ebx = 0    incl   %eax                     #eax = 1, sys_exit    int    $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在编译就不再需要动态链接器 <code>ld-linux.so</code> 了，也不再需要链接任何库。</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o hello.o hello.s$ ld -melf_i386 -o hello hello.o$ readelf -l helloElf <span class="token function">file</span> <span class="token function">type</span> is EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span>Entry point 0x8048062There are 1 program headers, starting at offset 52Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  LOAD           0x000000 0x08048000 0x08048000 0x0007b 0x0007b R E 0x1000 Section to Segment mapping:  Segment Sections<span class="token punctuation">..</span>.   00     .text$ sstrip hello$ ./hello           <span class="token comment" spellcheck="true">#完全可以正常工作</span>Hello World$ <span class="token function">wc</span> -c hello123 hello$ <span class="token keyword">echo</span> <span class="token string">"676-123"</span> <span class="token operator">|</span> <span class="token function">bc</span>   <span class="token comment" spellcheck="true">#相对于之前，已经只需要123个字节了，又减少了553个字节</span>553<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到效果很明显，只剩下一个 <code>LOAD</code> 段，它对应 <code>.text</code> 节区。</p><h3 id="把字符串作为参数输入"><a href="#把字符串作为参数输入" class="headerlink" title="把字符串作为参数输入"></a>把字符串作为参数输入</h3><p>不过是否还有办法呢？把 <code>Hello World</code> 作为参数输入，而不是硬编码在文件中。所以如果处理参数的代码少于 <code>Hello World</code> 字符串的长度，那么就可以达到减少目标文件大小的目的。</p><p>先来看一个能够打印程序参数的汇编语言程序：</p><pre class="line-numbers language-assembly"><code class="language-assembly">.text.globl _start_start:    popl    %ecx            # argcvnext:    popl    %ecx            # argv    test    %ecx, %ecx      # 空指针表明结束    jz      exit    movl    %ecx, %ebx    xorl    %edx, %edxstrlen:    movb    (%ebx), %al    inc     %edx    inc     %ebx    test    %al, %al    jnz     strlen    movb    $10, -1(%ebx)    movl    $4, %eax        # 系统调用号(sys_write)    movl    $1, %ebx        # 文件描述符(stdout)    int     $0x80    jmp     vnextexit:    movl    $1,%eax         # 系统调用号(sys_exit)    xorl    %ebx, %ebx      # 退出代码    int     $0x80    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译看看效果，</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o args.o args.s$ ld -melf_i386 -o args args.o$ ./args <span class="token string">"Hello World"</span>  <span class="token comment" spellcheck="true">#能够打印输入的字符串，不错</span>./argsHello World$ sstrip args$ <span class="token function">wc</span> -c args           <span class="token comment" spellcheck="true">#处理以后只剩下130字节</span>130 args<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，这个程序可以接收用户输入的参数并打印出来，不过得到的可执行文件为 130 字节，比之前的 123 个字节还多了 7 个字节，看看还有改进么？分析上面的代码后，发现，原来的代码有些地方可能进行优化，优化后得到如下代码。</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx        #弹出argcvnext:    popl %ecx        #弹出argv[0]的地址    test %ecx, %ecx  #空指针表明结束    jz exit    movl %ecx, %ebx  #复制字符串地址到ebx寄存器    xorl %edx, %edx  #把字符串长度清零strlen:                         #求输入字符串的长度    movb (%ebx), %al        #复制字符到al，以便判断是否为字符串结束符\0    inc %edx                #edx存放每个当前字符串的长度    inc %ebx                #ebx存放每个当前字符的地址    test %al, %al           #判断字符串是否结束，即是否遇到\0    jnz strlen    movb $10, -1(%ebx)      #在字符串末尾插入一个换行符\0xa    xorl %eax, %eax    movb $4, %al            #eax = 4, sys_write(fd, addr, len)    xorl %ebx, %ebx    incl %ebx               #ebx = 1, standard output    int $0x80    jmp vnextexit:    xorl %eax, %eax    movl %eax, %ebx                 #ebx = 0    incl %eax               #eax = 1, sys_exit    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再测试（记得先重新汇编、链接并删除没用的节区和节区表）。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wc</span> -c hello124 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在只有 124 个字节，不过还是比 123 个字节多一个，还有什么优化的办法么？</p><p>先来看看目前 <code>hello</code> 的功能，感觉不太符合要求，因为只需要打印 <code>Hello World</code>，所以不必处理所有的参数，仅仅需要接收并打印一个参数就可以。这样的话，把 <code>jmp vnext</code>（2 字节）这个循环去掉，然后在第一个 <code>pop %ecx</code> 语句之前加一个 <code>pop %ecx</code>（1 字节）语句就可以。</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx    popl %ecx        #弹出argc[0]的地址    popl %ecx        #弹出argv[1]的地址    test %ecx, %ecx    jz exit    movl %ecx, %ebx    xorl %edx, %edxstrlen:    movb (%ebx), %al    inc %edx    inc %ebx    test %al, %al    jnz strlen    movb $10, -1(%ebx)    xorl %eax, %eax    movb $4, %al    xorl %ebx, %ebx    incl %ebx    int $0x80exit:    xorl %eax, %eax    movl %eax, %ebx    incl %eax    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在刚好 123 字节，和原来那个代码大小一样，不过仔细分析，还是有减少代码的余地：因为在这个代码中，用了一段额外的代码计算字符串的长度，实际上如果仅仅需要打印 <code>Hello World</code>，那么字符串的长度是固定的，即 12 。所以这段代码可去掉，与此同时测试字符串是否为空也就没有必要（不过可能影响代码健壮性！），当然，为了能够在打印字符串后就换行，在串的末尾需要加一个回车（<code>$10</code>）并且设置字符串的长度为 <code>12+1</code>，即 13，</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx    popl %ecx    popl %ecx    movb $10,12(%ecx) #在Hello World的结尾加一个换行符    xorl %edx, %edx    movb $13, %dl    xorl %eax, %eax    movb $4, %al    xorl %ebx, %ebx    incl %ebx    int $0x80    xorl %eax, %eax    movl %eax, %ebx    incl %eax    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再看看效果，</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wc</span> -c hello111 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="寄存器赋值重用"><a href="#寄存器赋值重用" class="headerlink" title="寄存器赋值重用"></a>寄存器赋值重用</h3><p>现在只剩下 111 字节，比刚才少了 12 字节。貌似到了极限？还有措施么？</p><p>还有，仔细分析发现：系统调用 <code>sys_exit</code> 和 <code>sys_write</code> 都用到了 <code>eax</code> 和 <code>ebx</code> 寄存器，它们之间刚好有那么一点巧合：</p><ul><li>sys_exit 调用时，<code>eax</code> 需要设置为 1，<code>ebx</code> 需要设置为 0 。</li><li>sys_write 调用时，<code>ebx</code> 刚好是 1 。</li></ul><p>因此，如果在 <code>sys_exit</code> 调用之前，先把 <code>ebx</code> 复制到 <code>eax</code> 中，再对 <code>ebx</code> 减一，则可减少两个字节。</p><p>不过，因为标准输入、标准输出和标准错误都指向终端，如果往标准输入写入一些东西，它还是会输出到标准输出上，所以在上述代码中如果在 <code>sys_write</code> 之前 <code>ebx</code> 设置为 0，那么也可正常往屏幕上打印 <code>Hello World</code>，这样的话，<code>sys_exit</code> 调用前就没必要修改 <code>ebx</code>，而仅需把 <code>eax</code> 设置为 1，这样就可减少 3 个字节。</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx    popl %ecx    popl %ecx    movb $10,12(%ecx)    xorl %edx, %edx    movb $13, %dl    xorl %eax, %eax    movb $4, %al    xorl %ebx, %ebx    int $0x80    xorl %eax, %eax    incl %eax    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看效果，</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wc</span> -c hello108 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在看一下纯粹的指令还有多少？</p><pre class="line-numbers language-assembly"><code class="language-assembly">$ readelf -h hello | grep Size  Size of this header:               52 (bytes)  Size of program headers:           32 (bytes)  Size of section headers:           0 (bytes)$  echo "108-52-32" | bc24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通过文件名传递参数"><a href="#通过文件名传递参数" class="headerlink" title="通过文件名传递参数"></a>通过文件名传递参数</h3><p>对于标准的 <code>main</code> 函数的两个参数，文件名实际上作为第二个参数（数组）的第一个元素传入，如果仅仅是为了打印一个字符串，那么可以打印文件名本身。例如，要打印 <code>Hello World</code>，可以把文件名命名为 <code>Hello World</code> 即可。</p><p>这样地话，代码中就可以删除掉一条 <code>popl</code> 指令，减少 1 个字节，变成 107 个字节。</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx    popl %ecx    movb $10,12(%ecx)    xorl %edx, %edx    movb $13, %dl    xorl %eax, %eax    movb $4, %al    xorl %ebx, %ebx    int $0x80    xorl %eax, %eax    incl %eax    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看效果，</p><pre class="line-numbers language-assembly"><code class="language-assembly">$ as --32 -o hello.o hello.s$ ld -melf_i386 -o hello hello.o$ sstrip hello$ wc -c hello107$ mv hello "Hello World"$ export PATH=./:$PATH$ Hello\ WorldHello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除非必要指令"><a href="#删除非必要指令" class="headerlink" title="删除非必要指令"></a>删除非必要指令</h3><p>在测试中发现，<code>edx</code>，<code>eax</code>，<code>ebx</code> 的高位即使不初始化，也常为 0，如果不考虑健壮性（仅这里实验用，实际使用中必须考虑健壮性），几条 <code>xorl</code> 指令可以移除掉。</p><p>另外，如果只是为了演示打印字符串，完全可以不用打印换行符，这样下来，代码可以综合优化成如下几条指令：</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx    # argc    popl %ecx    # argv[0]    movb $5, %dl    # 设置字符串长度    movb $4, %al    # eax = 4, 设置系统调用号, sys_write(fd, addr, len) : ebx, ecx, edx    int $0x80    movb $1, %al    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看效果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o hello.o hello.s$ ld -melf_i386 -o hello hello.o$ sstrip hello$ <span class="token function">wc</span> -c hello96<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="合并代码段、程序头和文件头（52字节）"><a href="#合并代码段、程序头和文件头（52字节）" class="headerlink" title="合并代码段、程序头和文件头（52字节）"></a>合并代码段、程序头和文件头（52字节）</h2><h3 id="把代码段移入文件头"><a href="#把代码段移入文件头" class="headerlink" title="把代码段移入文件头"></a>把代码段移入文件头</h3><p>纯粹的指令只有 <code>96-84=12</code> 个字节了，还有办法再减少目标文件的大小么？这 12 个字节是否可以插入到文件头部或程序头部？如果可以那是否意味着还可减少可执行文件的大小呢？现在来比较一下这三部分的十六进制内容。</p><pre class="line-numbers language-bash"><code class="language-bash">$ hexdump -C hello -n 52     <span class="token comment" spellcheck="true">#文件头(52bytes)</span>00000000  7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 00  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 01 00 00 00  54 80 04 08 34 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.4<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  00 00 00 00 00 00 00 00  34 00 20 00 01 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  00 00 00 00                                       <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000034$ hexdump -C hello -s 52 -n 32    <span class="token comment" spellcheck="true">#程序头(32bytes)</span>00000034  01 00 00 00 00 00 00 00  00 80 04 08 00 80 04 08  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000044  6c 00 00 00 6c 00 00 00  05 00 00 00 00 10 00 00  <span class="token operator">|</span>l<span class="token punctuation">..</span>.l<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000054$ hexdump -C hello -s 84          <span class="token comment" spellcheck="true">#实际代码部分(12bytes)</span>00000054  59 59 b2 05 b0 04 <span class="token function">cd</span> 80  b0 01 <span class="token function">cd</span> 80              <span class="token operator">|</span>YY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000060<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面结果发现 <code>ELF</code> 文件头部和程序头部还有好些空洞（0），是否可以把指令字节分散放入到那些空洞里或者是直接覆盖掉那些系统并不关心的内容？抑或是把代码压缩以后放入可执行文件中，并在其中实现一个解压缩算法？还可以是通过一些代码覆盖率测试工具（<code>gcov</code>，<code>prof</code>）对你的代码进行优化？</p><p>在继续介绍之前，先来看一个 <code>dd</code> 工具，可以用来直接“编辑” <code>ELF</code> 文件，例如，</p><p>直接往指定位置写入 <code>0xff</code> ：</p><pre class="line-numbers language-bash"><code class="language-bash">$ hexdump -C hello -n 16    <span class="token comment" spellcheck="true"># 写入前，elf文件前16个字节</span>00000000  7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 00  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010$ <span class="token keyword">echo</span> -ne <span class="token string">"\xff"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 seek<span class="token operator">=</span>15 conv<span class="token operator">=</span>notrunc    <span class="token comment" spellcheck="true"># 把最后一个字节0覆盖掉</span>1+0 records <span class="token keyword">in</span>1+0 records out1 byte <span class="token punctuation">(</span>1 B<span class="token punctuation">)</span> copied, 3.7349e-05 s, 26.8 kB/s$ hexdump -C hello -n 16    <span class="token comment" spellcheck="true"># 写入后果然被覆盖</span>00000000  7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 ff  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>seek=15</code> 表示指定写入位置为第 15 个（从第 0 个开始）</li><li><code>conv=notrunc</code> 选项表示要保留写入位置之后的内容，默认情况下会截断。</li><li><code>bs=1</code> 表示一次读/写 1 个</li><li><code>count=1</code> 表示总共写 1 次</li></ul><p>覆盖多个连续的值：</p><p>把第 12，13，14，15 连续 4 个字节全部赋值为 <code>0xff</code> 。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\xff\xff\xff\xff"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>4 seek<span class="token operator">=</span>12 conv<span class="token operator">=</span>notrunc$ hexdump -C hello -n 1600000000  7f 45 4c 46 01 01 01 00  00 00 00 00 ff ff ff ff  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面，通过往文件头指定位置写入 <code>0xff</code> 确认哪些部分对于可执行文件的执行是否有影响？这里是逐步测试后发现依然能够执行的情况：</p><pre class="line-numbers language-bash"><code class="language-bash">$ hexdump -C hello00000000  7f 45 4c 46 ff ff ff ff  ff ff ff ff ff ff ff ff  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 ff ff ff ff  54 80 04 08 34 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.4<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  ff ff ff ff ff ff ff ff  34 00 20 00 01 00 ff ff  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  ff ff ff ff 01 00 00 00  00 00 00 00 00 80 04 08  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000040  00 80 04 08 60 00 00 00  60 00 00 00 05 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000050  00 10 00 00 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span>YY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000060<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，文件头部分，有 30 个字节即使被篡改后，该可执行文件依然可以正常执行。这意味着，这 30 字节是可以写入其他代码指令字节的。而我们的实际代码指令只剩下 12 个，完全可以直接移到前 12 个 <code>0xff</code> 的位置，即从第 4 个到第 15 个。</p><p>而代码部分的起始位置，通过 <code>readelf -h</code> 命令可以看到：</p><pre><code>$ readelf -h hello | grep &quot;Entry&quot;  Entry point address:               0x8048054</code></pre><p>上面地址的最后两位 <code>0x54=84</code> 就是代码在文件中的偏移，也就是刚好从程序头之后开始的，也就是用文件头（52）+程序头（32）个字节开始的 12 字节覆盖到第 4 个字节开始的 12 字节内容即可。</p><p>上面的 <code>dd</code> 命令从 <code>echo</code> 命令获得输入，下面需要通过可执行文件本身获得输入，先把代码部分移过去：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>hello of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 skip<span class="token operator">=</span>84 count<span class="token operator">=</span>12 seek<span class="token operator">=</span>4 conv<span class="token operator">=</span>notrunc12+0 records <span class="token keyword">in</span>12+0 records out12 bytes <span class="token punctuation">(</span>12 B<span class="token punctuation">)</span> copied, 4.9552e-05 s, 242 kB/s$ hexdump -C hello00000000  7f 45 4c 46 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span>.ELFYY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 01 00 00 00  54 80 04 08 34 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.4<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  00 00 00 00 00 00 00 00  34 00 20 00 01 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  00 00 00 00 01 00 00 00  00 00 00 00 00 80 04 08  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000040  00 80 04 08 60 00 00 00  60 00 00 00 05 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000050  00 10 00 00 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span>YY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000060<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着把代码部分截掉：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>hello of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 skip<span class="token operator">=</span>84 seek<span class="token operator">=</span>840+0 records <span class="token keyword">in</span>0+0 records out0 bytes <span class="token punctuation">(</span>0 B<span class="token punctuation">)</span> copied, 1.702e-05 s, 0.0 kB/s$ hexdump -C hello00000000  7f 45 4c 46 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span>.ELFYY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 01 00 00 00  54 80 04 08 34 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.4<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  00 00 00 00 00 00 00 00  34 00 20 00 01 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  00 00 00 00 01 00 00 00  00 00 00 00 00 80 04 08  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000040  00 80 04 08 60 00 00 00  60 00 00 00 05 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000050  00 10 00 00                                       <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000054<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候还不能执行，因为代码在文件中的位置被移动了，相应地，文件头中的 <code>Entry point address</code>，即文件入口地址也需要被修改为 <code>0x8048004</code> 。</p><p>即需要把 <code>0x54</code> 所在的第 24 个字节修改为 <code>0x04</code> ：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\x04"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 seek<span class="token operator">=</span>24 conv<span class="token operator">=</span>notrunc1+0 records <span class="token keyword">in</span>1+0 records out1 byte <span class="token punctuation">(</span>1 B<span class="token punctuation">)</span> copied, 3.7044e-05 s, 27.0 kB/s$ hexdump -C hello00000000  7f 45 4c 46 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span>.ELFYY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 01 00 00 00  04 80 04 08 34 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  84 00 00 00 00 00 00 00  34 00 20 00 01 00 28 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span>.<span class="token punctuation">(</span>.<span class="token operator">|</span>00000030  05 00 02 00 01 00 00 00  00 00 00 00 00 80 04 08  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000040  00 80 04 08 60 00 00 00  60 00 00 00 05 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000050  00 10 00 00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改后就可以执行了。</p><h3 id="把程序头移入文件头"><a href="#把程序头移入文件头" class="headerlink" title="把程序头移入文件头"></a>把程序头移入文件头</h3><p>程序头部分经过测试发现基本上都不能修改并且需要是连续的，程序头有 32 个字节，而文件头中连续的 <code>0xff</code> 可以被篡改的只有从第 46 个开始的 6 个了，另外，程序头刚好是 <code>01 00</code> 开头，而第 44，45 个刚好为 <code>01 00</code>，这样地话，这两个字节文件头可以跟程序头共享，这样地话，程序头就可以往文件头里头移动 8 个字节了。</p><pre><code>$ dd if=hello of=hello bs=1 skip=52 seek=44 count=32 conv=notrunc</code></pre><p>再把最后 8 个没用的字节删除掉，保留 <code>84-8=76</code> 个字节：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>hello of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 skip<span class="token operator">=</span>76 seek<span class="token operator">=</span>76$ hexdump -C hello00000000  7f 45 4c 46 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span>.ELFYY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 01 00 00 00  04 80 04 08 34 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  84 00 00 00 00 00 00 00  34 00 20 00 01 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  00 00 00 00 00 80 04 08  00 80 04 08 60 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000040  60 00 00 00 05 00 00 00  00 10 00 00              <span class="token operator">|</span><span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>0000004c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，还需要把文件头中程序头的位置信息改为 44，即第 28 个字节，原来是 <code>0x34</code>，即 52 的位置。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"obase=16;ibase=10;44"</span> <span class="token operator">|</span> <span class="token function">bc</span>    <span class="token comment" spellcheck="true"># 先把44转换是16进制的0x2C</span>2C$ <span class="token keyword">echo</span> -ne <span class="token string">"\x2C"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 seek<span class="token operator">=</span>28 conv<span class="token operator">=</span>notrunc    <span class="token comment" spellcheck="true"># 修改文件头</span>1+0 records <span class="token keyword">in</span>1+0 records out1 byte <span class="token punctuation">(</span>1 B<span class="token punctuation">)</span> copied, 3.871e-05 s, 25.8 kB/s$ hexdump -C hello00000000  7f 45 4c 46 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span>.ELFYY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 01 00 00 00  04 80 04 08 2c 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>,<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  84 00 00 00 00 00 00 00  34 00 20 00 01 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  00 00 00 00 00 80 04 08  00 80 04 08 60 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000040  60 00 00 00 05 00 00 00  00 10 00 00              <span class="token operator">|</span><span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>0000004c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改后即可执行了，目前只剩下 76 个字节：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">wc</span> -c hello76<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="在非连续的空间插入代码"><a href="#在非连续的空间插入代码" class="headerlink" title="在非连续的空间插入代码"></a>在非连续的空间插入代码</h3><p>另外，还有 12 个字节可以放代码，见 <code>0xff</code> 的地方：</p><pre class="line-numbers language-bash"><code class="language-bash">$ hexdump -C hello00000000  7f 45 4c 46 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span>.ELFYY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 ff ff ff ff  04 80 04 08 2c 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>,<span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  ff ff ff ff ff ff ff ff  34 00 20 00 01 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  00 00 00 00 00 80 04 08  00 80 04 08 60 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000040  60 00 00 00 05 00 00 00  00 10 00 00              <span class="token operator">|</span><span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>0000004c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过因为空间不是连续的，需要用到跳转指令作为跳板利用不同的空间。</p><p>例如，如果要利用后面的 <code>0xff</code> 的空间，可以把第 14，15 位置的 <code>cd 80</code> 指令替换为一条跳转指令，比如跳转到第 20 个字节的位置，从跳转指令之后的 16 到 20 刚好 4 个字节。</p><p>然后可以参考 X86 指令编码表（也可以写成汇编生成可执行文件后用 <code>hexdump</code> 查看），可以把 <code>jmp</code> 指令编码为： <code>0xeb 0x04</code> 。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\xeb\x04"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>2 seek<span class="token operator">=</span>14 conv<span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后把原来位置的 <code>cd 80</code> 移动到第 20 个字节开始的位置：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\xcd\x80"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>2 seek<span class="token operator">=</span>20 conv<span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>依然可以执行，类似地可以利用更多非连续的空间。</p><h3 id="把程序头完全合入文件头"><a href="#把程序头完全合入文件头" class="headerlink" title="把程序头完全合入文件头"></a>把程序头完全合入文件头</h3><p>通过分析 Linux 系统对 <code>ELF</code> 文件头部和程序头部的解析，可以更进一步合并程序头和文件头。</p><p>把最简的 <code>ELF</code> 文件（简单返回一个数值）压缩到 45 个字节，需要是非常极端的努力。</p><p>首先对 <code>ELF</code> 文件头部和程序头部做更彻底的理解，并具体到每一个字节的含义以及在 Linux 系统下的实际解析情况。</p><p>先来看看 <code>readelf -a</code> 的结果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o hello.o hello.s$ ld -melf_i386 -o hello hello.o$ sstrip hello$ readelf -a helloELF Header:  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  Class:                             ELF32  Data:                              2's complement, little endian  Version:                           1 <span class="token punctuation">(</span>current<span class="token punctuation">)</span>  OS/ABI:                            UNIX - System V  ABI Version:                       0  Type:                              EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span>  Machine:                           Intel 80386  Version:                           0x1  Entry point address:               0x8048054  Start of program headers:          52 <span class="token punctuation">(</span>bytes into file<span class="token punctuation">)</span>  Start of section headers:          0 <span class="token punctuation">(</span>bytes into file<span class="token punctuation">)</span>  Flags:                             0x0  Size of this header:               52 <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>  Size of program headers:           32 <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>  Number of program headers:         1  Size of section headers:           0 <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>  Number of section headers:         0  Section header string table index: 0There are no sections <span class="token keyword">in</span> this file.There are no sections to group <span class="token keyword">in</span> this file.Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  LOAD           0x000000 0x08048000 0x08048000 0x00060 0x00060 R E 0x1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后结合 <code>/usr/include/linux/elf.h</code> 分别做详细注解。</p><p>首先是 52 字节的 <code>Elf</code> 文件头的结构体 <code>elf32_hdr</code>：</p><table><thead><tr><th>变量类型</th><th>变量名</th><th>字节</th><th>说明</th><th>类型</th></tr></thead><tbody><tr><td>unsigned char</td><td>e_ident[EI_NIDENT]</td><td>16</td><td>.ELF 前四个标识文件类型</td><td>必须</td></tr><tr><td>Elf32_Half</td><td>e_type</td><td>2</td><td>指定为可执行文件</td><td>必须</td></tr><tr><td>Elf32_Half</td><td>e_machine</td><td>2</td><td>指示目标机类型，例如：Intel 386</td><td>必须</td></tr><tr><td>Elf32_Word</td><td>e_version</td><td>4</td><td>当前只有一个版本存在，被忽略了</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Addr</td><td>e_entry</td><td>4</td><td>代码入口=加载地址(p_vaddr+.text偏移)</td><td><strong>可调整</strong></td></tr><tr><td>Elf32_Off</td><td>e_phoff</td><td>4</td><td>程序头 Phdr 的偏移地址，用于加载代码</td><td>必须</td></tr><tr><td>Elf32_Off</td><td>e_shoff</td><td>4</td><td>所有节区相关信息对文件执行无效</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Word</td><td>e_flags</td><td>4</td><td>Intel 架构未使用</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Half</td><td>e_ehsize</td><td>2</td><td>文件头大小，Linux 没做校验</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Half</td><td>e_phentsize</td><td>2</td><td>程序头入口大小，新内核有用</td><td>必须</td></tr><tr><td>Elf32_Half</td><td>e_phnum</td><td>2</td><td>程序头入口个数</td><td>必须</td></tr><tr><td>Elf32_Half</td><td>e_shentsize</td><td>2</td><td>所有节区相关信息对文件执行无效</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Half</td><td>e_shnum</td><td>2</td><td>所有节区相关信息对文件执行无效</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Half</td><td>e_shstrndx</td><td>2</td><td>所有节区相关信息对文件执行无效</td><td><del>可篡改</del></td></tr></tbody></table><p>其次是 32 字节的程序头（Phdr）的结构体 <code>elf32_phdr</code>：</p><table><thead><tr><th>变量类型</th><th>变量名</th><th>字节</th><th>说明</th><th>类型</th></tr></thead><tbody><tr><td>Elf32_Word</td><td>p_type</td><td>4</td><td>标记为可加载段</td><td>必须</td></tr><tr><td>Elf32_Off</td><td>p_offset</td><td>4</td><td>相对程序头的偏移地址</td><td>必须</td></tr><tr><td>Elf32_Addr</td><td>p_vaddr</td><td>4</td><td>加载地址, 0x0~0x80000000，页对齐</td><td><strong>可调整</strong></td></tr><tr><td>Elf32_Addr</td><td>p_paddr</td><td>4</td><td>物理地址，暂时没用</td><td><del>可篡改</del></td></tr><tr><td>Elf32_Word</td><td>p_filesz</td><td>4</td><td>加载的文件大小，&gt;=real size</td><td><strong>可调整</strong></td></tr><tr><td>Elf32_Word</td><td>p_memsz</td><td>4</td><td>加载所需内存大小，&gt;= p_filesz</td><td><strong>可调整</strong></td></tr><tr><td>Elf32_Word</td><td>p_flags</td><td>4</td><td>权限:read(4),exec(1), 其中一个暗指另外一个</td><td><strong>可调整</strong></td></tr><tr><td>Elf32_Word</td><td>p_align</td><td>4</td><td>PIC(共享库需要)，对执行文件无效</td><td><del>可篡改</del></td></tr></tbody></table><p>接着，咱们把 Elf 中的文件头和程序头部分<strong>可调整</strong>和<del>可篡改</del>的字节（52 + 32 = 84个）全部用特别的字体标记出来。</p><pre><code>$ hexdump -C hello -n 84</code></pre><blockquote><p>00000000 7f 45 4c 46 <del>01 01 01 00 00 00 00 00 00 00 00 00</del></p><p>00000010 02 00 03 00 <del>01 00 00 00</del> <strong>54 80 04 08 34</strong> 00 00 00</p><p>00000020 <del>84 00 00 00 00 00 00 00</del> 34 00 20 00 01 00 <del>28 00</del></p><p>00000030 <del>05 00 02 00</del>|01 00 00 00 00 00 00 00 <strong>00 80 04 08</strong></p><p>00000040 <del>00 80 04 08</del> <strong>60 00 00 00 60 00 00 00 05 00 00 00</strong></p><p>00000050 <del>00 10 00 00</del></p><p>00000054</p></blockquote><p>上述 <code>|</code> 线之前为文件头，之后为程序头，之前的 <code>000000xx</code> 为偏移地址。</p><p>如果要把程序头彻底合并进文件头。从上述信息综合来看，文件头有 4 处必须保留，经过对比发现，如果把第 4 行开始的程序头往上平移 3 行，也就是：</p><blockquote><p>00000000 ========= <del>01 01 01 00 00 00 00 00 00 00 00 00</del></p><p>00000010 02 00 03 00 <del>01 00 00 00</del> <strong>54 80 04 08 34</strong> 00 00 00</p><p>00000020 <del>84 00 00 00</del></p><p>00000030 ========= 01 00 00 00 00 00 00 00 <strong>00 80 04 08</strong></p><p>00000040 <del>00 80 04 08</del> <strong>60 00 00 00 60 00 00 00 05 00 00 00</strong></p><p>00000050 <del>00 10 00 00</del></p><p>00000054</p></blockquote><p>把可直接合并的先合并进去，效果如下：</p><p>（文件头）</p><blockquote><p>00000000 ========= 01 00 00 00 00 00 00 00 <strong>00 80 04 08</strong> (^^ p_vaddr)</p><p>00000010 02 00 03 00 <del>60 00 00 00</del> <strong>54 80 04 08 34</strong> 00 00 00</p><p>00000020 =================== ^^ e_entry ^^ e_phoff</p></blockquote><p>（程序头）</p><blockquote><p>00000030 ========= 01 00 00 00 00 00 00 00 <strong>00 80 04 08</strong> (^^ p_vaddr)</p><p>00000040 02 00 03 00 <strong>60 00 00 00 60 00 00 00 05 00 00 00</strong></p><p>00000050 ========= ^^ p_filesz ^^ p_memsz ^^p_flags</p><p>00000054</p></blockquote><p>接着需要设法处理好可调整的 6 处，可以逐个解决，从易到难。</p><ul><li>首先，合并 <code>e_phoff</code> 与 <code>p_flags</code></li></ul><p>在合并程序头以后，程序头的偏移地址需要修改为 4，即文件的第 4 个字节开始，也就是说 <code>e_phoff</code> 需要修改为 04。</p><p>而恰好，<code>p_flags</code> 的 <code>read(4)</code> 和 <code>exec(1)</code> 可以只选其一，所以，只保留 <code>read(4)</code> 即可，刚好也为 04。</p><p>合并后效果如下：</p><p>（文件头）</p><blockquote><p>00000000 ========= 01 00 00 00 00 00 00 00 <strong>00 80 04 08</strong> (^^ p_vaddr)</p><p>00000010 02 00 03 00 <del>60 00 00 00</del> <strong>54 80 04 08</strong> 04 00 00 00</p><p>00000020 =================== ^^ e_entry</p></blockquote><p>（程序头）</p><blockquote><p>00000030 ========= 01 00 00 00 00 00 00 00 <strong>00 80 04 08</strong> (^^ p_vaddr)</p><p>00000040 02 00 03 00 <strong>60 00 00 00 60 00 00 00</strong> 04 00 00 00</p><p>00000050 ========= ^^ p_filesz ^^ p_memsz</p><p>00000054</p></blockquote><ul><li>接下来，合并 <code>e_entry</code>，<code>p_filesz</code>, <code>p_memsz</code> 和 <code>p_vaddr</code></li></ul><p>从早前的分析情况来看，这 4 个变量基本都依赖 <code>p_vaddr</code>，也就是程序的加载地址，大体的依赖关系如下：</p><pre class="line-numbers language-bash"><code class="language-bash">e_entry <span class="token operator">=</span> p_vaddr + text offset <span class="token operator">=</span> p_vaddr + 84 <span class="token operator">=</span> p_vaddr + 0x54p_memsz <span class="token operator">=</span> e_entryp_memsz <span class="token operator">>=</span> p_filesz，可以简单取 p_filesz <span class="token operator">=</span> p_memszp_vaddr <span class="token operator">=</span> page alignment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，首先需要确定 <code>p_vaddr</code>，通过测试，发现<code>p_vaddr</code> 最低必须有 64k，也就是 0x00010000，对应到 <code>hexdump</code> 的 <code>little endian</code> 导出结果，则为 <code>00 00 01 00</code>。</p><p>需要注意的是，为了尽量少了分配内存，我们选择了一个最小的<code>p_vaddr</code>，如果申请的内存太大，系统将无法分配。</p><p>接着，计算出另外 3 个变量：</p><pre><code>e_entry = 0x00010000 + 0x54 = 0x00010054 即 54 00 01 00p_memsz = 54 00 01 00p_filesz = 54 00 01 00</code></pre><p>完全合并后，修改如下：</p><p>（文件头）</p><blockquote><p>00000000 ========= 01 00 00 00 00 00 00 00 00 00 01 00</p><p>00000010 02 00 03 00 54 00 01 00 54 00 01 00 04 00 00 00</p><p>00000020 ========</p></blockquote><p>好了，直接把内容烧入：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\x01\x00\x00\x00\x00\x00\x00\x00"</span> \       <span class="token string">"\x00\x00\x01\x00\x02\x00\x03\x00"</span> \       <span class="token string">"\x54\x00\x01\x00\x54\x00\x01\x00\x04"</span> <span class="token operator">|</span>\       <span class="token function">tr</span> -d <span class="token string">' '</span> <span class="token operator">|</span>\    <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>25 seek<span class="token operator">=</span>4 conv<span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>截掉代码（52 + 32 + 12 = 96）之后的所有内容，查看效果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>hello of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 skip<span class="token operator">=</span>96 seek<span class="token operator">=</span>96$ hexdump -C hello -n 9600000000  7f 45 4c 46 01 00 00 00  00 00 00 00 00 00 01 00  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 54 00 01 00  54 00 01 00 04 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.T<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  84 00 00 00 00 00 00 00  34 00 20 00 01 00 28 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span>.<span class="token punctuation">(</span>.<span class="token operator">|</span>00000030  05 00 02 00 01 00 00 00  00 00 00 00 00 80 04 08  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000040  00 80 04 08 60 00 00 00  60 00 00 00 05 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token variable"><span class="token variable">`</span><span class="token punctuation">..</span>.<span class="token variable">`</span></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000050  00 10 00 00 59 59 b2 05  b0 04 <span class="token function">cd</span> 80 b0 01 <span class="token function">cd</span> 80  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span>YY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000060<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后的工作是查看文件头中剩下的<del>可篡改</del>的内容，并把<strong>代码部分</strong>合并进去，程序头已经合入，不再显示。</p><blockquote><p>00000000 7f 45 4c 46 01 00 00 00 00 00 00 00 00 00 01 00</p><p>00000010 02 00 03 00 54 00 01 00 54 00 01 00 04 00 00 00</p><p>00000020 <del>84 00 00 00 00 00 00 00</del> 34 00 20 00 01 00 <del>28 00</del></p><p>00000030 <del>05 00 02 00</del></p><p>00000040</p><p>00000050 ============= <strong>59 59 b2 05 b0 04 cd 80 b0 01 cd 80</strong></p><p>00000060</p></blockquote><p>我们的指令有 12 字节，<del>可篡改</del>的部分有 14 个字节，理论上一定放得下，不过因为把程序头搬进去以后，这 14 个字节并不是连续，刚好可以用上我们之前的跳转指令处理办法来解决。</p><p>并且，加入 2 个字节的跳转指令，刚好是 14 个字节，恰好把代码也完全包含进了文件头。</p><p>在预留好<strong>跳转指令</strong>位置的前提下，我们把代码部分先合并进去：</p><blockquote><p>00000000 7f 45 4c 46 01 00 00 00 00 00 00 00 00 00 01 00</p><p>00000010 02 00 03 00 54 00 01 00 54 00 01 00 04 00 00 00</p><p>00000020 <strong>59 59 b2 05 b0 04</strong> <del>00 00</del> 34 00 20 00 01 00 <strong>cd 80</strong></p><p>00000030 <strong>b0 01 cd 80</strong></p></blockquote><p>接下来设计跳转指令，跳转指令需要从所在位置跳到第一个 <strong>cd 80</strong> 所在的位置，相距 6 个字节，根据 <code>jmp</code> 短跳转的编码规范，可以设计为 <code>0xeb 0x06</code>，填完后效果如下：</p><blockquote><p>00000000 7f 45 4c 46 01 00 00 00 00 00 00 00 00 00 01 00</p><p>00000010 02 00 03 00 54 00 01 00 54 00 01 00 04 00 00 00</p><p>00000020 <strong>59 59 b2 05 b0 04 eb 06</strong> 34 00 20 00 01 00 <strong>cd 80</strong></p><p>00000030 <strong>b0 01 cd 80</strong></p></blockquote><p>用 <code>dd</code> 命令写入，分两段写入：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\x59\x59\xb2\x05\xb0\x04\xeb\x06"</span> <span class="token operator">|</span> \    <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>8 seek<span class="token operator">=</span>32 conv<span class="token operator">=</span>notrunc$ <span class="token keyword">echo</span> -ne <span class="token string">"\xcd\x80\xb0\x01\xcd\x80"</span> <span class="token operator">|</span> \    <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>6 seek<span class="token operator">=</span>46 conv<span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码合入以后，需要修改文件头中的代码的偏移地址，即 <code>e_entry</code>，也就是要把原来的偏移 84 (0x54) 修改为现在的偏移，即 0x20。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\x20"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 seek<span class="token operator">=</span>24 conv<span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改完以后恰好把合并进的程序头 <code>p_memsz</code>，也就是分配给文件的内存改小了，<code>p_filesz</code>也得相应改小。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -ne <span class="token string">"\x20"</span> <span class="token operator">|</span> <span class="token function">dd</span> of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 seek<span class="token operator">=</span>20 conv<span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>程序头和代码都已经合入，最后，把 52 字节之后的内容全部删掉：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>hello of<span class="token operator">=</span>hello bs<span class="token operator">=</span>1 count<span class="token operator">=</span>1 skip<span class="token operator">=</span>52 seek<span class="token operator">=</span>52$ hexdump -C hello00000000  7f 45 4c 46 01 00 00 00  00 00 00 00 00 00 01 00  <span class="token operator">|</span>.ELF<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>00000010  02 00 03 00 20 00 01 00  20 00 01 00 04 00 00 00  <span class="token operator">|</span><span class="token punctuation">..</span><span class="token punctuation">..</span>T<span class="token punctuation">..</span>.T<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000020  59 59 b2 05 b0 04 eb 06  34 00 20 00 01 00 <span class="token function">cd</span> 80  <span class="token operator">|</span>YY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>4. <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token operator">|</span>00000030  b0 01 <span class="token function">cd</span> 80$ <span class="token function">export</span> PATH<span class="token operator">=</span>./:<span class="token variable">$PATH</span>$ hellohello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码</strong>和<del>程序头</del>部分合并进文件头的汇总情况：</p><blockquote><p>00000000 7f 45 4c 46 <del>01 00 00 00 00 00 00 00 00 00 01 00</del></p><p>00000010 <del>02 00 03 00 20 00 01 00 20 00 01 00 04 00 00 00</del></p><p>00000020 <strong><del>59 59 b2 05</del> b0 04 eb 06</strong> 34 00 20 00 01 00 <strong>cd 80</strong></p><p>00000030 <strong>b0 01 cd 80</strong></p></blockquote><p>最后，我们的成绩是：</p><pre><code>$ wc -c hello52</code></pre><p>史上最小的可打印 <code>Hello World</code>（注：要完全打印得把代码中的5该为13，并且把文件名该为该字符串） 的 <code>Elf</code> 文件是 52 个字节。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> ELFkickers/tiny/$ <span class="token function">wc</span> -c hello59 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要特别提到的是，该作者创造的最小可执行 Elf 是 45 个字节。</p><p>但是由于那个程序只能返回一个数值，代码更简短，刚好可以直接嵌入到文件头中间，而文件末尾的 7 个 <code>0</code> 字节由于 Linux 加载时会自动填充，所以可以删掉，所以最终的文件大小是 52 - 7 即 45 个字节。</p><p>其大体可实现如下：</p><pre class="line-numbers language-bash"><code class="language-bash">.global _start_start:    mov <span class="token variable">$42</span>, %bl   <span class="token comment" spellcheck="true"># 设置返回值为 42</span>    xor %eax, %eax <span class="token comment" spellcheck="true"># eax = 0</span>    inc %eax       <span class="token comment" spellcheck="true"># eax = eax+1, 设置系统调用号, sys_exit()</span>    int <span class="token variable">$0x80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存为 ret.s，编译和执行效果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o ret.o ret.s$ ld -melf_i386 -o ret ret.o$ ./ret42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>代码字节数可这么查看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ ld -melf_i386 --oformat<span class="token operator">=</span>binary -o ret.bin ret.o$ hexdump -C ret.bin0000000  b3 2a 31 c0 40 <span class="token function">cd</span> 800000007<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里只有 7 条指令，刚好可以嵌入，而最后的 6 个字节因为<del>可篡改</del>为 0，并且内核可自动填充 0，所以干脆可以连续删掉最后 7 个字节的 0：</p><blockquote><p>00000000 7f 45 4c 46 01 00 00 00 00 00 00 00 00 00 01 00</p><p>00000010 02 00 03 00 54 00 01 00 54 00 01 00 04 00 00 00</p><p>00000020 <strong>b3 2a 31 c0 40 cd 80</strong> 00 34 00 20 00 01 00 00 00</p><p>00000030 00 00 00 00</p></blockquote><p>可以直接用已经合并好程序头的 <code>hello</code> 来做实验，这里一并截掉最后的 7 个 0 字节：</p><pre><code>$ cp hello ret$ echo -ne &quot;\xb3\x2a\x31\xc0\x40\xcd\x80&quot; |\    dd of=ret bs=1 count=8 seek=32 conv=notrunc$ dd if=ret of=hello bs=1 count=1 skip=45 seek=45$ hexdump -C hello00000000  7f 45 4c 46 01 00 00 00  00 00 00 00 00 00 01 00  |.ELF............|00000010  02 00 03 00 20 00 01 00  20 00 01 00 04 00 00 00  |.... ... .......|00000020  b3 2a 31 c0 40 cd 80 06  34 00 20 00 01           |.*1.@...4. ..|0000002d$ wc -c ret45 ret$ ./ret$ echo $?42</code></pre><p>如果想快速构建该 <code>Elf</code> 文件，可以直接使用下述 Shell 代码：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># generate_ret_elf.sh -- Generate a 45 bytes Elf file</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># $ bash generate_ret_elf.sh</span><span class="token comment" spellcheck="true"># $ chmod a+x ret.elf</span><span class="token comment" spellcheck="true"># $ ./ret.elf</span><span class="token comment" spellcheck="true"># $ echo $?</span><span class="token comment" spellcheck="true"># 42</span><span class="token comment" spellcheck="true">#</span>ret<span class="token operator">=</span><span class="token string">"\x7f\x45\x4c\x46\x01\x00\x00\x00"</span>ret<span class="token operator">=</span><span class="token variable">${ret}</span><span class="token string">"\x00\x00\x00\x00\x00\x00\x01\x00"</span>ret<span class="token operator">=</span><span class="token variable">${ret}</span><span class="token string">"\x02\x00\x03\x00\x20\x00\x01\x00"</span>ret<span class="token operator">=</span><span class="token variable">${ret}</span><span class="token string">"\x20\x00\x01\x00\x04\x00\x00\x00"</span>ret<span class="token operator">=</span><span class="token variable">${ret}</span><span class="token string">"\xb3\x2a\x31\xc0\x40\xcd\x80\x06"</span>ret<span class="token operator">=</span><span class="token variable">${ret}</span><span class="token string">"\x34\x00\x20\x00\x01"</span><span class="token keyword">echo</span> -ne <span class="token variable">$ret</span> <span class="token operator">></span> ret.elf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又或者是直接参照<code>tiny.asm</code> ，其代码如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly">; ret.asm  BITS 32            org     0x00010000            db      0x7F, "ELF"             ; e_ident            dd      1                                       ; p_type            dd      0                                       ; p_offset            dd      $$                                      ; p_vaddr            dw      2                       ; e_type        ; p_paddr            dw      3                       ; e_machine            dd      _start                  ; e_version     ; p_filesz            dd      _start                  ; e_entry       ; p_memsz            dd      4                       ; e_phoff       ; p_flags  _start:            mov     bl, 42                  ; e_shoff       ; p_align            xor     eax, eax            inc     eax                     ; e_flags            int     0x80            db      0            dw      0x34                    ; e_ehsize            dw      0x20                    ; e_phentsize            db      1                       ; e_phnum                                            ; e_shentsize                                            ; e_shnum                                            ; e_shstrndx  filesize      equ     $ - $$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译和运行效果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ nasm -f bin -o ret ret.asm$ <span class="token function">chmod</span> +x ret$ ./ret <span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token variable">$?</span>42$ <span class="token function">wc</span> -c ret45 ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面也给一下本文精简后的 <code>hello</code> 的 <code>nasm</code> 版本：</p><pre class="line-numbers language-assembly"><code class="language-assembly">; hello.asm  BITS 32            org     0x00010000            db      0x7F, "ELF"             ; e_ident            dd      1                                       ; p_type            dd      0                                       ; p_offset            dd      $$                                      ; p_vaddr            dw      2                       ; e_type        ; p_paddr            dw      3                       ; e_machine            dd      _start                  ; e_version     ; p_filesz            dd      _start                  ; e_entry       ; p_memsz            dd      4                       ; e_phoff       ; p_flags  _start:            pop     ecx     ; argc          ; e_shoff       ; p_align            pop     ecx     ; argv[0]            mov     dl, 5   ; str len       ; e_flags            mov     al, 4   ; sys_write(fd, addr, len) : ebx, ecx, edx            jmp     _next   ; jump to next part of the code            dw      0x34                      ; e_ehsize            dw      0x20                      ; e_phentsize            dw      1                         ; e_phnum  _next:        int     0x80    ; syscall         ; e_shentsize            mov     al, 1   ; eax=1,sys_exit  ; e_shnum            int     0x80    ; syscall         ; e_shstrndx  filesize      equ     $ - $$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译和用法如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ nasm -f bin -o hello hello.asm$ <span class="token function">chmod</span> a+x hello$ <span class="token function">export</span> PATH<span class="token operator">=</span>./:<span class="token variable">$PATH</span>$ hellohello$ <span class="token function">wc</span> -c hello52<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过一番努力，<code>AT&amp;T</code> 的完整 binary 版本如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly"># hello.s## as --32 -o hello.o hello.s# ld -melf_i386 --oformat=binary -o hello hello.o#    .file "hello.s"    .global _start, _load    .equ   LOAD_ADDR, 0x00010000   # Page aligned load addr, here 64k    .equ   E_ENTRY, LOAD_ADDR + (_start - _load)    .equ   P_MEM_SZ, E_ENTRY    .equ   P_FILE_SZ, P_MEM_SZ_load:    .byte  0x7F    .ascii "ELF"                  # e_ident, Magic Number    .long  1                                      # p_type, loadable seg    .long  0                                      # p_offset    .long  LOAD_ADDR                              # p_vaddr    .word  2                      # e_type, exec  # p_paddr    .word  3                      # e_machine, Intel 386 target    .long  P_FILE_SZ              # e_version     # p_filesz    .long  E_ENTRY                # e_entry       # p_memsz    .long  4                      # e_phoff       # p_flags, read(exec)    .text_start:    popl   %ecx    # argc         # e_shoff       # p_align    popl   %ecx    # argv[0]    mov    $5, %dl # str len      # e_flags    mov    $4, %al # sys_write(fd, addr, len) : ebx, ecx, edx    jmp    _next    # jump to next part of the code    .word  0x34                   # e_ehsize = 52    .word  0x20                   # e_phentsize = 32    .word  1                      # e_phnum = 1    .text_next:  int    $0x80   # syscall        # e_shentsize    mov    $1, %al # eax=1,sys_exit # e_shnum    int    $0x80   # syscall        # e_shstrndx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译和运行效果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o hello.o hello.s$ ld -melf_i386 --oformat<span class="token operator">=</span>binary -o hello hello.o$ <span class="token function">export</span> PATH<span class="token operator">=</span>./:<span class="token variable">$PATH</span>$ hellohello$ <span class="token function">wc</span> -c hello52 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注</strong>：编译时务必要加 <code>--oformat=binary</code> 参数，以便直接基于源文件构建一个二进制的 <code>Elf</code> 文件，否则会被 <code>ld</code> 默认编译，自动填充其他内容。</p><h2 id="汇编语言极限精简之道（45字节）"><a href="#汇编语言极限精简之道（45字节）" class="headerlink" title="汇编语言极限精简之道（45字节）"></a>汇编语言极限精简之道（45字节）</h2><p>经过上述努力，我们已经完全把程序头和代码都融入了 52 字节的 <code>Elf</code> 文件头，还可以再进一步吗？</p><p>如果再要努力，只能设法把 <code>Elf</code> 末尾的 7 个 0 字节删除，但是由于代码已经把 <code>Elf</code> 末尾的 7 字节 0 字符都填满了，所以要想在这一块努力，只能继续压缩代码。</p><p>继续研究下代码先：</p><pre class="line-numbers language-assembly"><code class="language-assembly">.global _start_start:    popl %ecx    # argc    popl %ecx    # argv[0]    movb $5, %dl    # 设置字符串长度    movb $4, %al    # eax = 4, 设置系统调用号, sys_write(fd, addr, len) : ebx, ecx, edx    int $0x80    movb $1, %al    int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看对应的编码：</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o hello.o hello.s$ ld -melf_i386 -o hello hello.o --oformat<span class="token operator">=</span>binary$ hexdump -C hello00000000  59 59 b2 05 b0 04 <span class="token function">cd</span> 80  b0 01 <span class="token function">cd</span> 80              <span class="token operator">|</span>YY<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">|</span>0000000c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每条指令对应的编码映射如下：</p><table><thead><tr><th>指令</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>popl %ecx</td><td>59</td><td>argc</td></tr><tr><td>popl %ecx</td><td>59</td><td>argv[0]</td></tr><tr><td>movb $5, %dl</td><td>b2 05</td><td>设置字符串长度</td></tr><tr><td>movb $4, %al</td><td>b0 04</td><td>eax = 4, 设置系统调用号, sys_write(fd, addr, len) : ebx, ecx, edx</td></tr><tr><td>int $0x80</td><td>cd 80</td><td>触发系统调用</td></tr><tr><td>movb $1, %al</td><td>b0 01</td><td>eax = 1, sys_exit</td></tr><tr><td>int $0x80</td><td>cd 80</td><td>触发系统调用</td></tr></tbody></table><p>可以观察到：</p><ul><li><code>popl</code> 的指令编码最简洁。</li><li><code>int $0x80</code> 重复了两次，而且每条都占用了 2 字节</li><li><code>movb</code> 每条都占用了 2 字节</li><li><code>eax</code> 有两次赋值，每次占用了 2 字节</li><li><code>popl %ecx</code> 取出的 argc 并未使用</li></ul><p>根据之前通过参数传递字符串的想法，咱们是否可以考虑通过参数来设置变量呢？</p><p>理论上，传入多个参数，通过 <code>pop</code> 弹出来赋予 <code>eax</code>, <code>ecx</code> 即可，但是实际上，由于从参数栈里头 <code>pop</code> 出来的参数是参数的地址，并不是参数本身，所以该方法行不通。</p><p>不过由于第一个参数取出的是数字，并且是参数个数，而且目前的那条 <code>popl %ecx</code> 取出的 <code>argc</code> 并没有使用，那么刚好可以用来设置 <code>eax</code>，替换后如下：</p><pre><code>.global _start_start:    popl %eax    # eax = 4, 设置系统调用号, sys_write(fd, addr, len) : ebx, ecx, edx    popl %ecx    # argv[0], 字符串    movb $5, %dl # 设置字符串长度    int $0x80    movb $1, %al # eax = 1, sys_exit    int $0x80</code></pre><p>这里需要传入 4 个参数，即让栈弹出的第一个值，也就是参数个数赋予 <code>eax</code>，也就是：<code>hello 5 4 1</code>。</p><p>这样，我们就把该代码优化到 10 个字节，刚好可以放到 <code>e_phentsize</code> 之前。</p><p>那最后的结果是，我们产生了一个可以正常打印字符串，大小只有 45 字节的 <code>Elf</code> 文件，最终的结果如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># hello.s</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># $ as --32 -o hello.o hello.s</span><span class="token comment" spellcheck="true"># $ ld -melf_i386 --oformat=binary -o hello hello.o</span><span class="token comment" spellcheck="true"># $ export PATH=./:$PATH</span><span class="token comment" spellcheck="true"># $ hello 0 0 0</span><span class="token comment" spellcheck="true"># hello</span><span class="token comment" spellcheck="true">#</span>    .file <span class="token string">"hello.s"</span>    .global _start, _load    .equ   LOAD_ADDR, 0x00010000   <span class="token comment" spellcheck="true"># Page aligned load addr, here 64k</span>    .equ   E_ENTRY, LOAD_ADDR + <span class="token punctuation">(</span>_start - _load<span class="token punctuation">)</span>    .equ   P_MEM_SZ, E_ENTRY    .equ   P_FILE_SZ, P_MEM_SZ_load:    .byte  0x7F    .ascii <span class="token string">"ELF"</span>              <span class="token comment" spellcheck="true"># e_ident, Magic Number</span>    .long  1                                      <span class="token comment" spellcheck="true"># p_type, loadable seg</span>    .long  0                                      <span class="token comment" spellcheck="true"># p_offset</span>    .long  LOAD_ADDR                              <span class="token comment" spellcheck="true"># p_vaddr</span>    .word  2                  <span class="token comment" spellcheck="true"># e_type, exec  # p_paddr</span>    .word  3                  <span class="token comment" spellcheck="true"># e_machine, Intel 386 target</span>    .long  P_FILE_SZ          <span class="token comment" spellcheck="true"># e_version     # p_filesz</span>    .long  E_ENTRY            <span class="token comment" spellcheck="true"># e_entry       # p_memsz</span>    .long  4                  <span class="token comment" spellcheck="true"># e_phoff       # p_flags, read(exec)</span>    .text_start:    popl   %eax    <span class="token comment" spellcheck="true"># argc     # e_shoff       # p_align</span>                   <span class="token comment" spellcheck="true"># 4 args, eax = 4, sys_write(fd, addr, len) : ebx, ecx, edx</span>                   <span class="token comment" spellcheck="true"># set 2nd eax = random addr to trigger bad syscall for exit</span>    popl   %ecx    <span class="token comment" spellcheck="true"># argv[0]</span>    mov    <span class="token variable">$5</span>, %dl <span class="token comment" spellcheck="true"># str len  # e_flags</span>    int    <span class="token variable">$0x80</span>    mov    <span class="token variable">$1</span>, %al <span class="token comment" spellcheck="true"># eax = 1, sys_exit</span>    int    <span class="token variable">$0x80</span>    .word  0x20               <span class="token comment" spellcheck="true"># e_phentsize = 32</span>    .byte  1                  <span class="token comment" spellcheck="true"># e_phnum = 1, remove trailing 7 bytes with 0 value</span>                              <span class="token comment" spellcheck="true"># e_shentsize</span>                              <span class="token comment" spellcheck="true"># e_shnum</span>                              <span class="token comment" spellcheck="true"># e_shstrndx</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ as --32 -o hello.o hello.s$ ld -melf_i386 -o hello hello.o --oformat<span class="token operator">=</span>binary$ <span class="token function">export</span> PATH<span class="token operator">=</span>./:<span class="token variable">$PATH</span>$ hello 0 0 0hello$ <span class="token function">wc</span> -c hello45 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，我们获得了史上最小的可以打印字符串的 <code>Elf</code> 文件，是的，只有 45 个字节。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，关于可执行文件的讨论暂且结束，最后来一段小小的总结，那就是我们设法去减少可执行文件大小的意义？</p><p>实际上，通过这样一个讨论深入到了很多技术的细节，包括可执行文件的格式、目标代码链接的过程、 Linux 下汇编语言开发等。与此同时，可执行文件大小的减少本身对嵌入式系统非常有用，如果删除那些对程序运行没有影响的节区和节区表将减少目标系统的大小，适应嵌入式系统资源受限的需求。除此之外，动态连接库中的很多函数可能不会被使用到，因此也可以通过某种方式剔除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文从减少可执行文件大小的角度分析了 &lt;code&gt;ELF&lt;/code&gt; 文件，期间通过经典的 &lt;code&gt;Hello World&lt;/code
      
    
    </summary>
    
    
      <category term="C" scheme="https://JoyTsing.github.io/categories/C/"/>
    
    
      <category term="Linux" scheme="https://JoyTsing.github.io/tags/Linux/"/>
    
      <category term="C" scheme="https://JoyTsing.github.io/tags/C/"/>
    
  </entry>
  
</feed>
