<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="复习"><meta name="description" content="计算机学院大三上软件工程课程复习"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>软件工程复习 | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/4.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">软件工程复习</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/UESTC/"><span class="chip bg-color">UESTC</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/UESTC/" class="post-category">UESTC</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2020-12-06</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-03-21</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 18.7k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 63 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="复习大纲"><a href="#复习大纲" class="headerlink" title="复习大纲"></a>复习大纲</h2><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><ul><li><p>软件：软件是逻辑和物理的系统，由程序、文档、数据和其他相关元素构成。软件是一个过程的抽象表示</p></li><li><p>软件工程：应用系统化、学科化、定量的方法，来开发、运行和维护软件，即将工程应用到软件。以及对以上过程中各种方法的研究</p></li><li><p><code>软件危机</code>：在计算机软件的开发和维护过程中所遇到的一系列严重问题</p><p><code>软件危机的表现</code>：</p><ul><li>开发<strong>成本</strong>和<strong>进度</strong>估计不准，开发<strong>进度难以控制</strong></li><li>用户对“已完成的”软件系统<strong>不满意</strong></li><li>软件<strong>质量和可靠性</strong>差强人意</li><li>软件常常是<strong>不可维护</strong>的</li><li>软件通常没有适当的<strong>文档</strong>资料</li><li>软件<strong>成本</strong>逐年上升</li><li>软件开发<strong>生产率</strong>滞后于硬件和计算机应用普及</li></ul></li><li><p><code>软件工程原则</code></p><ul><li>使用阶段性生命周期计划的管理</li><li>进行连续的验证</li><li>保证严格的产品控制</li><li>使用现代编程工具和工程实践</li><li>保持清晰的责任分配</li><li>用更好更少的人</li><li>保持过程改进</li></ul></li></ul><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ul><li><p>软件过程：开发和维护软件及其相关产品所涉及的一系列活动</p></li><li><p>过程模型： 软件过程模型是软件开发全部过程、活动和任务的结构框架</p></li><li><p>瀑布模型</p><ul><li><p>特点</p><p>阶段间具有<strong>顺序性</strong>和<strong>依赖性</strong>。<strong>推迟实现</strong>的观点。每个阶段必须完成规定的文档; 每个阶段结束前完成文档审查,及早改正错误</p></li><li><p>优点</p><ul><li>简单，过程<strong>透明性高</strong>，过程<strong>可管理性高</strong></li><li><strong>推迟实现</strong>，软件实现前必须进行系统分析和设计工作</li><li>以<strong>阶段评审和文档控制</strong>为手段进行质量控制，能够及时发现并纠正软件缺陷，能够达到预期质量要求</li></ul></li><li><p>缺点</p><ul><li>模型<strong>灵活性差</strong>，不适合需求不明确或准确的场合</li><li>模型<strong>风险控制能力弱</strong></li><li>过多的文档<strong>增加了工作量</strong>，当技术具有不确定性情况下完全以文档来评估项目进度时会产生错误的结论</li></ul></li><li><p>适用场合：适用于系统需求明确、技术成熟、工程管理较严格的场合</p></li></ul></li><li><p>演化模型-原型模型</p><ul><li><p>优点</p><ul><li><p>强调<strong>用户参与和决策</strong>，强化了用户与开发人员的沟通</p></li><li><p>可<strong>加快需求的确定</strong>，能够处理需求的不确定性和风险</p></li><li><p><strong>简化</strong>了项目管理、<strong>缩短</strong>了开发时间、<strong>降低</strong>了风险和开发成本</p></li></ul></li><li><p>缺点</p><ul><li><p>不适用于开发大型系统</p></li><li><p>软件<strong>可维护性差</strong></p></li><li><p><strong>用户合作要求高</strong>，如果合作不好，反而会拖延开发进度</p></li></ul></li><li><p>适用情况：客户定义一个总体目标集，但是他们并<strong>不清楚系统的具体输入输出</strong>；或开发者<strong>不确定算法的效率</strong>、软件与操作系统是否兼容以及客户与计算机交互的方式</p></li></ul></li><li><p>增量模型</p><ul><li><p>特点</p><ul><li>在前面增量的基础上开发后面的增量</li><li>每个增量的开发可用瀑布或快速原型模型</li><li>迭代的思路</li></ul></li><li><p>优点</p><ul><li>引入增量包概念，不需要提供完整的需求</li><li>在项目的初始阶段不需要投入太多的人力资源</li><li>增量可以有效地管理技术风险，降低系统失败风险</li><li>有利于增加客户信心，提高系统可靠性、可维护性和稳定性</li></ul></li><li><p>缺点</p><ul><li>增量粒度难以选择</li><li>确定所有的基本业务比较困难</li></ul></li></ul></li><li><p>RAD</p><ul><li><p>缺点</p><ul><li>对大型项目而言，RAD 需要足够的人力资源</li><li>由于时间约束，开发者和客户都要实现承诺，沟通配合不当都会导致失败</li><li>不适合：不能合理模块化的系统、高性能需求并且要调整构件接口的、技术风险很高的系统均不适合</li></ul></li><li><p>适用范围：管理类信息系统开发</p></li></ul></li><li><p>螺旋模型</p><ul><li><p>适用范围：需求不明确、特别是大型软件系统的开发</p></li><li><p>优点：</p><ul><li>支持用户需求的<strong>动态变化</strong></li><li><strong>原型可看作可执行的需求规格说明书</strong>，易于用户和开发人员共同理解，可作为继续开发的基础，为用户参与关键决策提供了方便</li><li>螺旋模型特别<strong>强调原型的可扩充性和可修改性</strong>，原型的进化贯穿整个软件生存周期，这将有助于目标软件的适应能力</li><li>螺旋模型为项目管理人员及时调整管理决策提供了方便，进而<strong>可降低开发风险</strong></li></ul></li><li><p>缺点</p><ul><li>如果每次迭代的效率不高，致使迭代次数过多，将会<strong>增加成本并推迟提交时间</strong></li><li>使用该模型需要有相当丰富的风险评估经验和专门知识，<strong>要求开发队伍水平较高</strong></li></ul></li></ul></li><li><p>敏捷过程</p><ul><li>缺点 ： 本身不是完整的方法论，是对生命周期过程的补充</li></ul></li></ul><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><ul><li><p>需求分析过程：通过对问题及环境的理解与分析，为问题涉及的信息、功能及系统行为建立模型，将用户需求精确化、完全化、最终形成需求规格说明，这一系列的活动，即为需求分析</p></li><li><p>需求分析步骤：需求获取，需求提炼，需求描述（需求规格书），需求验证</p></li></ul><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><ul><li><p>软件设计的主要技术：抽象，设计模式，模块化，信息隐藏，功能独立，细化，重构</p></li><li><p>主要活动：软件架构设计（概要设计），软件详细设计</p></li><li><p>模块化：是指解决一个复杂问题时自顶向下逐层分解成若干模块的过程。每个模块完成一个特定的子功能，所有模块按系统结构组合起来，完成整个系统所要求的功能</p></li><li><p>模块化设计标准</p><ul><li>模块化分解性</li><li>模块化组合性</li><li>模块化可理解性</li><li>模块化连续性</li><li>模块化保护</li></ul></li><li><p>模块独立标准：耦合、内聚</p></li></ul><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><ul><li><p>基于代码行数的度量方法</p><ul><li><p>优点</p><ul><li>LOC、KLOC和相关度量容易计算</li><li>许多现有的软件估算模型都使用LOC和KLOC作为一项重要输入</li><li>有大量的关于LOC的文献和数据</li></ul></li><li><p>缺点</p><ul><li>LOC依赖于使用的语言，这对短小精悍的程序不利</li><li>不太适用于非过程化语言</li><li>LOC是由在设计完成时候才能计算，估算需要一定程度的细节，而这些细节可能很难获得</li></ul></li></ul></li><li><p>基于功能点的度量方法</p><p>代码行数和功能点之间的关系依赖于编程语言</p></li></ul><h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><ul><li>软件测试的定义：1）在某种指定的条件下对操作系统或组件，观察或记录结果，对系统或组件的某些方面进行评估的过程。2）分析软件各项目以检测现有的结果和应有结果之间的差异（即软件缺陷），并评估软件各项目的特征的过程</li><li>软件测试目标<ul><li>确认系统满足其预期的使用和用户的需要。</li><li>确认解决了所需解决的问题（如实现商业规则和使用合适的系统假定）。</li><li>为测试的过程建立责任和可解释性。</li><li>便于及早发现软件和系统的异常。</li><li>及早提供软件和系统的性能评估。</li><li>为管理提供真实信息，以决定在当前状态下发布产品在商业上的风险</li><li>鉴别出程序在功能等方面的异常集聚之处。</li></ul></li></ul><h3 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h3><ul><li><p>单元测试</p><ul><li>概念： 针对软件的设计的最小单位-程序模块，进行正确性检验的测试工作</li><li><code>主要内容</code>：模块接口测试，局部数据结构测试，路径测试，出错处理测试，边界条件测试</li></ul></li><li><p>集成测试</p><ul><li>概念：将软件集成起来后进行测试。又称为子系统测试、组装测试、部件测试</li></ul></li><li><p>系统测试</p><ul><li>概念：系统测试是从用户使用的角度来进行的测试，主要工作是将完成了集成测试的系统放在真实的运行环境下进行测试，用于功能确认和验证</li><li>主要内容：功能性测试、性能测试、压力测试、恢复测试、安全测试</li></ul></li></ul><ul><li>验收测试<ul><li>概念：是软件测试部门对经过项目组内部单元测试、集成测试和系统测试后的软件所进行的测试</li><li>主要内容：根据合同进行的验收测试、用户验收测试、现场测试</li></ul></li></ul><h3 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h3><ul><li>软件维护：软件维护是指由于软件产品出现问题或需要改进而对代码及相关文档的修改，其目的是对现有软件产品进行修改的同时保持其完整性</li><li>必要性：<ul><li>改正错误</li><li>改善设计</li><li>实现软件的改进</li><li>与其他系统进行交互</li><li>为使用不同的硬件、软件、系统的新性能以及通讯设备等而对软件进行改进</li><li>完成遗留程序的移植</li><li>软件退出使用</li></ul></li></ul><h2 id="课程复习"><a href="#课程复习" class="headerlink" title="课程复习"></a>课程复习</h2><blockquote><p><em>斜体</em>表示补充内容，<strong>加粗</strong>表示出过简答，<code>着重</code>表示会挖空，引用部分为例题</p></blockquote><h3 id="分值介绍"><a href="#分值介绍" class="headerlink" title="分值介绍"></a>分值介绍</h3><p>选择题（20道题，每题1分），判断题（10道题，每题1分），填空题（10道题，每题1分），简答题（6道题，每题5分），应用题（3道题，每题10分）</p><h3 id="第一章-1"><a href="#第一章-1" class="headerlink" title="第一章"></a>第一章</h3><p>1.软件的四个层次以及各组成的定义</p><p><code>软件 = 程序 + 数据 + 文档</code></p><ul><li>软件是逻辑和物理的系统，由程序、文档、数据和其他相关元素组成</li><li>程序是按事先设计的<strong>功能</strong>和<strong>性能</strong>要求执行的指令序列</li><li>数据是使程序能正确地处理信息的数据结构</li><li>文档是与程序开发、维护和使用有关的图文资料</li></ul><p>2.<strong>软件的特点</strong></p><ul><li>软件是开发出来的或者说是工程化的，并不是制造出来的</li><li>软件开发环境对产品影响较大</li><li>软件开发的时间和工作量难以估算</li><li>用户往往不能一次性提出完整的需求，因此在经历了许多次修改后软件才能令人满意</li><li>几乎没有客观的标准或措施来评估软件的开发进度</li><li>软件的测试非常困难</li><li>软件不会”耗尽“</li><li>硬件可使用物理模型评价，而软件设计的评价取决于判断和直觉</li><li>硬件和软件的项目管理之间存在很大区别，传统的硬件项目控制方法应用到软件项目中可能会适得其反</li></ul><p>3.软件的双重作用</p><ul><li>一方面软件是一种产品，另一方面软件也是开发其他软件产品的工具，包括如下功能：<ul><li>支持或直接提供系统所需的功能</li><li>控制(如操作系统)其他程序</li><li>改善通信（如网络软件）</li><li>帮助开发其他软件（如软件开发工具）</li></ul></li></ul><p>4.软件工程的目标</p><ul><li>软件工程的目标是在给定的<code>时间</code>和<code>预算</code>内，按照用户的需求，开发易修改、高效、可靠、可维护、适应力强、可移动、可重用的软件</li></ul><p>5.<strong>软件工程的七个原则</strong></p><ul><li>使用阶段性生命周期计划的管理</li><li>进行连续的验证</li><li>保证严格的产品控制</li><li>使用现代编程工具和工程实践</li><li>保持清晰的责任分配</li><li>用更好、更少的人</li><li>保持过程改进</li></ul><p>6.IEEE软件工程体系的十个方面</p><ul><li><code>需求</code>、<code>设计</code>、<code>结构</code>、<code>测试</code>、<code>维护</code>、<code>配置管理</code>、<code>工程管理</code>、<code>工程过程</code>、<code>质量</code>、<code>工程工具与方法</code></li></ul><p>7.缺乏<code>有力的方法学</code>和<code>有效的开发工具</code>的支持，这往往是产生软件危机的原因之一</p><p>8.软件危机的表现</p><ul><li>项目超出预算</li><li>项目超过计划完成时间</li><li>软件运行效率很低</li><li>软件质量差</li><li>软件通常不符合要求</li><li>项目难以管理并且代码难以维护</li><li>软件不能交付</li></ul><p>9.对软件工程的误解（判断理解即可）</p><ul><li>更多的程序员赶进度可以加快落后的项目进度</li><li>软件项目外包给第三方可以减轻负担</li><li>对目标有一般陈述就足以开始编程，可以今后再补充细节</li><li>一旦变成完毕并成功运行则程序员的工作就结束了</li><li>在程序运行之前无法评估它的质量</li><li>唯一可交付的工作成果是一个成功运行的项目程序</li><li>软件工程会创建大量不必要的文档，并且拖慢了开发进度，软件工程仅仅是文档而已</li></ul><p>10.在软件工程中文档的作用</p><ul><li>提高软件开发过程的能见度</li><li>记录开发过程的有关信息，便于使用与维护</li><li>作为开发人员阶段工作成果和结束标志</li><li>提高开发效率</li><li>提供软件运行、维护、培训的有关资料</li><li>便于用户了解软件功能和性能</li></ul><blockquote><ol><li>软件产品的开发主要是<code>研制</code></li><li>软件是一种<code>逻辑产品</code></li><li>软件工程出现主要是由于<code>软件危机的出现</code></li></ol></blockquote><h3 id="第二章-1"><a href="#第二章-1" class="headerlink" title="第二章"></a>第二章</h3><p>11.<strong>软件过程的模型的定义：</strong></p><ul><li>软件过程模型是从软件项目需求定义直至软件运行维护为止，跨越整个生命周期的系统开发、运行和维护所实施的全部过程、 活动和任务的结构框架 ，软件过程模型能直观表达软件开发总过程，明确规定软件开发要完成的主要活动任务和开发策略。</li></ul><p><strong>12.</strong> 瀑布模型是非迭代的，它的<strong>特点</strong>以及<strong>全部缺点</strong></p><p>特点：</p><ul><li>阶段间具有顺序性和依赖性</li><li>推迟实现</li><li>每个阶段必须完成规定的文档，没有交出合格的文<br>档就是没有完成该阶段的任务</li><li>每个阶段结束前都要对所完成的文档进行评审，以<br>便尽早发现，改正错误</li></ul><p>缺点：</p><ul><li>不够灵活。在下一阶段开始之前， 当前阶段的结果需要固定下来，这个条件非常严格</li><li>整体性太强。开发计划是面向单一交付日期制定的，在分析阶段出现的任何错误，都只能在软件交付给用户后才能发现。若没有正确理解用户需求，或者在设计、编码和测试阶段需求发生改变，则瀑布模型将导致软件产品的不合格（ 增加了开发的风险）</li><li>严格的文档驱动，比较繁琐</li><li>在软件开发的早期就需要投入大量的成本，使得它难以应对客户需求的变更</li></ul><p>13.螺旋模型是风险驱动的，它的优缺点是</p><p>优点：</p><ul><li>强调可选方案和限制条件，以支持现有解决方案的重用</li><li>维护和开发一样，是螺旋模型的一个阶段</li><li>评估（预算和进度）更加准确，因为重要问题能被及早发现</li><li>更能应对开发过程中出现的各种变化</li><li>软件工程师可以提前开始项目工作</li></ul><p>缺点：</p><ul><li>仅适用于内部（一个公司内部） 项目，因为开发过程中要进行风险评估，该模型不能用于合同性的软件开发</li><li>螺旋模型是风险驱动的，因此它适合经验丰富的员工</li><li>使用该模型要求软件开发人员必须具有丰富的风险评估经验和这方面的专门知识，要求开发队伍水平较高</li><li>只适用于大型软件的开发。如果风险分析占用了整个项目成本的主要部分，则使用该模型没有任何意义</li></ul><p>14.增量模型的特点和优缺点,以及需要注意的问题</p><p>特点：在前面增量的基础上开发后面的增量，增量是可以运行的，在项目开发早期就可以得到程序的运行版本(常考)</p><p>优点：</p><ul><li>增量包概念的引入，以及它不需要提供完整的需求。只要有一个增量包出现，开发就可以进行</li><li>在项目的初始阶段不需要投入太多的人力资源。如果核心产品被用户接受，才会投入更多的人力资源</li><li>即使开发者不能在截止日期前完成项目，项目的核心产品也能交付给用户</li><li>增量可以有效地管理技术风险</li></ul><blockquote><ul><li>能在较短时间内向用户提交一些有用的工作产品，即从第一个增量交付之日起，用户就能做一些有用的工作</li><li>逐步增加产品的功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给用户带来的冲击</li><li>虽然在某些增量中可能遇到一些问题，但其他增量将能够成功地交付给客户</li><li>优先级最高的服务首先交付，然后再将其他增量逐次集成进来。因此， 最重要的系统服务将接受最多的测试，这样能够保证系统最重要的部分一般不会遭遇失败</li></ul></blockquote><p>缺点：</p><ul><li>每个增量必须提供一些系统功能，这使得开发者很难<br>根据客户需求给出大小适合的增量</li></ul><p>需要注意的问题：</p><ul><li><p>在把每个新的增量集成到现有软件体系结构中时， 必须不破坏原来已经开发出的产品</p></li><li><p>软件体系结构必须是开放的，即向现有产品中加入新构件的过程必须简单、方便</p></li><li><p>因此，采用增量模型比采用瀑布模型和快速原型模型更需要精心的设计</p></li></ul><p>15.增量模型适用于<code>软件需求不明确</code>，<code>设计方案有一定风险</code>的软件项目</p><p>16.如何选择过程模型的第三点</p><ul><li>软件过程决定了软件产品的质量，不同的项目需要不同的过程模型或模型的组合</li></ul><p>17.<strong>过程和产品的关系</strong></p><blockquote><p>工具不是过程模型，软件工程以<strong><code>质量</code></strong>为中心，<strong><code>软件过程、工具、方法</code></strong>为三要素</p></blockquote><p>18.软件生命周期的阶段和每个阶段的提交</p><ul><li>可行性研究和项目开发计划，并提交项目开发计划和可行性研究报告</li><li>需求分析，提交软件需求说明书</li><li>概要设计以及提交概要设计说明书</li><li>详细设计以及提交详细设计说明书</li><li>编码，提交源程序清单</li><li>测试，提交测试报告</li><li>维护，提交维护报告</li></ul><p>19.CMMI五个级别的名字和侧重点</p><table><thead><tr><th align="left">级别</th><th>侧重点</th></tr></thead><tbody><tr><td align="left">1.初始级</td><td>有能力的人和个人英雄主义</td></tr><tr><td align="left">2.可重复级</td><td>基本项目管理</td></tr><tr><td align="left">3.已定义级</td><td>过程标准化</td></tr><tr><td align="left">4.量化管理级</td><td>量化管理</td></tr><tr><td align="left">5.优化级</td><td>持续的过程改进</td></tr></tbody></table><p>20.增量模型和螺旋模型的异同</p><p>同：都是非整体的，迭代式的开发方式</p><p>不同：</p><ul><li>两者迭代的层次不同，增量模型是活动级的迭代，螺旋模型是过程级的迭代</li><li>两者需求分析的时间不同，增量模型往往是选做整体的需求分析，再做编码和逐个的增量包开发；而螺旋模型往往是开发周期内采用瀑布模型</li><li>两者交付软件的时间不同，增量模型是每次增量开发都在上一次增量基础上提交新一部分软件；而螺旋模型每次迭代都提交一个新的完整的软件版本</li><li>两者减小风险的方式不同，增量模型避免使用未成熟的技术和经常的客户反馈降低风险；螺旋模型则直接饮用风险设计和分析</li></ul><blockquote><ol><li>大多数软件系统是不易变化的(指不易改动)的，除非它们在设计时考虑了变化</li><li>目前绝大多数软件都适合快速原型技术</li><li>不属于能力成熟度模型的级别:高效性(确定级≈定义级)</li><li>用户和设计交互最频繁的方法：<code>原型化方法</code></li><li>增量构件的开发可以采用瀑布方式</li><li>瀑布、<code>演化</code>、增量模型是常用的三种软件过程模型</li></ol></blockquote><h3 id="第三章-1"><a href="#第三章-1" class="headerlink" title="第三章"></a>第三章</h3><p>21.软件需求的定义</p><ul><li>软件需求表达了对解决现实世界中某类问题的产品的要求和约束</li></ul><p>22.功能性需求和非功能性需求的定义和区别（理解例子）</p><blockquote><p>设计问题和需求问题，举例非功能性需求5个</p></blockquote><ul><li>功能性需求：描述软件执行时的功能</li><li>非功能性需求：指解决问题时的约束，非功能性需求有时也称为限制或质量需求<ul><li>非功能性需求可进一步被分为性能要求、可维护性要求、安全需求、可靠性要求、可移植性要求、 ……</li></ul></li></ul><p>23.需求分析的4个步骤和定义</p><ul><li><code>需求获取</code>指的是软件需求的来源以及软件工程师收集这些软件需求的方法</li><li><code>需求分析</code>产生操作规格参数表，指明与其他系统元件的软件接口，确定软件必须遵循的约束</li><li><code>需求定义</code>即编写《 软件需求规格说明书》</li><li><code>需求验证</code>即检查需求的正确性、完整性、非二义性、内部和外部的连贯性</li></ul><p>24.需求分析的主要任务</p><ul><li>准确地定义未来系统的目标，确定为了满足用户的需求系统需要做什么，并用需求规格说明书规范的形式准确地表达用户需求</li></ul><p>25.结构化分析建立哪三种模型？核心是面向什么？分别对应什么建模？</p><ul><li>核心是<code>数据字典</code></li><li>围绕这个核心，有3种图： <code>数据流图</code>（ DFD，用于<code>功能建模</code>）、<code>实体-关系图</code>（ ER图，用于<code>数据建模</code>）、 <code>状态转换图</code>（ STD，用于<code>行为建模</code>）</li></ul><p>26.数据流图4种符号(只考填空)，数据流图至少有<code>一个输入数据流</code>和<code>一个输出数据流</code></p><p><img src="/posts/49397/1.png" alt="数据流图符号"></p><p>27.结构化分析方法的策略是：<code>自顶向下逐步求精</code></p><p>28.UML图有：<code>部署图</code>、<code>活动图</code>、<code>顺序或时序图</code>、<code>用例图</code>、<code>交互图</code>、<code>类图</code></p><p>29.UML动态模型的描述工具有哪三种图：<code>顺序图</code>、<code>活动图</code>、<code>状态图</code></p><p>30.用例图的绘制（填空加大题），用例图有哪些元素</p><ul><li>元素：<code>用例</code>、<code>参与者</code>、<code>系统</code>、<code>用例之间关系</code></li></ul><p>31.用例图的用途：<code>用于需求的获取，定义和分析</code></p><p>32.<strong>UML中哪些是系统的参与者，可以提出哪些问题来确定？</strong></p><ul><li>谁或者什么为系统提供输入？</li><li>谁或者什么接收系统的输出？</li><li>需要与其他系统连接的接口吗？</li><li>是否存在在预定的时间自动触发的事件？</li><li>谁将维护系统中的信息？</li></ul><p>33.顺序图的组成元素：<code>类角色（参与者）</code>、<code>对象</code>、<code>激活期</code>、<code>生命线</code>、<code>消息</code></p><p>34.<strong>什么是用例图，它的作用是什么？内容是什么</strong></p><ul><li>用例图是体现一组用例、参与者和它们之间关系的图，从用户角度而不是开发者角度来描述，体现对软件开发产品的需求，分析产品所需的功能和动态行为</li><li>用例图对需求建模是至关重要的，其正确与否直接影响到客户对最终产品的满意度</li><li>内容包括了参与者、用例与拓展的泛化关系</li></ul><h3 id="第四章-1"><a href="#第四章-1" class="headerlink" title="第四章"></a>第四章</h3><p>35.软件设计包含的两类主要活动</p><ul><li>软件架构设计（又称为顶层设计、概要设计）：描述软件的顶层架构和组织，划分不同的组件</li><li>软件详细设计：详细描述各组件以便能够编码实现</li></ul><p>36.创新设计不是软件设计中的步骤，是<code>需求分析</code>中的步骤</p><p>37.模块划分不是越多越好，单个复杂度降低但接口增多，会成为一个U型曲线</p><p>38.简述模块化与软件成本间的关系</p><ul><li>尽管模块分解可以简化要解决的问题，但模块分解并不是越小越好</li><li>当模块数目增加时，每个模块的规模将减小， 开发单个模块的成本确实减少了；但是，随着模块数目增加， 模<br>块之间关系的复杂程度也会增加，设计模块间接口所需要的工作量也将增加</li></ul><p>39.模块的扇入数大好不好？何时好何时不好？</p><ul><li>模块的扇出数是指模块调用子模块的个数。 如果一个模块的扇出数过大，就意味着该模块过分复杂，需要协调和控制过多的下属模块 。</li><li>一个模块的扇入数越大，则共享该模块的上级模块数目越多， 但如果一个模块的扇入数太大，如超过8，而它又不是公用模块，说明该模块可能具有多个功能， 这时应当对其进一步分析并将其功能分解</li></ul><p>40.模块独立的两个标准是什么？分别表示什么含义？</p><ul><li><code>内聚性</code>：模块的功能相对强度</li><li><code>耦合性</code>：模块之间的相互依赖程度</li></ul><blockquote><p>高内聚低耦合表示独立性强的模块</p></blockquote><p>41.内聚和耦合的类型，它们各自的定义和含义，顺序中最高最低是什么？</p><ul><li><p>内聚</p><ul><li>一个模块内部各个元素之间的结合越紧密，其内聚性就越高</li></ul></li><li><p>耦合</p><ul><li>耦合的强弱取决于模块间接口的复杂程度、进入或访问模块的点，以及通过接口的数据</li><li>模块之间的连接越紧密，耦合性就越高，而模块的独立性就越弱</li></ul></li><li><p>模块间的耦合</p><p><img src="/posts/49397/3.png" alt="模块间的耦合"></p><ul><li>非直接耦合:两个模块之间没有直接关系，即它们中的任何一个都不依赖于另一个而能独立工作</li><li>数据耦合：两个模块之间仅通过模块参数交换信息，且交换的信息全部为简单数据</li><li>标记耦合：两个模块之间通过参数表传递一个数据结构的一部分（如某一数据结构的子结构）</li><li>控制耦合：如果一个模块传送给另一个模块的参数中包含了控制信息，该控制信息用于控制接收模块中的执行逻辑</li><li>外部耦合 ：指模块间通过软件之外的环境联结（如I/O将模块耦合到特定的设备、格式、通信协议上）</li><li>公共耦合 ：一组模块都访问同一个公共数据环境</li><li><strong><code>内容耦合 ：若一个模块对另一模块中的内容（包括数据和程序段）进行了直接的引用甚至修改，或通过非正常入口进入到另一模块内部，或一个模块具有多个入口，或两个模块共享一部分代码</code></strong><ul><li>内容耦合是所有耦合关系中耦合程度最高的，会使因模块间的联系过于紧密而对后期的开发和维护工作带来很大的麻烦</li><li>有两种情况：(1)进入另一模块内部 (2)模块代码重迭（只可能出现在汇编语言中）</li></ul></li></ul></li><li><p>模块的内聚</p><p><img src="/posts/49397/4.png" alt="模块的内聚"></p><ul><li><p>巧合内聚 ：一个模块由多个完成不同任务的语句段组成，各语句段之间的联系十分松散或根本没有任何联系</p></li><li><p>逻辑内聚 ：把几种功能组合在一起，每次调用时，由传递给模块的判定参数来确定该模块应执行哪一种功能</p></li><li><p>时间内聚 ：一个模块包含了需要在同一时间段中执行的多个任务</p></li><li><p>过程内聚 ：一个模块中的各个部分相关，并且必须按特定的次序执行</p></li><li><p>通信内聚 ：一个模块中的各个部分使用同一个输入数据或产生同一个输出数据</p></li><li><p><strong><code>顺序内聚 ：一个模块中的各个部分都与同一个功能密切相关，并且必须按照先后顺序执行（通常前一个部分的输出数据就是后一个部分的输入数据）</code></strong></p><blockquote><p>顺序内聚的例子：假设有一个按给出的生日计算雇员年龄、退休时间的子程序，如果它是<code>利用所计算的年龄</code>来确定雇员将要<code>退休的时间</code>（即：生日-&gt;年龄-&gt;退休时间），那么它就具有<code>顺序内聚性</code>。而如果它是<code>分别计算</code>年龄和退休时间的，但使用相同生日数据（即： 生日-&gt;年龄， 生日-&gt;退休时间），那它就只具有<code>通讯内聚</code>性</p></blockquote></li><li><p>功能内聚 ：一个模块中各个组成部分构成一个整体并共同完成一个单一的功能</p></li></ul></li></ul><p>42.设计是<code>模块化</code>的，换言之软件在逻辑上应划分为多个元素或子系统</p><blockquote><p>结构化的设计思想是把系统设计成相对独立的，功能单一的模块组成的层次结构</p></blockquote><p>43.理解模块调用的四个图（软件结构的宽度和深度，模块扇入数和扇出数）</p><ul><li><p>模块结构最普通的形式就是树状结构和网状结构</p><p><img src="/posts/49397/5.png" alt="模块的结构"></p><ul><li>树状结构<ul><li>只有一个顶层模块，上层模块调用下层模块， 同一层模块之间互不调用</li><li>在最底层可能存在一些公共模块，使得整个系统的模块结构不是严格的树状结构，这属于正常情况</li></ul></li><li>网状结构<ul><li>任意两个模块之间都可以有调用关系，因此无法分出层次。</li><li>由于模块间相互关系的任意性，使得整个系统的结构十分复杂，难以处理</li></ul></li></ul></li><li><p>结构图</p><ul><li><p>模块的调用关系和接口：在结构图中，两个模块之间用单向箭头连接</p></li><li><p>模块间的信息传递：当一个模块调用另一个模块时，调用模块把数据和/或控制信息传送给被调用模块，以使被调用模块能够运行</p><p><img src="/posts/49397/6.png" alt></p></li><li><p>条件调用和循环调用 ：当模块A<code>有条件地</code>调用另一个模块B时，在模块A的箭头尾部标以一个菱形符号；当一个模块A反复地调用模块C和模块D时，在调用箭头尾部则标以一个<code>弧形符号</code></p><p><img src="/posts/49397/7.png" alt></p></li><li><p>结构图的形态特征。在图中，上级模块调用下级模块，它们之间存在主从关系</p><p><img src="/posts/49397/8.png" alt></p><blockquote><ul><li><p>程序结构的深度：程序结构的层次数称为结构的深度</p></li><li><p>程序结构的宽度：层次结构中同一层模块的最大模块个数称为结构的宽度</p></li><li><p>模块的扇入和扇出：扇出表示一个模块直接调用（或控制）的其它模块数目。扇入则定义为调用（或控制）一个给定模块的模块个数。 多扇出意味着需要控制和协调许多下属模块。而多扇入的模块通常是公用模块</p></li></ul></blockquote></li></ul></li></ul><p>44.重构的定义</p><ul><li>重构是不改变代码（设计）现有功能的基础上对其内部结构进行修改的过程</li></ul><p>45.用户界面设计由一系列分析开始</p><ul><li>用户特点分析：应用从具体业务和技术资料收集而来的各种信息，定义各种最终用户的属性和配置信息</li><li>用户任务分析：使用结构化设计方法或面向对象方法定义用户任务和相关操作</li><li>应用场景分析：确定用户操作接口的呈现方式约束和布局风格约束</li></ul><p>46.接口设计包含哪三个方面</p><ul><li>内部接口：软件内部结构模块之间的接口</li><li>外部接口<ul><li>与其他软、硬件之间的接口</li><li>软件与用户之间接口</li></ul></li></ul><p><em>外部接口设计依据环境图进行</em></p><p>47.信息隐藏原则</p><ul><li>模块定义和设计应当保证模块内的信息（包括过程和数据）不可以被不需要这些信息的其他模块访问</li><li>信息隐藏原则有利于提高模块<code>内聚性</code></li><li>有效的模块划分可以通过定义一些相对独立的模块来实现</li></ul><p>48.<strong>架构风格和模式的简要分类</strong></p><ul><li>数据中心架构</li><li>数据流体系架构</li><li>调用和返回架构</li><li>面向对象架构</li><li>层次架构</li></ul><p>49.结构化程序的定义</p><ul><li>如果一个程序的代码块仅仅通过顺序、选择和循环这三种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的</li></ul><p><img src="/posts/49397/9.png" alt></p><p>50.<strong>程序流程图的主要缺点</strong></p><ul><li>程序流程图从本质上来说不是逐步求精的好工具，它容易使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构。</li><li>程序流程图中用箭头代表控制流，程序员可以不顾结构程序设计的精神，随意转移控制，而使程序结构过于混乱。</li><li>程序流程图在表示数据结构方面存在不足。</li></ul><p>51.体系结构的另一种分类</p><ul><li>单主机结构（集中式体系结构）</li><li>分布式结构<ul><li>多处理器体系结构</li><li>客户机/服务器体系结构(C/S、B/S结构)</li><li>分布式对象体系结构</li><li>代理</li></ul></li></ul><p>52.概要设计包含三个层次</p><blockquote><p>概要设计=体系结构设计+接口设计+数据设计</p></blockquote><p><img src="/posts/49397/2.png" alt="软件设计的任务"></p><h3 id="第七章-1"><a href="#第七章-1" class="headerlink" title="第七章"></a>第七章</h3><p>53.软件测试的基本原则</p><ul><li>穷尽测试是不可能的</li><li>测试无法显示潜伏的软件缺陷</li><li>测试活动应尽早进行</li><li>软件缺陷具有群聚性</li><li>注意杀虫剂现象</li><li>应尽量由独立的测试团队进行测试</li></ul><p>54.软件测试的目标</p><ul><li>确认系统满足其预期的使用和用户的需要</li><li>确认解决了所需解决的问题</li><li>为测试的过程建立责任和可解释性</li><li>便于及早发现软件和系统的异常</li><li>及早提供软件和系统的性能的评估</li><li>为管理提供真实信息，以决定在当前状态下发布产品在商业上的风险</li><li>鉴别出程序在功能等方面的异常集聚之处</li></ul><p>55.什么情况下称为发现软件缺陷</p><ul><li>至少满足下列一个条件，则称发生了一个软件缺陷：<ul><li>软件未实现产品说明书要求的功能</li><li>软件出现了产品说明书指明不能出现的错误</li><li>软件实现了产品说明书未提到的功能</li><li>软件未实现产品说明书虽未明确提及但应该实现的目标</li><li>软件难以理解、不易使用、运行缓慢，或者测试员的角度看，最终用户会认为不好</li></ul></li></ul><p>56.测试用例的定义由哪三部分组成</p><ul><li>测试用例是<code>测试输入</code>、 <code>执行条件</code>，以及<code>预期结果</code>的集合，是为特定的目的开发的，例如执行特定的程序路径或验证与指定的需求相符合</li></ul><p>57.软件测试的评估准则</p><ul><li>覆盖率</li><li>故障插入(软件缺陷)</li><li>变异分支</li></ul><p>58.覆盖率的定义，100%测试率是可能的吗？为什么？</p><ul><li>给定一个测试需求集合TR和一个测试集合T， 覆盖率可以定义为T满足的测试需求占TR 总数的比例</li><li>某些测试需求是不能满足的，例如测试需求要求每条语句都得到执行，在某些不能执行到得情况下就是不能满足的。对大多数覆盖标准，检测不可行测试在需求形式上是不可判定的。因此100%测试率在实际中是不现实的。</li></ul><p>59.测试人员的目标是？</p><ul><li>尽早找出软件缺陷，并确保缺陷得已修复</li></ul><p>60.软件白盒、黑盒、灰盒测试的定义</p><ul><li>黑盒测试：指忽略系统或组件的内部机制，仅关注于那些响应所选择的输入及相应执行条件的输出的测试形式，也称为功能性测试</li><li>白盒测试：指考虑系统或组件的内部机制的测试形式，也称为结构性测试。由于通常需要进行白盒测试，因此软件测试工程师也需要具有编程能力</li><li>灰盒测试：兼具黑盒测试和白盒测试的特性，对所有输入数据的各种可能值的排列组合都进行测试，来检查程序是否都能产生正确的输出</li></ul><p>61.<strong>简述软件测试与调试的同与不同</strong></p><ul><li>两者都包含有处理软件缺陷和查看代码的过程</li><li>测试的目标是发现软件缺陷的存在， 调试的目标是定位与修复缺陷。软件测试员把问题缩减为能够演示软件缺陷的最简化测试用例（或可疑的代码行），进行调试的程序员进而判断到底是什么导致软件缺陷，并设法修复</li></ul><p>62.软件测试的目标</p><ul><li>确认系统满足其预期的使用和用户的需要</li><li>确认解决了所需解决的问题（如实现商业规则和使用合适的系统假定）</li><li>为测试的过程建立责任和可解释性</li><li>便于及早发现软件和系统的异常</li><li>及早提供软件和系统的性能的评估</li><li>为管理提供真实信息，以决定在当前状态下发布产品在商业上的风险</li><li>鉴别出程序在功能等方面的异常集聚之处</li></ul><p>63.不同覆盖准则设计测试用例</p><ul><li>语句覆盖</li><li>分支覆盖</li><li>条件覆盖</li><li><em>判定—条件覆盖</em></li><li>条件组合覆盖</li><li>路径覆盖</li></ul><p>64.不同覆盖准则之间的强弱关系</p><ul><li>语句覆盖是最弱的逻辑覆盖</li><li>分支覆盖具有比语句覆盖更强的测试能力，但仍是弱的逻辑覆盖</li><li>条件覆盖不一定包含分支覆盖，满足条件覆盖不一定满足分支覆盖</li><li><em>判定—条件覆盖</em>即既满足条件覆盖，又满足判定覆盖</li><li>条件组合覆盖满足分支覆盖、条件覆盖准则，但可能有的路径会遗漏掉</li><li>路径覆盖覆盖程序中所有可能的路径</li></ul><p>65.分支覆盖又叫判定覆盖</p><p>66.<strong>基本路径测试的控制流图与环路复杂度</strong></p><ul><li>控制流图仅描述程序内部的控制流程，完全不表现对数据的具体操作，以及分支和循环的具体条件</li></ul><p><img src="/posts/49397/10.png" alt></p><p><img src="/posts/49397/11.png" alt></p><ul><li><p>边和节点围成的封闭域叫做区域，当对区域计数时，图形外的区域也应记为一个区域</p></li><li><p>程序的环形复杂度 :对于一个程序的控制流图G（其中的决策节点均是基本判定），程序的环形复杂度V(G)即是控制流图中的区域数</p></li><li><p>也可以用以下公式计算：</p><blockquote><p>V(G)＝ e－ n＋ 2，其中 e是图G中边的数目， n是图G中节点的数目</p></blockquote></li><li><p>可以证明：</p><blockquote><p>V(G)＝ P＋ 1,其中， P是图G中的基本判定的数目</p></blockquote></li><li><p>McCabe提出的基线方法和反转接点</p></li></ul><p>67.基本路径集合不唯一但数目唯一</p><p>68.黑盒测试的3种方法和定义(补充的错误猜测法和因果图法)</p><ul><li>等价类划分方法：把所有可能的输入（被测程序的输入域） 划分成若干互不相交的部分（子集），然后从每一个部分中选取少数具有代表性的数据（通常是1个） 作为测试用例</li><li>边界值分析方法：对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界</li><li>状态测试：通常，访问所有的状态是可以实现的，但除了极少数简单程序外， 不可能以走完所有分支的方式来达到每种状态，即必须选择重要的内容进行测试</li><li>错误猜测法：在测试程序时，人们可以根据经验或直觉推测程序中可能存在的各种错误，从而有针对性地编写检查这些错误的测试用例的方法</li><li>因果图法：用图解的方法表示输入的各种组合关系，写出判定表，从而设计相应的测试用例</li></ul><p>69.<strong>错误猜测法和因果图法</strong></p><ul><li>考虑为失效性测试设计用例，主要以已知的缺陷空间为依据设计测试用例。设计测试用例的目的是证明已知的缺陷在软件中都不存在</li></ul><p>70.静态测试的目的和基本思想</p><ul><li>静态测试的范围很广，软件开发项目中的代码、所有的文档以及项目外有价值的文档都可以通过人工方式审查。其目的是从已有的规格说明、已定义的标准以及项目的计划中发现缺陷和偏差。这些检查的结果可以用于优化开发过程</li><li>静态测试的基本思想是缺陷的预防，即尽可能早地在缺陷和偏差对将来开发过程产生影响之前发现并修改它们，否则会导致代价高昂的返工</li></ul><p>71.<strong>通用评审过程的步骤</strong></p><p>评审过程就是执行静态分析的过程:</p><ul><li>计划</li><li>概述</li><li>准备</li><li>评审会议</li><li>返工</li><li>跟踪</li></ul><p>72.正式评审和非正式评审的3种类型</p><ul><li>同事审查(非正式)</li><li>走查(非正式)</li><li>审查 (正式)</li></ul><h3 id="第八章-1"><a href="#第八章-1" class="headerlink" title="第八章"></a>第八章</h3><p>73.V模型中四个级别的测试的主要目的或测试依据</p><ul><li>单元测试的主要目的是验证软件模块是否按详细设计的规格说明正确运行</li><li>集成测试的主要目的是检查多个模块间是否按概要设计说明的方式协同工作</li><li>系统测试的主要目的是验证整个系统是否满足需求规格说明</li><li>验收测试从用户的角度检查系统是否满足合同中定义的需求，以及以确认产品是否能符合业务上的需要</li></ul><p>74.系统测试的定义</p><ul><li>从用户使用的角度来进行的测试，主要工作是将完成了集成测试的软件放在真实的运行环境下进行测试，用于功能确认和验证</li></ul><p>75.验收测试中测试用例如何得到？验收测试的关注点？是否需要客户参与？</p><ul><li>测试用例采用项目组的系统测试用例子集，或者由验收测试人员自行决定测试内容</li><li>关注点是客户的观点和判断，如果软件是为指定客户开发的，那么验收测试就更为重要。验收测试通常情况下需要客户的参与，甚至客户可以完全负责验收测试</li><li>验收测试在多个级别中进行</li></ul><p>76.在改进的V模型中，测试要提前，一旦有了<code>文档提供</code>就可以<code>开始测试计划，确定测试条件和编写测试用例等测试</code></p><p>77.回归测试</p><ul><li>原因：在软件测试的各个阶段，在修正发现的软件缺陷或增加新功能时， 变化的部分必须进行再测试。此外，对软件进行修改还可能会导致引入新的软件缺陷以及其他问题。为解决这些问题，需要进行回归测试</li><li>回归测试是指有选择地重新测试系统或其组件，以验证对软件的修改没有导致不希望出现的影响，以及系统或组件仍然符合其指定的需求</li><li>回归测试可以在所有的测试级别执行，并应用于功能和非功能测试中</li><li>回归测试应该尽量采用自动化测试</li></ul><p>78.4级别测试分别采用白盒测试还是黑盒测试</p><ul><li>单元测试：主要采用白盒测试方法设计测试用例，但在白盒测试方法之前应该先依据详细设计说明书建立黑盒<br>测试用例进行测试，使之对任何合理的输入和不合理的输入，都能鉴别和响应</li><li>集成测试：既有白盒测试的成分又有黑盒测试的成分，也称为灰盒测试</li><li>系统测试：基本上使用黑盒测试方法</li><li>验收测试：黑盒测试方法</li></ul><p>79.驱动模块和桩模块的含义</p><ul><li>驱动模块用来调用被测模块，使被测的模块得到执行。在绝大多数情况下， 驱动模块执行的任务是接收测试数据，把数据传送给待测模块，然后从待测模块获取返回的数据，并输出测试的结果。通常， 测试用例是在驱动模块中实现的</li><li>桩模块也叫做存根模块， 用以替代被测模块所调用的那些模块。桩模块的接口与其替代的模块完全一致， 但其功能非常简单，且不包含错误。桩模块的作用首先是隔离缺陷，在用桩模块替代被测模块调用的模块后，如果测试中发现问题，则问题肯定出在被测模块的内部。其次， 可以用桩模块来模拟一些被调用模块难以出现的情况（例如，数量很大的网络连接）， 降低测试的费用</li></ul><p>80.被测模块需要驱动模块时，测试常在<code>驱动模块</code>中实现</p><p>81.<strong>单元测试的主要内容</strong></p><ul><li>对模块接口的测试保证在测试时进出程序单元的数据流是正确的</li><li>对局部数据结构的测试保证临时存储的数据在算法执行的整个过程中都能维持其完整性</li><li>对边界条件的测试保证模块在极限或严格的情形下仍然能够正确执行</li><li>控制结构中的所有独立路径（基本路径）原则上都应覆盖，以保证在一个模块中的所有语句都能至少执行一次</li><li>要对所有出错处理的路径进行测试</li></ul><p>82.为什么单元测试的依据不是代码？</p><ul><li>单元测试的主要依据是详细设计，而不是针对代码的测试。因为未测代码可能包含错误和缺陷，如果依照其测试，则可能无法发现一些错误</li></ul><p>83.集成测试有哪3种集成方法？</p><ul><li>自顶向下的集成方法</li><li>自底向上的集成方法</li><li>Smoke方法</li></ul><p>84.什么是自顶向下/自底向上的集成测试，它们的优缺点是什么？</p><ul><li><p>自顶向下的集成方法：从顶层模块（主控模块）开始，沿着软件的控制层次向下移动，逐渐把各个模块结合起来，这种集成方式中，每层程序调用的下一层程序单元都要打桩，整个集成可以按深度或宽度优先进行，采用前者可以快速验证一个子系统的完整性</p><ul><li><p>优点：</p><ul><li><p>可以较早地验证主程序的功能</p></li><li><p>缺陷隔离较好</p></li><li><p>可以较早地验证主要的控制和判断点</p></li></ul></li><li><p>缺点：</p><ul><li>桩的开发量较大</li></ul></li></ul></li><li><p>自底向上的集成方法：是从软件结构最底层的模块开始，按照接口依赖关系逐层向上集成以进行测试。由于是从最底层开始集成，对于一个给定层次的模块，它的子模块（包括子模块的所有下属模块）已经集成并测试完成，所以不再需要使用桩模块进行辅助测试，在模块的测试过程中需要从子模块得到的信息可以直接运行子模块得到。 但需要为每个模块编写驱动模块</p><ul><li><p>优点：</p><ul><li>每个模块调用的各底层模块都已经测试，不需要桩模块</li></ul></li><li><p>缺点：</p><ul><li>每个模块都必须编写驱动模块</li><li>缺陷隔离和定位不如自顶向下的集成方法</li></ul></li></ul></li></ul><p>85.自顶向下结合的渐增式测试法在组合模块时有两种组合策略：<code>深度优先</code>,<code>广度优先</code></p><p>86.系统测试的五种方法</p><ul><li>功能性测试</li><li>性能测试</li><li>压力测试</li><li>恢复测试</li><li>安全测试</li></ul><p>87.压力测试为<code>比平常限度约高一个数量级输入</code>，用来检查软件系统对异常情况的承受能力压力测试强迫系统在异常情况（如异常数量、异常频率、异常资源配置等）下运行 ，压力测试经常与<code>性能测试</code>一起进行</p><p>88.现场测试包含α测试和β测试，各自的定义是什么？</p><ul><li>α测试是用户在开发者的场所来进行的，软件在开发者对用户的指导下进行测试， 开发者负责记录错误和使用中出现的问题，α测试人员是除产品开发人员外首先见到产品的人， 他们提出的功能和修改意见是特别有价值的</li><li>β测试是在一个开发者不能控制的真实环境中进行的软件现场应用。与α测试不同， 开发者不在测试现场。用户记录下所有在测试中遇到的问题，并定期把这些问题报告给开发者，在接到β测试的问题报告之后，开发者对系统进行最后的修改，然后就开始准备向所有的用户发布最终的软件产品</li></ul><blockquote><ol><li>单元测试主要针对模块的几个基本特例进行测试，该阶段不能完成的测试是<code>系统功能</code>测试</li><li><code>接口</code>不属于系统测试的主要内容</li><li>系统测试是把软件、硬件和环境连在一起的全面测试</li><li>单元测试时对所有出错处理的路径都要进行测试</li></ol></blockquote><p>89.生产力度量包括<code>基于功能点的度量</code>和<code>代码行数</code>的度量</p><h3 id="第五章-1"><a href="#第五章-1" class="headerlink" title="第五章"></a>第五章</h3><p>90.FP（功能点方法）的计算</p><ul><li><p>根据软件的每类功能的各级复杂性功能点的数量，可以计算出该软件的未调节功能点 total_counts</p></li><li><p>任何软件都会有其自身特性，因此前面计算出的未调节功能点（ total_counts） 还需要进行调节，即乘以一个复杂度调节因子CAF，最终得到交付功能点，教材上简称为功能点FP</p><blockquote><p>FP= total_counts× (0.65+0.01× ∑Fi)</p></blockquote></li></ul><p>91.LOC或FP的相关计算（记得带上单位）</p><ul><li><p>生产率是指平均每个人月生成出多大规模的软件（生产出多少代码行数LOC或功能点FP），其单位是LOC(或KLOC)/人月、 FP/人月</p></li><li><p>直接测量——基于代码行数的度量即：基于代码行数（ LOC）进行度量。生产率即每人月的代码行数： <code>总代码行数(LOC或KLOC)/总人月</code>, 此外， 基于LOC还可以得到其他一些度量，如：</p><ul><li><p>每千代码行的错误数： <code>总错误数/总KLOC</code></p></li><li><p>每千代码行的缺陷数： <code>总缺陷数/总KLOC</code></p></li><li><p>每千代码行的文档页数： <code>总文档页数/总KLO</code></p></li></ul></li><li><p>间接测量——基于功能点的度量即：基于功能点（ FP）进行度量。生产率即每人月的FP数： 总FP数/总人月此外， 基于FP还可以得到其他一些度量，如：</p><ul><li>每FP的错误数： <code>总错误数/总FP数</code></li><li>每FP的缺陷数： <code>总缺陷数/总FP数</code></li><li>每FP的文档页数： <code>总文档页数/总FP数</code></li></ul></li></ul><p>92.LOC(代码行数)估计软件生产率的优缺点</p><ul><li>优点<ul><li>LOC、 KLOC和相关度量容易计算</li><li>许多现有的软件估算模型都使用LOC和KLOC作为一项重要输入</li><li>有大量的关于LOC的参考文献和数据</li></ul></li><li>缺点<ul><li>LOC依赖于使用的语言，这对短小精悍的程序不利</li><li>不太适用于非过程化语言</li><li>LOC只有在设计完成时候才能计算，同时估算需要一定程度的细节，而这些细节可能很难获得。项目计划人员很难在分析和设计完成之前估算LOC</li></ul></li></ul><p>93.FP与LOC的换算</p><p><img src="/posts/49397/12.png" alt></p><p>94.不应当苛刻的关注生产率度量，工程师可能会通过产生较大的LOC和FP来追求高生产率，而降低产品的质量。“低生产率的”程序员写的代码可能会更加可靠，容易理解和维护</p><p>95.COCOMO模型是成本估算模型</p><h3 id="第九章-1"><a href="#第九章-1" class="headerlink" title="第九章"></a>第九章</h3><p>96.<strong>ISO-IEC 12207-2008</strong>中对软件维护的定义</p><ul><li>软件维护是指由于软件产品出现问题或需要改进而对代码及相关文档的修改，其目的是对现有软件产品进行修改的同时保持其完整性</li></ul><p>97.软件维护耗时最多的部分<code>测试用例</code></p><p>98.软件维护中4种维护及每种百分比</p><ul><li>纠错性维护(21%)</li><li>适应性维护(25%)</li><li>完善性维护(50%)</li><li>预防性维护(4%)</li></ul><p>99.各类维护占维护工作量的比例</p><ul><li>在维护阶段的最初一段时期，纠错性维护的工作量较大。随着错误发现率逐渐降低，并趋于稳定，软件进入正常使用期。然而，由于新需求的提出， 适应性维护和完善性维护的工作量逐步增加。在整个软件维护阶段花费的全部工作量中， 完善性维护占了几乎一半的工作量</li></ul><p>100.软件维护的必要性</p><ul><li>软件维护能够改正错误</li><li>软件维护能够改善设计</li><li>软件维护能够实现软件的改进</li><li>软件维护能够与其他系统进行交互</li><li>软件维护能够为使用不同的硬件、软件、系统的新性能以及通讯设备等而对软件进行改进</li><li>软件维护能够完成遗留程序的移植</li><li>软件退出使用</li></ul><p>101.软件维护的困难性</p><ul><li><strong>配置管理工作不到位</strong> ，软件系统的改动没有被标记，所要维护的软件无文档、文档不完整或者有些文档没有及时更新，导致维护过程中参考的是过时的文档</li><li><strong>人员变动</strong>造成的影响</li><li><strong>维护人员大多不是编写代码的人</strong>，所以必须先理解软件，然后才能进行维护。但是许多软件的<strong>可读性差，导致理解困难</strong></li><li>往往是<strong>在任务急、时间紧的情况下处理维护请求</strong>的，这就要求维护人员必须在短时间内发现并解决问题</li></ul><p>102.IEEE对可维护性的定义</p><ul><li>是指通过一定的手段，使软件可以被维护、改进、改动或修正，以满足特定的需求的方便程度</li></ul><p>103.估算维护工作量的模型，理解4个参数与复杂程度</p><blockquote><p>维护工作量的一个模型： M=P+K·exp(c-d)</p></blockquote><ul><li>维护分成生产性活动（如分析评价、修改设计和编写程序代码等）和非生产性活动（如理解程序代码的功能，解释数据结构、接口特点和性能限度等）</li><li>M是维护用的总工作量， P是生产性工作量， K是经验常数， c是复杂程度（非结构化设计和缺少文档都会增加软件的复杂程度）， d是维护人员对软件的熟悉程度</li></ul><p>104.软件维护技术</p><ul><li>程序的理解</li><li>软件再工程</li><li>软件逆向工程</li></ul><p>105.软件再工程的定义</p><ul><li>指对现有软件进行仔细审查和改造，对其进行重新构造，使之成为一个新的形式，同时包括随之产生的对新形式的实现</li></ul><p>106.理解逆向工程的含义和主要三方面内容与过程(了解)</p><ul><li><p>含义：分析目标系统，识别系统的构件及其交互关系，并且通过高层抽象或其他形式来展现目标系统的过程</p></li><li><p>主要内容：</p><ul><li>① 数据的逆向工程</li><li>② 处理的逆向工程</li><li>③ 用户界面的逆向工程过程：</li></ul></li><li><p>过程：</p><p><img src="/posts/49397/14.png" alt></p></li></ul><h3 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h3><p>107.P-CMM是什么？五个级别分别是？</p><ul><li>人员资源管理能力成熟度模型(People Capability Maturity Model)</li><li>五个级别<ul><li>初始级</li><li>管理级</li><li>定义级</li><li>可预测级</li><li>优化级</li></ul></li></ul><p>108.软件项目管理的四要素，其中最重要的是？</p><ul><li>人员(最重要)</li><li>产品</li><li>过程</li><li>项目</li></ul><p>109.3种团队组织形式，名字与缩写分别是？</p><ul><li>民主分权制(DD)</li><li>有控制的分权制(CD)</li><li>有控制的集中制(CC)</li></ul><p>110.沟通是横向的还是垂直的？</p><ul><li>民主分权制(DD)中对问题的解决方法都由小组达成共识，团队成员之间进行横向通信</li><li>有控制的分权制(CD)中小组和个人之间横向沟通，垂直控制层次的沟通都会发生</li><li>有控制的集中制(CC)中领导者和团队成员之间的沟通是垂直的</li></ul><p>111.团队有没有领导者？有的话是一个还是多个？</p><ul><li>民主分权制(DD)中团队没有永久的领导者，任务协调员的任期为短工期，协调不同的任务时由不同的协调员取代</li><li>有控制的分权制(CD)中有领导协调具体任务，也有负责子任务的次要领导人</li><li>有控制的集中制(CC)中团队内部问题的解决和协调是由一个团队的领导者来管理的</li></ul><p>112.虚拟团队的定义以及优缺点?</p><ul><li>定义：跨越时间、空间和组织界限，运用通信技术加强连接的队伍</li><li>优点：提高生产力，扩大市场机遇，进行知识转移</li><li>缺点：沟通不足，领导不力，团队成员不称职</li></ul><p>113.对一个团队来说，<code>目标</code>是最重要的方面</p><p>114.在策划一个项目以前，应当建立产品的目标和范围，应考虑其他解决办法，以及约束技术和管理。如果没有这些信息，它无法精确地界定费用、进行有效风险评估、适当地分解项目任务、制定管理的项目进度表或提供有意义的进度估计</p><p>115.软件项目管理的第一个活动<code>确定软件范围</code></p><p>116.项目估算方法</p><ul><li>分解技术</li><li>经验模型</li></ul><p>117.项目计划</p><ul><li>软件项目计划的目的是使项目经理能够对资源、成本及时间进行合理的估算，一般是在项目开始时进行，随着项目进展定期更新。此外估算应该尝试确定最好和最坏的情况，使项目的成果是有界的</li><li>要注意软件项目计划不是一个静态的文件，也就是说随着项目的进行，项目组反复修正计划、更新风险估计和有关信息</li></ul><p>118.软件开发者和客户必须一起定义产品的目标和范围。在许多情况下，这个活动开始时作为系统工程或业务过程的一部分，接下来作为软件需求分析的第一步。</p><p>119.问题分解是用来干什么的</p><ul><li>将一个复杂的问题划分成更易于管理的小问题，有助于更精确地定义软件范围，从而指定更准确的项目计划</li></ul><p>120.哪种团队组织形式会带来更高的满意度？模块化程度高或低分别对应哪一个模型？</p><ul><li>民主分权制(DD)队伍结构会带来比较高的士气和工作满意度</li><li>民主分权制(DD)队伍结构最好应用于模块化程度相对较低的项目，因为它需要较高的通信量</li><li>在高度模块化的任务中，有控制的分权制(CD)和有控制的集中制(CC)队伍结构更加合适</li></ul><blockquote><ol><li>软件质量保证涵盖了整个软件开发过程</li><li>问题分解不适用于对软件的详细设计</li></ol></blockquote><h3 id="大概率出的问题"><a href="#大概率出的问题" class="headerlink" title="大概率出的问题"></a>大概率出的问题</h3><p><strong>软件危机定义和表现</strong></p><p>原因:</p><blockquote><p>缺乏<code>有力的方法学</code>和<code>有效的开发工具</code>的支持，这往往是产生软件危机的原因之一</p></blockquote><ul><li>项目超出预算</li><li>项目超过计划完成时间</li><li>软件运行效率很低</li><li>软件质量差</li><li>软件通常不符合要求</li><li>项目难以管理并且代码难以维护</li><li>软件不能交付</li></ul><p><strong>软件工程的七个原则</strong></p><ul><li>使用阶段性生命周期计划的管理</li><li>进行连续的验证</li><li>保证严格的产品控制</li><li>使用现代编程工具和工程实践</li><li>保持清晰的责任分配</li><li>用更好、更少的人</li><li>保持过程改进</li></ul><p>软件的特点</p><ul><li>软件是开发出来的或者说是工程化的，并不是制造出来的</li><li>软件开发环境对产品影响较大</li><li>软件开发的时间和工作量难以估算</li><li>用户往往不能一次性提出完整的需求，因此在经历了许多次修改后软件才能令人满意</li><li>几乎没有客观的标准或措施来评估软件的开发进度</li><li>软件的测试非常困难</li><li>软件不会”耗尽“</li><li>硬件可使用物理模型评价，而软件设计的评价取决于判断和直觉</li><li>硬件和软件的项目管理之间存在很大区别，传统的硬件项目控制方法应用到软件项目中可能会适得其反</li></ul><p><strong>软件设计的主要技术</strong></p><ul><li>软件架构设计（又称为顶层设计、概要设计）：描述软件的顶层架构和组织，划分不同的组件</li><li>软件详细设计：详细描述各组件以便能够编码实现</li></ul><p>软件过程模型的定义：</p><ul><li>软件过程模型是从软件项目需求定义直至软件运行维护为止，跨越整个生命周期的系统开发、运行和维护所实施的全部过程、 活动和任务的结构框架 ，软件过程模型能直观表达软件开发总过程，明确规定软件开发要完成的主要活动任务和开发策略。</li></ul><p>增量模型和螺旋模型的异同</p><ul><li>同：都是非整体的，迭代式的开发方式</li><li>不同：<ul><li>两者迭代的层次不同，增量模型是活动级的迭代，螺旋模型是过程级的迭代</li><li>两者需求分析的时间不同，增量模型往往是选做整体的需求分析，再做编码和逐个的增量包开发；而螺旋模型往往是开发周期内采用瀑布模型</li><li>两者交付软件的时间不同，增量模型是每次增量开发都在上一次增量基础上提交新一部分软件；而螺旋模型每次迭代都提交一个新的完整的软件版本</li><li>两者减小风险的方式不同，增量模型避免使用未成熟的技术和经常的客户反馈降低风险；螺旋模型则直接饮用风险设计和分析</li></ul></li></ul><p>需求分析过程与步骤</p><ul><li><code>需求获取</code>指的是软件需求的来源以及软件工程师收集这些软件需求的方法</li><li><code>需求分析</code>产生操作规格参数表，指明与其他系统元件的软件接口，确定软件必须遵循的约束</li><li><code>需求定义</code>即编写《 软件需求规格说明书》</li><li><code>需求验证</code>即检查需求的正确性、完整性、非二义性、内部和外部的连贯性</li></ul><p>结构化分析建立哪三种模型？核心是面向什么？分别对应什么建模？</p><ul><li>核心是<code>数据字典</code></li><li>围绕这个核心，有3种图： <code>数据流图</code>（ DFD，用于<code>功能建模</code>）、<code>实体-关系图</code>（ ER图，用于<code>数据建模</code>）、 <code>状态转换图</code>（ STD，用于<code>行为建模</code>）</li></ul><p>什么是用例图，它的作用是什么？内容是什么</p><ul><li>用例图是体现一组用例、参与者和它们之间关系的图，从用户角度而不是开发者角度来描述，体现对软件开发产品的需求，分析产品所需的功能和动态行为</li><li>用例图对需求建模是至关重要的，其正确与否直接影响到客户对最终产品的满意度</li><li>内容包括了参与者、用例与拓展的泛化关系</li></ul><p>UML中哪些是系统的参与者，可以提出哪些问题来确定？</p><ul><li>谁或者什么为系统提供输入？</li><li>谁或者什么接收系统的输出？</li><li>需要与其他系统连接的接口吗？</li><li>是否存在在预定的时间自动触发的事件？</li><li>谁将维护系统中的信息？</li></ul><p><strong>模块的扇入数大好不好？何时好何时不好？</strong></p><ul><li>模块的扇出数是指模块调用子模块的个数。 如果一个模块的扇出数过大，就意味着该模块过分复杂，需要协调和控制过多的下属模块 。</li><li>一个模块的扇入数越大，则共享该模块的上级模块数目越多， 但如果一个模块的扇入数太大，如超过8，而它又不是公用模块，说明该模块可能具有多个功能， 这时应当对其进一步分析并将其功能分解</li></ul><p><strong>模块化模块独立的标准</strong></p><ul><li><code>内聚性</code>：模块的功能相对强度</li><li><code>耦合性</code>：模块之间的相互依赖程度</li></ul><p><strong>模块数量的确定</strong></p><ul><li>尽管模块分解可以简化要解决的问题，但模块分解并不是越小越好</li><li>当模块数目增加时，每个模块的规模将减小， 开发单个模块的成本确实减少了；但是，随着模块数目增加， 模<br>块之间关系的复杂程度也会增加，设计模块间接口所需要的工作量也将增加</li></ul><p><strong>基于功能点和代码行数的相关指标计算，优缺点</strong></p><ul><li>优点<ul><li>LOC、 KLOC和相关度量容易计算</li><li>许多现有的软件估算模型都使用LOC和KLOC作为一项重要输入</li><li>有大量的关于LOC的参考文献和数据</li></ul></li><li>缺点<ul><li>LOC依赖于使用的语言，这对短小精悍的程序不利</li><li>不太适用于非过程化语言</li><li>LOC只有在设计完成时候才能计算，同时估算需要一定程度的细节，而这些细节可能很难获得。项目计划人员很难在分析和设计完成之前估算LOC</li></ul></li></ul><p>软件测试的基本原则</p><ul><li>穷尽测试是不可能的</li><li>测试无法显示潜伏的软件缺陷</li><li>测试活动应尽早进行</li><li>软件缺陷具有群聚性</li><li>注意杀虫剂现象</li><li>应尽量由独立的测试团队进行测试</li></ul><p>软件测试的目标</p><ul><li>确认系统满足其预期的使用和用户的需要</li><li>确认解决了所需解决的问题</li><li>为测试的过程建立责任和可解释性</li><li>便于及早发现软件和系统的异常</li><li>及早提供软件和系统的性能的评估</li><li>为管理提供真实信息，以决定在当前状态下发布产品在商业上的风险</li><li>鉴别出程序在功能等方面的异常集聚之处</li></ul><p>什么情况下称为发现软件缺陷</p><ul><li>至少满足下列一个条件，则称发生了一个软件缺陷：<ul><li>软件未实现产品说明书要求的功能</li><li>软件出现了产品说明书指明不能出现的错误</li><li>软件实现了产品说明书未提到的功能</li><li>软件未实现产品说明书虽未明确提及但应该实现的目标</li><li>软件难以理解、不易使用、运行缓慢，或者测试员的角度看，最终用户会认为不好</li></ul></li></ul><p><strong>白盒测试和黑盒测试的含义</strong></p><ul><li>黑盒测试：指忽略系统或组件的内部机制，仅关注于那些响应所选择的输入及相应执行条件的输出的测试形式，也称为功能性测试</li><li>白盒测试：指考虑系统或组件的内部机制的测试形式，也称为结构性测试。由于通常需要进行白盒测试，因此软件测试工程师也需要具有编程能力</li></ul><p>简述软件测试与调试的同与不同</p><ul><li>两者都包含有处理软件缺陷和查看代码的过程</li><li>测试的目标是发现软件缺陷的存在， 调试的目标是定位与修复缺陷。软件测试员把问题缩减为能够演示软件缺陷的最简化测试用例（或可疑的代码行），进行调试的程序员进而判断到底是什么导致软件缺陷，并设法修复</li></ul><p>V模型中四个级别的测试的主要目的或测试依据</p><ul><li>单元测试的主要目的是验证软件模块是否按详细设计的规格说明正确运行</li><li>集成测试的主要目的是检查多个模块间是否按概要设计说明的方式协同工作</li><li>系统测试的主要目的是验证整个系统是否满足需求规格说明</li><li>验收测试从用户的角度检查系统是否满足合同中定义的需求，以及以确认产品是否能符合业务上的需要</li></ul><p><strong>单元测试的主要内容</strong></p><ul><li>对模块接口的测试保证在测试时进出程序单元的数据流是正确的</li><li>对局部数据结构的测试保证临时存储的数据在算法执行的整个过程中都能维持其完整性</li><li>对边界条件的测试保证模块在极限或严格的情形下仍然能够正确执行</li><li>控制结构中的所有独立路径（基本路径）原则上都应覆盖，以保证在一个模块中的所有语句都能至少执行一次</li><li>要对所有出错处理的路径进行测试</li></ul><p>集成测试有哪3种集成方法？</p><ul><li>自顶向下的集成方法</li><li>自底向上的集成方法</li><li>Smoke方法</li></ul><p>4级别测试分别采用白盒测试还是黑盒测试</p><ul><li>单元测试：主要采用白盒测试方法设计测试用例，但在白盒测试方法之前应该先依据详细设计说明书建立黑盒<br>测试用例进行测试，使之对任何合理的输入和不合理的输入，都能鉴别和响应</li><li>集成测试：既有白盒测试的成分又有黑盒测试的成分，也称为灰盒测试</li><li>系统测试：基本上使用黑盒测试方法</li><li>验收测试：黑盒测试方法</li></ul><p>软件维护的定义和必要性</p><ul><li>软件维护是指由于软件产品出现问题或需要改进而对代码及相关文档的修改，其目的是对现有软件产品进行修改的同时保持其完整性</li><li>软件维护能够改正错误</li><li>软件维护能够改善设计</li><li>软件维护能够实现软件的改进</li><li>软件维护能够与其他系统进行交互</li><li>软件维护能够为使用不同的硬件、软件、系统的新性能以及通讯设备等而对软件进行改进</li><li>软件维护能够完成遗留程序的移植</li><li>软件退出使用</li></ul><blockquote><p>复习到此结束 希望之后有愿意看的同学 多看一下数据流图怎么画</p></blockquote></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/UESTC/"><span class="chip bg-color">UESTC</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/33911/"><div class="card-image"><img src="/medias/featureimages/3.jpg" class="responsive-img" alt="代码测试、调试与优化"> <span class="card-title">代码测试、调试与优化</span></div></a><div class="card-content article-content"><div class="summary block-with-text">前言代码写完以后往往要做测试（或验证）、调试，可能还要优化。 关于测试（或验证） 通常对应着两个英文单词 Verification 和 Validation The differences between verification an</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-08 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/C/" class="post-category">C</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/10533/"><div class="card-image"><img src="/medias/featureimages/20.jpg" class="responsive-img" alt="记录博客的一次更新"> <span class="card-title">记录博客的一次更新</span></div></a><div class="card-content article-content"><div class="summary block-with-text">记录一次博客的更新已经很久没有写博客了，上一次写博客还是在半年前因为课程要求做读书笔记才记的，这半年来发生了很多事情，我的想法与之前也发生了很大的变化，希望能够从现在开始认认真真读几本书，好好写一下博客，记录一下自己的生活，最后希望自己能够</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-05 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%9D%82%E8%AE%B0/" class="post-category">杂记</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E7%AB%99%E7%82%B9%E7%9B%B8%E5%85%B3/"><span class="chip bg-color">站点相关</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0!==window.getSelection&&((""+(n=window.getSelection())).length<Number.parseInt("120")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: JoyTsing<br />文章作者: JoyTsing<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者joytsing所有，请任何形式的转载都请注明出处并在文章评论区处告知。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)))})</script><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">849.2k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script></body></html>