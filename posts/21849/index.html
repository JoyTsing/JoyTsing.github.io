<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="有栈协程与无栈协程, joytsing blog"><meta name="description" content="协程之间亦有不同"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>有栈协程与无栈协程 | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/27.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">有栈协程与无栈协程</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Go/"><span class="chip bg-color">Go</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Go/" class="post-category">Go</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2024-04-19</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-04-19</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 3.6k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 13 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，先问自己一个问题，<code>什么是协程？</code>，<code>为什么需要协程？</code>，<code>能解决什么痛点？</code></p><h2 id="协程，what，why？"><a href="#协程，what，why？" class="headerlink" title="协程，what，why？"></a>协程，what，why？</h2><p>什么是协程，现在流行的有几种说法：</p><ul><li>第一种： “可以暂停和恢复执行” 的函数，<strong>其“全部精神就在于控制流的主动让出和恢复”</strong>。这种观点来自协程概念的提出者Conway在1963年发表的论文”<strong><a href="http://melconway.com/Home/pdf/compiler.pdf">Design of a separable transition-diagram compiler</a></strong>“</li><li>第二种：是运行在用户态的线程，避免了向内核态下陷从而提高性能。实现一个用户态线程有两个必须要处理的问题：一是碰着阻塞式I\O会导致整个进程被挂起；二是由于缺乏时钟阻塞，进程需要自己拥有调度线程的能力。如果一种实现使得每个线程需要自己通过调用某个方法，主动交出控制权。那么我们就称这种用户态线程是协作式的，即是<strong>协程</strong>。</li><li>第三种：Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. —— from <strong><a href="https://en.wikipedia.org/wiki/Coroutine">Wikipieda</a></strong></li></ul><p>所以这几种定义哪个才是协程，还是说他们都对？然后是我们为什么要协程？</p><ul><li>让原来需要使用异步+回调方式写的非人类代码,用看似同步的方式写出来</li><li>既要同步编程风格，能够让业务开发人员很便捷地去开发业务逻辑代码，同时能够达到「异步回调模型的性能」。</li></ul><h2 id="有栈协程与无栈协程"><a href="#有栈协程与无栈协程" class="headerlink" title="有栈协程与无栈协程"></a>有栈协程与无栈协程</h2><p>如今协程已经成为大多数语言的标配，例如 Golang 里的 goroutine，JavaScript 里的 async/await。尽管名称可能不同，但它们都可以被划分为两大类，一类是有栈（stackful）协程，例如 goroutine；一类是无栈（stackless）协程，例如 async/await。</p><p>此处「有栈」和「无栈」的含义不是指协程在运行时是否需要栈，对于大多数语言来说，一个函数调用另一个函数，总是存在调用栈的；而是指协程是否可以在其<strong>任意</strong>嵌套函数中被挂起，此处的嵌套函数读者可以理解为子函数、匿名函数等。显然有栈协程是可以的，而无栈协程则不可以。似乎难以理解？不要慌，让我们先从函数调用栈开始讲起。</p><h3 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h3><p>调用栈是一段连续的地址空间，无论是 caller（调用方）还是 callee（被调用方）都位于这段空间之内。而调用栈中一个函数所占用的地址空间我们称之为「栈帧」（stack frame），调用栈便是由若干个栈帧拼接而成的。</p><p><img src="/posts/21849/call-stack.png" alt="DrawSquare 是 caller，DrawLine 是 callee"></p><p>Stack Pointer 即栈顶指针，总是指向调用栈的顶部地址，该地址由 esp 寄存器存储；Frame Pointer 即基址指针，总是指向当前栈帧（当前正在运行的子函数）的底部地址，该地址由 ebp 寄存器存储。Return Address 则在是 callee 返回后，caller 将继续执行的指令所在的地址；而指令地址是由 eip 寄存器负责读取的，且 eip 寄存器总是预先读取了<strong>当前栈帧中</strong>下一条将要执行的指令的地址。</p><p>我们可以很轻易地构造一段 C 代码，然后将其转换为汇编，看看底层究竟做了什么。网页上推荐使用 <a href="https://godbolt.org/">Compiler Explorer</a> 查看汇编更加简洁清晰。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">callee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// callee:</span>
               <span class="token comment" spellcheck="true">//   pushl %ebp</span>
               <span class="token comment" spellcheck="true">//   movl  %esp, %ebp</span>
               <span class="token comment" spellcheck="true">//   subl  $16, %esp</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//   movl  $0, -4(%ebp)</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//   movl -4(%ebp), %eax</span>
               <span class="token comment" spellcheck="true">//   leave</span>
               <span class="token comment" spellcheck="true">//   ret</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">caller</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// caller:</span>
               <span class="token comment" spellcheck="true">//   pushl %ebp</span>
               <span class="token comment" spellcheck="true">//   movl  %esp, %ebp</span>
    <span class="token function">callee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//   call  callee</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//   movl  $0, %eax</span>
               <span class="token comment" spellcheck="true">//   popl  %ebp</span>
               <span class="token comment" spellcheck="true">//   ret</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 caller 调用 callee 时，执行了以下步骤（注意注释中的执行顺序：</p><pre class="line-numbers language-assembly"><code class="language-assembly">callee:
    // 3. 将 caller 的栈帧底部地址入栈保存
    pushl %ebp
    // 4. 将此时的调用栈顶部地址作为 callee 的栈帧底部地址
    movl  %esp, %ebp
    // 5. 将调用栈顶部扩展 16 bytes 作为 callee 的栈帧空间；
    //    在 x86 平台中，调用栈的地址增长方向是从高位向低位增长的，
    //    所以这里用的是 subl 指令而不是 addl 指令
    subl  $16, %esp
    ...
caller:
    ...
    // "call callee" 等价于如下两条指令：
    // 1. 将 eip 存储的指令地址入栈保存；
    //    此时的指令地址即为 caller 的 return address，
    //    即 caller 的 "movl $0, %eax" 这条指令所在的地址
    // 2. 然后跳转到 callee
    pushl %eip
    jmp callee
    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/21849/caller-to-callee.png" alt="caller 调用 callee 的调用栈变化（忽略传参）">caller 调用 callee 的调用栈变化（忽略传参）</p><p>当 callee 返回 caller 时，则执行了以下步骤（注意注释中的执行顺序：</p><pre class="line-numbers language-assembly"><code class="language-assembly">callee:
    ...
    // "leave" 等价于如下两条指令：
    // 6. 将调用栈顶部与 callee 栈帧底部对齐，释放 callee 栈帧空间
    // 7. 将之前保存的 caller 的栈帧底部地址出栈并赋值给 ebp
    movl %ebp, %esp
    popl %ebp
    // "ret" 等价如下指令：
    // 8. 将之前保存的 caller 的 return address 出栈并赋值给 eip，
    //    即 caller 的 "movl $0, %eax" 这条指令所在的地址
    popl eip
caller:
    ...
    // 9. 从 callee 返回了，继续执行后续指令
    movl $0, %eax
    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/21849/callee-to-caller.png" alt="callee 返回 caller 的调用栈变化（忽略传参）">callee 返回 caller 的调用栈变化（忽略传参)</p><p>以上便是函数调用栈的大致运行过程了。当然真实的调用栈运行过程要复杂一些，需要带上参数传递等等，对此感兴趣，则推荐阅读这篇文章 <a href="https://www.csee.umbc.edu/~chang/cs313.s02/stack.shtml">C Function Call Conventions and the Stack</a>。</p><h3 id="有栈协程"><a href="#有栈协程" class="headerlink" title="有栈协程"></a>有栈协程</h3><p>实现一个协程的关键点在于如何保存、恢复和切换上下文。已知函数运行在调用栈上；如果将一个函数作为协程，我们很自然地联想到，保存上下文即是保存从这个函数及其嵌套函数的（连续的）栈帧存储的值，以及此时寄存器存储的值；恢复上下文即是将这些值分别重新写入对应的栈帧和寄存器；而切换上下文无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的函数的上下文。有栈协程便是这种朴素思想下的产物，即类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核而已。</p><p>有栈协程是可以在其任意嵌套函数中被挂起的 —— 毕竟它都能保存和恢复自己完整的上下文了，那自然是在哪里被挂起都可以。我们可以自己实现一个简单的例子证明这个事实，同时也有助于我们从底层理解有栈协程的运行过程。</p><p>首先我们需要申请一段能存储上下文的内存空间。在保存上下文时，我们可以选择把上下文都拷贝到这段内存；亦或者直接将这段内存作为协程运行时的栈帧空间，这样就能避免拷贝带来的性能损失了。注意，如果申请的内存空间小了，协程在运行时会爆栈；如果大了，则浪费内存；不过具体的分配策略我们就不做过多讨论了。</p><p>同时还需要保存寄存器的值。这里便涉及到了函数调用栈中的一个知识点，<a href="https://en.wikipedia.org/wiki/X86_calling_conventions#Caller-saved_(volatile)_registers">根据约定</a>，有的寄存器是由 caller 负责保存的，如 eax、ecx 和 edx；而有的寄存器是 callee 负责保存的，如 ebx、edi 和 esi。对于被调用的协程而言，只需要保存 callee 相关的寄存器的值，调用栈相关的 ebp 和 esp 的值，以及 eip 存储的 return address。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 1) 存储 return address</span>
<span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 2) 存储 ebx</span>
<span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 3) 存储 edi</span>
<span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 4) 存储 esi</span>
<span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 5) 存储 ebp</span>
<span class="token comment" spellcheck="true">// *(ctx + CTX_SIZE - 6) 存储 esp</span>

<span class="token comment" spellcheck="true">// 注意 x86 的栈增长方向是从高位向低位增长的，所以寻址是向下偏移的</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 动态申请 CTX_SIZE 内存用于存储协程上下文</span>
    size_t size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> CTX_SIZE<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>ctx <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 将 func 的地址作为其栈帧 return address 的初始值，</span>
    <span class="token comment" spellcheck="true">// 当 func 第一次被调度时，将从其入口处开始执行</span>
    <span class="token operator">*</span><span class="token punctuation">(</span>ctx <span class="token operator">+</span> CTX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> func<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// https://github.com/mthli/blog/pull/12</span>
    <span class="token comment" spellcheck="true">// 需要预留 6 个寄存器内容的存储空间，</span>
    <span class="token comment" spellcheck="true">// 余下的内存空间均可以作为 func 的栈帧空间</span>
    <span class="token operator">*</span><span class="token punctuation">(</span>ctx <span class="token operator">+</span> CTX_SIZE <span class="token operator">-</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx <span class="token operator">+</span> CTX_SIZE <span class="token operator">-</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ctx <span class="token operator">+</span> CTX_SIZE<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，为了保存和恢复寄存器的值，我们还需要撰写几段汇编代码。假设此时我们已经将存储上下文的内存地址赋值给了 eax，则保存的逻辑如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly">// 依次将各个寄存器的值存储；
// 注意 x86 的栈增长方向是从高位向低位增长的，所以寻址是向下偏移的
movl %ebx,  -8(%eax)
movl %edi, -12(%eax)
movl %esi, -16(%eax)
movl %ebp, -20(%eax)
movl %esp, -24(%eax)

//  %esp  存储的是当前调用栈的顶部所在的地址，
// (%esp) 是顶部地址所指向的内存区域存储的值，
// 将这个值存储为 return address
movl (%esp), %ecx
movl %ecx, -4(%eax)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而与之相对应的恢复逻辑如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly">// 依次将存储的值写入各个寄存器；
// 注意 x86 的栈增长方向是从高位向低位增长的，所以寻址是向下偏移的
movl  -8(%eax), %ebx
movl -12(%eax), %edi
movl -16(%eax), %esi
movl -20(%eax), %ebp
movl -24(%eax), %esp

//  %esp  存储的是当前调用栈的顶部所在的地址，
// (%esp) 是顶部地址所指向的内存区域存储的值，
// 将存储的 return address 写入到该内存区域
movl -4(%eax), %ecx
movl %ecx, (%esp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而前文已经说过，切换上下文无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的函数的上下文。于是我们可以基于上述两段汇编构造一个 <code>void swap_ctx(char **current, char **next)</code> 函数，分别传入 <code>char **init_ctx(char *func)</code> 构造好的上下文即可实现切换。为了方便使用，我们可以将 <code>swap_ctx()</code> 封装成 <code>yield()</code> 函数，在这个函数里简单实现了不同函数的调度逻辑。于是一个简单的例子便完成了：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>MAIN_CTX<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>NEST_CTX<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>FUNC_CTX_1<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>FUNC_CTX_2<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">nest_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">nest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 随机生成一个整数作为 tag</span>
    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"nest, tag: %d, index: %d\n"</span><span class="token punctuation">,</span> tag<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">nest_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 随机生成一个整数作为 tag</span>
    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"func, tag: %d, index: %d\n"</span><span class="token punctuation">,</span> tag<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MAIN_CTX <span class="token operator">=</span> <span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> main<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 证明 nest() 可以在其任意嵌套函数中被挂起</span>
    NEST_CTX <span class="token operator">=</span> <span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> nest<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 证明同一个函数在不同的栈帧空间上运行</span>
    FUNC_CTX_1 <span class="token operator">=</span> <span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>
    FUNC_CTX_2 <span class="token operator">=</span> <span class="token function">init_ctx</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"main, tag: %d, index: %d\n"</span><span class="token punctuation">,</span> tag<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">free</span><span class="token punctuation">(</span>MAIN_CTX <span class="token operator">-</span> CTX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>NEST_CTX <span class="token operator">-</span> CTX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>FUNC_CTX_1 <span class="token operator">-</span> CTX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>FUNC_CTX_2 <span class="token operator">-</span> CTX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整的代码可通过 <a href="https://github.com/mthli/blog/blob/master/content/blog/stackful-stackless/">这个链接</a> 获得，使用 <code>gcc -m32 stackful.c stackful.s</code> 编译，然后运行 <code>./a.out</code> 的得到如下结果：</p><p><img src="/posts/21849/image-20240419205041630.png" alt></p><p>可以注意到 <code>tag</code> 的值在每次调度过程中均未改变，而循环叠加 <code>index</code> 的逻辑也并未因为挂起和恢复受到影响。所以 <code>nest()</code> 的确是可以在其任意嵌套函数中被挂起；同时我们还证明了同一个函数被调用多次时，的确是在不同的栈帧空间上运行的。</p><h2 id="无栈协程"><a href="#无栈协程" class="headerlink" title="无栈协程"></a>无栈协程</h2><p>相比于有栈协程直接切换栈帧的思路，无栈协程在不改变函数调用栈的情况下，采用类似生成器（generator）的思路实现了上下文切换，此处请直接阅读文章 <a href="https://mthli.xyz/coroutines-in-c/">使用 C 语言实现协程</a> —— 尽管作者在文中没有说明，但这正是一种无栈协程的实现。<strong>无栈协程的本质就是一个状态机（state machine）</strong>，它可以理解为在另一个角度去看问题，即<strong>同一协程协程的切换本质不过是指令指针寄存器的改变</strong>。</p><p>此外我们还可以通过译文提供的 <a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutine.h">coroutine.h</a> 看到，作者通过 C 语言的宏将所有协程的变量统一包装进了一个结构体，然后再为这个结构体申请内存空间，从而实现了分配确定大小的内存空间，避免了内存浪费 —— 而这正是有栈协程所做不到的。</p><p>从执行时栈的角度来看，其实所有的协程共用的都是一个栈，即系统栈，也就也不必我们自行去给协程分配栈，因为是函数调用，我们当然也不必去显示的保存寄存器的值，而且<strong>相比有栈协程把局部变量放在新开的空间上，无栈协程直接使用系统栈使得CPU cache局部性更好，同时也使得无栈协程的中断和函数返回几乎没有区别</strong>，这样也可以凸显出无栈协程的高效。</p><h2 id="对称协程和非对称协程"><a href="#对称协程和非对称协程" class="headerlink" title="对称协程和非对称协程"></a>对称协程和非对称协程</h2><p>其实对于“对称”这个名词，阐述的实际是协程之间的关系，用大白话来说就是对称协程就是说协程之间人人平等，没有谁调用谁一说，大家都是一样的，而非对称协程就是协程之间存在明显的调用关系。</p><p>简单来说就是这样：</p><ul><li>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。</li><li>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。</li></ul><p>回到开头的问题，协程分为无栈协程和有栈协程两种，无栈指可挂起/恢复的函数，有栈协程则相当于用户态线程。有栈协程切换的成本是用户态线程切换的成本，而无栈协程切换的成本则相当于函数调用的成本。</p><ul><li>无栈协程和线程的区别：无栈协程只能被线程调用，本身并不抢占内核调度，而线程则可抢占内核调度。</li><li>协程函数与普通函数的区别：普通函数执行完返回，则结束，协程函数可以运行到一半，返回并保留上下文；下次唤醒时恢复上下文，可以接着执行。</li></ul></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Go/"><span class="chip bg-color">Go</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/24827/"><div class="card-image"><img src="/medias/featureimages/22.jpg" class="responsive-img" alt="Boost中Asio网络编程"> <span class="card-title">Boost中Asio网络编程</span></div></a><div class="card-content article-content"><div class="summary block-with-text">什么时候才有标准网络库</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-04-21 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Cpp/" class="post-category">Cpp</a></span></div></div><div class="card-action article-tags"><a href="/tags/Cpp/"><span class="chip bg-color">Cpp</span> </a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="chip bg-color">计算机网络</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/59192/"><div class="card-image"><img src="/medias/featureimages/23.jpg" class="responsive-img" alt="Go里的GMP协程调度"> <span class="card-title">Go里的GMP协程调度</span></div></a><div class="card-content article-content"><div class="summary block-with-text">调度是提高生产之源</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2024-04-19 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/Go/" class="post-category">Go</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Go/"><span class="chip bg-color">Go</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0!==window.getSelection&&((""+(n=window.getSelection())).length<Number.parseInt("120")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: JoyTsing<br />文章作者: JoyTsing<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者joytsing所有，请任何形式的转载都请注明出处并在文章评论区处告知。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)))})</script><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">834k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body></html>