<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="缓冲区溢出与注入分析, joytsing blog"><meta name="description" content="前言虽然程序加载以及动态符号链接都已经很理解了，但是这伙却被进程的内存映像给”纠缠”住。看着看着就一发不可收拾——很有趣。
下面一起来探究“缓冲区溢出和注入”问题（主要是关心程序的内存映像）。
进程的内存映像永远的 Hello World，"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="theme-color" content="white"><title>缓冲区溢出与注入分析 | JoyTsing</title><link rel="apple-touch-icon" href="/"><link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="/libs/jquery/jquery.min.js"></script><script src="https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js"></script><script>const aegis=new Aegis({id:"6ojk8FlnQlqWeL6vQo",uin:"joyblog",reportApiSpeed:!0,reportAssetSpeed:!0,spa:!0,hostUrl:"https://rumt-sg.com"});console.log("aegis load")</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JoyTsing" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/apple-touch-icon.png" class="logo-img" alt="LOGO"> <span class="logo-span">JoyTsing</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友链</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/avatars/touxiang2.jpg" class="logo-img circle responsive-img"><div class="logo-name">JoyTsing</div><div class="logo-desc">joytsing的个人网站</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友链</a></li><li><div class="divider"></div></li><li><a href="https://github.com/JoyTsing" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Follow Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#000;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/JoyTsing" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/6.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">缓冲区溢出与注入分析</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="chip bg-color">操作系统</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category">操作系统</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2020-12-22</div><div class="post-date info-break-policy"><i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-04-20</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 13.1k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 54 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然程序加载以及动态符号链接都已经很理解了，但是这伙却被进程的内存映像给”纠缠”住。看着看着就一发不可收拾——很有趣。</p><p>下面一起来探究“缓冲区溢出和注入”问题（主要是关心程序的内存映像）。</p><h2 id="进程的内存映像"><a href="#进程的内存映像" class="headerlink" title="进程的内存映像"></a>进程的内存映像</h2><p>永远的 <code>Hello World</code>，太熟悉了吧，</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要用内联汇编（<code>inline assembly</code>）来写呢？</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token number">1</span>  <span class="token comment" spellcheck="true">/* shellcode.c */</span>
 <span class="token number">2</span>  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token number">3</span>  <span class="token punctuation">{</span>
 <span class="token number">4</span>      <span class="token function">__asm____volatile__</span><span class="token punctuation">(</span><span class="token string">"jmp forward;"</span>
 <span class="token number">5</span>                   <span class="token string">"backward:"</span>
 <span class="token number">6</span>                           <span class="token string">"popl   %esi;"</span>
 <span class="token number">7</span>                           <span class="token string">"movl   $4, %eax;"</span>
 <span class="token number">8</span>                           <span class="token string">"movl   $2, %ebx;"</span>
 <span class="token number">9</span>                           <span class="token string">"movl   %esi, %ecx;"</span>
<span class="token number">10</span>                           <span class="token string">"movl   $12, %edx;"</span>
<span class="token number">11</span>                           <span class="token string">"int    $0x80;"</span>    <span class="token comment" spellcheck="true">/* system call 1 */</span>
<span class="token number">12</span>                           <span class="token string">"movl   $1, %eax;"</span>
<span class="token number">13</span>                           <span class="token string">"movl   $0, %ebx;"</span>
<span class="token number">14</span>                           <span class="token string">"int    $0x80;"</span>    <span class="token comment" spellcheck="true">/* system call 2 */</span>
<span class="token number">15</span>                   <span class="token string">"forward:"</span>
<span class="token number">16</span>                           <span class="token string">"call   backward;"</span>
<span class="token number">17</span>                           <span class="token string">".string \"Hello World\\n\";"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">18</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来很复杂，实际上就做了一个事情，往终端上写了个 <code>Hello World</code> 。不过这个非常有意思。先简单分析一下流程：</p><ul><li>第 4 行指令的作用是跳转到第 15 行（即 <code>forward</code> 标记处），接着执行第 16 行。</li><li>第 16 行调用 <code>backward</code>，跳转到第 5 行，接着执行 6 到 14 行。</li><li>第 6 行到第 11 行负责在终端打印出 <code>Hello World</code> 字符串（等一下详细介绍）。</li><li>第 12 行到第 14 行退出程序（等一下详细介绍）。</li></ul><p>为了更好的理解上面的代码和后续的分析，先来介绍几个比较重要的内容。</p><h3 id="常用寄存器初识"><a href="#常用寄存器初识" class="headerlink" title="常用寄存器初识"></a>常用寄存器初识</h3><p><code>X86</code> 处理器平台有三个常用寄存器：程序指令指针、程序堆栈指针与程序基指针：</p><table><thead><tr><th>寄存器</th><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>EIP</td><td>程序指令指针</td><td>通常指向下一条指令的位置</td></tr><tr><td>ESP</td><td>程序堆栈指针</td><td>通常指向当前堆栈的当前位置</td></tr><tr><td>EBP</td><td>程序基指针</td><td>通常指向函数使用的堆栈顶端</td></tr></tbody></table><p>当然，上面都是扩展的寄存器，用于 32 位系统，对应的 16 系统为 <code>ip</code>，<code>sp</code>，<code>bp</code> 。</p><h3 id="call，ret-指令的作用分析"><a href="#call，ret-指令的作用分析" class="headerlink" title="call，ret 指令的作用分析"></a>call，ret 指令的作用分析</h3><ul><li><p><code>call</code> 指令</p><p>跳转到某个位置，并在之前把下一条指令的地址（<code>EIP</code>）入栈（为了方便”程序“返回以后能够接着执行）。这样的话就有：</p><pre><code>  call backward   ==&gt;   push eip
                        jmp backward</code></pre></li><li><p><code>ret</code> 指令</p><p>通常 <code>call</code> 指令和 <code>ret</code> 是配合使用的，前者压入跳转前的下一条指令地址，后者弹出 <code>call</code> 指令压入的那条指令，从而可以在函数调用结束以后接着执行后面的指令。</p><pre><code>  ret                    ==&gt;   pop eip</code></pre></li></ul><p>通常在函数调用后，还需要恢复 <code>esp</code> 和 <code>ebp</code>，恢复 <code>esp</code> 即恢复当前栈指针，以便释放调用函数时为存储函数的局部变量而自动分配的空间；恢复 <code>ebp</code> 是从栈中弹出一个数据项（通常函数调用过后的第一条语句就是 <code>push ebp</code>），从而恢复当前的函数指针为函数调用者本身。这两个动作可以通过一条 <code>leave</code> 指令完成。</p><p>这三个指令对我们后续的解释会很有帮助。</p><h3 id="什么是系统调用（以-Linux-2-6-21-版本和-x86-平台为例）"><a href="#什么是系统调用（以-Linux-2-6-21-版本和-x86-平台为例）" class="headerlink" title="什么是系统调用（以 Linux 2.6.21 版本和 x86 平台为例）"></a>什么是系统调用（以 Linux 2.6.21 版本和 x86 平台为例）</h3><p>系统调用是用户和内核之间的接口，用户如果想写程序，很多时候直接调用了 C 库，并没有关心系统调用，而实际上 C 库也是基于系统调用的。这样应用程序和内核之间就可以通过系统调用联系起来。它们分别处于操作系统的用户空间和内核空间（主要是内存地址空间的隔离）。</p><pre><code>用户空间         应用程序(Applications)
                        |      |
                        |     C库（如glibc）
                        |      |
                       系统调用(System Calls，如sys_read, sys_write, sys_exit)
                            |
内核空间              内核(Kernel)</code></pre><p>系统调用实际上也是一些函数，它们被定义在 <code>arch/i386/kernel/sys_i386.c</code> （老的在 <code>arch/i386/kernel/sys.c</code>）文件中，并且通过一张系统调用表组织，该表在内核启动时就已经加载了，这个表的入口在内核源代码的 <code>arch/i386/kernel/syscall_table.S</code> 里头（老的在 <code>arch/i386/kernel/entry.S</code>）。这样，如果想添加一个新的系统调用，修改上面两个内核中的文件，并重新编译内核就可以。当然，如果要在应用程序中使用它们，还得把它写到 <code>include/asm/unistd.h</code> 中。</p><p>如果要在 C 语言中使用某个系统调用，需要包含头文件 <code>/usr/include/asm/unistd.h</code>，里头有各个系统调用的声明以及系统调用号（对应于调用表的入口，即在调用表中的索引，为方便查找调用表而设立的）。如果是自己定义的新系统调用，可能还要在开头用宏 <code>_syscall(type, name, type1, name1...)</code>来声明好参数。</p><p>如果要在汇编语言中使用，需要用到 <code>int 0x80</code> 调用，这个是系统调用的中断入口。涉及到传送参数的寄存器有这么几个，<code>eax</code> 是系统调用号（可以到 <code>/usr/include/asm-i386/unistd.h</code> 或者直接到 <code>arch/i386/kernel/syscall_table.S</code> 查到），其他寄存器如 <code>ebx</code>，<code>ecx</code>，<code>edx</code>，<code>esi</code>，<code>edi</code> 一次存放系统调用的参数。而系统调用的返回值存放在 <code>eax</code> 寄存器中。</p><p>下面我们就很容易解释前面的 <code>Shellcode.c</code> 程序流程的 2，3 两部分了。因为都用了 <code>int 0x80</code> 中断，所以都用到了系统调用。</p><p>第 3 部分很简单，用到的系统调用号是 1，通过查表（查 <code>/usr/include/asm-i386/unistd.h</code> 或 <code>arch/i386/kernel/syscall_table.S</code>）可以发现这里是 <code>sys_exit</code> 调用，再从 <code>/usr/include/unistd.h</code> 文件看这个系统调用的声明，发现参数 <code>ebx</code> 是程序退出状态。</p><p>第 2 部分比较有趣，而且复杂一点。我们依次来看各个寄存器，首先根据 <code>eax</code> 为 4 确定（同样查表）系统调用为 <code>sys_write</code>，而查看它的声明（从 <code>/usr/include/unistd.h</code>），我们找到了参数依次为文件描述符、字符串指针和字符串长度。</p><ul><li>第一个参数是 <code>ebx</code>，正好是 2，即标准错误输出，默认为终端。</li><li>第二个参数是 <code>ecx</code>，而 <code>ecx</code> 的内容来自 <code>esi</code>，<code>esi</code> 来自刚弹出栈的值（见第 6 行 <code>popl %esi;</code>），而之前刚好有 <code>call</code> 指令引起了最近一次压栈操作，入栈的内容刚好是 <code>call</code> 指令的下一条指令的地址，即 <code>.string</code> 所在行的地址，这样 <code>ecx</code> 刚好引用了 <code>Hello World\\n</code> 字符串的地址。</li><li>第三个参数是 <code>edx</code>，刚好是 12，即 <code>Hello World\\n</code> 字符串的长度（包括一个空字符）。这样，<code>Shellcode.c</code> 的执行流程就很清楚了，第 4，5，15，16 行指令的巧妙之处也就容易理解了（把 <code>.string</code> 存放在 <code>call</code> 指令之后，并用 <code>popl</code> 指令把 <code>eip</code> 弹出当作字符串的入口）。</li></ul><h3 id="什么是-ELF-文件"><a href="#什么是-ELF-文件" class="headerlink" title="什么是 ELF 文件"></a>什么是 ELF 文件</h3><p>这里的 ELF 不是“精灵”，而是 Executable and Linking Format 文件，是 Linux 下用来做目标文件、可执行文件和共享库的一种文件格式，它有专门的标准。</p><p>下面简单描述 <code>ELF</code> 的格式。</p><p><code>ELF</code> 文件主要有三种，分别是：</p><ul><li>可重定位的目标文件，在编译时用 <code>gcc</code> 的 <code>-c</code> 参数时产生。</li><li>可执行文件，这类文件就是我们后面要讨论的可以执行的文件。</li><li>共享库，这里主要是动态共享库，而静态共享库则是可重定位的目标文件通过 <code>ar</code> 命令组织的。</li></ul><p><code>ELF</code> 文件的大体结构：</p><pre><code>ELF Header               #程序头，有该文件的Magic number(参考man magic)，类型等
Program Header Table     #对可执行文件和共享库有效，它描述下面各个节(section)组成的段
Section1
Section2
Section3
.....
Program Section Table   #仅对可重定位目标文件和静态库有效，用于描述各个Section的重定位信息等。</code></pre><p>对于可执行文件，文件最后的 <code>Program Section Table</code> （节区表）和一些非重定位的 <code>Section</code>，比如 <code>.comment</code>，<code>.note.XXX.debug</code> 等信息都可以删除掉，不过如果用 <code>strip</code>，<code>objcopy</code> 等工具删除掉以后，就不可恢复了。因为这些信息对程序的运行一般没有任何用处。</p><p><code>ELF</code> 文件的主要节区（<code>section</code>）有 <code>.data</code>，<code>.text</code>，<code>.bss</code>，<code>.interp</code> 等，而主要段（<code>segment</code>）有 <code>LOAD</code>，<code>INTERP</code> 等。它们之间（节区和段）的主要对应关系如下：</p><table><thead><tr><th>Section</th><th>解释</th><th>实例</th></tr></thead><tbody><tr><td>.data</td><td>初始化的数据</td><td>比如 <code>int a=10</code></td></tr><tr><td>.bss</td><td>未初始化的数据</td><td>比如 <code>char sum[100];</code> 这个在程序执行之前，内核将初始化为 0</td></tr><tr><td>.text</td><td>程序代码正文</td><td>即可执行指令集</td></tr><tr><td>.interp</td><td>描述程序需要的解释器（动态连接和装载程序）</td><td>存有解释器的全路径，如 <code>/lib/ld-linux.so</code></td></tr></tbody></table><p>而程序在执行以后，<code>.data</code>，<code>.bss</code>，<code>.text</code> 等一些节区会被 <code>Program header table</code> 映射到 <code>LOAD</code> 段，<code>.interp</code> 则被映射到了 <code>INTERP</code> 段。</p><p>对于 <code>ELF</code> 文件的分析，建议使用 <code>file</code>，<code>size</code>，<code>readelf</code>，<code>objdump</code>，<code>strip</code>，<code>objcopy</code>，<code>gdb</code>，<code>nm</code> 等工具。</p><p>这里简单地演示这几个工具：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -g -o shellcode shellcode.c  <span class="token comment" spellcheck="true">#如果要用gdb调试，编译时加上-g是必须的</span>
shellcode.c: In <span class="token keyword">function</span> ‘main’:
shellcode.c:3: warning: <span class="token keyword">return</span> <span class="token function">type</span> of ‘main’ is not ‘int’
f$ <span class="token function">file</span> shellcode  <span class="token comment" spellcheck="true">#file命令查看文件类型，想了解工作原理，可man magic,man file</span>
shellcode: ELF 32-bit LSB executable, Intel 80386, version 1 <span class="token punctuation">(</span>SYSV<span class="token punctuation">)</span>,
dynamically linked <span class="token punctuation">(</span>uses shared libs<span class="token punctuation">)</span>, not stripped
$ readelf -l shellcode  <span class="token comment" spellcheck="true">#列出ELF文件前面的program head table，后面是它描</span>
                       <span class="token comment" spellcheck="true">#述了各个段(segment)和节区(section)的关系,即各个段包含哪些节区。</span>
Elf <span class="token function">file</span> <span class="token function">type</span> is EXEC <span class="token punctuation">(</span>Executable file<span class="token punctuation">)</span>
Entry point 0x8048280
There are 7 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4
  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1
      <span class="token punctuation">[</span>Requesting program interpreter: /lib/ld-linux.so.2<span class="token punctuation">]</span>
  LOAD           0x000000 0x08048000 0x08048000 0x0044c 0x0044c R E 0x1000
  LOAD           0x00044c 0x0804944c 0x0804944c 0x00100 0x00104 RW  0x1000
  DYNAMIC        0x000460 0x08049460 0x08049460 0x000c8 0x000c8 RW  0x4
  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4

 Section to Segment mapping:
  Segment Sections<span class="token punctuation">..</span>.
   00
   01     .interp
   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r
          .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame
   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss
   04     .dynamic
   05     .note.ABI-tag
   06
$ size shellcode   <span class="token comment" spellcheck="true">#可用size命令查看各个段（对应后面将分析的进程内存映像）的大小</span>
   text    data     bss     dec     hex filename
    815     256       4    1075     433 shellcode
$ strip -R .note.ABI-tag shellcode <span class="token comment" spellcheck="true">#可用strip来给可执行文件“减肥”，删除无用信息</span>
$ size shellcode               <span class="token comment" spellcheck="true">#“减肥”后效果“明显”，对于嵌入式系统应该有很大的作用</span>
   text    data     bss     dec     hex filename
    783     256       4    1043     413 shellcode
$ objdump -s -j .interp shellcode <span class="token comment" spellcheck="true">#这个主要工作是反编译，不过用来查看各个节区也很厉害</span>

shellcode:     <span class="token function">file</span> <span class="token function">format</span> elf32-i386

Contents of section .interp:
 8048114 2f6c6962 2f6c642d 6c696e75 782e736f  /lib/ld-linux.so
 8048124 2e3200                               .2.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补充：如果要删除可执行文件的 <code>Program Section Table</code>，可以用 <a href="http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html">A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux</a> 一文的作者写的 <a href="http://www.muppetlabs.com/~breadbox/software/elfkickers.html">elf kicker</a> 工具链中的 <code>sstrip</code> 工具。</p><h3 id="程序执行基本过程"><a href="#程序执行基本过程" class="headerlink" title="程序执行基本过程"></a>程序执行基本过程</h3><p>在命令行下，敲入程序的名字或者是全路径，然后按下回车就可以启动程序，这个具体是怎么工作的呢？</p><p>首先要再认识一下我们的命令行，命令行是内核和用户之间的接口，它本身也是一个程序。在 Linux 系统启动以后会为每个终端用户建立一个进程执行一个 Shell 解释程序，这个程序解释并执行用户输入的命令，以实现用户和内核之间的接口。这类解释程序有哪些呢？目前 Linux 下比较常用的有 <code>/bin/bash</code> 。那么该程序接收并执行命令的过程是怎么样的呢？</p><p>先简单描述一下这个过程：</p><ul><li>读取用户由键盘输入的命令行。</li><li>分析命令，以命令名作为文件名，并将其它参数改为系统调用 <code>execve</code> 内部处理所要求的形式。</li><li>终端进程调用 <code>fork</code> 建立一个子进程。</li><li>终端进程本身用系统调用 <code>wait4</code> 来等待子进程完成（如果是后台命令，则不等待）。当子进程运行时调用 <code>execve</code>，子进程根据文件名（即命令名）到目录中查找有关文件（这是命令解释程序构成的文件），将它调入内存，执行这个程序（解释这条命令）。</li><li>如果命令末尾有 <code>&amp;</code> 号（后台命令符号），则终端进程不用系统调用 <code>wait4</code> 等待，立即发提示符，让用户输入下一个命令，转 1）。如果命令末尾没有 <code>&amp;</code> 号，则终端进程要一直等待，当子进程（即运行命令的进程）完成处理后终止，向父进程（终端进程）报告，此时终端进程醒来，在做必要的判别等工作后，终端进程发提示符，让用户输入新的命令，重复上述处理过程。</li></ul><p>现在用 <code>strace</code> 来跟踪一下程序执行过程中用到的系统调用。</p><pre><code>$ strace -f -o strace.out test
$ cat strace.out | grep \(.*\) | sed -e &quot;s#[0-9]* \([a-zA-Z0-9_]*\)(.*).*#\1#g&quot;
execve
brk
access
open
fstat64
mmap2
close
open
read
fstat64
mmap2
mmap2
mmap2
mmap2
close
mmap2
set_thread_area
mprotect
munmap
brk
brk
open
fstat64
mmap2
close
close
close
exit_group</code></pre><p>相关的系统调用基本体现了上面的执行过程，需要注意的是，里头还涉及到内存映射（<code>mmap2</code>）等。</p><p>下面再罗嗦一些比较有意思的内容，参考《深入理解 Linux 内核》的程序的执行（P681）。</p><p>Linux 支持很多不同的可执行文件格式，这些不同的格式是如何解释的呢？平时我们在命令行下敲入一个命令就完了，也没有去管这些细节。实际上 Linux 下有一个 <code>struct linux_binfmt</code> 结构来管理不同的可执行文件类型，这个结构中有对应的可执行文件的处理函数。大概的过程如下：</p><ul><li>在用户态执行了 <code>execve</code> 后，引发 <code>int 0x80</code> 中断，进入内核态，执行内核态的相应函数 <code>do_sys_execve</code>，该函数又调用 <code>do_execve</code> 函数。 <code>do_execve</code> 函数读入可执行文件，检查权限，如果没问题，继续读入可执行文件需要的相关信息（<code>struct linux_binprm</code> 描述的）。</li><li>接着执行 <code>search_binary_handler</code>，根据可执行文件的类型（由上一步的最后确定），在 <code>linux_binfmt</code> 结构链表（<code>formats</code>，这个链表可以通过 <code>register_binfmt</code> 和 <code>unregister_binfmt</code> 注册和删除某些可执行文件的信息，因此注册新的可执行文件成为可能，后面再介绍）上查找，找到相应的结构，然后执行相应的 <code>load_binary</code> 函数开始加载可执行文件。在该链表的最后一个元素总是对解释脚本（<code>interpreted script</code>）的可执行文件格式进行描述的一个对象。这种格式只定义了 <code>load_binary</code> 方法，其相应的 <code>load_script</code> 函数检查这种可执行文件是否以两个 <code>#!</code> 字符开始，如果是，这个函数就以另一个可执行文件的路径名作为参数解释第一行的其余部分，并把脚本文件名作为参数传递以执行这个脚本（实际上脚本程序把自身的内容当作一个参数传递给了解释程序（如 <code>/bin/bash</code>），而这个解释程序通常在脚本文件的开头用 <code>#!</code> 标记，如果没有标记，那么默认解释程序为当前 <code>SHELL</code>）。</li><li>对于 <code>ELF</code> 类型文件，其处理函数是 <code>load_elf_binary</code>，它先读入 <code>ELF</code> 文件的头部，根据头部信息读入各种数据，再次扫描程序段描述表（<code>Program Header Table</code>），找到类型为 <code>PT_LOAD</code> 的段（即 <code>.text</code>，<code>.data</code>，<code>.bss</code> 等节区），将其映射（<code>elf_map</code>）到内存的固定地址上，如果没有动态连接器的描述段，把返回的入口地址设置成应用程序入口。完成这个功能的是 <code>start_thread</code>，它不启动一个线程，而只是用来修改了 <code>pt_regs</code> 中保存的 <code>PC</code> 等寄存器的值，使其指向加载的应用程序的入口。当内核操作结束，返回用户态时接着就执行应用程序本身了。</li><li>如果应用程序使用了动态连接库，内核除了加载指定的可执行文件外，还要把控制权交给动态连接器（<code>ld-linux.so</code>）以便处理动态连接的程序。内核搜寻段表（<code>Program Header Table</code>），找到标记为 <code>PT_INTERP</code> 段中所对应的动态连接器的名称，并使用 <code>load_elf_interp</code> 加载其映像，并把返回的入口地址设置成 <code>load_elf_interp</code> 的返回值，即动态链接器的入口。当 <code>execve</code> 系统调用退出时，动态连接器接着运行，它检查应用程序对共享链接库的依赖性，并在需要时对其加载，对程序的外部引用进行重定位。然后把控制权交给应用程序，从 <code>ELF</code> 文件头部中定义的程序进入点（用 <code>readelf -h</code> 可以出看到，<code>Entry point address</code> 即是）开始执行。（不过对于非 <code>LIB_BIND_NOW</code> 的共享库装载是在有外部引用请求时才执行的）。</li></ul><p>对于内核态的函数调用过程，没有办法通过 <code>strace</code>（它只能跟踪到系统调用层）来做的，因此要想跟踪内核中各个系统调用的执行细节，需要用其他工具。比如可以通过 Ftrace 来跟踪内核具体调用了哪些函数。当然，也可以通过 <code>ctags/cscope/LXR</code> 等工具分析内核的源代码。</p><p>Linux 允许自己注册我们自己定义的可执行格式，主要接口是 <code>/procy/sys/fs/binfmt_misc/register</code>，可以往里头写入特定格式的字符串来实现。该字符串格式如下： <code>:name:type:offset:string:mask:interpreter:</code></p><ul><li><code>name</code> 新格式的标示符</li><li><code>type</code> 识别类型（<code>M</code> 表示魔数，<code>E</code> 表示扩展）</li><li><code>offset</code> 魔数（<code>magic number</code>，请参考 <code>man magic</code> 和 <code>man file</code>）在文件中的启始偏移量</li><li><code>string</code> 以魔数或者以扩展名匹配的字节序列</li><li><code>mask</code> 用来屏蔽掉 <code>string</code> 的一些位</li><li><code>interpreter</code> 程序解释器的完整路径名</li></ul><h3 id="Linux-下程序的内存映像"><a href="#Linux-下程序的内存映像" class="headerlink" title="Linux 下程序的内存映像"></a>Linux 下程序的内存映像</h3><p>Linux 下是如何给进程分配内存（这里仅讨论虚拟内存的分配）的呢？可以从 <code>/proc/&lt;pid&gt;/maps</code> 文件中看到个大概。这里的 <code>pid</code> 是进程号。</p><p><code>/proc</code> 下有一个文件比较特殊，是 <code>self</code>，它链接到当前进程的进程号，例如：</p><pre><code>$ ls /proc/self -l
lrwxrwxrwx 1 root root 64 2000-01-10 18:26 /proc/self -&gt; 11291/
$ ls /proc/self -l
lrwxrwxrwx 1 root root 64 2000-01-10 18:26 /proc/self -&gt; 11292/</code></pre><p>看到没？每次都不一样，这样我们通过 <code>cat /proc/self/maps</code> 就可以看到 <code>cat</code> 程序执行时的内存映像了。</p><pre><code>$ cat -n /proc/self/maps
     1  08048000-0804c000 r-xp 00000000 03:01 273716     /bin/cat
     2  0804c000-0804d000 rw-p 00003000 03:01 273716     /bin/cat
     3  0804d000-0806e000 rw-p 0804d000 00:00 0          [heap]
     4  b7b90000-b7d90000 r--p 00000000 03:01 87528      /usr/lib/locale/locale-archive
     5  b7d90000-b7d91000 rw-p b7d90000 00:00 0
     6  b7d91000-b7ecd000 r-xp 00000000 03:01 466875     /lib/libc-2.5.so
     7  b7ecd000-b7ece000 r--p 0013c000 03:01 466875     /lib/libc-2.5.so
     8  b7ece000-b7ed0000 rw-p 0013d000 03:01 466875     /lib/libc-2.5.so
     9  b7ed0000-b7ed4000 rw-p b7ed0000 00:00 0
    10  b7eeb000-b7f06000 r-xp 00000000 03:01 402817     /lib/ld-2.5.so
    11  b7f06000-b7f08000 rw-p 0001b000 03:01 402817     /lib/ld-2.5.so
    12  bfbe3000-bfbf8000 rw-p bfbe3000 00:00 0          [stack]
    13  ffffe000-fffff000 r-xp 00000000 00:00 0          [vdso]</code></pre><p>编号是原文件里头没有的，为了说明方便，用 <code>-n</code> 参数加上去的。我们从中可以得到如下信息：</p><ul><li>第 1，2 行对应的内存区是我们的程序（包括指令，数据等）</li><li>第 3 到 12 行对应的内存区是堆栈段，里头也映像了程序引用的动态连接库</li><li>第 13 行是内核空间</li></ul><p>总结一下：</p><ul><li>前两部分是用户空间，可以从 <code>0x00000000</code> 到 <code>0xbfffffff</code> （在测试的 <code>2.6.21.5-smp</code> 上只到 <code>bfbf8000</code>），而内核空间从 <code>0xC0000000</code> 到 <code>0xffffffff</code>，分别是 <code>3G</code> 和 <code>1G</code>，所以对于每一个进程来说，共占用 <code>4G</code> 的虚拟内存空间</li><li>从程序本身占用的内存，到堆栈段（动态获取内存或者是函数运行过程中用来存储局部变量、参数的空间，前者是 <code>heap</code>，后者是 <code>stack</code>），再到内核空间，地址是从低到高的</li><li>栈顶并非 <code>0xC0000000</code> 下的一个固定数值</li></ul><p>结合相关资料，可以得到这么一个比较详细的进程内存映像表（以 <code>Linux 2.6.21.5-smp</code> 为例）：</p><table><thead><tr><th>地址</th><th>内核空间</th><th>描述</th></tr></thead><tbody><tr><td>0xC0000000</td><td></td><td></td></tr><tr><td></td><td>(program flie) 程序名</td><td>execve 的第一个参数</td></tr><tr><td></td><td>(environment) 环境变量</td><td>execve 的第三个参数，main 的第三个参数</td></tr><tr><td></td><td>(arguments) 参数</td><td>execve 的第二个参数，main 的形参</td></tr><tr><td></td><td>(stack) 栈</td><td>自动变量以及每次函数调用时所需保存的信息都</td></tr><tr><td></td><td></td><td>存放在此，包括函数返回地址、调用者的</td></tr><tr><td></td><td></td><td>环境信息等，函数的参数，局部变量都存放在此</td></tr><tr><td></td><td>(shared memory) 共享内存</td><td>共享内存的大概位置</td></tr><tr><td></td><td>…</td><td></td></tr><tr><td></td><td>…</td><td></td></tr><tr><td></td><td>(heap) 堆</td><td>主要在这里进行动态存储分配，比如 malloc，new 等。</td></tr><tr><td></td><td>…</td><td></td></tr><tr><td></td><td>.bss (uninitilized data)</td><td>没有初始化的数据（全局变量哦）</td></tr><tr><td></td><td>.data (initilized global data)</td><td>已经初始化的全局数据（全局变量）</td></tr><tr><td></td><td>.text (Executable Instructions)</td><td>通常是可执行指令</td></tr><tr><td>0x08048000</td><td></td><td></td></tr><tr><td>0x00000000</td><td></td><td>…</td></tr></tbody></table><p>光看没有任何概念，我们用 <code>gdb</code> 来看看刚才那个简单的程序。</p><pre class="line-numbers language-c"><code class="language-c">$ gcc <span class="token operator">-</span>g <span class="token operator">-</span>o shellcode shellcode<span class="token punctuation">.</span>c   #要用gdb调试，在编译时需要加<span class="token operator">-</span>g参数
$ gdb <span class="token operator">-</span>q <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">shellcode</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> set args arg1 arg2 arg3 arg4  #为了测试，设置几个参数
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l                             #浏览代码
<span class="token number">1</span> <span class="token comment" spellcheck="true">/* shellcode.c */</span>
<span class="token number">2</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">3</span> <span class="token punctuation">{</span>
<span class="token number">4</span>     __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">"jmp forward;"</span>
<span class="token number">5</span>     <span class="token string">"backward:"</span>
<span class="token number">6</span>        <span class="token string">"popl   %esi;"</span>
<span class="token number">7</span>        <span class="token string">"movl   $4, %eax;"</span>
<span class="token number">8</span>        <span class="token string">"movl   $2, %ebx;"</span>
<span class="token number">9</span>        <span class="token string">"movl   %esi, %ecx;"</span>
<span class="token number">10</span>               <span class="token string">"movl   $12, %edx;"</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token number">4</span>               #在汇编入口设置一个断点，让程序运行后停到这里
Breakpoint <span class="token number">1</span> at <span class="token number">0x8048332</span><span class="token punctuation">:</span> file shellcode<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">4</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> r                     #运行程序
Starting program<span class="token punctuation">:</span> <span class="token operator">/</span>mnt<span class="token operator">/</span>hda8<span class="token operator">/</span>Temp<span class="token operator">/</span>c<span class="token operator">/</span>program<span class="token operator">/</span>shellcode arg1 arg2 arg3 arg4

Breakpoint <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> at shellcode<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">4</span>
<span class="token number">4</span>     __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">"jmp forward;"</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print $esp            #打印当前堆栈指针值，用于查找整个栈的栈顶
$<span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">0xbffe1584</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>100s $esp<span class="token operator">+</span><span class="token number">4000</span>      #改变后面的<span class="token number">4000</span>，不断往更大的空间找
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>1s <span class="token number">0xbffe1fd9</span>       #在 <span class="token number">0xbffe1fd9</span> 找到了程序名，这里是该次运行时的栈顶
<span class="token number">0xbffe1fd9</span><span class="token punctuation">:</span>      <span class="token string">"/mnt/hda8/Temp/c/program/shellcode"</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>10s <span class="token number">0xbffe17b7</span>      #其他环境变量信息
<span class="token number">0xbffe17b7</span><span class="token punctuation">:</span>      <span class="token string">"CPLUS_INCLUDE_PATH=/usr/lib/qt/include"</span>
<span class="token number">0xbffe17de</span><span class="token punctuation">:</span>      <span class="token string">"MANPATH=/usr/local/man:/usr/man:/usr/X11R6/man:/usr/lib/java/man:/usr/share/texmf/man"</span>
<span class="token number">0xbffe1834</span><span class="token punctuation">:</span>      <span class="token string">"HOSTNAME=falcon.lzu.edu.cn"</span>
<span class="token number">0xbffe184f</span><span class="token punctuation">:</span>      <span class="token string">"TERM=xterm"</span>
<span class="token number">0xbffe185a</span><span class="token punctuation">:</span>      <span class="token string">"SSH_CLIENT=219.246.50.235 3099 22"</span>
<span class="token number">0xbffe187c</span><span class="token punctuation">:</span>      <span class="token string">"QTDIR=/usr/lib/qt"</span>
<span class="token number">0xbffe188e</span><span class="token punctuation">:</span>      <span class="token string">"SSH_TTY=/dev/pts/0"</span>
<span class="token number">0xbffe18a1</span><span class="token punctuation">:</span>      <span class="token string">"USER=falcon"</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>5s <span class="token number">0xbffe1780</span>    #一些传递给main函数的参数，包括文件名和其他参数
<span class="token number">0xbffe1780</span><span class="token punctuation">:</span>      <span class="token string">"/mnt/hda8/Temp/c/program/shellcode"</span>
<span class="token number">0xbffe17a3</span><span class="token punctuation">:</span>      <span class="token string">"arg1"</span>
<span class="token number">0xbffe17a8</span><span class="token punctuation">:</span>      <span class="token string">"arg2"</span>
<span class="token number">0xbffe17ad</span><span class="token punctuation">:</span>      <span class="token string">"arg3"</span>
<span class="token number">0xbffe17b2</span><span class="token punctuation">:</span>      <span class="token string">"arg4"</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print init  #打印init函数的地址，这个是<span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>crti<span class="token punctuation">.</span>o里头的函数，做一些初始化操作
$<span class="token number">2</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span>text variable<span class="token punctuation">,</span> no debug info<span class="token operator">></span><span class="token punctuation">}</span> <span class="token number">0xb7e73d00</span> <span class="token operator">&lt;</span>init<span class="token operator">></span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print fini   #也在<span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>crti<span class="token punctuation">.</span>o中定义，在程序结束时做一些处理工作
$<span class="token number">3</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span>text variable<span class="token punctuation">,</span> no debug info<span class="token operator">></span><span class="token punctuation">}</span> <span class="token number">0xb7f4a380</span> <span class="token operator">&lt;</span>fini<span class="token operator">></span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print _start #在<span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>crt1<span class="token punctuation">.</span>o，这个才是程序的入口，必须的，ld会检查这个
$<span class="token number">4</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span>text variable<span class="token punctuation">,</span> no debug info<span class="token operator">></span><span class="token punctuation">}</span> <span class="token number">0x8048280</span> <span class="token operator">&lt;</span>__libc_start_main@plt<span class="token operator">+</span><span class="token number">20</span><span class="token operator">></span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print main   #这里是我们的main函数
$<span class="token number">5</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token number">0x8048324</span> <span class="token operator">&lt;</span>main<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补充：在进程的内存映像中可能看到诸如 <code>init</code>，<code>fini</code>，<code>_start</code> 等函数（或者是入口），这些东西并不是我们自己写的啊？为什么会跑到我们的代码里头呢？实际上这些东西是链接的时候 <code>gcc</code> 默认给连接进去的，主要用来做一些进程的初始化和终止的动作。上面的操作对堆栈的操作比较少，下面我们用一个例子来演示栈在内存中的情况。</p><h3 id="栈在内存中的组织"><a href="#栈在内存中的组织" class="headerlink" title="栈在内存中的组织"></a>栈在内存中的组织</h3><p>这一节主要介绍一个函数被调用时，参数是如何传递的，局部变量是如何存储的，它们对应的栈的位置和变化情况，从而加深对栈的理解。在操作时发现和参考资料的结果不太一样（参考资料中没有 <code>edi</code> 和 <code>esi</code> 相关信息，再第二部分的一个小程序里头也没有），可能是 <code>gcc</code> 版本的问题或者是它对不同源代码的处理不同。我的版本是 <code>4.1.2</code> （可以通过 <code>gcc --version</code> 查看）。</p><p>先来一段简单的程序，这个程序除了做一个加法操作外，还复制了一些字符串。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span>     </span><span class="token comment" spellcheck="true">/* memset, memcpy */</span>

<span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 8</span>

<span class="token macro property">#<span class="token directive keyword">ifndef</span> STR_SRC</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>

    sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>

    <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum<span class="token punctuation">;</span>

    sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个代码没有什么问题，编译执行一下：</p><pre><code>$ make testshellcode
cc     testshellcode.c   -o testshellcode
$ ./testshellcode
sum = 6</code></pre><p>下面调试一下，看看在调用 <code>func</code> 后的栈的内容。</p><pre class="line-numbers language-c"><code class="language-c">$ gcc <span class="token operator">-</span>g <span class="token operator">-</span>o testshellcode testshellcode<span class="token punctuation">.</span>c  #为了调试，需要在编译时加<span class="token operator">-</span>g选项
$ gdb <span class="token operator">-</span>q <span class="token punctuation">.</span><span class="token operator">/</span>testshellcode   #启动gdb调试
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> set logging on    #如果要记录调试过程中的信息，可以把日志记录功能打开
Copying output to gdb<span class="token punctuation">.</span>txt<span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l main            #列出源代码
<span class="token number">20</span>
<span class="token number">21</span>              <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token number">22</span>      <span class="token punctuation">}</span>
<span class="token number">23</span>
<span class="token number">24</span>      <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">25</span>      <span class="token punctuation">{</span>
<span class="token number">26</span>              <span class="token keyword">int</span> sum<span class="token punctuation">;</span>
<span class="token number">27</span>
<span class="token number">28</span>              sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">29</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token number">28</span>   #在调用func函数之前让程序停一下，以便记录当时的<span class="token function">ebp</span><span class="token punctuation">(</span>基指针<span class="token punctuation">)</span>
Breakpoint <span class="token number">1</span> at <span class="token number">0x80483ac</span><span class="token punctuation">:</span> file testshellcode<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">28</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> func #设置断点在函数入口，以便逐步记录栈信息
Breakpoint <span class="token number">2</span> at <span class="token number">0x804835c</span><span class="token punctuation">:</span> file testshellcode<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">13</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disassemble main   #反编译main函数，以便记录调用func后的下一条指令地址
Dump of assembler code <span class="token keyword">for</span> function main<span class="token punctuation">:</span>
<span class="token number">0x0804839b</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">:</span>    lea    <span class="token function">0x4</span><span class="token punctuation">(</span><span class="token operator">%</span>esp<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>ecx
<span class="token number">0x0804839f</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">4</span><span class="token operator">></span><span class="token punctuation">:</span>    and    $<span class="token number">0xfffffff0</span><span class="token punctuation">,</span><span class="token operator">%</span>esp
<span class="token number">0x080483a2</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">7</span><span class="token operator">></span><span class="token punctuation">:</span>    pushl  <span class="token function">0xfffffffc</span><span class="token punctuation">(</span><span class="token operator">%</span>ecx<span class="token punctuation">)</span>
<span class="token number">0x080483a5</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">10</span><span class="token operator">></span><span class="token punctuation">:</span>   push   <span class="token operator">%</span>ebp
<span class="token number">0x080483a6</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">11</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    <span class="token operator">%</span>esp<span class="token punctuation">,</span><span class="token operator">%</span>ebp
<span class="token number">0x080483a8</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">13</span><span class="token operator">></span><span class="token punctuation">:</span>   push   <span class="token operator">%</span>ecx
<span class="token number">0x080483a9</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">14</span><span class="token operator">></span><span class="token punctuation">:</span>   sub    $<span class="token number">0x14</span><span class="token punctuation">,</span><span class="token operator">%</span>esp
<span class="token number">0x080483ac</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">17</span><span class="token operator">></span><span class="token punctuation">:</span>   push   $<span class="token number">0x3</span>
<span class="token number">0x080483ae</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">19</span><span class="token operator">></span><span class="token punctuation">:</span>   push   $<span class="token number">0x2</span>
<span class="token number">0x080483b0</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">21</span><span class="token operator">></span><span class="token punctuation">:</span>   push   $<span class="token number">0x1</span>
<span class="token number">0x080483b2</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">23</span><span class="token operator">></span><span class="token punctuation">:</span>   call   <span class="token number">0x8048354</span> <span class="token operator">&lt;</span>func<span class="token operator">></span>
<span class="token number">0x080483b7</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">28</span><span class="token operator">></span><span class="token punctuation">:</span>   add    $<span class="token number">0xc</span><span class="token punctuation">,</span><span class="token operator">%</span>esp
<span class="token number">0x080483ba</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">31</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token function">0xfffffff8</span><span class="token punctuation">(</span><span class="token operator">%</span>ebp<span class="token punctuation">)</span>
<span class="token number">0x080483bd</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">34</span><span class="token operator">></span><span class="token punctuation">:</span>   sub    $<span class="token number">0x8</span><span class="token punctuation">,</span><span class="token operator">%</span>esp
<span class="token number">0x080483c0</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">37</span><span class="token operator">></span><span class="token punctuation">:</span>   pushl  <span class="token function">0xfffffff8</span><span class="token punctuation">(</span><span class="token operator">%</span>ebp<span class="token punctuation">)</span>
<span class="token number">0x080483c3</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">40</span><span class="token operator">></span><span class="token punctuation">:</span>   push   $<span class="token number">0x80484c0</span>
<span class="token number">0x080483c8</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">45</span><span class="token operator">></span><span class="token punctuation">:</span>   call   <span class="token number">0x80482a0</span> <span class="token operator">&lt;</span>printf@plt<span class="token operator">></span>
<span class="token number">0x080483cd</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">50</span><span class="token operator">></span><span class="token punctuation">:</span>   add    $<span class="token number">0x10</span><span class="token punctuation">,</span><span class="token operator">%</span>esp
<span class="token number">0x080483d0</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">53</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0x0</span><span class="token punctuation">,</span><span class="token operator">%</span>eax
<span class="token number">0x080483d5</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">58</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    <span class="token function">0xfffffffc</span><span class="token punctuation">(</span><span class="token operator">%</span>ebp<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>ecx
<span class="token number">0x080483d8</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">61</span><span class="token operator">></span><span class="token punctuation">:</span>   leave
<span class="token number">0x080483d9</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">62</span><span class="token operator">></span><span class="token punctuation">:</span>   lea    <span class="token function">0xfffffffc</span><span class="token punctuation">(</span><span class="token operator">%</span>ecx<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>esp
<span class="token number">0x080483dc</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">65</span><span class="token operator">></span><span class="token punctuation">:</span>   ret
End of assembler dump<span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> r        #运行程序
Starting program<span class="token punctuation">:</span> <span class="token operator">/</span>mnt<span class="token operator">/</span>hda8<span class="token operator">/</span>Temp<span class="token operator">/</span>c<span class="token operator">/</span>program<span class="token operator">/</span>testshellcode

Breakpoint <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> at testshellcode<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">28</span>
<span class="token number">28</span>              sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print $ebp  #打印调用func函数之前的基地址，即Previous frame pointer。
$<span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">0xbf84fdd8</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n           #执行call指令并跳转到func函数的入口

Breakpoint <span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">func</span> <span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span> at testshellcode<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">13</span>
<span class="token number">13</span>              <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n
<span class="token number">16</span>              sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>11x $esp  #打印当前栈的内容，可以看出，地址从低到高，注意标记有蓝色和红色的值
                 #它们分别是前一个栈基地址<span class="token punctuation">(</span>ebp<span class="token punctuation">)</span>和call调用之后的下一条指令的指针<span class="token punctuation">(</span>eip<span class="token punctuation">)</span>
<span class="token number">0xbf84fd94</span><span class="token punctuation">:</span>     <span class="token number">0x00000000</span>      <span class="token number">0x00000000</span>      <span class="token number">0x080482e0</span>      <span class="token number">0x00000000</span>
<span class="token number">0xbf84fda4</span><span class="token punctuation">:</span>     <span class="token number">0xb7f2bce0</span>      <span class="token number">0x00000000</span>      <span class="token number">0xbf84fdd8</span>      <span class="token number">0x080483b7</span>
<span class="token number">0xbf84fdb4</span><span class="token punctuation">:</span>     <span class="token number">0x00000001</span>      <span class="token number">0x00000002</span>      <span class="token function">0x00000003</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n       #执行sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c，后，比较栈内容第一行，第<span class="token number">4</span>列，由<span class="token number">0</span>变为<span class="token number">6</span>
<span class="token number">18</span>              <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>11x $esp
<span class="token number">0xbf84fd94</span><span class="token punctuation">:</span>     <span class="token number">0x00000000</span>      <span class="token number">0x00000000</span>      <span class="token number">0x080482e0</span>      <span class="token number">0x00000006</span>
<span class="token number">0xbf84fda4</span><span class="token punctuation">:</span>     <span class="token number">0xb7f2bce0</span>      <span class="token number">0x00000000</span>      <span class="token number">0xbf84fdd8</span>      <span class="token number">0x080483b7</span>
<span class="token number">0xbf84fdb4</span><span class="token punctuation">:</span>     <span class="token number">0x00000001</span>      <span class="token number">0x00000002</span>      <span class="token function">0x00000003</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n
<span class="token number">19</span>              <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>11x $esp #缓冲区初始化以后变成了<span class="token number">0</span>
<span class="token number">0xbf84fd94</span><span class="token punctuation">:</span>     <span class="token number">0x00000000</span>      <span class="token number">0x00000000</span>      <span class="token number">0x00000000</span>      <span class="token number">0x00000006</span>
<span class="token number">0xbf84fda4</span><span class="token punctuation">:</span>     <span class="token number">0xb7f2bce0</span>      <span class="token number">0x00000000</span>      <span class="token number">0xbf84fdd8</span>      <span class="token number">0x080483b7</span>
<span class="token number">0xbf84fdb4</span><span class="token punctuation">:</span>     <span class="token number">0x00000001</span>      <span class="token number">0x00000002</span>      <span class="token function">0x00000003</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n
<span class="token number">21</span>              <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>11x $esp #进行copy以后，这两列的值变了，大小刚好是<span class="token number">7</span>个字节，最后一个字节为<span class="token string">'\0'</span>
<span class="token number">0xbf84fd94</span><span class="token punctuation">:</span>     <span class="token number">0x00000000</span>      <span class="token number">0x41414141</span>      <span class="token number">0x00414141</span>      <span class="token number">0x00000006</span>
<span class="token number">0xbf84fda4</span><span class="token punctuation">:</span>     <span class="token number">0xb7f2bce0</span>      <span class="token number">0x00000000</span>      <span class="token number">0xbf84fdd8</span>      <span class="token number">0x080483b7</span>
<span class="token number">0xbf84fdb4</span><span class="token punctuation">:</span>     <span class="token number">0x00000001</span>      <span class="token number">0x00000002</span>      <span class="token function">0x00000003</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> c
Continuing<span class="token punctuation">.</span>
sum <span class="token operator">=</span> <span class="token number">6</span>

Program exited normally<span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的操作过程，我们可以得出大概的栈分布(<code>func</code> 函数结束之前)如下：</p><table><thead><tr><th>地址</th><th>值(hex)</th><th>符号或者寄存器</th><th>注释</th></tr></thead><tbody><tr><td>低地址</td><td></td><td></td><td>栈顶方向</td></tr><tr><td>0xbf84fd98</td><td>0x41414141</td><td>buf[0]</td><td>可以看出little endian(小端，重要的数据在前面)</td></tr><tr><td>0xbf84fd9c</td><td>0x00414141</td><td>buf[1]</td><td></td></tr><tr><td>0xbf84fda0</td><td>0x00000006</td><td>sum</td><td>可见这上面都是func函数里头的局部变量</td></tr><tr><td>0xbf84fda4</td><td>0xb7f2bce0</td><td>esi</td><td>源索引指针，可以通过产生中间代码查看，貌似没什么作用</td></tr><tr><td>0xbf84fda8</td><td>0x00000000</td><td>edi</td><td>目的索引指针</td></tr><tr><td>0xbf84fdac</td><td>0xbf84fdd8</td><td>ebp</td><td>调用func之前的栈的基地址，以便调用函数结束之后恢复</td></tr><tr><td>0xbf84fdb0</td><td>0x080483b7</td><td>eip</td><td>调用func之前的指令指针，以便调用函数结束之后继续执行</td></tr><tr><td>0xbf84fdb4</td><td>0x00000001</td><td>a</td><td>第一个参数</td></tr><tr><td>0xbf84fdb8</td><td>0x00000002</td><td>b</td><td>第二个参数</td></tr><tr><td>0xbf84fdbc</td><td>0x00000003</td><td>c</td><td>第三个参数，可见参数是从最后一个开始压栈的</td></tr><tr><td>高地址</td><td></td><td></td><td>栈底方向</td></tr></tbody></table><p>先说明一下 <code>edi</code> 和 <code>esi</code> 的由来（在上面的调试过程中我们并没有看到），是通过产生中间汇编代码分析得出的。</p><pre><code>$ gcc -S testshellcode.c</code></pre><p>在产生的 <code>testShellcode.s</code> 代码里头的 <code>func</code> 部分看到 <code>push ebp</code> 之后就 <code>push</code> 了 <code>edi</code> 和 <code>esi</code> 。但是搜索了一下代码，发现就这个函数里头引用了这两个寄存器，所以保存它们没什么用，删除以后编译产生目标代码后证明是没用的。</p><pre class="line-numbers language-assembly"><code class="language-assembly">$ cat testshellcode.s
...
func:
        pushl   %ebp
        movl    %esp, %ebp
        pushl   %edi
        pushl   %esi
...
        popl    %esi
        popl    %edi
        popl    %ebp
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面就不管这两部分（<code>edi</code> 和 <code>esi</code>）了，主要来分析和函数相关的这几部分在栈内的分布：</p><ul><li>函数局部变量，在靠近栈顶一端</li><li>调用函数之前的栈的基地址（<code>ebp</code>，<code>Previous Frame Pointer</code>），在中间靠近栈顶方向</li><li>调用函数指令的下一条指令地址 `` （<code>eip</code>），在中间靠近栈底的方向</li><li>函数参数，在靠近栈底的一端，最后一个参数最先入栈</li></ul><p>到这里，函数调用时的相关内容在栈内的分布就比较清楚了，在具体分析缓冲区溢出问题之前，我们再来看一个和函数关系很大的问题，即函数返回值的存储问题：函数的返回值存放在寄存器 <code>eax</code> 中。</p><p>先来看这段代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**
 * test_return.c -- the return of a function is stored in register eax
 */</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token function">__asm__</span> <span class="token punctuation">(</span><span class="token string">"movl $1, %eax"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"the return of func: %d\n"</span><span class="token punctuation">,</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译运行后，可以看到返回值为 1，刚好是我们在 <code>func</code> 函数中 <code>mov</code> 到 <code>eax</code> 中的“立即数” 1，因此很容易理解返回值存储在 <code>eax</code> 中的事实，如果还有疑虑，可以再看看汇编代码。在函数返回之后，<code>eax</code> 中的值当作了 <code>printf</code> 的参数压入了栈中，而在源代码中我们正是把 <code>func</code> 的结果作为 <code>printf</code> 的第二个参数的。</p><pre class="line-numbers language-c"><code class="language-c">$ make test_return
cc     test_return<span class="token punctuation">.</span>c   <span class="token operator">-</span>o test_return
$ <span class="token punctuation">.</span><span class="token operator">/</span>test_return
the <span class="token keyword">return</span> of func<span class="token punctuation">:</span> <span class="token number">1</span>
$ gcc <span class="token operator">-</span>S test_return<span class="token punctuation">.</span>c
$ cat test_return<span class="token punctuation">.</span>s
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        call    func
        subl    $<span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">%</span>esp
        pushl   <span class="token operator">%</span>eax      #printf的第二个参数，把func的返回值压入了栈底
        pushl   $<span class="token punctuation">.</span>LC0     #printf的第一个参数the <span class="token keyword">return</span> of func<span class="token punctuation">:</span> <span class="token operator">%</span>d\n
        call    printf
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于系统调用，返回值也存储在 <code>eax</code> 寄存器中。</p><h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><h3 id="实例分析：字符串复制"><a href="#实例分析：字符串复制" class="headerlink" title="实例分析：字符串复制"></a>实例分析：字符串复制</h3><p>先来看一段简短的代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span>     </span><span class="token comment" spellcheck="true">/* memset, memcpy */</span>

<span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 8</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR1</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA\0\1\0\0\0"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token macro property">#<span class="token directive keyword">ifndef</span> STR_SRC</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>

        sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>

        <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum<span class="token punctuation">;</span>

        sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译一下看看结果：</p><pre><code>$ gcc -DSTR1 -o testshellcode testshellcode.c  #通过-D定义宏STR1，从而采用第一个STR_SRC的值
$ ./testshellcode
sum = 1</code></pre><p>不知道你有没有发现异常呢？上面用红色标记的地方，本来 <code>sum</code> 为 <code>1+2+3</code> 即 6，但是实际返回的竟然是 1 。到底是什么原因呢？大家应该有所了解了，因为我们在复制字符串 <code>AAAAAAA\\0\\1\\0\\0\\0</code> 到 <code>buf</code> 的时候超出 <code>buf</code> 本来的大小。 <code>buf</code> 本来的大小是 <code>BUF_SIZE</code>，8 个字节，而我们要复制的内容是 12 个字节，所以超出了四个字节。根据第一小节的分析，我们用栈的变化情况来表示一下这个复制过程（即执行 <code>memcpy</code> 的过程）。</p><pre><code>memcpy(buffer, STR_SRC, sizeof(STR_SRC)-1);

（低地址）
复制之前     ====&gt; 复制之后
0x00000000       0x41414141      #char buf[8]
0x00000000       0x00414141
0x00000006       0x00000001      #int sum
（高地址）</code></pre><p>下面通过 <code>gdb</code> 调试来确认一下(只摘录了一些片断)。</p><pre><code>$ gcc -DSTR1 -g -o testshellcode testshellcode.c
$ gdb -q ./testshellcode
...
(gdb) l
21
22              memset(buffer, &#39;\0&#39;, BUF_SIZE);
23              memcpy(buffer, STR_SRC, sizeof(STR_SRC)-1);
24
25              return sum;
...
(gdb) break 23
Breakpoint 1 at 0x804837f: file testshellcode.c, line 23.
(gdb) break 25
Breakpoint 2 at 0x8048393: file testshellcode.c, line 25.
(gdb) r
Starting program: /mnt/hda8/Temp/c/program/testshellcode

Breakpoint 1, func (a=1, b=2, c=3) at testshellcode.c:23
23              memcpy(buffer, STR_SRC, sizeof(STR_SRC)-1);
(gdb) x/3x $esp+4
0xbfec6bd8:     0x00000000      0x00000000      0x00000006
(gdb) n

Breakpoint 2, func (a=1, b=2, c=3) at testshellcode.c:25
25              return sum;
(gdb) x/3x $esp+4
0xbfec6bd8:     0x41414141      0x00414141      0x00000001</code></pre><p>可以看出，因为 C 语言没有对数组的边界进行限制。我们可以往数组中存入预定义长度的字符串，从而导致缓冲区溢出。</p><h3 id="缓冲区溢出后果"><a href="#缓冲区溢出后果" class="headerlink" title="缓冲区溢出后果"></a>缓冲区溢出后果</h3><p>溢出之后的问题是导致覆盖栈的其他内容，从而可能改变程序原来的行为。</p><p>如果这类问题被“黑客”利用那将产生非常可怕的后果，小则让非法用户获取了系统权限，把你的服务器当成“僵尸”，用来对其他机器进行攻击，严重的则可能被人删除数据（所以备份很重要）。</p><h3 id="缓冲区溢出应对策略"><a href="#缓冲区溢出应对策略" class="headerlink" title="缓冲区溢出应对策略"></a>缓冲区溢出应对策略</h3><p>那这个怎么办呢？貌似<a href="http://www.ibm.com/developerworks/cn/linux/l-overflow/index.html">Linux下缓冲区溢出攻击的原理及对策</a>提到有一个 <code>libsafe</code> 库，可以至少用来检测程序中出现的类似超出数组边界的问题。对于上面那个具体问题，为了保护 <code>sum</code> 不被修改，有一个小技巧，可以让求和操作在字符串复制操作之后来做，以便求和操作把溢出的部分给重写。这个呆伙在下面一块看效果吧。继续看看缓冲区的溢出吧。</p><p>先来看看这个代码，还是 <code>testShellcode.c</code> 的改进。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> </span><span class="token comment" spellcheck="true">/* memset, memcpy */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 8</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR1</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR2</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBB"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR3</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCC"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR4</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCCDDDD"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token macro property">#<span class="token directive keyword">ifndef</span> STR_SRC</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>

        <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//把求和操作放在复制操作之后可以在一定情况下“保护”求和结果</span>

        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum<span class="token punctuation">;</span>

        sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看运行情况：</p><pre><code>$ gcc -D STR2 -o testshellcode testshellcode.c   #再多复制8个字节，结果和STR1时一样
                        #原因是edi,esi这两个没什么用的，覆盖了也没关系
$ ./testshellcode       #看到没？这种情况下，让整数操作在字符串复制之后做可以“保护‘整数结果
sum = 6
$ gcc -D STR3 -o testshellcode testshellcode.c  #再多复制4个字节，现在就会把ebp给覆盖
                                               #了，这样当main函数再要用ebp访问数据
                                              #时就会出现访问非法内存而导致段错误。
$ ./testshellcode
Segmentation fault</code></pre><p>如果感兴趣，自己还可以用gdb类似之前一样来查看复制字符串以后栈的变化情况。</p><h3 id="如何保护-ebp-不被修改"><a href="#如何保护-ebp-不被修改" class="headerlink" title="如何保护 ebp 不被修改"></a>如何保护 ebp 不被修改</h3><p>下面来做一个比较有趣的事情：如何设法保护我们的 <code>ebp</code> 不被修改。</p><p>首先要明确 <code>ebp</code> 这个寄存器的作用和“行为”，它是栈基地址，并且发现在调用任何一个函数时，这个 <code>ebp</code> 总是在第一条指令被压入栈中，并在最后一条指令（<code>ret</code>）之前被弹出。类似这样：</p><pre><code>func:                        #函数
       pushl %ebp            #第一条指令
       ...
       popl %ebp             #倒数第二条指令
       ret</code></pre><p>还记得之前（第一部分）提到的函数的返回值是存储在 <code>eax</code> 寄存器中的么？如果我们在一个函数中仅仅做放这两条指令：</p><pre><code>popl %eax
pushl %eax</code></pre><p>那不就刚好有：</p><pre><code>func:                        #函数
       pushl %ebp            #第一条指令
       popl %eax             #把刚压入栈中的ebp弹出存放到eax中
       pushl %eax            #又把ebp压入栈
       popl %ebp             #倒数第二条指令
       ret</code></pre><p>这样我们没有改变栈的状态，却获得了 <code>ebp</code> 的值，如果在调用任何一个函数之前，获取这个 <code>ebp</code>，并且在任何一条字符串复制语句（可能导致缓冲区溢出的语句）之后重新设置一下 <code>ebp</code> 的值，那么就可以保护 <code>ebp</code> 啦。具体怎么实现呢？看这个代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> </span><span class="token comment" spellcheck="true">/* memset, memcpy */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 8</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR1</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR2</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBB"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR3</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCC"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR4</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCCDDDD"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token macro property">#<span class="token directive keyword">ifndef</span> STR_SRC</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">get_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token function">__asm__</span> <span class="token punctuation">(</span><span class="token string">"popl %eax;"</span>
                                <span class="token string">"pushl %eax;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ebp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>

        sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
        <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>buffer<span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">=</span> ebp<span class="token punctuation">;</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum<span class="token punctuation">,</span> ebp<span class="token punctuation">;</span>

        ebp <span class="token operator">=</span> <span class="token function">get_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> ebp<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码和之前的代码的不同有：</p><ul><li>给 <code>func</code> 函数增加了一个参数 <code>ebp</code>，（其实可以用全局变量替代的）</li><li>利用了刚介绍的原理定义了一个函数 <code>get_ebp</code> 以便获取老的 <code>ebp</code></li><li>在 <code>main</code> 函数中调用 <code>func</code> 之前调用了 <code>get_ebp</code>，并把它作为 <code>func</code> 的最后一个参数</li><li>在 <code>func</code> 函数中调用 <code>memcpy</code> 函数（可能发生缓冲区溢出的地方）之后添加了一条恢复设置 <code>ebp</code> 的语句，这条语句先把 <code>buffer+20</code> 这个地址（存放 <code>ebp</code> 的地址，你可以类似第一部分提到的用 <code>gdb</code> 来查看）强制转换为指向一个 <code>unsigned long</code> 型的整数（4 个字节），然后把它指向的内容修改为老的 <code>ebp</code> 。</li></ul><p>看看效果：</p><pre><code>$ gcc -D STR3 -o testshellcode testshellcode.c
$ ./testshellcode         #现在没有段错误了吧，因为ebp得到了“保护”
sum = 6</code></pre><h3 id="如何保护-eip-不被修改？"><a href="#如何保护-eip-不被修改？" class="headerlink" title="如何保护 eip 不被修改？"></a>如何保护 eip 不被修改？</h3><p>如果我们复制更多的字节过去了，比如再多复制四个字节进去，那么 <code>eip</code> 就被覆盖了。</p><pre><code>$ gcc -D STR4 -o testshellcode testshellcode.c
$ ./testshellcode
Segmentation fault</code></pre><p>同样会出现段错误，因为下一条指令的位置都被改写了，<code>func</code> 返回后都不知道要访问哪个”非法“地址啦。呵呵，如果是一个合法地址呢？</p><p>如果在缓冲区溢出时，<code>eip</code> 被覆盖了，并且被修改为了一条合法地址，那么问题就非常”有趣“了。如果这个地址刚好是调用func的那个地址，那么整个程序就成了死循环，如果这个地址指向的位置刚好有一段关机代码，那么系统正在运行的所有服务都将被关掉，如果那个地方是一段更恶意的代码，那就？你可以尽情想像哦。如果是黑客故意利用这个，那么那些代码貌似就叫做<a href="http://janxin.bokee.com/4067220.html">shellcode</a>了。</p><p>有没有保护 <code>eip</code> 的办法呢？呵呵，应该是有的吧。不知道 <code>gas</code> 有没有类似 <code>masm</code> 汇编器中 <code>offset</code> 的伪操作指令（查找了一下，貌似没有），如果有的话在函数调用之前设置一个标号，在后面某个位置获取，再加上一个可能的偏移（包括 <code>call</code> 指令的长度和一些 <code>push</code> 指令等），应该可以算出来，不过貌似比较麻烦（或许你灵感大作，找到好办法了！），这里直接通过 <code>gdb</code> 反汇编求得它相对 <code>main</code> 的偏移算出来得了。求出来以后用它来”保护“栈中的值。</p><p>看看这个代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> </span><span class="token comment" spellcheck="true">/* memset, memcpy */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 8</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR1</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR2</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBB"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR3</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCC"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR4</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCCDDDD"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token macro property">#<span class="token directive keyword">ifndef</span> STR_SRC</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">define</span> OFFSET  40</span>

<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">get_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token function">__asm__</span> <span class="token punctuation">(</span><span class="token string">"popl %eax;"</span>
                                <span class="token string">"pushl %eax;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ebp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>

        <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>

        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>buffer<span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">=</span> ebp<span class="token punctuation">;</span>
        <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>buffer<span class="token operator">+</span><span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>main<span class="token operator">+</span>OFFSET<span class="token punctuation">;</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum<span class="token punctuation">,</span> ebp<span class="token punctuation">;</span>

        ebp <span class="token operator">=</span> <span class="token function">get_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> ebp<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看效果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ gcc -D STR4 -o testshellcode testshellcode.c
$ ./testshellcode
<span class="token function">sum</span> <span class="token operator">=</span> 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样，<code>EIP</code> 也得到了“保护”（这个方法很糟糕）。</p><p>类似地，如果再多复制一些内容呢？那么栈后面的内容都将被覆盖，即传递给 <code>func</code> 函数的参数都将被覆盖，因此上面的方法，包括所谓的对 <code>sum</code> 和 <code>ebp</code> 等值的保护都没有任何意义了。在这里，之所以提出类似这样的保护方法，实际上只是为了讨论一些有趣的细节并加深对缓冲区溢出这一问题的理解。</p><h3 id="缓冲区溢出检测"><a href="#缓冲区溢出检测" class="headerlink" title="缓冲区溢出检测"></a>缓冲区溢出检测</h3><p>要确实解决这类问题，从主观上讲，还得程序员来做相关的工作，比如限制将要复制的字符串的长度，保证它不超过当初申请的缓冲区的大小。</p><p>例如，在上面的代码中，我们在 <code>memcpy</code> 之前，可以加入一个判断，并且可以对缓冲区溢出进行很好的检查。如果能够设计一些比较好的测试实例把这些判断覆盖到，那么相关的问题就可以得到比较不错的检查了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>      </span><span class="token comment" spellcheck="true">/* printf */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> </span><span class="token comment" spellcheck="true">/* memset, memcpy */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span>     </span><span class="token comment" spellcheck="true">/* exit */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 8</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> STR4</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAAa\1\0\0\0BBBBBBBBCCCCDDDD"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token macro property">#<span class="token directive keyword">ifndef</span> STR_SRC</span>
<span class="token macro property"># <span class="token directive keyword">define</span> STR_SRC "AAAAAAA"</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>

        <span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">,</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">></span> BUF_SIZE <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"buffer overflow!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> STR_SRC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>STR_SRC<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>

        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum<span class="token punctuation">;</span>

        sum <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在的效果如下：</p><pre><code>$ gcc -DSTR4 -g -o testshellcode testshellcode.c
$ ./testshellcode      #如果存在溢出，那么就会得到阻止并退出，从而阻止可能的破坏
buffer overflow!
$ gcc -g -o testshellcode testshellcode.c
$ ./testshellcode
sum = 6</code></pre><p>当然，如果能够在 C 标准里头加入对数组操作的限制可能会更好，或者在编译器中扩展对可能引起缓冲区溢出的语法检查。</p><h2 id="缓冲区注入实例"><a href="#缓冲区注入实例" class="headerlink" title="缓冲区注入实例"></a>缓冲区注入实例</h2><p>最后给出一个利用上述缓冲区溢出来进行缓冲区注入的例子。也就是通过往某个缓冲区注入一些代码，并把eip修改为这些代码的入口从而达到破坏目标程序行为的目的。</p><p>这个例子来自<a href="http://www.ibm.com/developerworks/cn/linux/l-overflow/index.html">Linux 下缓冲区溢出攻击的原理及对策</a>，这里主要利用上面介绍的知识对它进行了比较详细的分析。</p><h3 id="准备：把-C-语言函数转换为字符串序列"><a href="#准备：把-C-语言函数转换为字符串序列" class="headerlink" title="准备：把 C 语言函数转换为字符串序列"></a>准备：把 C 语言函数转换为字符串序列</h3><p>首先回到第一部分，看看那个 <code>Shellcode.c</code> 程序。我们想获取它的汇编代码，并以十六进制字节的形式输出，以便把这些指令当字符串存放起来，从而作为缓冲区注入时的输入字符串。下面通过 <code>gdb</code> 获取这些内容。</p><pre class="line-numbers language-c"><code class="language-c">$ gcc <span class="token operator">-</span>g <span class="token operator">-</span>o shellcode shellcode<span class="token punctuation">.</span>c
$ gdb <span class="token operator">-</span>q <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">shellcode</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disassemble main
Dump of assembler code <span class="token keyword">for</span> function main<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">0x08048331</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">13</span><span class="token operator">></span><span class="token punctuation">:</span>   push   <span class="token operator">%</span>ecx
<span class="token number">0x08048332</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">14</span><span class="token operator">></span><span class="token punctuation">:</span>   jmp    <span class="token number">0x8048354</span> <span class="token operator">&lt;</span>forward<span class="token operator">></span>
<span class="token number">0x08048334</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">16</span><span class="token operator">></span><span class="token punctuation">:</span>   pop    <span class="token operator">%</span>esi
<span class="token number">0x08048335</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">17</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0x4</span><span class="token punctuation">,</span><span class="token operator">%</span>eax
<span class="token number">0x0804833a</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">22</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0x2</span><span class="token punctuation">,</span><span class="token operator">%</span>ebx
<span class="token number">0x0804833f</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">27</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    <span class="token operator">%</span>esi<span class="token punctuation">,</span><span class="token operator">%</span>ecx
<span class="token number">0x08048341</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">29</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0xc</span><span class="token punctuation">,</span><span class="token operator">%</span>edx
<span class="token number">0x08048346</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">34</span><span class="token operator">></span><span class="token punctuation">:</span>   <span class="token keyword">int</span>    $<span class="token number">0x80</span>
<span class="token number">0x08048348</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">36</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0x1</span><span class="token punctuation">,</span><span class="token operator">%</span>eax
<span class="token number">0x0804834d</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">41</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0x0</span><span class="token punctuation">,</span><span class="token operator">%</span>ebx
<span class="token number">0x08048352</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">46</span><span class="token operator">></span><span class="token punctuation">:</span>   <span class="token keyword">int</span>    $<span class="token number">0x80</span>
<span class="token number">0x08048354</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">:</span> call   <span class="token number">0x8048334</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">16</span><span class="token operator">></span>
<span class="token number">0x08048359</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">5</span><span class="token operator">></span><span class="token punctuation">:</span> dec    <span class="token operator">%</span>eax
<span class="token number">0x0804835a</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">6</span><span class="token operator">></span><span class="token punctuation">:</span> gs
<span class="token number">0x0804835b</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">7</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token function">insb</span>   <span class="token punctuation">(</span><span class="token operator">%</span>dx<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>es<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">%</span>edi<span class="token punctuation">)</span>
<span class="token number">0x0804835c</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">8</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token function">insb</span>   <span class="token punctuation">(</span><span class="token operator">%</span>dx<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>es<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">%</span>edi<span class="token punctuation">)</span>
<span class="token number">0x0804835d</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">9</span><span class="token operator">></span><span class="token punctuation">:</span> outsl  <span class="token operator">%</span>ds<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">%</span>esi<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">%</span>dx<span class="token punctuation">)</span>
<span class="token number">0x0804835e</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">10</span><span class="token operator">></span><span class="token punctuation">:</span>        and    <span class="token operator">%</span>dl<span class="token punctuation">,</span><span class="token function">0x6f</span><span class="token punctuation">(</span><span class="token operator">%</span>edi<span class="token punctuation">)</span>
<span class="token number">0x08048361</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">13</span><span class="token operator">></span><span class="token punctuation">:</span>        jb     <span class="token number">0x80483cf</span> <span class="token operator">&lt;</span>__libc_csu_init<span class="token operator">+</span><span class="token number">79</span><span class="token operator">></span>
<span class="token number">0x08048363</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">15</span><span class="token operator">></span><span class="token punctuation">:</span>        or     <span class="token operator">%</span>fs<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token operator">%</span>eax<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>al
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
End of assembler dump<span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> set logging on   #开启日志功能，记录操作结果
Copying output to gdb<span class="token punctuation">.</span>txt<span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>52bx main<span class="token operator">+</span><span class="token number">14</span>  #以十六进制单字节（字符）方式打印出shellcode的核心代码
<span class="token number">0x8048332</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">14</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token number">0xeb</span>    <span class="token number">0x20</span>    <span class="token number">0x5e</span>    <span class="token number">0xb8</span>    <span class="token number">0x04</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>   <span class="token number">0x00</span>
<span class="token number">0x804833a</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">22</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token number">0xbb</span>    <span class="token number">0x02</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0x89</span>    <span class="token number">0xf1</span>   <span class="token number">0xba</span>
<span class="token number">0x8048342</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">30</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token number">0x0c</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0xcd</span>    <span class="token number">0x80</span>    <span class="token number">0xb8</span>   <span class="token number">0x01</span>
<span class="token number">0x804834a</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">38</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0xbb</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>    <span class="token number">0x00</span>   <span class="token number">0x00</span>
<span class="token number">0x8048352</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">46</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token number">0xcd</span>    <span class="token number">0x80</span>    <span class="token number">0xe8</span>    <span class="token number">0xdb</span>    <span class="token number">0xff</span>    <span class="token number">0xff</span>    <span class="token number">0xff</span>   <span class="token number">0x48</span>
<span class="token number">0x804835a</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">6</span><span class="token operator">></span><span class="token punctuation">:</span>  <span class="token number">0x65</span>    <span class="token number">0x6c</span>    <span class="token number">0x6c</span>    <span class="token number">0x6f</span>    <span class="token number">0x20</span>    <span class="token number">0x57</span>    <span class="token number">0x6f</span>   <span class="token number">0x72</span>
<span class="token number">0x8048362</span> <span class="token operator">&lt;</span>forward<span class="token operator">+</span><span class="token number">14</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token number">0x6c</span>    <span class="token number">0x64</span>    <span class="token number">0x0a</span>    <span class="token function">0x00</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> quit
$ cat gdb<span class="token punctuation">.</span>txt <span class="token operator">|</span> sed <span class="token operator">-</span>e <span class="token string">"s/^.*://g;s/\t/\\\/g;s/^/\"/g;s/\$/\"/g"</span>  #把日志里头的内容处理一下，得到这样一个字符串
<span class="token string">"\0xeb\0x20\0x5e\0xb8\0x04\0x00\0x00\0x00"</span>
<span class="token string">"\0xbb\0x02\0x00\0x00\0x00\0x89\0xf1\0xba"</span>
<span class="token string">"\0x0c\0x00\0x00\0x00\0xcd\0x80\0xb8\0x01"</span>
<span class="token string">"\0x00\0x00\0x00\0xbb\0x00\0x00\0x00\0x00"</span>
<span class="token string">"\0xcd\0x80\0xe8\0xdb\0xff\0xff\0xff\0x48"</span>
<span class="token string">"\0x65\0x6c\0x6c\0x6f\0x20\0x57\0x6f\0x72"</span>
<span class="token string">"\0x6c\0x64\0x0a\0x00"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注入：在-C-语言中执行字符串化的代码"><a href="#注入：在-C-语言中执行字符串化的代码" class="headerlink" title="注入：在 C 语言中执行字符串化的代码"></a>注入：在 C 语言中执行字符串化的代码</h3><p>得到上面的字符串以后我们就可以设计一段下面的代码啦。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* testshellcode.c */</span>
<span class="token keyword">char</span> shellcode<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"\xeb\x20\x5e\xb8\x04\x00\x00\x00"</span>
<span class="token string">"\xbb\x02\x00\x00\x00\x89\xf1\xba"</span>
<span class="token string">"\x0c\x00\x00\x00\xcd\x80\xb8\x01"</span>
<span class="token string">"\x00\x00\x00\xbb\x00\x00\x00\x00"</span>
<span class="token string">"\xcd\x80\xe8\xdb\xff\xff\xff\x48"</span>
<span class="token string">"\x65\x6c\x6c\x6f\x20\x57\x6f\x72"</span>
<span class="token string">"\x6c\x64\x0a\x00"</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">callshellcode</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">int</span> <span class="token operator">*</span>ret<span class="token punctuation">;</span>
   ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
   <span class="token punctuation">(</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>shellcode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token function">callshellcode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行看看，</p><pre class="line-numbers language-c"><code class="language-c">$ gcc <span class="token operator">-</span>o testshellcode testshellcode<span class="token punctuation">.</span>c
$ <span class="token punctuation">.</span><span class="token operator">/</span>testshellcode
Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>竟然打印出了 <code>Hello World</code>，实际上，如果只是为了让 <code>Shellcode</code> 执行，有更简单的办法，直接把 <code>Shellcode</code> 这个字符串入口强制转换为一个函数入口，并调用就可以，具体见这段代码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">char</span> shellcode<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"\xeb\x20\x5e\xb8\x04\x00\x00\x00"</span>
<span class="token string">"\xbb\x02\x00\x00\x00\x89\xf1\xba"</span>
<span class="token string">"\x0c\x00\x00\x00\xcd\x80\xb8\x01"</span>
<span class="token string">"\x00\x00\x00\xbb\x00\x00\x00\x00"</span>
<span class="token string">"\xcd\x80\xe8\xdb\xff\xff\xff\x48"</span>
<span class="token string">"\x65\x6c\x6c\x6f\x20\x57\x6f\x72"</span>
<span class="token string">"\x6c\x64\x0a\x00"</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//定义一个指向函数的指针func，而函数的返回值和参数均为void</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token punctuation">(</span>func<span class="token punctuation">)</span>shellcode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注入原理分析"><a href="#注入原理分析" class="headerlink" title="注入原理分析"></a>注入原理分析</h3><p>这里不那样做，为什么也能够执行到 <code>Shellcode</code> 呢？仔细分析一下 <code>callShellcode</code> 里头的代码就可以得到原因了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>ret<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里定义了一个指向整数的指针，<code>ret</code> 占用 4 个字节（可以用 <code>sizeof(int *)</code> 算出）。</p><pre class="line-numbers language-c"><code class="language-c">ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里把 <code>ret</code> 修改为它本身所在的地址再加上两个单位。 首先需要求出 <code>ret</code> 本身所在的位置，因为 <code>ret</code> 是函数的一个局部变量，它在栈中偏栈顶的地方。 然后呢？再增加两个单位，这个单位是 <code>sizeof(int)</code>，即 4 个字节。这样，新的 <code>ret</code> 就是 <code>ret</code> 所在的位置加上 8 个字节，即往栈底方向偏移 8 个字节的位置。对于我们之前分析的 <code>Shellcode</code>，那里应该是 <code>edi</code>，但实际上这里并不是 <code>edi</code>，可能是 <code>gcc</code> 在编译程序时有不同的处理，这里实际上刚好是 <code>eip</code>，即执行这条语句之后 <code>ret</code> 的值变成了 <code>eip</code> 所在的位置。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">(</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>shellcode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于之前 <code>ret</code> 已经被修改为了 <code>eip</code> 所在的位置，这样对 <code>(*ret)</code> 赋值就会修改 <code>eip</code> 的值，即下一条指令的地址，这里把 <code>eip</code> 修改为了 <code>Shellcode</code> 的入口。因此，当函数返回时直接去执行 <code>Shellcode</code> 里头的代码，并打印了 <code>Hello World</code> 。</p><p>用 <code>gdb</code> 调试一下看看相关变量的值的情况。这里主要关心 <code>ret</code> 本身。 <code>ret</code> 本身是一个地址，首先它所在的位置变成了 <code>EIP</code> 所在的位置（把它自己所在的位置加上 <code>2*4</code> 以后赋于自己），然后，<code>EIP</code> 又指向了 <code>Shellcode</code> 处的代码。</p><pre class="line-numbers language-c"><code class="language-c">$ gcc <span class="token operator">-</span>g <span class="token operator">-</span>o testshellcode testshellcode<span class="token punctuation">.</span>c
$ gdb <span class="token operator">-</span>q <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">testshellcode</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l
<span class="token number">8</span>       <span class="token keyword">void</span> <span class="token function">callshellcode</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token number">9</span>       <span class="token punctuation">{</span>
<span class="token number">10</span>         <span class="token keyword">int</span> <span class="token operator">*</span>ret<span class="token punctuation">;</span>
<span class="token number">11</span>         ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">12</span>         <span class="token punctuation">(</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>shellcode<span class="token punctuation">;</span>
<span class="token number">13</span>      <span class="token punctuation">}</span>
<span class="token number">14</span>
<span class="token number">15</span>      <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">16</span>      <span class="token punctuation">{</span>
<span class="token number">17</span>              <span class="token function">callshellcode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token number">17</span>
Breakpoint <span class="token number">1</span> at <span class="token number">0x804834d</span><span class="token punctuation">:</span> file testshell<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">17</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token number">11</span>
Breakpoint <span class="token number">2</span> at <span class="token number">0x804832a</span><span class="token punctuation">:</span> file testshell<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">11</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token number">12</span>
Breakpoint <span class="token number">3</span> at <span class="token number">0x8048333</span><span class="token punctuation">:</span> file testshell<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">12</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">break</span> <span class="token number">13</span>
Breakpoint <span class="token number">4</span> at <span class="token number">0x804833d</span><span class="token punctuation">:</span> file testshell<span class="token punctuation">.</span>c<span class="token punctuation">,</span> line <span class="token number">13</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> r
Starting program<span class="token punctuation">:</span> <span class="token operator">/</span>mnt<span class="token operator">/</span>hda8<span class="token operator">/</span>Temp<span class="token operator">/</span>c<span class="token operator">/</span>program<span class="token operator">/</span>testshell

Breakpoint <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> at testshell<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">17</span>
<span class="token number">17</span>              <span class="token function">callshellcode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print $ebp       #打印ebp寄存器里的值
$<span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">0xbfcfd2c8</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disassemble main
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">0x0804834d</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">14</span><span class="token operator">></span><span class="token punctuation">:</span>   call   <span class="token number">0x8048324</span> <span class="token operator">&lt;</span>callshellcode<span class="token operator">></span>
<span class="token number">0x08048352</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">19</span><span class="token operator">></span><span class="token punctuation">:</span>   mov    $<span class="token number">0x0</span><span class="token punctuation">,</span><span class="token operator">%</span>eax
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n

Breakpoint <span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">callshellcode</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> at testshell<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">11</span>
<span class="token number">11</span>         ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>6x $esp
<span class="token number">0xbfcfd2ac</span><span class="token punctuation">:</span>     <span class="token number">0x08048389</span>      <span class="token number">0xb7f4eff4</span>      <span class="token number">0xbfcfd36c</span>      <span class="token number">0xbfcfd2d8</span>
<span class="token number">0xbfcfd2bc</span><span class="token punctuation">:</span>     <span class="token number">0xbfcfd2c8</span>      <span class="token function">0x08048352</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print <span class="token operator">&amp;</span>ret #分别打印出ret所在的地址和ret的值，刚好在ebp之上，我们发现这里并没有
       #之前的testshellcode代码中的edi和esi，可能是gcc在汇编的时候有不同处理。
$<span class="token number">2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">0xbfcfd2b8</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print ret
$<span class="token number">3</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">0xbfcfd2d8</span> #这里的ret是个随机值
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n

Breakpoint <span class="token number">3</span><span class="token punctuation">,</span> <span class="token function">callshellcode</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> at testshell<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">12</span>
<span class="token function">12</span>         <span class="token punctuation">(</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>shellcode<span class="token punctuation">;</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print ret   #执行完ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>后，ret变成了自己地址加上<span class="token number">2</span><span class="token operator">*</span><span class="token number">4</span>，
                  #刚好是eip所在的位置。
$<span class="token number">5</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">0xbfcfd2c0</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>6x $esp
<span class="token number">0xbfcfd2ac</span><span class="token punctuation">:</span>     <span class="token number">0x08048389</span>      <span class="token number">0xb7f4eff4</span>      <span class="token number">0xbfcfd36c</span>      <span class="token number">0xbfcfd2c0</span>
<span class="token number">0xbfcfd2bc</span><span class="token punctuation">:</span>     <span class="token number">0xbfcfd2c8</span>      <span class="token function">0x08048352</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>4x <span class="token operator">*</span>ret  #此时<span class="token operator">*</span>ret刚好为eip，<span class="token number">0x8048352</span>
<span class="token number">0x8048352</span> <span class="token operator">&lt;</span>main<span class="token operator">+</span><span class="token number">19</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token number">0x000000b8</span>      <span class="token number">0x8d5d5900</span>      <span class="token number">0x90c3fc61</span>      <span class="token function">0x89559090</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> n

Breakpoint <span class="token number">4</span><span class="token punctuation">,</span> <span class="token function">callshellcode</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> at testshell<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">13</span>
<span class="token number">13</span>      <span class="token punctuation">}</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>6x $esp #现在eip被修改为了shellcode的入口
<span class="token number">0xbfcfd2ac</span><span class="token punctuation">:</span>     <span class="token number">0x08048389</span>      <span class="token number">0xb7f4eff4</span>      <span class="token number">0xbfcfd36c</span>      <span class="token number">0xbfcfd2c0</span>
<span class="token number">0xbfcfd2bc</span><span class="token punctuation">:</span>     <span class="token number">0xbfcfd2c8</span>      <span class="token function">0x8049560</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>4x <span class="token operator">*</span>ret  #现在修改了<span class="token punctuation">(</span><span class="token operator">*</span>ret<span class="token punctuation">)</span>的值，即修改了eip的值，使eip指向了shellcode
<span class="token number">0x8049560</span> <span class="token operator">&lt;</span>shellcode<span class="token operator">></span><span class="token punctuation">:</span>  <span class="token number">0xb85e20eb</span>      <span class="token number">0x00000004</span>      <span class="token number">0x000002bb</span>      <span class="token number">0xbaf18900</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的过程很难弄，呵呵。主要是指针不大好理解，如果直接把它当地址绘出下面的图可能会容易理解一些。</p><p>callshellcode栈的初始分布：</p><pre class="line-numbers language-c"><code class="language-c">ret<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ret<span class="token operator">+</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">0xbfcfd2bc</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">4</span><span class="token operator">=</span><span class="token number">0xbfcfd2c0</span>
<span class="token number">0xbfcfd2b8</span>      <span class="token function">ret</span><span class="token punctuation">(</span>随机值<span class="token punctuation">)</span>                     <span class="token number">0xbfcfd2c0</span>
<span class="token number">0xbfcfd2bc</span>      <span class="token function">ebp</span><span class="token punctuation">(</span>这里不关心<span class="token punctuation">)</span>
<span class="token number">0xbfcfd2c0</span>      <span class="token function">eip</span><span class="token punctuation">(</span><span class="token number">0x08048352</span><span class="token punctuation">)</span>         <span class="token function">eip</span><span class="token punctuation">(</span><span class="token number">0x8049560</span> <span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token operator">*</span>ret<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>shellcode<span class="token punctuation">;</span>即eip<span class="token operator">=</span><span class="token number">0x8049560</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之，最后体现为函数调用的下一条指令指针（<code>eip</code>）被修改为一段注入代码的入口，从而使得函数返回时执行了注入代码。</p><h3 id="缓冲区注入与防范"><a href="#缓冲区注入与防范" class="headerlink" title="缓冲区注入与防范"></a>缓冲区注入与防范</h3><p>这个程序里头的注入代码和被注入程序竟然是一个程序，傻瓜才自己攻击自己（不过有些黑客有可能利用程序中一些空闲空间注入代码哦），真正的缓冲区注入程序是分开的，比如作为被注入程序的一个字符串参数。而在被注入程序中刚好没有做字符串长度的限制，从而让这段字符串中的一部分修改了 <code>eip</code>，另外一部分作为注入代码运行了，从而实现了注入的目的。不过这会涉及到一些技巧，即如何刚好用注入代码的入口地址来修改 <code>eip</code> （即新的 <code>eip</code> 能够指向注入代码）？如果 <code>eip</code> 的位置和缓冲区的位置之间的距离是确定，那么就比较好处理了，但从上面的两个例子中我们发现，有一个编译后有 <code>edi</code> 和 <code>esi</code>，而另外一个则没有，另外，缓冲区的位置，以及被注入程序有多少个参数我们都无法预知，因此，如何计算 <code>eip</code> 所在的位置呢？这也会很难确定。还有，为了防止缓冲区溢出带来的注入问题，现在的操作系统采取了一些办法，比如让 <code>esp</code> 随机变化（比如和系统时钟关联起来），所以这些措施将导致注入更加困难。如果有兴趣，你可以接着看看最后的几篇参考资料并进行更深入的研究。</p><p>需要提到的是，因为很多程序可能使用 <code>strcpy</code> 来进行字符串的复制，在实际编写缓冲区注入代码时，会采取一定的办法（指令替换），把代码中可能包含的 <code>\0</code> 字节去掉，从而防止 <code>strcpy</code> 中断对注入代码的复制，进而可以复制完整的注入代码。具体的技巧可以参考 <a href="http://www.ibm.com/developerworks/cn/linux/l-overflow/index.html">Linux下缓冲区溢出攻击的原理及对策</a>，<a href="http://janxin.bokee.com/4067220.html">Shellcode技术杂谈</a>，<a href="http://virus.bartolich.at/virus-writing-HOWTO/_html/">virus-writing-HOWTO</a>。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实际上缓冲区溢出应该是语法和逻辑方面的双重问题，由于语法上的不严格（对数组边界没有检查）导致逻辑上可能出现严重缺陷（程序执行行为被改变）。另外，这类问题是对程序运行过程中的程序映像的栈区进行注入。实际上除此之外，程序在安全方面还有很多类似的问题。比如，虽然程序映像的正文区受到系统保护（只读），但是如果内存（硬件本身，内存条）出现故障，在程序运行的过程中，程序映像的正文区的某些字节就可能被修改了，也可能发生非常严重的后果，因此程序运行过程的正文区检查等可能的手段需要被引入。</p></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="chip bg-color">操作系统</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="wechat,qq" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/comment_bg.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;left:20px;top:15px;padding-bottom:5px"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"98JpzSGcrl9jFqHO13vqxHvX-gzGzoHsz",appKey:"mDmr2h9PB20xvPMNqgyRnNIC",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/46405/"><div class="card-image"><img src="/medias/featureimages/19.jpg" class="responsive-img" alt="程序执行时发生了什么"> <span class="card-title">程序执行时发生了什么</span></div></a><div class="card-content article-content"><div class="summary block-with-text">当我们在 Linux 下的命令行输入一个命令之后，这背后发生了什么？</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-24 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category">操作系统</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="chip bg-color">操作系统</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/posts/59293/"><div class="card-image"><img src="/medias/featureimages/27.jpg" class="responsive-img" alt="动态符号链接的细节"> <span class="card-title">动态符号链接的细节</span></div></a><div class="card-content article-content"><div class="summary block-with-text">贯穿工程，但又隐藏。</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-20 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category">操作系统</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"><span class="chip bg-color">原理剖析</span> </a><a href="/tags/Linux/"><span class="chip bg-color">Linux</span> </a><a href="/tags/C/"><span class="chip bg-color">C</span> </a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="chip bg-color">操作系统</span></a></div></div></div></div></article></div><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h2, h3, h4, h5"});let t=0;var e="toc-heading-";$("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)});var n=parseInt(.4*$(window).height()-64);let o=$(".toc-widget");$(window).scroll(function(){var t=$(window).scrollTop();n<t?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});var i="expanded";let a=$("#toc-aside"),c=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){a.hasClass(i)?(a.removeClass(i).hide(),c.removeClass("l9")):(a.addClass(i).show(),c.addClass("l9")),function(){let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}}()})})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" rel="external nofollow noreferrer">JoyTsing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="sitetime">载入运行时间...</span> <span id="busuanzi_container_site_pv">|&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fa fa-user"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br>&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">718.6k</span>&nbsp;字 <span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom" alt="icp"> <a href="https://beian.miit.gov.cn/" target="_blank">陕公网安备61019002002862号 滇ICP备2024026466号-1</a></span><script>function siteTime(){var e=864e5,t="2019",n=(m=new Date).getFullYear(),o=m.getMonth()+1,r=m.getDate(),a=m.getHours(),i=m.getMinutes(),l=m.getSeconds(),m=Date.UTC(t,"7","24","0","0","0"),r=Date.UTC(n,o,r,a,i,l)-m,a=Math.floor(r/31536e6),i=Math.floor(r/e-365*a),l=Math.floor((r-(365*a+i)*e)/36e5),m=Math.floor((r-(365*a+i)*e-36e5*l)/6e4),M=Math.floor((r-(365*a+i)*e-36e5*l-6e4*m)/1e3);t==n?(document.getElementById("year").innerHTML=n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒"):(document.getElementById("year").innerHTML=t+" - "+n,document.getElementById("sitetime").innerHTML="本站已安全运行 "+a+" 年 "+i+" 天 "+l+" 小时 "+m+" 分钟 "+M+" 秒")}setInterval(siteTime,1e3)</script></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/JoyTsing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="/medias/wechat.jpg" target="_blank" data-tooltip="添加我的微信: [object Object]" data-position="top" data-delay="50"><i class="fa fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3a39d92b69933ae56c7eb41ffb9aa2e0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(oﾟvﾟ)ノ Hi",clearTimeout(st)):(document.title="(*´∇｀*) 欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.8" zindex="-1" count="150" src="/libs/background/canvas-nest.js"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script></body></html>